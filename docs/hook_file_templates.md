## HookFile Templates

##### generated by AI

The `bm2` code generator uses a set of template files, referred to as "HookFiles", to generate code for different languages. These templates allow for customization of the generated code, such as specifying language-specific syntax, data types, and code structures.

The `src/bm2/hook_list.bgn` file defines an enum `HookFile` that lists all available template files. These files are located in the `hook` directory (or a directory specified by the `--hook-dir` command-line option).

The `src/bm2/gen_template.cpp` file is responsible for reading the template files and using them to generate code. The `may_write_from_hook` function reads the content of a template file and inserts it into the generated code.

### Template Categories

The HookFile templates are categorized into several groups:

- **General file structure:** These templates define the overall structure of the generated file, such as the header, footer, and namespace declarations.
  - `file_top.txt`: Contains the code that is placed at the beginning of the generated file.
  - `file_bottom.txt`: Contains the code that is placed at the end of the generated file.
- **Context definitions:** These templates define the context object that is used during code generation.
  - `bm_context.txt`: Contains the definitions for the `bm2xx::Context` class.
- **Command-line flag definitions:** These templates define the command-line flags that are used to configure the code generator.
  - `flags.txt`: Contains the definitions for the command-line flags.
- **Inner function/block related templates:** These templates define the structure of inner functions and blocks of code.
  - `inner_function_start.txt`: Contains the code that is placed at the beginning of an inner function.
  - `inner_function_each_code.txt`: Contains the code that is executed for each instruction within an inner function.
  - `inner_block_start.txt`: Contains the code that is placed at the beginning of an inner block.
  - `inner_block_each_code.txt`: Contains the code that is executed for each instruction within an inner block.
- **Parameter related templates:** These templates define how parameters are handled in the generated code.
  - `param_start.txt`: Contains the code that is placed at the beginning of a parameter list.
  - `param_each_code.txt`: Contains the code that is executed for each parameter in a parameter list.
  - `call_param_start.txt`: Contains the code that is placed at the beginning of a function call's parameter list.
  - `call_param_each_code.txt`: Contains the code that is executed for each parameter in a function call's parameter list.
- **Operation-specific templates:** These templates define the code that is generated for specific abstract operations.
  - `inner_function_op.txt`: Contains the code that is generated for a specific abstract operation within an inner function. The template file name is formatted as `func_{}.txt`, where `{}` is replaced with the lowercase name of the abstract operation.
  - `inner_block_op.txt`: Contains the code that is generated for a specific abstract operation within an inner block. The template file name is formatted as `block_{}.txt`, where `{}` is replaced with the lowercase name of the abstract operation.
  - `eval_op.txt`: Contains the code that is generated for evaluating a specific abstract operation. The template file name is formatted as `eval_{}.txt`, where `{}` is replaced with the lowercase name of the abstract operation.
  - `type_op.txt`: Contains the code that is generated for a specific storage type. The template file name is formatted as `type_{}.txt`, where `{}` is replaced with the lowercase name of the storage type.
  - `param_op.txt`: Contains the code that is generated for a specific abstract operation when defining parameters. The template file name is formatted as `param_{}.txt`, where `{}` is replaced with the lowercase name of the abstract operation.
  - `call_param_op.txt`: Contains the code that is generated for a specific abstract operation when calling functions with parameters. The template file name is formatted as `call_param_{}.txt`, where `{}` is replaced with the lowercase name of the abstract operation.

### Usage

The `gen_template.cpp` file reads the binary module and iterates through its code, using the `AbstractOp` enum to determine the type of instruction. For each instruction, it calls the `may_write_from_hook` function with the appropriate `HookFile` enum value to insert the corresponding template code into the generated code.

The template files can contain placeholders that are replaced with language-specific values, such as data types, variable names, and operators. The `Flags` struct in `src/bm2/gen_template.cpp` defines the following variables that can be used as placeholders in the hook files:

- `lang_name`: The name of the target language.
- `comment_prefix`: The prefix for comments.
- `comment_suffix`: The suffix for comments.
- `int_type_placeholder`: The placeholder for integer types (e.g., `std::int{}_t`).
- `uint_type_placeholder`: The placeholder for unsigned integer types (e.g., `std::uint{}_t`).
- `float_type_placeholder`: The placeholder for floating-point types (e.g., `float{}_t`).
- `array_type_placeholder`: The placeholder for array types (e.g., `std::array<{}, {}>`).
- `array_has_one_placeholder`: A boolean indicating whether the array type has one placeholder.
- `vector_type_placeholder`: The placeholder for vector types (e.g., `std::vector<{}>`).
- `optional_type_placeholder`: The placeholder for optional types (e.g., `std::optional<{}>`).
- `pointer_type_placeholder`: The placeholder for pointer types (e.g., `{}*`).
- `bool_type`: The string representation of the boolean type (e.g., `bool`).
- `true_literal`: The string representation of the true literal (e.g., `true`).
- `false_literal`: The string representation of the false literal (e.g., `false`).
- `coder_return_type`: The return type for coder functions (e.g., `bool`).
- `property_setter_return_type`: The return type for property setter functions (e.g., `bool`).
- `end_of_statement`: The string that marks the end of a statement (e.g., `;`).
- `block_begin`: The string that marks the beginning of a block (e.g., `{`).
- `block_end`: The string that marks the end of a block (e.g., `}`).
- `block_end_type`: The string that marks the end of a type definition block (e.g., `};`).
- `struct_keyword`: The keyword for defining structs (e.g., `struct`).
- `enum_keyword`: The keyword for defining enums (e.g., `enum`).
- `define_var_keyword`: The keyword for defining variables.
- `var_type_separator`: The separator between a variable name and its type.
- `field_type_separator`: The separator between a field name and its type.
- `field_end`: The string that marks the end of a field definition (e.g., `;`).
- `enum_member_end`: The string that marks the end of an enum member definition (e.g., `,`).
- `func_keyword`: The keyword for defining functions.
- `func_type_separator`: The separator between a function name and its return type.
- `func_void_return_type`: The string representation of the void return type (e.g., `void`).
- `if_keyword`: The keyword for if statements.
- `elif_keyword`: The keyword for else if statements.
- `else_keyword`: The keyword for else statements.
- `infinity_loop`: The string representation of an infinite loop (e.g., `for(;;)`).
- `conditional_loop`: The keyword for conditional loops (e.g., `while`).
- `self_ident`: The identifier for the self object (e.g., `(*this)`).
- `param_type_separator`: The separator between a parameter name and its type.
- `self_param`: The string representation of the self parameter.
- `encoder_param`: The parameters for encoder functions (e.g., `Encoder& w`).
- `decoder_param`: The parameters for decoder functions (e.g., `Decoder& w`).
- `func_style_cast`: Whether to use function-style casts.
