import subprocess as sp
import sys
import os
import json


def execute(command, env, capture=True) -> bytes:
    passEnv = os.environ.copy()
    if env is not None:
        passEnv.update(env)
    if capture:
        return sp.check_output(command, env=passEnv, stderr=sys.stderr)
    else:
        return sp.check_call(command, env=passEnv, stdout=sys.stdout, stderr=sys.stderr)


def get_tools():
    TOOL_DIR = "tool/"
    OUTPUT_DIR = "src/ebmcg/"

    # search output dirs
    # 1. walk output dir
    LANG_NAME_LIST = []
    for root, dirs, files in os.walk(OUTPUT_DIR):
        for name in dirs:
            if name.startswith("ebm2"):
                LANG_NAME_LIST.append(name[4:])

    # 2. remove duplicates
    LANG_NAME_LIST = list(set(LANG_NAME_LIST))

    # 3. find the ebm2{lang name}[.exe] in tools dir
    TOOLS = []
    for lang in LANG_NAME_LIST:
        exe_name = f"ebm2{lang}"
        if sys.platform == "win32":
            exe_name += ".exe"
        exe_path = os.path.join(TOOL_DIR, exe_name)
        if os.path.exists(exe_path):
            TOOLS.append({"name": lang, "path": exe_path})

    # 4. get commandline flag descriptions
    for tool in TOOLS:
        cmd = [tool["path"], "--show-flags"]
        output = execute(cmd, env=None)
        tool["flags"] = json.loads(output)
    return TOOLS


# 5. generate web glue code
def web_glue_names(tool: dict) -> dict:
    LSP_LANG = str(tool["flags"]["lsp_name"])
    WORKER_NAME = str(tool["flags"]["webworker_name"])
    UI_LANG_NAME = str(tool["flags"]["ui_lang_name"])
    UPPER_LANG_NAME = UI_LANG_NAME[0].upper() + UI_LANG_NAME[1:]
    CALL_WORKER_FUNC = "generate" + UPPER_LANG_NAME
    CALL_UI_FUNC = "set" + UPPER_LANG_NAME + "UIConfig"
    CALL_UI_TO_OPT_FUNC = "convert" + UPPER_LANG_NAME + "UIConfigToOption"
    CALL_SET_UI_FUNC = "set" + UPPER_LANG_NAME + "UIConfig"
    print(f"Generating web glue for {tool["flags"]["lang_name"]} ({tool['path']})")
    return {
        "ui_lang_name": UI_LANG_NAME,
        "worker_name": WORKER_NAME,
        "call_worker_func": CALL_WORKER_FUNC,
        "call_ui_func": CALL_UI_FUNC,
        "call_ui_to_opt_func": CALL_UI_TO_OPT_FUNC,
        "call_set_ui_func": CALL_SET_UI_FUNC,
        "lsp_lang": LSP_LANG,
    }


def worker_glue_code(web_glue: dict):
    return (
        f"""/*license*/
// Code generated by ebmwebgen, DO NOT EDIT.
import * as ebmgen  from "./{web_glue["worker_name"]}.js";
"""
        + 'import { EmWorkContext } from "../../s2j/em_work_ctx.js";'
        + """
const ebmgenModule = ebmgen.default /*as EmscriptenModuleFactory<MyEmscriptenModule>*/;
// avoid exceptions
export const base64ToUint8Array = (base64) => {
    const base64Characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    //const base64URLCharacters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
    let cleanedBase64 = base64.replace(/-/g, "+").replace(/_/g, "/").trim();
    const padding = (4 - (cleanedBase64.length % 4)) % 4;
    cleanedBase64 += "=".repeat(padding);
    const rawLength = cleanedBase64.length;
    const decodedLength = (rawLength * 3) / 4 - padding;
    const uint8Array = new Uint8Array(decodedLength);
    let byteIndex = 0;
    for (let i = 0; i < rawLength; i += 4) {
        const encoded1 = base64Characters.indexOf(cleanedBase64[i]);
        const encoded2 = base64Characters.indexOf(cleanedBase64[i + 1]);
        const encoded3 = base64Characters.indexOf(cleanedBase64[i + 2]);
        const encoded4 = base64Characters.indexOf(cleanedBase64[i + 3]);
        if (encoded1 < 0 || encoded2 < 0 || encoded3 < 0 || encoded4 < 0) {
            return new Error("invalid base64 string");
        }
        const decoded1 = (encoded1 << 2) | (encoded2 >> 4);
        const decoded2 = ((encoded2 & 15) << 4) | (encoded3 >> 2);
        const decoded3 = ((encoded3 & 3) << 6) | encoded4;
        uint8Array[byteIndex++] = decoded1;
        if (encoded3 !== 64)
            uint8Array[byteIndex++] = decoded2;
        if (encoded4 !== 64)
            uint8Array[byteIndex++] = decoded3;
    }
    return uint8Array;
};
const requestCallback = (e /*JobRequest*/, m /* MyEmscriptenModule */) => {
    switch (e.lang /*as string*/) {"""
        + f"""
        case "{web_glue['ui_lang_name']}":
"""
        + """            const bm = base64ToUint8Array(e.sourceCode);
            if(bm instanceof Error) {
                return bm;
            }
            m.FS.writeFile("/editor.ebm",  bm);\n"""
        + f"            return [\"{web_glue['worker_name']}\",\"-i\", \"/editor.ebm\"];"
        + """
        default:
            return new Error("unknown message type");
    }
};
const bmgenWorker = new EmWorkContext(ebmgenModule,requestCallback, () => {
"""
        + f'    console.log("{web_glue["worker_name"]} worker is ready");\n'
        + """});
"""
    )


def ui_glue_code(web_glue: dict, tool: dict):
    ui_lang_name = web_glue["ui_lang_name"]
    upper_ui_lang_name = ui_lang_name[0].upper() + ui_lang_name[1:]
    worker_name = web_glue["worker_name"]
    flags = tool["flags"]["flags"]  # Access the 'flags' list from the tool dictionary

    code = f"""
const convert{upper_ui_lang_name}OptionToFlags = (opt) => {{
    const flags = [];
"""
    for flag in flags:
        if flag["web_filtered"]:
            continue
        flag_name = flag["name"]
        flag_var_name = flag_name.replace("-", "_")
        flag_type = flag["type"]
        if flag_type == "bool":
            code += f"""    if (opt.{flag_var_name}) {{
        flags.push("--{flag_name}");
    }}
"""
        elif flag_type == "string":
            if (
                "argdesc" in flag and flag["argdesc"]
            ):  # Check if it's a flag that takes an argument
                code += f"""    if (opt.{flag_var_name} !== "") {{ // Assuming empty string as default for UI
        flags.push("--{flag_name}", opt.{flag_var_name});
    }}
"""
    code += f"""    return flags;
}};

const generate{upper_ui_lang_name} = async (factory,traceID,opt,sourceCode) => {{
    const worker_mgr = factory.getWorker("{worker_name}");
    const req = worker_mgr.getRequest(traceID,"{ui_lang_name}",sourceCode);
    req.arguments = convert{upper_ui_lang_name}OptionToFlags(opt);
    return worker_mgr.doRequest(req);
}};

const convert{upper_ui_lang_name}UIConfigToOption = (ui) => {{
    const opt = {{}};
"""
    for flag in flags:
        if flag["web_filtered"]:
            continue
        flag_name = flag["name"]
        flag_var_name = flag_name.replace("-", "_")
        code += f"""    opt.{flag_var_name} = ui.getLanguageConfig("{ui_lang_name}","{flag_name}");
"""
    code += f"""    return opt;
}};

function set{upper_ui_lang_name}UIConfig(ui) {{
    ui.set_flags("{ui_lang_name}",(nest_setter) => {{
"""
    for flag in flags:
        if flag["web_filtered"]:
            continue
        flag_name = flag["name"]
        flag_type = flag["type"]
        if flag_type == "bool":
            code += f"""        nest_setter("{flag_name}",{{
            type: "checkbox",
            value: false, // Assuming false as default for UI
        }});
"""
        elif flag_type == "string":
            code += f"""        nest_setter("{flag_name}",{{
            type: "text",
            value: "", // Assuming empty string as default for UI
        }});
"""
    code += f"""    }});
}}
"""
    return code


def generate_web_glue_files(tools: list[dict], output_dir):
    UI_GLUE = b""
    UI_CALLS = b""
    UI_SETS = b""
    LSP_MAPPER = b"export const EBM_LSP_LANGUAGES = Object.freeze({\n"
    UI_CANDIDATES = b"export const EBM_LANGUAGES = Object.freeze(["
    WORKER_FACTORY = b"export const ebm_workers = Object.freeze({\n"
    COPY_WASM = b""
    for tool in tools:
        web_glue = web_glue_names(tool)
        WORKER_GLUE = worker_glue_code(web_glue).encode()
        with open(f"{output_dir}/{web_glue['worker_name']}_worker.js", "wb") as f:
            f.write(WORKER_GLUE)
        print(f"Generated: {output_dir}/{web_glue["worker_name"]}_worker.js")
        # print(WORKER_GLUE)
        UI_GLUE += ui_glue_code(web_glue, tool).encode()
        UI_CALLS += f"    case \"{web_glue['ui_lang_name']}\": return {web_glue['call_worker_func']}(factory,traceID,{web_glue["call_ui_to_opt_func"]}(ui),sourceCode);\n".encode()
        UI_CANDIDATES += f"\"{web_glue['ui_lang_name']}\", ".encode()
        WORKER_FACTORY += f"    \"{web_glue['worker_name']}\": () => new Worker(new URL('./{web_glue['worker_name']}_worker.js', import.meta.url),{"{type: \"module\"}"}),\n".encode()
        UI_SETS += f"  {web_glue['call_set_ui_func']}(ui);\n".encode()
        LSP_MAPPER += (
            f"  \"{web_glue['ui_lang_name']}\": \"{web_glue['lsp_lang']}\",\n".encode()
        )
        COPY_WASM += f"copyWasm('bmgen/{web_glue['worker_name']}.js');\n".encode()
        COPY_WASM += f"copyWasm('bmgen/{web_glue['worker_name']}.wasm');\n".encode()
        COPY_WASM += (
            f"copyWasm('bmgen/{web_glue['worker_name']}_worker.js');\n".encode()
        )  # also copy worker js
    UI_CANDIDATES += b"]);\n"
    WORKER_FACTORY += b"});\n"
    LSP_MAPPER += b"});\n"
    with open(f"{output_dir}/ebm_caller.js", "wb") as f:
        f.write(
            b"""/*license*/
// Code generated by ebmwebgen, DO NOT EDIT.
"""
        )
        f.write(UI_GLUE)
        f.write(
            b"export function generateEBMCode(factory,ui,traceID,lang,sourceCode) {"
            + b" switch(lang) {\n"
            + UI_CALLS
            + b"    default: throw new Error('Unsupported language: ' + lang);\n"
            + b"  }\n"
            + b"}\n"
        )
        f.write(UI_CANDIDATES)
        f.write(LSP_MAPPER)
        f.write(b"export function setEBMUIConfig(ui) {\n" + UI_SETS + b"}\n")
    print(f"Generated: {output_dir}/ebm_caller.js")
    with open(f"{output_dir}/ebm_workers.js", "wb") as f:
        f.write(
            b"""/*license*/
// Code generated by ebmwebgen, DO NOT EDIT.
"""
        )
        f.write(WORKER_FACTORY)
    print(f"Generated: {output_dir}/ebm_workers.js")
    with open(f"{output_dir}/ebmWasmCopy.js.txt", "wb") as f:
        f.write(COPY_WASM)
    print(f"Generated: {output_dir}/ebmWasmCopy.js.txt")


if __name__ == "__main__":
    generate_web_glue_files(get_tools(), "web/tool")
