/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_PROGRAM_DECL_class
  Available Variables:
    ctx: Context_Statement_PROGRAM_DECL
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        module_: ebmgen::MappingTable
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
      item_id: ebm::StatementRef
      kind: const ebm::StatementKind&
      block: const ebm::Block&
        len: Varint
        container: std::vector<StatementRef>
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include <unordered_map>
#include "../codegen.hpp"
#include "ebm/extended_binary_module.hpp"
#include "ebmcg/ebm2c/codegen.hpp"
#include "ebmcodegen/stub/dependency.hpp"
#include "ebmcodegen/stub/util.hpp"
#include "ebmgen/common.hpp"
#include "includes.hpp"

namespace ebm2c {

}

DEFINE_VISITOR_CLASS(Statement_PROGRAM_DECL) {
    using Context = CODEGEN_CONTEXT(Statement_PROGRAM_DECL);
    struct C_Context {
        std::vector<ebm2c::Struct> structs;
        std::unordered_map<std::uint64_t, ebm2c::Union> unions;
        std::unordered_map<std::uint64_t, ebm2c::Variant> variants;
        std::vector<ebm2c::VectorType> vector_types;
        std::vector<ebm2c::ArrayType> array_types;
        std::vector<ebm2c::OptionalType> optional_types;
        std::vector<ebm2c::Enum> enums;
        std::set<std::string> optional_used;  // temporary ad-hoc set to track optional usage
        std::unordered_set<std::uint64_t> written_variants;
        bool has_can_read_stream = false;
        bool has_recursive_struct = false;
    };

    void write_vector_macros(CodeWriter & w) {
        w.write_unformatted(R"a(
    #ifndef VECTOR_APPEND
    #define VECTOR_APPEND(vector, elem,typ_str) do { \
        if (!input->append) {\
            EBM_EMIT_ERROR("EncoderInput append function is not set"); \
            return -1; \
        } \
        int res = input->append(input, (VECTOR_OF(void)*)(void*)&(vector),&(elem), sizeof(elem), typ_str); \
        if (res != 0) { \
            return res; \
        } \
    } while(0)
    #endif
)a");
    }

    void write_decoder_macros(CodeWriter & w) {
        w.write_unformatted(R"a(
    #ifndef DECODER_CAN_READ
    #define DECODER_CAN_READ(io, num_bytes) ((io)->can_read ? (io)->can_read(io, num_bytes) : ((io)->data_end - ((io)->data + (io)->offset)) >= (num_bytes))
    #endif

    #define EBM_READ_ARRAY_BYTES_TEMPORARY(io, target, size, offset_value,field_str) do { \
        if (DECODER_CAN_READ((io), (size))) { \
            if ((offset_value) == 0) { \
                (target) = (uint8_t*)((io)->data + (io)->offset); \
            }  \
            (io)->offset += (size); \
        } else { \
            EBM_EMIT_ERROR(field_str ": Not enough data to read array bytes temporary"); \
            return -1; \
        } \
    } while(0)

    #define EBM_READ_BYTES(io, target, size_value, offset_value,field_str) do { \
        if (DECODER_CAN_READ((io), (size_value))) { \
            if ((offset_value) == 0) { \
                (target).data = (uint8_t*)((io)->data + (io)->offset); \
                (target).size = (size_value); \
                (target).capacity = (target).size; \
            }  \
            (io)->offset += (size_value); \
        } else { \
            EBM_EMIT_ERROR(field_str ": Not enough data to read bytes"); \
            return -1; \
        } \
    } while(0)

    #define EBM_READ_ARRAY_BYTES(io, target, size_value, offset_value,field_str) do { \
        if (DECODER_CAN_READ((io), (size_value))) { \
            if ((offset_value) == 0) { \
                MEMCPY((target), (io)->data + (io)->offset, (size_value)); \
            }  \
            (io)->offset += (size_value); \
        } else { \
            EBM_EMIT_ERROR(field_str ": Not enough data to read array bytes"); \
            return -1; \
        } \
    } while(0)

    #ifndef EBM_GET_REMAINING_BYTES
    #define EBM_GET_REMAINING_BYTES(io) ((size_t)((io)->data_end - ((io)->data + (io)->offset)))
    #endif
)a");
    }

    void write_allocate_macros(CodeWriter & w) {
        w.write_unformatted(R"a(
    #ifndef EBM_ALLOCATE
    #define EBM_ALLOCATE(io,type) (type*)(io->allocate ? io->allocate(io, sizeof(type)) : NULL)
    #endif
)a");
    }

    void write_encoder_macros(CodeWriter & w) {
        w.write_unformatted(R"a(
    #define EBM_RESERVE_DATA(io,target, size, field_str) do { \
        if ((io)->offset + (size) > (size_t)((io)->data_end - (io)->data)) { \
            EBM_EMIT_ERROR(field_str ": Not enough space to reserve data"); \
            return -1; \
        } \
        target = (uint8_t*)((io)->data + (io)->offset); \
    } while(0)

    #define EBM_WRITE_ARRAY_BYTES_TEMPORARY(io, source, size_value, offset_value,field_str) do { \
        if ((io)->offset + (size_value) <= (size_t)((io)->data_end - (io)->data)) { \
            (io)->offset += (size_value); \
        } else { \
            EBM_EMIT_ERROR(field_str ": Not enough space to write array bytes temporary"); \
            return -1; \
        } \
    } while(0)

    #ifndef MEMCPY
    #define MEMCPY(dest, src, size) __builtin_memcpy((dest), (src), (size))
    #endif

    #define EBM_WRITE_BYTES(io, source, size_value, offset_value,field_str) do { \
        if((io)->emit) { \
            int res = (io)->emit((io), &(source), (size_value)); \
            if (res != 0) { \
                return res; \
            } \
        } \
        else if ((io)->offset + (size_value) <= (size_t)((io)->data_end - (io)->data)) { \
            if((source).size != (size_value)) { \
                EBM_EMIT_ERROR(field_str ": Source size does not match size value in write bytes"); \
                return -1; \
            } \
            MEMCPY((io)->data + (io)->offset, (source).data, (size_value)); \
            (io)->offset += (size_value); \
        } else { \
            EBM_EMIT_ERROR(field_str ": Not enough space to write bytes"); \
            return -1; \
        } \
    } while(0)

    #define EBM_WRITE_ARRAY_BYTES(io, source, size_value, offset_value,field_str) do { \
        if ((io)->offset + (size_value) <= (size_t)((io)->data_end - (io)->data)) { \
            MEMCPY((io)->data + (io)->offset, (source), (size_value)); \
            (io)->offset += (size_value); \
        } else { \
            EBM_EMIT_ERROR(field_str ": Not enough space to write array bytes"); \
            return -1; \
        } \
    } while(0)

    #define EBM_FREE_VECTOR(vector, elem_size) do { \
        if(input->free) \
        { \
            input->free(input, (VECTOR_OF(void)*)(void*)&(vector), elem_size); \
        } \
    } while(0)
)a");
    }

    DEFINE_VISITOR_FUNCTION(Statement_PROGRAM_DECL) {
        using namespace CODEGEN_NAMESPACE;
        C_Context c_ctx;
        MAYBE_VOID(ok, collect_structs(ctx, c_ctx));

        auto get_field_type = [&](ebm::StatementRef field_ref) -> expected<std::pair<Result, ebm::TypeRef>> {
            if (auto field = ctx.get_field<"field_decl.field_type">(field_ref)) {
                return ctx.visit(*field).transform([&](auto&& x) {
                    return std::make_pair(x, *field);
                });
            }
            else if (auto composite = ctx.get_field<"composite_field_decl.composite_type">(field_ref)) {
                return ctx.visit(*composite).transform([&](auto&& x) {
                    return std::make_pair(x, *composite);
                });
            }
            else {
                return unexpect_error("failed to get field type");
            }
        };
        CodeWriter w;
        w.writeln("#include <stdint.h>");
        w.writeln("#include <stddef.h>");
        w.writeln("");
        w.writeln("// Forward declarations");
        for (auto& s : c_ctx.structs) {
            auto ident = ctx.identifier(s.id);
            w.writeln("typedef struct ", ident, " ", ident, ";");
            // for recursive struct, add _ptr typedef
            if (s.is_recursive) {
                w.writeln("typedef ", ident, "* ", ident, "_ptr;");
            }
        }

        // enums first
        for (auto& e : c_ctx.enums) {
            MAYBE(enum_, ctx.visit(e.id));
            w.writeln(enum_.to_writer());
        }
        for (auto& e : c_ctx.enums) {
            auto ident = ctx.identifier(e.id);
            w.writeln("typedef enum ", ident, " ", ident, ";");
        }
        w.writeln("");

        if (c_ctx.vector_types.size() > 0) {
            w.writeln("// Vector type definitions");
            w.writeln("#ifndef VECTOR_OF");
            w.writeln("#define VECTOR_OF(type) type##_vector");
            w.writeln("typedef struct {");
            {
                auto scope = w.indent_scope();
                w.writeln("void* data;");
                w.writeln("size_t size;");
                w.writeln("size_t capacity;");
            }
            w.writeln("} VECTOR_OF(void);");
            for (auto& v : c_ctx.vector_types) {
                MAYBE(elem_type, ctx.visit(v.elem_type));
                w.writeln("typedef struct {");
                {
                    auto scope = w.indent_scope();
                    w.writeln(elem_type.to_writer(), "* data;");
                    w.writeln(ctx.config().usize_type_name, " size;");
                    w.writeln(ctx.config().usize_type_name, " capacity;");
                }
                w.writeln("} VECTOR_OF(", elem_type.to_writer(), ");");
                w.writeln("");
            }
            w.writeln("#endif");
            w.writeln("");
            write_vector_macros(w);
        }
        if (c_ctx.array_types.size() > 0) {
            w.writeln("// Array type definitions");
            w.writeln("#ifndef ARRAY_OF");
            w.writeln("#define ARRAY_OF(type, size) ArrayOf_##type##_##size");
            for (auto& a : c_ctx.array_types) {
                MAYBE(elem_type, ctx.visit(a.elem_type));
                auto size_str = std::to_string(a.size);
                w.writeln("typedef ", elem_type.to_writer(), " ARRAY_OF(", elem_type.to_writer(), ", ", size_str, ")[", size_str, "];");
                w.writeln("");
            }
            w.writeln("#endif");
        }

        w.writeln("#ifndef EBM_EMIT_ERROR");
        w.write_unformatted(&R"(
        #define EBM_EMIT_ERROR(msg) \
            do { if (input->set_last_error) input->set_last_error(msg); } while(0)
        #define LAST_ERROR_HANDLER void(*set_last_error)(const char* msg)
        )"[1]);
        w.writeln("#endif");
        w.write_unformatted(&R"(
        #ifndef EBM_FUNCTION_PROLOGUE
        #define EBM_FUNCTION_PROLOGUE() do {} while(0)
        #endif
        #ifndef EBM_FUNCTION_EPILOGUE
        #define EBM_FUNCTION_EPILOGUE() do {} while(0)
        #endif
        )"[1]);

        w.writeln("typedef struct EncoderInput {");
        {
            auto scope = w.indent_scope();
            w.writeln("uint8_t* data;");
            w.writeln("uint8_t* data_end;");
            w.writeln("size_t offset;");
            if (c_ctx.vector_types.size() > 0) {
                w.writeln("int (*emit)(struct EncoderInput* self, const VECTOR_OF(uint8_t)* data, size_t size);");
            }
            w.writeln("LAST_ERROR_HANDLER;");
        }
        w.writeln("} EncoderInput;");
        w.writeln("");

        write_encoder_macros(w);
        w.writeln("typedef struct DecoderInput {");
        {
            auto scope = w.indent_scope();
            w.write_unformatted(&R"a(
            const uint8_t* data;
            const uint8_t* data_end;
            size_t offset;
        )a"[1]);
            if (c_ctx.vector_types.size() > 0) {
                w.writeln("int (*append)(struct DecoderInput* self, VECTOR_OF(void)* vector, const void* data,size_t size,const char* type_str);");
            }
            w.writeln("int (*can_read)(struct DecoderInput* self, size_t num_bytes);");
            if (c_ctx.has_recursive_struct) {
                w.writeln("void* (*allocate)(struct DecoderInput* self, size_t size);");
            }
            w.writeln("LAST_ERROR_HANDLER;");
        }
        w.writeln("} DecoderInput;");

        w.writeln("typedef struct FreeFunctionInput {");
        {
            auto scope = w.indent_scope();
            if (c_ctx.vector_types.size() > 0) {
                w.writeln("void (*free)(struct FreeFunctionInput* self, VECTOR_OF(void)* vector, size_t elem_size);");
            }
            w.writeln("LAST_ERROR_HANDLER;");
        }
        w.writeln("} FreeFunctionInput;");

        write_decoder_macros(w);
        if (c_ctx.has_recursive_struct) {
            write_allocate_macros(w);
        }

        w.writeln("");
        std::vector<ebm::StatementRef> composite_fns;
        std::unordered_set<std::uint64_t> parents_set;
        auto collect_composite_fn = [&](ebm::StatementRef composite) -> expected<void> {
            auto comp = ctx.get_field<"composite_field_decl">(composite);
            if (!comp) {
                return {};
            }
            for (auto& f : comp->fields.container) {
                auto decl = ctx.get_field<"field_decl">(f);
                if (!decl) {
                    continue;
                }
                auto getter = decl->composite_getter();
                auto setter = decl->composite_setter();
                if (getter) {
                    composite_fns.push_back(getter->id);
                    parents_set.insert(get_id(decl->parent_struct));
                }
                if (setter) {
                    composite_fns.push_back(setter->id);
                    parents_set.insert(get_id(decl->parent_struct));
                }
            }
            return {};
        };
        auto write_union = [&](Union& u) -> expected<void> {
            auto ident = std::format("{}{}", ctx.config().variant_prefix, get_id(u.id));
            for (auto& v : u.variants) {
                for (auto& f : v.fields) {
                    MAYBE_VOID(ok, collect_composite_fn(f.id));
                }
            }
            CodeWriter parent;
            CodeWriter union_w;
            union_w.writeln("typedef union ", ident, " {");
            auto scope = union_w.indent_scope();
            for (auto& v : u.variants) {
                auto var_ident = ctx.identifier(v.id);
                auto for_each_field = [&](CodeWriter& w) -> expected<void> {
                    auto var_scope = w.indent_scope();
                    for (auto& f : v.fields) {
                        auto field_ident = ctx.identifier(f.id);
                        MAYBE(typ, get_field_type(f.id));
                        w.writeln(typ.first.to_writer(), " ", field_ident, ";");
                    }
                    return {};
                };
                parent.writeln("typedef struct ", var_ident, "{");
                MAYBE_VOID(ok, for_each_field(parent));
                parent.writeln("}", var_ident, ";");
                union_w.writeln("struct ", var_ident, " ", var_ident, ";");
            }
            scope.execute();
            union_w.writeln("}", ident, ";");
            union_w.writeln("");
            w.write(parent);
            w.write(union_w);
            return {};
        };

        auto write_variant = [&](Variant& v) -> expected<void> {
            auto ident = std::format("{}{}", ctx.config().variant_prefix, get_id(v.id));
            CodeWriter w_var;
            w_var.writeln("typedef struct {");
            {
                auto scope = w_var.indent_scope();
                w_var.writeln("uint32_t tag;");
                w_var.writeln("union {");
                {
                    auto u_scope = w_var.indent_scope();
                    size_t idx = 0;
                    for (auto& m : v.members) {
                        MAYBE(type, ctx.visit(m));
                        w_var.writeln(type.to_writer(), " v", std::to_string(idx), ";");
                        idx++;
                    }
                }
                w_var.writeln("} value;");
            }
            w_var.writeln("} ", ident, ";");
            w_var.writeln("");
            w.write(w_var);
            return {};
        };

        for (auto& s : c_ctx.structs) {
            auto ident = ctx.identifier(s.id);
            // first lookup unions used in this struct
            for (auto& f : s.fields) {
                MAYBE(typ, get_field_type(f.id));
                if (auto found = c_ctx.unions.find(get_id(typ.second)); found != c_ctx.unions.end()) {
                    MAYBE_VOID(ok, write_union(found->second));
                }
            }
            w.writeln("struct ", ident, " {");
            auto scope = w.indent_scope();
            for (auto& f : s.fields) {
                auto field_ident = ctx.identifier(f.id);
                MAYBE(typ, get_field_type(f.id));
                w.writeln(typ.first.to_writer(), " ", field_ident, ";");
                MAYBE_VOID(ok, collect_composite_fn(f.id));
            }
            scope.execute();
            w.writeln("};");
            w.writeln("");

            for (auto& prop_ref : s.properties) {
                auto prop = ctx.get_field<"property_decl">(prop_ref);
                if (!prop) continue;
                auto typ_ref = prop->property_type;
                auto typ = ctx.module().get_type(typ_ref);
                if (typ && typ->body.kind == ebm::TypeKind::VARIANT) {
                    auto id = get_id(typ->id);
                    if (auto found = c_ctx.variants.find(id); found != c_ctx.variants.end()) {
                        MAYBE_VOID(ok, write_variant(found->second));
                    }
                }
            }
        }

        if (c_ctx.optional_types.size() > 0) {
            w.writeln("// Optional type definitions");
            w.writeln("#ifndef OPTIONAL_OF");
            w.writeln("#define OPTIONAL_OF(type) Optional_##type");
            for (auto& o : c_ctx.optional_types) {
                MAYBE(elem_type, ctx.visit(o.elem_type));
                w.writeln("typedef struct {");
                {
                    auto scope = w.indent_scope();
                    w.writeln("bool has_value;");
                    w.writeln(elem_type.to_writer(), " value;");
                }
                w.writeln("} OPTIONAL_OF(", elem_type.to_writer(), ");");
                w.writeln("");
            }
            w.writeln("#endif");
        }
        auto foreach_function = [&] -> expected<void> {
            for (auto& composite_fn_ref : composite_fns) {
                MAYBE(func, ctx.visit(composite_fn_ref));
                w.writeln(func.to_writer());
            }
            // for each properties
            for (auto& s : c_ctx.structs) {
                for (auto& prop_ref : s.properties) {
                    MAYBE(prop, ctx.visit(prop_ref));
                    w.writeln(prop.to_writer());
                }
            }
            // write encoding/decoding functions if any
            for (auto& s : c_ctx.structs) {
                if (s.encode_function) {
                    MAYBE(func, ctx.visit(*s.encode_function));
                    w.writeln(func.to_writer());
                    ctx.config().on_destructor_generation = true;
                    ctx.config().encoder_input_type = "FreeFunctionInput*";
                    MAYBE(free_func, ctx.visit(*s.encode_function));
                    w.writeln(free_func.to_writer());
                    ctx.config().on_destructor_generation = false;
                    ctx.config().encoder_input_type = "EncoderInput*";
                }
                if (s.decode_function) {
                    MAYBE(func, ctx.visit(*s.decode_function));
                    w.writeln(func.to_writer());
                }
            }
            return {};
        };
        ctx.config().forward_decl = true;
        MAYBE_VOID(fwd, foreach_function());
        ctx.config().forward_decl = false;
        MAYBE_VOID(def, foreach_function());
        return w;
    };

    ebmgen::expected<void> collect_structs(Context & ctx, C_Context & c_ctx) {
        auto handle_struct_decl = [&](std::vector<ebm2c::Struct>& structs, ebm::StatementRef stmt_ref, bool in_union) {
            auto struct_ = ctx.get_field<"struct_decl">(stmt_ref);
            if (!struct_) {
                return;
            }
            if (is_nil(struct_->name) && !in_union) {
                return;
            }
            Struct s;
            s.id = stmt_ref;
            s.is_recursive = struct_->is_recursive();
            for (auto& decl_ref : struct_->fields.container) {
                auto composite = ctx.get_field<"composite_field_decl">(decl_ref);
                if (composite && composite->kind != ebm::CompositeFieldKind::BULK_PRIMITIVE) {
                    for (auto& inner_field : composite->fields.container) {
                        s.fields.push_back(Field{.id = inner_field});
                    }
                    continue;
                }
                s.fields.push_back(Field{.id = decl_ref});
            }
            if (auto props = struct_->properties()) {
                for (auto& prop_ref : props->container) {
                    s.properties.push_back(prop_ref);
                }
            }
            if (auto funcs = struct_->methods()) {
                for (auto& func_ref : funcs->container) {
                    s.properties.push_back(func_ref);
                }
            }
            if (auto encode_func = struct_->encode_fn()) {
                s.encode_function = *encode_func;
            }
            if (auto decode_func = struct_->decode_fn()) {
                s.decode_function = *decode_func;
            }
            structs.push_back(s);
        };
        MAYBE(sorted, sorted_struct(ctx));
        for (auto stmt_ref : sorted) {
            handle_struct_decl(c_ctx.structs, stmt_ref, false);
        }
        for (auto& e : ctx.module().module().statements) {
            auto enum_decl = ctx.get_field<"enum_decl">(e.id);
            if (!enum_decl) {
                continue;
            }
            ebm2c::Enum en{.id = e.id};
            c_ctx.enums.push_back(en);
        }
        for (auto& s : ctx.module().module().types) {
            if (s.body.kind == ebm::TypeKind::VECTOR) {
                MAYBE(elem_type, s.body.element_type());
                ebm2c::VectorType v{.elem_type = elem_type};
                c_ctx.vector_types.push_back(v);
                continue;
            }
            if (s.body.kind == ebm::TypeKind::RECURSIVE_STRUCT) {
                c_ctx.has_recursive_struct = true;
                continue;
            }
            if (s.body.kind == ebm::TypeKind::ARRAY) {
                MAYBE(elem_type, s.body.element_type());
                MAYBE(length, s.body.length());
                MAYBE(annotation, s.body.array_annotation());
                if (annotation == ebm::ArrayAnnotation::read_temporary || annotation == ebm::ArrayAnnotation::write_temporary) {
                    continue;
                }
                ebm2c::ArrayType a{.elem_type = elem_type, .size = static_cast<size_t>(length.value())};
                c_ctx.array_types.push_back(a);
                continue;
            }
            if (s.body.kind == ebm::TypeKind::OPTIONAL) {
                MAYBE(text_repr, ctx.visit(s.id));
                if (c_ctx.optional_used.insert(text_repr.to_string()).second == false) {
                    continue;
                }
                c_ctx.optional_used.insert(text_repr.to_string());
                MAYBE(elem_type, s.body.inner_type());
                ebm2c::OptionalType o{.elem_type = elem_type};
                c_ctx.optional_types.push_back(o);
                continue;
            }
            if (s.body.kind == ebm::TypeKind::PTR) {
                if (is_optionalized_pointer_element(ctx, *s.body.pointee_type())) {
                    MAYBE(text_repr, ctx.visit(*s.body.pointee_type()));
                    auto optional_text = std::format("OPTIONAL_OF({})",
                                                     text_repr.to_string());
                    if (c_ctx.optional_used.insert(optional_text).second == false) {
                        continue;
                    }
                    MAYBE(elem_type, s.body.pointee_type());
                    ebm2c::OptionalType o{.elem_type = elem_type};
                    c_ctx.optional_types.push_back(o);
                    continue;
                }
            }
            auto variant_desc = s.body.variant_desc();
            if (!variant_desc) {
                continue;
            }
            if (is_nil(variant_desc->related_field)) {
                Variant v{.id = s.id};
                for (auto member : variant_desc->members.container) {
                    v.members.push_back(member);
                }
                c_ctx.variants[get_id(s.id)] = v;
            }
            else {
                Union u{.id = s.id};
                for (auto member_type_ref : variant_desc->members.container) {
                    auto struct_key = ctx.get_field<"body.id">(member_type_ref);
                    if (!struct_key) {
                        continue;
                    }
                    handle_struct_decl(u.variants, from_weak(*struct_key), true);
                }
                c_ctx.unions[get_id(s.id)] = u;
            }
        }
        for (auto& exprs : ctx.module().module().expressions) {
            if (exprs.body.kind == ebm::ExpressionKind::CAN_READ_STREAM) {
                c_ctx.has_can_read_stream = true;
                break;
            }
        }
        return {};
    }
};
