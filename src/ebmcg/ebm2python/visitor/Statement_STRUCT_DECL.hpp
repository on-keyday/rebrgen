/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_STRUCT_DECL
  Available variables:
    *this: Visitor
    module_: MappingTable
    item_id: StatementRef
    kind: StatementKind
    struct_decl: StructDecl
      name: IdentifierRef
      fields: Block
        len: Varint
        container: std::vector<StatementRef>
      is_recursive: bool
      is_fixed_size: bool
      has_related_variant: bool
      has_encode_decode: bool
      reserved: std::uint8_t
      related_variant: *TypeRef
      size: *Size
        unit: SizeUnit
        ref: *ExpressionRef
        size: *Varint
      decode_fn: *StatementRef
      encode_fn: *StatementRef
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/
// This code is included within the visit_Statement_STRUCT_DECL function.
// We can use variables like `visitor` and `struct_decl` directly.
CodeWriter w;
auto name = this->module_.get_associated_identifier(item_id);

if (this->module_.get_identifier(item_id)) {
    output.struct_names.push_back(name);
}
w.writeln("@dataclasses.dataclass");
w.writeln_with_loc(to_any_ref(item_id), "class ", name, ":");
size_t size = w.str_size();
auto scope = w.indent_scope();

for (auto& field_ref : struct_decl.fields.container) {
    MAYBE(field, this->module_.get_statement(field_ref));
    MAYBE(res, visit_Statement(*this, field));
    merge_result(*this, w, res);
}

// __init__ method
w.writeln("def __init__(self):");
{
    auto init_scope = w.indent_scope();
    auto size = w.str_size();
    auto result = handle_fields(*this, struct_decl.fields, true, [&](auto&& field_ref, auto&& field) -> ebmgen::expected<void> {
        if (auto field_decl = field.body.field_decl()) {
            MAYBE(default_, as_DEFAULT_VALUE(*this, field_decl->field_type));
            auto field_name = this->module_.get_associated_identifier(field_ref);
            w.writeln("self.", field_name, " = ", default_.to_writer());
        }
        return {};
    });
    if (!result) {
        return unexpect_error("Failed to handle fields in __init__: {}", result.error().error());
    }
    if (w.str_size() == size) {
        w.writeln("pass");  // If the __init__ body is empty, we just pass
    }
}

// Visit encode_fn if it exists
if (auto enc_fn = struct_decl.encode_fn()) {  // Corrected: Check value() of Varint id
    MAYBE(encode_fn_stmt, this->module_.get_statement(*enc_fn));
    MAYBE(res, visit_Statement(*this, encode_fn_stmt));
    merge_result(*this, w, res);
}

// Visit decode_fn if it exists
if (auto dec_fn = struct_decl.decode_fn()) {  // Corrected: Check value() of Varint id
    MAYBE(decode_fn_stmt, this->module_.get_statement(*dec_fn));
    MAYBE(res, visit_Statement(*this, decode_fn_stmt));
    merge_result(*this, w, res);
}

if (w.str_size() == size) {
    w.writeln("pass");  // If the class body is empty, we just pass
}

w.writeln();  // Add a blank line for readability.

return w;