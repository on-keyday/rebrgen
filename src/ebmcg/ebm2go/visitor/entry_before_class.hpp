/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: entry_before_class
  Available Variables:
    ctx: Context_entry_before<Result>
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        module_: ebmgen::MappingTable
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
      main_logic: ebmcodegen::util::MainLogicWrapper<Result>
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include <string>
#include "../codegen.hpp"
#include "ebm/extended_binary_module.hpp"
DEFINE_VISITOR(entry_before) {
    using namespace CODEGEN_NAMESPACE;
    ctx.config().array_type_wrapper = [](Result r, size_t size, ebm::ArrayAnnotation) -> expected<Result> {
        return CODE("[", std::to_string(size), "]", r.to_writer());
    };
    ctx.config().vector_type_wrapper = [](Result r) -> expected<Result> {
        return CODE("[]", r.to_writer());
    };
    ctx.config().field_name_prior_to_type = true;
    ctx.config().int_prefix = "int";
    ctx.config().uint_prefix = "uint";
    ctx.config().float_prefix = "float";
    ctx.config().struct_definition_start_wrapper = [&](Context_Statement_STRUCT_DECL& sctx) -> expected<Result> {
        CodeWriter w;
        auto name = sctx.identifier();
        w.writeln("type ", name, " struct ", ctx.config().begin_block);
        return w;
    };
    ctx.config().function_define_keyword = "func";
    ctx.config().function_return_type_separator = "";
    ctx.config().encoder_return_type = "error";
    ctx.config().decoder_return_type = "error";
    ctx.config().encoder_input_type = "[]byte";
    ctx.config().decoder_input_type = "[]byte";
    ctx.config().function_definition_start_wrapper = [&](Result return_type, std::string_view name, CodeWriter params, Context_Statement_FUNCTION_DECL& fctx) -> expected<Result> {
        CodeWriter w;
        if (!is_nil(fctx.func_decl.parent_format)) {
            auto struct_name = ctx.identifier(fctx.func_decl.parent_format);
            w.writeln(ctx.config().function_define_keyword, " (this *", struct_name, ") ", name, "(", params, ") ", ctx.config().function_return_type_separator, " ", return_type.to_writer(), " ", ctx.config().begin_block);
        }
        else {
            w.writeln(ctx.config().function_define_keyword, " ", name, "(", params, ") ", ctx.config().function_return_type_separator, return_type.to_writer(), " ", ctx.config().begin_block);
        }
        return w;
    };
    ctx.config().composite_field_decl_visitor = [&](Context_Statement_COMPOSITE_FIELD_DECL& cctx) -> expected<Result> {
        if (cctx.composite_field_decl.kind == ebm::CompositeFieldKind::BULK_PRIMITIVE ||
            cctx.composite_field_decl.kind == ebm::CompositeFieldKind::PREFIXED_UNION_PRIMITIVE) {
            auto ident = cctx.identifier();
            MAYBE(typ, ctx.visit(cctx.composite_field_decl.composite_type));
            return CODELINE(ident, " ", typ.to_writer());
        }
        return cctx.visit(cctx.composite_field_decl.fields);
    };
    ctx.config().read_data_visitor = [&](Context_Statement_READ_DATA& rctx) -> expected<Result> {
        if (auto low = rctx.read_data.lowered_statement()) {
            if (low->lowering_type == ebm::LoweringIOType::VECTORIZED_IO) {
                return rctx.visit(low->io_statement.id);
            }
        }
        if (auto cand = is_bytes_type(rctx, rctx.read_data.data_type)) {
            MAYBE(target, rctx.visit(rctx.read_data.target));
            MAYBE(size_str, get_size_str(rctx, rctx.read_data.size));
            auto io_ = rctx.identifier(rctx.read_data.io_ref);
            auto offset_val = CODE("0");
            if (auto offset = rctx.read_data.offset()) {
                MAYBE(offset_str, rctx.visit(*offset));
                offset_val = offset_str.to_writer();
            }
            MAYBE(layer_str, get_identifier_layer_str(rctx, from_weak(rctx.read_data.field)));
            layer_str = "\"" + layer_str + "\"";
            if (cand == BytesType::vector) {
                return CODELINE("/* read from buffer*/");
            }
            else if (cand == BytesType::array) {
                return CODELINE("/* read from buffer */");
            }
        }
        if (auto lw = rctx.read_data.lowered_statement()) {
            return rctx.visit(lw->io_statement.id);
        }
        return "/* not implemented read data */";
    };
    ctx.config().write_data_visitor = [&](Context_Statement_WRITE_DATA& wctx) -> expected<Result> {
        if (auto low = wctx.write_data.lowered_statement()) {
            if (low->lowering_type == ebm::LoweringIOType::VECTORIZED_IO) {
                return wctx.visit(low->io_statement.id);
            }
        }
        if (auto cand = is_bytes_type(wctx, wctx.write_data.data_type)) {
            MAYBE(target, wctx.visit(wctx.write_data.target));
            MAYBE(size_str, get_size_str(wctx, wctx.write_data.size));
            auto io_ = wctx.identifier(wctx.write_data.io_ref);
            auto offset_val = CODE("0");
            if (auto offset = wctx.write_data.offset()) {
                MAYBE(offset_str, wctx.visit(*offset));
                offset_val = offset_str.to_writer();
            }
            MAYBE(layer_str, get_identifier_layer_str(wctx, from_weak(wctx.write_data.field)));
            layer_str = "\"" + layer_str + "\"";
            if (cand == BytesType::vector) {
                return CODELINE("/* write to buffer*/");
            }
            else if (cand == BytesType::array) {
                return CODELINE("/* write to buffer */");
            }
        }
        if (auto lw = wctx.write_data.lowered_statement()) {
            return wctx.visit(lw->io_statement.id);
        }
        return "/* not implemented write data */";
    };
    ctx.config().is_error_visitor = [&](Context_Expression_IS_ERROR& ectx) -> expected<Result> {
        MAYBE(err, ctx.visit(ectx.target_expr));
        return CODE(err.to_writer(), " != nil");
    };
    ctx.config().error_return_visitor = [&](Context_Statement_ERROR_RETURN& rctx) -> expected<Result> {
        MAYBE(err_expr, ctx.visit(rctx.value));
        return CODELINE("return ", err_expr.to_writer());
    };
    ctx.config().variable_type_separator = "";
    ctx.config().variable_with_type = false;
    ctx.config().variable_initializer = ":=";
    ctx.config().enum_decl_visitor = [&](Context_Statement_ENUM_DECL& ectx) -> expected<Result> {
        CodeWriter w;
        auto name = ectx.identifier();
        w.writeln("type ", name, " int");
        w.writeln("");
        w.writeln("const (");
        {
            auto scope = w.indent_scope();
            for (auto& member_ref : ectx.enum_decl.members.container) {
                MAYBE(member, ectx.visit(member_ref));
                w.writeln(member.to_writer());
            }
        }
        w.writeln(")");
        return w;
    };
    ctx.config().enum_member_decl_visitor = [&](Context_Statement_ENUM_MEMBER_DECL& mctx) -> expected<Result> {
        auto enum_name = ctx.identifier(mctx.enum_member_decl.enum_decl);
        auto member_name = mctx.identifier();
        MAYBE(value_expr, ctx.visit(mctx.enum_member_decl.value));
        return CODELINE(enum_name, "_", member_name, " ", enum_name, " = ", value_expr.to_writer());
    };
    ctx.config().enum_member_accessor = "_";
    ctx.config().init_check_visitor = [&](Context_Statement_INIT_CHECK& ictx) -> expected<Result> {
        MAYBE(target, ctx.visit(ictx.init_check.target_field));
        MAYBE(expect, ctx.visit(ictx.init_check.expect_value));
    };

    return pass;
}
