// Code generated by json2cpp2
#pragma once
#include <cstdint>
#include <vector>
#include <array>
#include <optional>
#include <variant>
#include <string_view>

#include <binary/flags.h>
#include <binary/float.h>
#include <view/iovec.h>
#include <binary/number.h>
#include <error/error.h>
namespace bm2 {
    enum class HookFile {
        keyword = 0,
        generator_top = 1,
        file_top = 2,
        file_bottom = 3,
        bm_context = 4,
        flags = 5,
        eval_result = 6,
        escape_ident = 7,
        each_inner_block = 8,
        each_inner_function = 9,
        inner_function_start = 10,
        inner_function_each_code = 11,
        inner_block_start = 12,
        inner_block_each_code = 13,
        param_start = 14,
        param_each_code = 15,
        call_param_start = 16,
        call_param_each_code = 17,
        inner_function_op = 18,
        inner_block_op = 19,
        eval_op = 20,
        type_op = 21,
        param_op = 22,
        call_param_op = 23,
        field_accessor_op = 24,
        type_accessor_op = 25,
    };
    constexpr const char* to_string(HookFile e) {
        switch (e) {
            case HookFile::keyword:
                return "keywords";
            case HookFile::generator_top:
                return "generator_top";
            case HookFile::file_top:
                return "file_top";
            case HookFile::file_bottom:
                return "file_bottom";
            case HookFile::bm_context:
                return "bm_context";
            case HookFile::flags:
                return "flags";
            case HookFile::eval_result:
                return "eval_result";
            case HookFile::escape_ident:
                return "escape_ident";
            case HookFile::each_inner_block:
                return "each_inner_block";
            case HookFile::each_inner_function:
                return "each_inner_function";
            case HookFile::inner_function_start:
                return "inner_function_start";
            case HookFile::inner_function_each_code:
                return "inner_function_each_code";
            case HookFile::inner_block_start:
                return "inner_block_start";
            case HookFile::inner_block_each_code:
                return "inner_block_each_code";
            case HookFile::param_start:
                return "param_start";
            case HookFile::param_each_code:
                return "param_each_code";
            case HookFile::call_param_start:
                return "call_param_start";
            case HookFile::call_param_each_code:
                return "call_param_each_code";
            case HookFile::inner_function_op:
                return "func_{}";
            case HookFile::inner_block_op:
                return "block_{}";
            case HookFile::eval_op:
                return "eval_{}";
            case HookFile::type_op:
                return "type_{}";
            case HookFile::param_op:
                return "param_{}";
            case HookFile::call_param_op:
                return "call_param_{}";
            case HookFile::field_accessor_op:
                return "field_accessor_{}";
            case HookFile::type_accessor_op:
                return "type_accessor_{}";
        }
        return "";
    }

    constexpr std::optional<HookFile> HookFile_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "keywords") {
            return HookFile::keyword;
        }
        if (str == "generator_top") {
            return HookFile::generator_top;
        }
        if (str == "file_top") {
            return HookFile::file_top;
        }
        if (str == "file_bottom") {
            return HookFile::file_bottom;
        }
        if (str == "bm_context") {
            return HookFile::bm_context;
        }
        if (str == "flags") {
            return HookFile::flags;
        }
        if (str == "eval_result") {
            return HookFile::eval_result;
        }
        if (str == "escape_ident") {
            return HookFile::escape_ident;
        }
        if (str == "each_inner_block") {
            return HookFile::each_inner_block;
        }
        if (str == "each_inner_function") {
            return HookFile::each_inner_function;
        }
        if (str == "inner_function_start") {
            return HookFile::inner_function_start;
        }
        if (str == "inner_function_each_code") {
            return HookFile::inner_function_each_code;
        }
        if (str == "inner_block_start") {
            return HookFile::inner_block_start;
        }
        if (str == "inner_block_each_code") {
            return HookFile::inner_block_each_code;
        }
        if (str == "param_start") {
            return HookFile::param_start;
        }
        if (str == "param_each_code") {
            return HookFile::param_each_code;
        }
        if (str == "call_param_start") {
            return HookFile::call_param_start;
        }
        if (str == "call_param_each_code") {
            return HookFile::call_param_each_code;
        }
        if (str == "func_{}") {
            return HookFile::inner_function_op;
        }
        if (str == "block_{}") {
            return HookFile::inner_block_op;
        }
        if (str == "eval_{}") {
            return HookFile::eval_op;
        }
        if (str == "type_{}") {
            return HookFile::type_op;
        }
        if (str == "param_{}") {
            return HookFile::param_op;
        }
        if (str == "call_param_{}") {
            return HookFile::call_param_op;
        }
        if (str == "field_accessor_{}") {
            return HookFile::field_accessor_op;
        }
        if (str == "type_accessor_{}") {
            return HookFile::type_accessor_op;
        }
        return std::nullopt;
    }
    enum class HookFileSub {
        main = 0,
        op = 1,
        empty = 2,
        value = 3,
        self = 4,
        field = 5,
        fallback = 6,
        no_fallback = 7,
        before = 8,
        after = 9,
    };
    constexpr const char* to_string(HookFileSub e) {
        switch (e) {
            case HookFileSub::main:
                return "";
            case HookFileSub::op:
                return "_op";
            case HookFileSub::empty:
                return "_empty";
            case HookFileSub::value:
                return "_value";
            case HookFileSub::self:
                return "_self";
            case HookFileSub::field:
                return "_field";
            case HookFileSub::fallback:
                return "_fallback";
            case HookFileSub::no_fallback:
                return "_no_fallback";
            case HookFileSub::before:
                return "_before";
            case HookFileSub::after:
                return "_after";
        }
        return "";
    }

    constexpr std::optional<HookFileSub> HookFileSub_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "") {
            return HookFileSub::main;
        }
        if (str == "_op") {
            return HookFileSub::op;
        }
        if (str == "_empty") {
            return HookFileSub::empty;
        }
        if (str == "_value") {
            return HookFileSub::value;
        }
        if (str == "_self") {
            return HookFileSub::self;
        }
        if (str == "_field") {
            return HookFileSub::field;
        }
        if (str == "_fallback") {
            return HookFileSub::fallback;
        }
        if (str == "_no_fallback") {
            return HookFileSub::no_fallback;
        }
        if (str == "_before") {
            return HookFileSub::before;
        }
        if (str == "_after") {
            return HookFileSub::after;
        }
        return std::nullopt;
    }
}  // namespace bm2
