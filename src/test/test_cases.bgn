# recursive test 
#script\gen_sample C:\workspace\shbrgen\rebrgen\src\test\test_cases.bgn
config.cpp.namespace = "recursive"

enum StorageType:
    :u8
    # terminal
    INT   
    UINT 
    FLOAT 
    STRUCT_REF
    RECURSIVE_STRUCT_REF
    BYTE_VECTOR # special case of vector

    # qualifiers
    ENUM
    ARRAY
    VECTOR
    # for recursive type
    PTR
    # for union
    VARIANT

format Varint:
    prefix :u2
    match prefix:
        0 => value :u6
        1 => value :u14
        2 => value :u30
        3 => value :u62


format Storage:
    type :StorageType
    match type:
        StorageType.INT:
            size :Varint
        StorageType.UINT:
            size :Varint
        StorageType.FLOAT:
            size :Varint
        StorageType.STRUCT_REF:
            ref :Varint
        StorageType.RECURSIVE_STRUCT_REF:
            ref :Varint
        StorageType.BYTE_VECTOR:
            ..
        StorageType.ENUM:
            ref :Varint
            base :Storage
        StorageType.ARRAY:
            size :Varint
            base :Storage
        StorageType.VECTOR:
            ref :Varint
            base :Storage
        StorageType.VARIANT:
            ref :Varint 
            size :Varint
            variants :[size.value]Storage

format X:
    x :X

state M:
    s :bool

fn define() -> X:
    x :X
    x.x = x
    return x

fn get(x :u1) -> u2:
    return if x == 0:
        0
    else:
        1

fn mapToHiragana(code :u6) -> u16:
    return match code:
        0x0 => 'あ'
        0x1 => 'い'
        0x2 => 'う'
        0x3 => 'え'
        0x4 => 'お'
        0x5 => 'か'
        0x6 => 'き'
        0x7 => 'く'
        0x8 => 'け'
        0x9 => 'こ'
        0xa => 'さ'
        0xb => 'し'
        0xc => 'す'
        0xd => 'せ'
        0xe => 'そ'
        0xf => 'た'
        0x10 => 'ち'
        0x11 => 'つ'
        0x12 => 'て'
        0x13 => 'と'
        0x14 => 'な'
        0x15 => 'に'
        0x16 => 'ぬ'
        0x17 => 'ね'
        0x18 => 'の'
        0x19 => 'は'
        0x1a => 'ひ'
        0x1b => 'ふ'
        0x1c => 'へ'
        0x1d => 'ほ'
        0x1e => 'ま'
        0x1f => 'み'
        0x20 => 'む'
        0x21 => 'め'
        0x22 => 'も'
        0x23 => 'や'
        0x24 => 'ゆ'
        0x25 => 'よ'
        0x26 => 'ら'
        0x27 => 'り'
        0x28 => 'る'
        0x29 => 'れ'
        0x2a => 'ろ'
        0x2b => 'わ'
        0x2c => 'が'
        0x2d => 'ぎ'
        0x2e => 'ぐ'
        0x2f => 'げ'
        0x30 => 'ご'
        0x31 => 'ざ'
        0x32 => 'じ'
        0x33 => 'ず'
        0x34 => 'ぜ'
        0x35 => 'ぞ'
        0x36 => 'ば'
        0x37 => 'び'
        0x38 => 'ぶ'
        0x39 => 'べ'
        0x3a => 'ぼ'
        0x3b => 'ぱ'
        0x3c => 'ぴ'
        0x3d => 'ぷ'
        0x3e => 'ぺ'
        0x3f => 'ぽ'


format MIDIData:
    time_division_flag : ub1
    match time_division_flag:
        0 => time_division : ub15
        1 => time_division : SMPTE
    if available(time_division,SMPTE):
        s :ub8
        

format SMPTE:
    frames_per_second : ub7
    ticks_per_frame : ub8


format MapBitInt:
    len_bit :u8
    value :[len_bit]u1(config.type=u32)

enum AbstractEnum:
    abs
    rel

format MapEnum:
    x :AbstractEnum(config.type=u8)

format LEB128:
  value :u64
  fn encode():
    data := value
    # encode value to LEB128
    for:
      if data < 0x80:
        output.put(u8(data))
        break
      else:
        output.put(u8(data & 0x7f))
        data = data >> 7

  fn decode():
    # decode LEB128 to value
    i := 0
    for value < 0x80:
      byte := input.get()
      value = value | u64(byte & 0x7f) << (i * 7)
      i = i + 1

  fn u64() -> u64:
    return value

format Tricky:
    x :u2
    l ::= input.get()
    y :[l]u8

format TCPHeader:
    srcPort :u16
    dstPort :u16
    seqNum :u32
    ackNum :u32
    dataOffset :u4
    reserved :u4
    CWR :u1 ECE :u1 URG :u1 ACK :u1 PSH :u1 RST :u1 SYN :u1 FIN :u1
    windowSize :u16
    checksum :u16
    urgentPointer :u16
    options :[..]TCPOption(input = input.subrange(u8(dataOffset*4)-20))

enum TCPOptionKind:
    :u8
    END_OF_OPTIONS_LIST = 0
    NOP = 1
    MAXIMUM_SEGMENT_SIZE = 2
    WINDOW_SCALE = 3
    SACK_PERMITTED = 4
    SACK = 5
    TIMESTAMP = 8

format TCPOption:
    kind :TCPOptionKind
    match kind:
        TCPOptionKind.END_OF_OPTIONS_LIST => ..
        TCPOptionKind.NOP => ..
        TCPOptionKind.MAXIMUM_SEGMENT_SIZE:
            length :u8
            length == 4
            mss :u16    
        TCPOptionKind.WINDOW_SCALE:
            length :u8
            length == 3
            shiftCount :u8
        TCPOptionKind.SACK_PERMITTED: 
            length :u8
            length == 2
        TCPOptionKind.SACK:
            length :u8
            length >= 2
            sack :Sack(input = input.subrange(length-2))  
        TCPOptionKind.TIMESTAMP:
            length :u8
            length == 10
            timestamp :Timestamp(input = input.subrange(length-2))  
        ..:
            length :u8
            length >= 2
            data :[length-2]u8

format SackBlock:
    left :u32
    right :u32

format Sack:
    blocks :[..]SackBlock

format Timestamp:
    value :u32
    echoReply :u32
