//Code generated by json2cpp2
#pragma once
#include <cstdint>
#include <vector>
#include <array>
#include <optional>
#include <variant>
#include <string_view>

#include <binary/flags.h>
#include <binary/float.h>
#include <view/iovec.h>
#include <binary/number.h>
#include <memory>
#include <error/error.h>
#include <string>
#ifndef EBM_API
#ifdef _WIN32
#define EBM_API __declspec(dllimport)
#else
#define EBM_API
#endif
#endif
namespace ebm {
    enum class BinaryOp : std::uint8_t {
        mul = 0,
        div = 1,
        mod = 2,
        left_shift = 3,
        right_shift = 4,
        bit_and = 5,
        add = 6,
        sub = 7,
        bit_or = 8,
        bit_xor = 9,
        equal = 10,
        not_equal = 11,
        less = 12,
        less_or_eq = 13,
        grater = 14,
        grater_or_eq = 15,
        logical_and = 16,
        logical_or = 17,
    };
    constexpr const char* to_string(BinaryOp e) {
        switch(e) {
            case BinaryOp::mul: return "*";
            case BinaryOp::div: return "/";
            case BinaryOp::mod: return "%";
            case BinaryOp::left_shift: return "<<";
            case BinaryOp::right_shift: return ">>";
            case BinaryOp::bit_and: return "&";
            case BinaryOp::add: return "+";
            case BinaryOp::sub: return "-";
            case BinaryOp::bit_or: return "|";
            case BinaryOp::bit_xor: return "^";
            case BinaryOp::equal: return "==";
            case BinaryOp::not_equal: return "!=";
            case BinaryOp::less: return "<";
            case BinaryOp::less_or_eq: return "<=";
            case BinaryOp::grater: return ">";
            case BinaryOp::grater_or_eq: return ">=";
            case BinaryOp::logical_and: return "&&";
            case BinaryOp::logical_or: return "||";
        }
        return "";
    }
    
    constexpr std::optional<BinaryOp> BinaryOp_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "*") {
            return BinaryOp::mul;
        }
        if (str == "/") {
            return BinaryOp::div;
        }
        if (str == "%") {
            return BinaryOp::mod;
        }
        if (str == "<<") {
            return BinaryOp::left_shift;
        }
        if (str == ">>") {
            return BinaryOp::right_shift;
        }
        if (str == "&") {
            return BinaryOp::bit_and;
        }
        if (str == "+") {
            return BinaryOp::add;
        }
        if (str == "-") {
            return BinaryOp::sub;
        }
        if (str == "|") {
            return BinaryOp::bit_or;
        }
        if (str == "^") {
            return BinaryOp::bit_xor;
        }
        if (str == "==") {
            return BinaryOp::equal;
        }
        if (str == "!=") {
            return BinaryOp::not_equal;
        }
        if (str == "<") {
            return BinaryOp::less;
        }
        if (str == "<=") {
            return BinaryOp::less_or_eq;
        }
        if (str == ">") {
            return BinaryOp::grater;
        }
        if (str == ">=") {
            return BinaryOp::grater_or_eq;
        }
        if (str == "&&") {
            return BinaryOp::logical_and;
        }
        if (str == "||") {
            return BinaryOp::logical_or;
        }
        return std::nullopt;
    }
    enum class UnaryOp : std::uint8_t {
        logical_not = 0,
        minus_sign = 1,
        bit_not = 2,
    };
    constexpr const char* to_string(UnaryOp e) {
        switch(e) {
            case UnaryOp::logical_not: return "!";
            case UnaryOp::minus_sign: return "-";
            case UnaryOp::bit_not: return "~";
        }
        return "";
    }
    
    constexpr std::optional<UnaryOp> UnaryOp_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "!") {
            return UnaryOp::logical_not;
        }
        if (str == "-") {
            return UnaryOp::minus_sign;
        }
        if (str == "~") {
            return UnaryOp::bit_not;
        }
        return std::nullopt;
    }
    enum class Endian : std::uint8_t {
        unspec = 0,
        big = 1,
        little = 2,
        dynamic = 3,
        native = 4,
    };
    constexpr const char* to_string(Endian e) {
        switch(e) {
            case Endian::unspec: return "unspec";
            case Endian::big: return "big";
            case Endian::little: return "little";
            case Endian::dynamic: return "dynamic";
            case Endian::native: return "native";
        }
        return "";
    }
    
    constexpr std::optional<Endian> Endian_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "unspec") {
            return Endian::unspec;
        }
        if (str == "big") {
            return Endian::big;
        }
        if (str == "little") {
            return Endian::little;
        }
        if (str == "dynamic") {
            return Endian::dynamic;
        }
        if (str == "native") {
            return Endian::native;
        }
        return std::nullopt;
    }
    enum class ExpressionOp : std::uint8_t {
        LITERAL_INT = 0,
        LITERAL_BOOL = 1,
        LITERAL_STRING = 2,
        LITERAL_TYPE = 3,
        IDENTIFIER = 4,
        BINARY_OP = 5,
        UNARY_OP = 6,
        CALL = 7,
        INDEX_ACCESS = 8,
        MEMBER_ACCESS = 9,
        TYPE_CAST = 10,
    };
    constexpr const char* to_string(ExpressionOp e) {
        switch(e) {
            case ExpressionOp::LITERAL_INT: return "LITERAL_INT";
            case ExpressionOp::LITERAL_BOOL: return "LITERAL_BOOL";
            case ExpressionOp::LITERAL_STRING: return "LITERAL_STRING";
            case ExpressionOp::LITERAL_TYPE: return "LITERAL_TYPE";
            case ExpressionOp::IDENTIFIER: return "IDENTIFIER";
            case ExpressionOp::BINARY_OP: return "BINARY_OP";
            case ExpressionOp::UNARY_OP: return "UNARY_OP";
            case ExpressionOp::CALL: return "CALL";
            case ExpressionOp::INDEX_ACCESS: return "INDEX_ACCESS";
            case ExpressionOp::MEMBER_ACCESS: return "MEMBER_ACCESS";
            case ExpressionOp::TYPE_CAST: return "TYPE_CAST";
        }
        return "";
    }
    
    constexpr std::optional<ExpressionOp> ExpressionOp_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "LITERAL_INT") {
            return ExpressionOp::LITERAL_INT;
        }
        if (str == "LITERAL_BOOL") {
            return ExpressionOp::LITERAL_BOOL;
        }
        if (str == "LITERAL_STRING") {
            return ExpressionOp::LITERAL_STRING;
        }
        if (str == "LITERAL_TYPE") {
            return ExpressionOp::LITERAL_TYPE;
        }
        if (str == "IDENTIFIER") {
            return ExpressionOp::IDENTIFIER;
        }
        if (str == "BINARY_OP") {
            return ExpressionOp::BINARY_OP;
        }
        if (str == "UNARY_OP") {
            return ExpressionOp::UNARY_OP;
        }
        if (str == "CALL") {
            return ExpressionOp::CALL;
        }
        if (str == "INDEX_ACCESS") {
            return ExpressionOp::INDEX_ACCESS;
        }
        if (str == "MEMBER_ACCESS") {
            return ExpressionOp::MEMBER_ACCESS;
        }
        if (str == "TYPE_CAST") {
            return ExpressionOp::TYPE_CAST;
        }
        return std::nullopt;
    }
    enum class LoopType : std::uint8_t {
        INFINITE = 0,
        WHILE = 1,
        FOR_EACH = 2,
    };
    constexpr const char* to_string(LoopType e) {
        switch(e) {
            case LoopType::INFINITE: return "INFINITE";
            case LoopType::WHILE: return "WHILE";
            case LoopType::FOR_EACH: return "FOR_EACH";
        }
        return "";
    }
    
    constexpr std::optional<LoopType> LoopType_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "INFINITE") {
            return LoopType::INFINITE;
        }
        if (str == "WHILE") {
            return LoopType::WHILE;
        }
        if (str == "FOR_EACH") {
            return LoopType::FOR_EACH;
        }
        return std::nullopt;
    }
    enum class PackedOpType : std::uint8_t {
        FIXED = 0,
        VARIABLE = 1,
    };
    constexpr const char* to_string(PackedOpType e) {
        switch(e) {
            case PackedOpType::FIXED: return "FIXED";
            case PackedOpType::VARIABLE: return "VARIABLE";
        }
        return "";
    }
    
    constexpr std::optional<PackedOpType> PackedOpType_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "FIXED") {
            return PackedOpType::FIXED;
        }
        if (str == "VARIABLE") {
            return PackedOpType::VARIABLE;
        }
        return std::nullopt;
    }
    enum class StatementOp : std::uint8_t {
        ASSIGNMENT = 0,
        RETURN = 1,
        ASSERT = 2,
        NEW_OBJECT = 3,
        READ_DATA = 4,
        WRITE_DATA = 5,
        SEEK_STREAM = 6,
        GET_STREAM_OFFSET = 7,
        GET_REMAINING_BYTES = 8,
        CAN_READ_STREAM = 9,
        IF_STATEMENT = 10,
        LOOP_STATEMENT = 11,
        MATCH_STATEMENT = 12,
        BREAK = 13,
        CONTINUE = 14,
        FUNCTION_DECL = 15,
        VARIABLE_DECL = 16,
        FIELD_DECL = 17,
        ENUM_DECL = 18,
        ENUM_MEMBER_DECL = 19,
        STRUCT_DECL = 20,
        UNION_DECL = 21,
        PROGRAM_DECL = 22,
        STATE_DECL = 23,
        BIT_FIELD_DECL = 24,
        PROPERTY_DECL = 25,
        METADATA = 26,
        IMPORT_MODULE = 27,
        PHI_NODE = 28,
        ERROR_REPORT = 29,
    };
    constexpr const char* to_string(StatementOp e) {
        switch(e) {
            case StatementOp::ASSIGNMENT: return "ASSIGNMENT";
            case StatementOp::RETURN: return "RETURN";
            case StatementOp::ASSERT: return "ASSERT";
            case StatementOp::NEW_OBJECT: return "NEW_OBJECT";
            case StatementOp::READ_DATA: return "READ_DATA";
            case StatementOp::WRITE_DATA: return "WRITE_DATA";
            case StatementOp::SEEK_STREAM: return "SEEK_STREAM";
            case StatementOp::GET_STREAM_OFFSET: return "GET_STREAM_OFFSET";
            case StatementOp::GET_REMAINING_BYTES: return "GET_REMAINING_BYTES";
            case StatementOp::CAN_READ_STREAM: return "CAN_READ_STREAM";
            case StatementOp::IF_STATEMENT: return "IF_STATEMENT";
            case StatementOp::LOOP_STATEMENT: return "LOOP_STATEMENT";
            case StatementOp::MATCH_STATEMENT: return "MATCH_STATEMENT";
            case StatementOp::BREAK: return "BREAK";
            case StatementOp::CONTINUE: return "CONTINUE";
            case StatementOp::FUNCTION_DECL: return "FUNCTION_DECL";
            case StatementOp::VARIABLE_DECL: return "VARIABLE_DECL";
            case StatementOp::FIELD_DECL: return "FIELD_DECL";
            case StatementOp::ENUM_DECL: return "ENUM_DECL";
            case StatementOp::ENUM_MEMBER_DECL: return "ENUM_MEMBER_DECL";
            case StatementOp::STRUCT_DECL: return "STRUCT_DECL";
            case StatementOp::UNION_DECL: return "UNION_DECL";
            case StatementOp::PROGRAM_DECL: return "PROGRAM_DECL";
            case StatementOp::STATE_DECL: return "STATE_DECL";
            case StatementOp::BIT_FIELD_DECL: return "BIT_FIELD_DECL";
            case StatementOp::PROPERTY_DECL: return "PROPERTY_DECL";
            case StatementOp::METADATA: return "METADATA";
            case StatementOp::IMPORT_MODULE: return "IMPORT_MODULE";
            case StatementOp::PHI_NODE: return "PHI_NODE";
            case StatementOp::ERROR_REPORT: return "ERROR_REPORT";
        }
        return "";
    }
    
    constexpr std::optional<StatementOp> StatementOp_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "ASSIGNMENT") {
            return StatementOp::ASSIGNMENT;
        }
        if (str == "RETURN") {
            return StatementOp::RETURN;
        }
        if (str == "ASSERT") {
            return StatementOp::ASSERT;
        }
        if (str == "NEW_OBJECT") {
            return StatementOp::NEW_OBJECT;
        }
        if (str == "READ_DATA") {
            return StatementOp::READ_DATA;
        }
        if (str == "WRITE_DATA") {
            return StatementOp::WRITE_DATA;
        }
        if (str == "SEEK_STREAM") {
            return StatementOp::SEEK_STREAM;
        }
        if (str == "GET_STREAM_OFFSET") {
            return StatementOp::GET_STREAM_OFFSET;
        }
        if (str == "GET_REMAINING_BYTES") {
            return StatementOp::GET_REMAINING_BYTES;
        }
        if (str == "CAN_READ_STREAM") {
            return StatementOp::CAN_READ_STREAM;
        }
        if (str == "IF_STATEMENT") {
            return StatementOp::IF_STATEMENT;
        }
        if (str == "LOOP_STATEMENT") {
            return StatementOp::LOOP_STATEMENT;
        }
        if (str == "MATCH_STATEMENT") {
            return StatementOp::MATCH_STATEMENT;
        }
        if (str == "BREAK") {
            return StatementOp::BREAK;
        }
        if (str == "CONTINUE") {
            return StatementOp::CONTINUE;
        }
        if (str == "FUNCTION_DECL") {
            return StatementOp::FUNCTION_DECL;
        }
        if (str == "VARIABLE_DECL") {
            return StatementOp::VARIABLE_DECL;
        }
        if (str == "FIELD_DECL") {
            return StatementOp::FIELD_DECL;
        }
        if (str == "ENUM_DECL") {
            return StatementOp::ENUM_DECL;
        }
        if (str == "ENUM_MEMBER_DECL") {
            return StatementOp::ENUM_MEMBER_DECL;
        }
        if (str == "STRUCT_DECL") {
            return StatementOp::STRUCT_DECL;
        }
        if (str == "UNION_DECL") {
            return StatementOp::UNION_DECL;
        }
        if (str == "PROGRAM_DECL") {
            return StatementOp::PROGRAM_DECL;
        }
        if (str == "STATE_DECL") {
            return StatementOp::STATE_DECL;
        }
        if (str == "BIT_FIELD_DECL") {
            return StatementOp::BIT_FIELD_DECL;
        }
        if (str == "PROPERTY_DECL") {
            return StatementOp::PROPERTY_DECL;
        }
        if (str == "METADATA") {
            return StatementOp::METADATA;
        }
        if (str == "IMPORT_MODULE") {
            return StatementOp::IMPORT_MODULE;
        }
        if (str == "PHI_NODE") {
            return StatementOp::PHI_NODE;
        }
        if (str == "ERROR_REPORT") {
            return StatementOp::ERROR_REPORT;
        }
        return std::nullopt;
    }
    enum class CastType : std::uint8_t {
        ENUM_TO_INT = 0,
        INT_TO_ENUM = 1,
        FLOAT_TO_INT_BIT = 2,
        INT_TO_FLOAT_BIT = 3,
        VECTOR_TO_ARRAY = 4,
        ARRAY_TO_VECTOR = 5,
        INT_TO_VECTOR = 6,
        INT_TO_ARRAY = 7,
        SMALL_INT_TO_LARGE_INT = 8,
        LARGE_INT_TO_SMALL_INT = 9,
        SIGNED_TO_UNSIGNED = 10,
        UNSIGNED_TO_SIGNED = 11,
        BOOL_TO_INT = 12,
        INT_TO_BOOL = 13,
        STRUCT_TO_RECURSIVE_STRUCT = 14,
        RECURSIVE_STRUCT_TO_STRUCT = 15,
        OTHER = 16,
    };
    constexpr const char* to_string(CastType e) {
        switch(e) {
            case CastType::ENUM_TO_INT: return "ENUM_TO_INT";
            case CastType::INT_TO_ENUM: return "INT_TO_ENUM";
            case CastType::FLOAT_TO_INT_BIT: return "FLOAT_TO_INT_BIT";
            case CastType::INT_TO_FLOAT_BIT: return "INT_TO_FLOAT_BIT";
            case CastType::VECTOR_TO_ARRAY: return "VECTOR_TO_ARRAY";
            case CastType::ARRAY_TO_VECTOR: return "ARRAY_TO_VECTOR";
            case CastType::INT_TO_VECTOR: return "INT_TO_VECTOR";
            case CastType::INT_TO_ARRAY: return "INT_TO_ARRAY";
            case CastType::SMALL_INT_TO_LARGE_INT: return "SMALL_INT_TO_LARGE_INT";
            case CastType::LARGE_INT_TO_SMALL_INT: return "LARGE_INT_TO_SMALL_INT";
            case CastType::SIGNED_TO_UNSIGNED: return "SIGNED_TO_UNSIGNED";
            case CastType::UNSIGNED_TO_SIGNED: return "UNSIGNED_TO_SIGNED";
            case CastType::BOOL_TO_INT: return "BOOL_TO_INT";
            case CastType::INT_TO_BOOL: return "INT_TO_BOOL";
            case CastType::STRUCT_TO_RECURSIVE_STRUCT: return "STRUCT_TO_RECURSIVE_STRUCT";
            case CastType::RECURSIVE_STRUCT_TO_STRUCT: return "RECURSIVE_STRUCT_TO_STRUCT";
            case CastType::OTHER: return "OTHER";
        }
        return "";
    }
    
    constexpr std::optional<CastType> CastType_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "ENUM_TO_INT") {
            return CastType::ENUM_TO_INT;
        }
        if (str == "INT_TO_ENUM") {
            return CastType::INT_TO_ENUM;
        }
        if (str == "FLOAT_TO_INT_BIT") {
            return CastType::FLOAT_TO_INT_BIT;
        }
        if (str == "INT_TO_FLOAT_BIT") {
            return CastType::INT_TO_FLOAT_BIT;
        }
        if (str == "VECTOR_TO_ARRAY") {
            return CastType::VECTOR_TO_ARRAY;
        }
        if (str == "ARRAY_TO_VECTOR") {
            return CastType::ARRAY_TO_VECTOR;
        }
        if (str == "INT_TO_VECTOR") {
            return CastType::INT_TO_VECTOR;
        }
        if (str == "INT_TO_ARRAY") {
            return CastType::INT_TO_ARRAY;
        }
        if (str == "SMALL_INT_TO_LARGE_INT") {
            return CastType::SMALL_INT_TO_LARGE_INT;
        }
        if (str == "LARGE_INT_TO_SMALL_INT") {
            return CastType::LARGE_INT_TO_SMALL_INT;
        }
        if (str == "SIGNED_TO_UNSIGNED") {
            return CastType::SIGNED_TO_UNSIGNED;
        }
        if (str == "UNSIGNED_TO_SIGNED") {
            return CastType::UNSIGNED_TO_SIGNED;
        }
        if (str == "BOOL_TO_INT") {
            return CastType::BOOL_TO_INT;
        }
        if (str == "INT_TO_BOOL") {
            return CastType::INT_TO_BOOL;
        }
        if (str == "STRUCT_TO_RECURSIVE_STRUCT") {
            return CastType::STRUCT_TO_RECURSIVE_STRUCT;
        }
        if (str == "RECURSIVE_STRUCT_TO_STRUCT") {
            return CastType::RECURSIVE_STRUCT_TO_STRUCT;
        }
        if (str == "OTHER") {
            return CastType::OTHER;
        }
        return std::nullopt;
    }
    enum class MergeMode : std::uint8_t {
        COMMON_TYPE = 0,
        STRICT_TYPE = 1,
        STRICT_COMMON_TYPE = 2,
    };
    constexpr const char* to_string(MergeMode e) {
        switch(e) {
            case MergeMode::COMMON_TYPE: return "COMMON_TYPE";
            case MergeMode::STRICT_TYPE: return "STRICT_TYPE";
            case MergeMode::STRICT_COMMON_TYPE: return "STRICT_COMMON_TYPE";
        }
        return "";
    }
    
    constexpr std::optional<MergeMode> MergeMode_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "COMMON_TYPE") {
            return MergeMode::COMMON_TYPE;
        }
        if (str == "STRICT_TYPE") {
            return MergeMode::STRICT_TYPE;
        }
        if (str == "STRICT_COMMON_TYPE") {
            return MergeMode::STRICT_COMMON_TYPE;
        }
        return std::nullopt;
    }
    enum class TypeKind : std::uint8_t {
        INT = 0,
        UINT = 1,
        FLOAT = 2,
        STRUCT = 3,
        RECURSIVE_STRUCT = 4,
        BOOL = 5,
        ENUM = 6,
        ARRAY = 7,
        VECTOR = 8,
        VARIANT = 9,
        CODER_RETURN = 10,
        PROPERTY_SETTER_RETURN = 11,
        OPTIONAL = 12,
        PTR = 13,
    };
    constexpr const char* to_string(TypeKind e) {
        switch(e) {
            case TypeKind::INT: return "INT";
            case TypeKind::UINT: return "UINT";
            case TypeKind::FLOAT: return "FLOAT";
            case TypeKind::STRUCT: return "STRUCT";
            case TypeKind::RECURSIVE_STRUCT: return "RECURSIVE_STRUCT";
            case TypeKind::BOOL: return "BOOL";
            case TypeKind::ENUM: return "ENUM";
            case TypeKind::ARRAY: return "ARRAY";
            case TypeKind::VECTOR: return "VECTOR";
            case TypeKind::VARIANT: return "VARIANT";
            case TypeKind::CODER_RETURN: return "CODER_RETURN";
            case TypeKind::PROPERTY_SETTER_RETURN: return "PROPERTY_SETTER_RETURN";
            case TypeKind::OPTIONAL: return "OPTIONAL";
            case TypeKind::PTR: return "PTR";
        }
        return "";
    }
    
    constexpr std::optional<TypeKind> TypeKind_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "INT") {
            return TypeKind::INT;
        }
        if (str == "UINT") {
            return TypeKind::UINT;
        }
        if (str == "FLOAT") {
            return TypeKind::FLOAT;
        }
        if (str == "STRUCT") {
            return TypeKind::STRUCT;
        }
        if (str == "RECURSIVE_STRUCT") {
            return TypeKind::RECURSIVE_STRUCT;
        }
        if (str == "BOOL") {
            return TypeKind::BOOL;
        }
        if (str == "ENUM") {
            return TypeKind::ENUM;
        }
        if (str == "ARRAY") {
            return TypeKind::ARRAY;
        }
        if (str == "VECTOR") {
            return TypeKind::VECTOR;
        }
        if (str == "VARIANT") {
            return TypeKind::VARIANT;
        }
        if (str == "CODER_RETURN") {
            return TypeKind::CODER_RETURN;
        }
        if (str == "PROPERTY_SETTER_RETURN") {
            return TypeKind::PROPERTY_SETTER_RETURN;
        }
        if (str == "OPTIONAL") {
            return TypeKind::OPTIONAL;
        }
        if (str == "PTR") {
            return TypeKind::PTR;
        }
        return std::nullopt;
    }
    struct Varint;
    struct EndianExpr;
    struct String;
    struct IdentifierRef;
    struct TypeRef;
    struct ExpressionRef;
    struct StringRef;
    struct StatementRef;
    struct PhiParam;
    struct Loc;
    struct Block;
    struct IfStatement;
    struct UnionMemberDecl;
    struct FieldDecl;
    struct BitFieldDecl;
    struct PropertyDecl;
    struct EnumMemberDecl;
    struct MatchBranch;
    struct LoopStatement;
    struct VariableDecl;
    struct MatchStatement;
    struct StructDecl;
    struct UnionDecl;
    struct Metadata;
    struct Type;
    struct DebugInfo;
    struct FunctionDecl;
    struct EnumDecl;
    struct Expression;
    struct Statement;
    struct ExtendedBinaryModule;
    struct EBM_API Varint{
        ::futils::binary::flags_t<std::uint64_t,2,62> flags_1_;
        bits_flag_alias_method(flags_1_,0,prefix);
        bits_flag_alias_method(flags_1_,1,value);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 0;
    };
    struct EBM_API EndianExpr{
        ::futils::binary::flags_t<std::uint8_t, 3, 1, 4> flags_2_;
        bits_flag_alias_method_with_enum(flags_2_,0,endian,Endian);
        bits_flag_alias_method(flags_2_,1,sign);
        bits_flag_alias_method(flags_2_,2,reserved);
        Varint dynamic_ref;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
    };
    struct EBM_API String{
        Varint length;
        std::string data;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API IdentifierRef{
        Varint id;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API TypeRef{
        Varint id;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API ExpressionRef{
        Varint id;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API StringRef{
        Varint id;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API StatementRef{
        Varint id;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API PhiParam{
        ExpressionRef condition;
        ExpressionRef value;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API Loc{
        Varint ident;
        Varint file_id;
        Varint line;
        Varint column;
        Varint start;
        Varint end;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API Block{
        Varint statements_len;
        std::vector<StatementRef> statements;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API IfStatement{
        ExpressionRef condition;
        Block then_block;
        Block else_block;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API UnionMemberDecl{
        IdentifierRef name;
        TypeRef field_type;
        ::futils::binary::flags_t<std::uint8_t, 1, 7> flags_3_;
        bits_flag_alias_method(flags_3_,0,is_state_variable);
        bits_flag_alias_method(flags_3_,1,reserved);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API FieldDecl{
        IdentifierRef name;
        TypeRef field_type;
        IdentifierRef parent_struct;
        ::futils::binary::flags_t<std::uint8_t, 1, 7> flags_4_;
        bits_flag_alias_method(flags_4_,0,is_state_variable);
        bits_flag_alias_method(flags_4_,1,reserved);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API BitFieldDecl{
        IdentifierRef name;
        IdentifierRef parent_format;
        Varint bit_size;
        PackedOpType packed_op_type{};
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API PropertyDecl{
        IdentifierRef name;
        IdentifierRef parent_format;
        TypeRef property_type;
        MergeMode merge_mode{};
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API EnumMemberDecl{
        IdentifierRef name;
        ExpressionRef value;
        IdentifierRef string_repr;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API MatchBranch{
        ExpressionRef condition;
        Block body;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API LoopStatement{
        LoopType loop_type{};
        struct EBM_API union_struct_7{
        };
        struct EBM_API union_struct_8{
            ExpressionRef condition;
        };
        struct EBM_API union_struct_9{
            IdentifierRef item_var;
            ExpressionRef collection;
        };
        std::variant<std::monostate, union_struct_7, union_struct_8, union_struct_9> union_variant_6;
        std::optional<ExpressionRef> collection() const;
        bool collection(ExpressionRef&& v);
        bool collection(const ExpressionRef& v);
        std::optional<ExpressionRef> condition() const;
        bool condition(ExpressionRef&& v);
        bool condition(const ExpressionRef& v);
        std::optional<IdentifierRef> item_var() const;
        bool item_var(IdentifierRef&& v);
        bool item_var(const IdentifierRef& v);
        Block body;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
    };
    struct EBM_API VariableDecl{
        IdentifierRef name;
        TypeRef var_type;
        ExpressionRef initial_value;
        ::futils::binary::flags_t<std::uint8_t, 1, 7> flags_10_;
        bits_flag_alias_method(flags_10_,0,is_constant);
        bits_flag_alias_method(flags_10_,1,reserved);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API MatchStatement{
        ExpressionRef target;
        ::futils::binary::flags_t<std::uint8_t, 1, 7> flags_11_;
        bits_flag_alias_method(flags_11_,0,is_exhaustive);
        bits_flag_alias_method(flags_11_,1,reserved);
        Varint branches_len;
        std::vector<MatchBranch> branches;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API StructDecl{
        IdentifierRef name;
        Varint fields_len;
        std::vector<FieldDecl> fields;
        ::futils::binary::flags_t<std::uint8_t, 1, 7> flags_12_;
        bits_flag_alias_method(flags_12_,0,is_recursive);
        bits_flag_alias_method(flags_12_,1,reserved);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API UnionDecl{
        IdentifierRef name;
        IdentifierRef parent_field;
        Varint members_len;
        std::vector<UnionMemberDecl> members;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API Metadata{
        IdentifierRef name;
        Varint values_len;
        std::vector<ExpressionRef> values;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API Type{
        TypeKind kind{};
        struct EBM_API union_struct_15{
            std::uint8_t size = 0;
        };
        struct EBM_API union_struct_16{
            std::uint8_t size = 0;
        };
        struct EBM_API union_struct_17{
            std::uint8_t size = 0;
        };
        struct EBM_API union_struct_18{
        };
        struct EBM_API union_struct_19{
            TypeRef base_type;
        };
        struct EBM_API union_struct_20{
            TypeRef element_type;
            Varint length;
        };
        struct EBM_API union_struct_21{
            TypeRef element_type;
        };
        struct EBM_API union_struct_22{
            IdentifierRef name;
        };
        struct EBM_API union_struct_23{
            IdentifierRef name;
        };
        struct EBM_API union_struct_24{
            TypeRef common_type;
        };
        struct EBM_API union_struct_25{
            TypeRef coder_type;
        };
        struct EBM_API union_struct_26{
            TypeRef property_type;
        };
        struct EBM_API union_struct_27{
            TypeRef inner_type;
        };
        struct EBM_API union_struct_28{
            TypeRef pointee_type;
        };
        std::variant<std::monostate, union_struct_15, union_struct_16, union_struct_17, union_struct_18, union_struct_19, union_struct_20, union_struct_21, union_struct_22, union_struct_23, union_struct_24, union_struct_25, union_struct_26, union_struct_27, union_struct_28> union_variant_14;
        std::optional<TypeRef> base_type() const;
        bool base_type(TypeRef&& v);
        bool base_type(const TypeRef& v);
        std::optional<TypeRef> coder_type() const;
        bool coder_type(TypeRef&& v);
        bool coder_type(const TypeRef& v);
        std::optional<TypeRef> common_type() const;
        bool common_type(TypeRef&& v);
        bool common_type(const TypeRef& v);
        std::optional<TypeRef> element_type() const;
        bool element_type(TypeRef&& v);
        bool element_type(const TypeRef& v);
        std::optional<TypeRef> inner_type() const;
        bool inner_type(TypeRef&& v);
        bool inner_type(const TypeRef& v);
        std::optional<Varint> length() const;
        bool length(Varint&& v);
        bool length(const Varint& v);
        std::optional<IdentifierRef> name() const;
        bool name(IdentifierRef&& v);
        bool name(const IdentifierRef& v);
        std::optional<TypeRef> pointee_type() const;
        bool pointee_type(TypeRef&& v);
        bool pointee_type(const TypeRef& v);
        std::optional<TypeRef> property_type() const;
        bool property_type(TypeRef&& v);
        bool property_type(const TypeRef& v);
        std::optional<std::uint8_t> size() const;
        bool size(std::uint8_t&& v);
        bool size(const std::uint8_t& v);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
    };
    struct EBM_API DebugInfo{
        Varint len_files;
        std::vector<String> files;
        Varint len_locs;
        std::vector<Loc> locs;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API FunctionDecl{
        IdentifierRef name;
        TypeRef return_type;
        Varint params_len;
        std::vector<VariableDecl> params;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API EnumDecl{
        IdentifierRef name;
        TypeRef base_type;
        Varint members_len;
        std::vector<EnumMemberDecl> members;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API Expression{
        ExpressionRef id;
        ExpressionOp op{};
        struct EBM_API union_struct_31{
            std::uint64_t value = 0;
        };
        struct EBM_API union_struct_32{
            std::uint8_t value = 0;
        };
        struct EBM_API union_struct_33{
            StringRef value;
        };
        struct EBM_API union_struct_34{
            TypeRef type_ref;
        };
        struct EBM_API union_struct_35{
            IdentifierRef value;
        };
        struct EBM_API union_struct_36{
            BinaryOp bop{};
            ExpressionRef left;
            ExpressionRef right;
        };
        struct EBM_API union_struct_37{
            UnaryOp uop{};
            ExpressionRef operand;
        };
        struct EBM_API union_struct_38{
            ExpressionRef callee;
            Varint args_len;
            std::vector<ExpressionRef> arguments;
        };
        struct EBM_API union_struct_39{
            ExpressionRef base;
            ExpressionRef index;
        };
        struct EBM_API union_struct_40{
            ExpressionRef base;
            IdentifierRef member;
        };
        struct EBM_API union_struct_41{
            TypeRef target_type;
            ExpressionRef source_expr;
            CastType cast_kind{};
        };
        std::variant<std::monostate, union_struct_31, union_struct_32, union_struct_33, union_struct_34, union_struct_35, union_struct_36, union_struct_37, union_struct_38, union_struct_39, union_struct_40, union_struct_41> union_variant_30;
        std::optional<Varint> args_len() const;
        bool args_len(Varint&& v);
        bool args_len(const Varint& v);
        std::optional<std::vector<ExpressionRef>> arguments() const;
        bool arguments(std::vector<ExpressionRef>&& v);
        bool arguments(const std::vector<ExpressionRef>& v);
        std::optional<ExpressionRef> base() const;
        bool base(ExpressionRef&& v);
        bool base(const ExpressionRef& v);
        std::optional<BinaryOp> bop() const;
        bool bop(BinaryOp&& v);
        bool bop(const BinaryOp& v);
        std::optional<ExpressionRef> callee() const;
        bool callee(ExpressionRef&& v);
        bool callee(const ExpressionRef& v);
        std::optional<CastType> cast_kind() const;
        bool cast_kind(CastType&& v);
        bool cast_kind(const CastType& v);
        std::optional<ExpressionRef> index() const;
        bool index(ExpressionRef&& v);
        bool index(const ExpressionRef& v);
        std::optional<ExpressionRef> left() const;
        bool left(ExpressionRef&& v);
        bool left(const ExpressionRef& v);
        std::optional<IdentifierRef> member() const;
        bool member(IdentifierRef&& v);
        bool member(const IdentifierRef& v);
        std::optional<ExpressionRef> operand() const;
        bool operand(ExpressionRef&& v);
        bool operand(const ExpressionRef& v);
        std::optional<ExpressionRef> right() const;
        bool right(ExpressionRef&& v);
        bool right(const ExpressionRef& v);
        std::optional<ExpressionRef> source_expr() const;
        bool source_expr(ExpressionRef&& v);
        bool source_expr(const ExpressionRef& v);
        std::optional<TypeRef> target_type() const;
        bool target_type(TypeRef&& v);
        bool target_type(const TypeRef& v);
        std::optional<TypeRef> type_ref() const;
        bool type_ref(TypeRef&& v);
        bool type_ref(const TypeRef& v);
        std::optional<UnaryOp> uop() const;
        bool uop(UnaryOp&& v);
        bool uop(const UnaryOp& v);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API Statement{
        StatementRef id;
        StatementOp statement_kind{};
        struct EBM_API union_struct_44{
            ExpressionRef target;
            ExpressionRef value;
        };
        struct EBM_API union_struct_45{
            ExpressionRef value;
        };
        struct EBM_API union_struct_46{
            ExpressionRef condition;
            IdentifierRef message;
        };
        struct EBM_API union_struct_47{
            IdentifierRef target_var;
            TypeRef object_type;
        };
        struct EBM_API union_struct_48{
            IdentifierRef target_var;
            TypeRef data_type;
            EndianExpr endian;
            Varint bit_size;
        };
        struct EBM_API union_struct_49{
            ExpressionRef source_expr;
            TypeRef data_type;
            EndianExpr endian;
            Varint bit_size;
        };
        struct EBM_API union_struct_50{
            ExpressionRef offset;
            IdentifierRef stream_type;
        };
        struct EBM_API union_struct_51{
            IdentifierRef target_var;
            IdentifierRef stream_type;
        };
        struct EBM_API union_struct_52{
            IdentifierRef target_var;
            IdentifierRef stream_type;
        };
        struct EBM_API union_struct_53{
            IdentifierRef target_var;
            IdentifierRef stream_type;
            ExpressionRef num_bytes;
        };
        struct EBM_API union_struct_54{
            IfStatement if_statement;
        };
        struct EBM_API union_struct_55{
            LoopStatement loop;
        };
        struct EBM_API union_struct_56{
            MatchStatement match_statement;
        };
        struct EBM_API union_struct_57{
        };
        struct EBM_API union_struct_58{
        };
        struct EBM_API union_struct_59{
            FunctionDecl func_decl;
        };
        struct EBM_API union_struct_60{
            VariableDecl var_decl;
        };
        struct EBM_API union_struct_61{
            FieldDecl field_decl;
        };
        struct EBM_API union_struct_62{
            EnumDecl enum_decl;
        };
        struct EBM_API union_struct_63{
            EnumMemberDecl enum_member_decl;
        };
        struct EBM_API union_struct_64{
            StructDecl struct_decl;
        };
        struct EBM_API union_struct_65{
            UnionDecl union_decl;
        };
        struct EBM_API union_struct_66{
            IdentifierRef name;
            Block body;
        };
        struct EBM_API union_struct_67{
            IdentifierRef name;
            Block body;
        };
        struct EBM_API union_struct_68{
            BitFieldDecl bit_field_decl;
        };
        struct EBM_API union_struct_69{
            PropertyDecl property_decl;
        };
        struct EBM_API union_struct_70{
            Metadata metadata;
        };
        struct EBM_API union_struct_71{
            IdentifierRef module_name;
            IdentifierRef alias;
        };
        struct EBM_API union_struct_72{
            IdentifierRef target_var;
            Varint params_len;
            std::vector<PhiParam> params;
        };
        struct EBM_API union_struct_73{
            StringRef message;
            Varint args_len;
            std::vector<ExpressionRef> arguments;
        };
        std::variant<std::monostate, union_struct_44, union_struct_45, union_struct_46, union_struct_47, union_struct_48, union_struct_49, union_struct_50, union_struct_51, union_struct_52, union_struct_53, union_struct_54, union_struct_55, union_struct_56, union_struct_57, union_struct_58, union_struct_59, union_struct_60, union_struct_61, union_struct_62, union_struct_63, union_struct_64, union_struct_65, union_struct_66, union_struct_67, union_struct_68, union_struct_69, union_struct_70, union_struct_71, union_struct_72, union_struct_73> union_variant_43;
        std::optional<IdentifierRef> alias() const;
        bool alias(IdentifierRef&& v);
        bool alias(const IdentifierRef& v);
        std::optional<Varint> args_len() const;
        bool args_len(Varint&& v);
        bool args_len(const Varint& v);
        std::optional<std::vector<ExpressionRef>> arguments() const;
        bool arguments(std::vector<ExpressionRef>&& v);
        bool arguments(const std::vector<ExpressionRef>& v);
        std::optional<BitFieldDecl> bit_field_decl() const;
        bool bit_field_decl(BitFieldDecl&& v);
        bool bit_field_decl(const BitFieldDecl& v);
        std::optional<Varint> bit_size() const;
        bool bit_size(Varint&& v);
        bool bit_size(const Varint& v);
        std::optional<Block> body() const;
        bool body(Block&& v);
        bool body(const Block& v);
        std::optional<ExpressionRef> condition() const;
        bool condition(ExpressionRef&& v);
        bool condition(const ExpressionRef& v);
        std::optional<TypeRef> data_type() const;
        bool data_type(TypeRef&& v);
        bool data_type(const TypeRef& v);
        std::optional<EndianExpr> endian() const;
        bool endian(EndianExpr&& v);
        bool endian(const EndianExpr& v);
        std::optional<EnumDecl> enum_decl() const;
        bool enum_decl(EnumDecl&& v);
        bool enum_decl(const EnumDecl& v);
        std::optional<EnumMemberDecl> enum_member_decl() const;
        bool enum_member_decl(EnumMemberDecl&& v);
        bool enum_member_decl(const EnumMemberDecl& v);
        std::optional<FieldDecl> field_decl() const;
        bool field_decl(FieldDecl&& v);
        bool field_decl(const FieldDecl& v);
        std::optional<FunctionDecl> func_decl() const;
        bool func_decl(FunctionDecl&& v);
        bool func_decl(const FunctionDecl& v);
        std::optional<IfStatement> if_statement() const;
        bool if_statement(IfStatement&& v);
        bool if_statement(const IfStatement& v);
        std::optional<LoopStatement> loop() const;
        bool loop(LoopStatement&& v);
        bool loop(const LoopStatement& v);
        std::optional<MatchStatement> match_statement() const;
        bool match_statement(MatchStatement&& v);
        bool match_statement(const MatchStatement& v);
        std::optional<Metadata> metadata() const;
        bool metadata(Metadata&& v);
        bool metadata(const Metadata& v);
        std::optional<IdentifierRef> module_name() const;
        bool module_name(IdentifierRef&& v);
        bool module_name(const IdentifierRef& v);
        std::optional<IdentifierRef> name() const;
        bool name(IdentifierRef&& v);
        bool name(const IdentifierRef& v);
        std::optional<ExpressionRef> num_bytes() const;
        bool num_bytes(ExpressionRef&& v);
        bool num_bytes(const ExpressionRef& v);
        std::optional<TypeRef> object_type() const;
        bool object_type(TypeRef&& v);
        bool object_type(const TypeRef& v);
        std::optional<ExpressionRef> offset() const;
        bool offset(ExpressionRef&& v);
        bool offset(const ExpressionRef& v);
        std::optional<std::vector<PhiParam>> params() const;
        bool params(std::vector<PhiParam>&& v);
        bool params(const std::vector<PhiParam>& v);
        std::optional<Varint> params_len() const;
        bool params_len(Varint&& v);
        bool params_len(const Varint& v);
        std::optional<PropertyDecl> property_decl() const;
        bool property_decl(PropertyDecl&& v);
        bool property_decl(const PropertyDecl& v);
        std::optional<ExpressionRef> source_expr() const;
        bool source_expr(ExpressionRef&& v);
        bool source_expr(const ExpressionRef& v);
        std::optional<IdentifierRef> stream_type() const;
        bool stream_type(IdentifierRef&& v);
        bool stream_type(const IdentifierRef& v);
        std::optional<StructDecl> struct_decl() const;
        bool struct_decl(StructDecl&& v);
        bool struct_decl(const StructDecl& v);
        std::optional<ExpressionRef> target() const;
        bool target(ExpressionRef&& v);
        bool target(const ExpressionRef& v);
        std::optional<IdentifierRef> target_var() const;
        bool target_var(IdentifierRef&& v);
        bool target_var(const IdentifierRef& v);
        std::optional<UnionDecl> union_decl() const;
        bool union_decl(UnionDecl&& v);
        bool union_decl(const UnionDecl& v);
        std::optional<ExpressionRef> value() const;
        bool value(ExpressionRef&& v);
        bool value(const ExpressionRef& v);
        std::optional<VariableDecl> var_decl() const;
        bool var_decl(VariableDecl&& v);
        bool var_decl(const VariableDecl& v);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    struct EBM_API ExtendedBinaryModule{
        //"EBMG" (4 bytes)
        std::uint8_t version = 0;
        Varint identifiers_len;
        std::vector<String> identifiers;
        Varint strings_len;
        std::vector<String> strings;
        Varint types_len;
        std::vector<Type> types;
        Varint statements_len;
        std::vector<Statement> statements;
        Varint expressions_len;
        std::vector<Expression> expressions;
        DebugInfo debug_info;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 5;
    };
} // namespace ebm

