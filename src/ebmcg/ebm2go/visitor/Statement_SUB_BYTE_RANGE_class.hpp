/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_SUB_BYTE_RANGE_class
  Available Variables:
    ctx: Context_Statement_SUB_BYTE_RANGE
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        module_: ebmgen::MappingTable
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
      item_id: ebm::StatementRef
      kind: const ebm::StatementKind&
      sub_byte_range: const ebm::SubByteRange&
        stream_type: StreamType
        range_type: SubByteRangeType
        expression: *ExpressionRef
        length: *ExpressionRef
        offset: *ExpressionRef
        io_ref: StatementRef
        parent_io_ref: WeakStatementRef
        io_statement: StatementRef
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include "../codegen.hpp"
DEFINE_VISITOR(Statement_SUB_BYTE_RANGE) {
    using namespace CODEGEN_NAMESPACE;
    auto io_ = ctx.identifier(ctx.sub_byte_range.io_ref);
    auto io_base_ = io_ + "_base";
    auto parent_io_ = ctx.identifier(ctx.sub_byte_range.parent_io_ref);

    CodeWriter w;

    if (ctx.sub_byte_range.range_type == ebm::SubByteRangeType::bytes) {
        MAYBE(length, ctx.sub_byte_range.length());
        MAYBE(length_str, ctx.visit(length));

        if (ctx.config().use_io_reader_writer) {
            if (ctx.sub_byte_range.stream_type == ebm::StreamType::INPUT) {
                // Decode: read length bytes from reader, wrap in bytes.Reader for child
                ctx.config().imports.insert("bytes");
                w.writeln(io_base_, " := make([]byte, int(", length_str.to_writer(), "))");
                w.writeln("if _, err := io.ReadFull(", parent_io_, ", ", io_base_, "); err != nil {");
                w.indent_writeln("return err");
                w.writeln("}");
                w.writeln(io_, " := bytes.NewReader(", io_base_, ")");
            }
            else {
                // Encode: create bytes.Buffer for child to write to
                ctx.config().imports.insert("bytes");
                w.writeln(io_, " := &bytes.Buffer{}");
            }

            MAYBE(do_io, ctx.visit(ctx.sub_byte_range.io_statement));
            w.write(do_io.to_writer());

            if (ctx.sub_byte_range.stream_type == ebm::StreamType::OUTPUT) {
                // After encoding: verify length and write to parent
                ctx.config().imports.insert("fmt");
                w.writeln("if ", io_, ".Len() != int(", length_str.to_writer(), ") {");
                w.indent_writeln("return fmt.Errorf(\"subrange length mismatch: expected %d, got %d\", int(", length_str.to_writer(), "), ", io_, ".Len())");
                w.writeln("}");
                w.writeln("if _, err := ", parent_io_, ".Write(", io_, ".Bytes()); err != nil {");
                w.indent_writeln("return err");
                w.writeln("}");
            }
            return w;
        }

        if (ctx.sub_byte_range.stream_type == ebm::StreamType::INPUT) {
            // Decode: slice length bytes from parent, create *[]byte for child IO
            ctx.config().imports.insert("errors");
            w.writeln("if len(*", parent_io_, ") < int(", length_str.to_writer(), ") {");
            w.indent_writeln("return errors.New(\"not enough data for subrange\")");
            w.writeln("}");
            w.writeln(io_base_, " := (*", parent_io_, ")[:int(", length_str.to_writer(), ")]");
            w.writeln(io_, " := &", io_base_);
            w.writeln("*", parent_io_, " = (*", parent_io_, ")[int(", length_str.to_writer(), "):]");
        }
        else {
            // Encode: pre-allocate buffer, create *[]byte for child IO
            w.writeln(io_base_, " := make([]byte, 0, int(", length_str.to_writer(), "))");
            w.writeln(io_, " := &", io_base_);
        }

        MAYBE(do_io, ctx.visit(ctx.sub_byte_range.io_statement));
        w.write(do_io.to_writer());

        if (ctx.sub_byte_range.stream_type == ebm::StreamType::OUTPUT) {
            // After encoding: verify length and copy to parent
            ctx.config().imports.insert("fmt");
            ctx.config().imports.insert("errors");
            w.writeln("if len(*", io_, ") != int(", length_str.to_writer(), ") {");
            w.indent_writeln("return fmt.Errorf(\"subrange length mismatch: expected %d, got %d\", int(", length_str.to_writer(), "), len(*", io_, "))");
            w.writeln("}");
            w.writeln("if len(*", parent_io_, ") < len(*", io_, ") {");
            w.indent_writeln("return errors.New(\"not enough space for subrange\")");
            w.writeln("}");
            w.writeln("copy((*", parent_io_, ")[:len(*", io_, ")], *", io_, ")");
            w.writeln("*", parent_io_, " = (*", parent_io_, ")[len(*", io_, "):]");
        }
    }
    else if (ctx.sub_byte_range.range_type == ebm::SubByteRangeType::seek_bytes) {
        MAYBE(length, ctx.sub_byte_range.length());
        MAYBE(length_str, ctx.visit(length));
        MAYBE(offset, ctx.sub_byte_range.offset());
        MAYBE(offset_str, ctx.visit(offset));

        if (ctx.sub_byte_range.stream_type == ebm::StreamType::INPUT) {
            // Decode: slice from offset with length, no parent advancement
            w.writeln(io_base_, " := (*", parent_io_, ")[int(", offset_str.to_writer(), "):int(", offset_str.to_writer(), " + ", length_str.to_writer(), ")]");
            w.writeln(io_, " := &", io_base_);
        }
        else {
            // Encode: slice from offset with length for writing
            w.writeln(io_base_, " := (*", parent_io_, ")[int(", offset_str.to_writer(), "):int(", offset_str.to_writer(), " + ", length_str.to_writer(), ")]");
            w.writeln(io_, " := &", io_base_);
        }

        MAYBE(do_io, ctx.visit(ctx.sub_byte_range.io_statement));
        w.write(do_io.to_writer());
    }

    return w;
}
