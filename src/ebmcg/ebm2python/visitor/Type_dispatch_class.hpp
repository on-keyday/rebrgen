/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Type_dispatch_class
  Available Variables:
    ctx: Context_Type
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        module_: ebmgen::MappingTable
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
      in: const ebm::Type&
      alias_ref: ebm::TypeRef
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include "../codegen.hpp"
DEFINE_VISITOR(Type_dispatch) {
    using namespace CODEGEN_NAMESPACE;
    /*here to write the hook*/
    const auto& type = ctx.in;
    auto& visitor = ctx;

    auto type_to_python_str = [&](ebm::TypeRef type_ref) -> expected<std::string> {
        MAYBE(res, visit_Type(visitor, type_ref));
        return res.to_string();
    };

    switch (type.body.kind) {
        case ebm::TypeKind::INT:
        case ebm::TypeKind::UINT:
            return "int";
        case ebm::TypeKind::FLOAT:
            return "float";
        case ebm::TypeKind::BOOL:
            return "bool";
        case ebm::TypeKind::STRUCT:
        case ebm::TypeKind::RECURSIVE_STRUCT: {  // Handle RECURSIVE_STRUCT here as well
            // For structs, get the name of the struct
            MAYBE(layers, get_identifier_layer(visitor, from_weak(*type.body.id())));
            return join(".", layers | std::views::values);
        }
        case ebm::TypeKind::VOID:
            return "None";
        case ebm::TypeKind::META:
            return "Any";
        case ebm::TypeKind::ARRAY:
        case ebm::TypeKind::VECTOR: {  // Handle both ARRAY and VECTOR here
            MAYBE(element_type_obj, ctx.get(*type.body.element_type()));
            if ((element_type_obj.body.kind == ebm::TypeKind::UINT || element_type_obj.body.kind == ebm::TypeKind::INT) &&
                element_type_obj.body.size() && element_type_obj.body.size()->value() == 8) {
                return "bytearray";
            }
            else {
                MAYBE(element_type_str, type_to_python_str(*type.body.element_type()));  // Recursive call
                return "list[" + element_type_str + "]";
            }
        }
        case ebm::TypeKind::ENUM: {
            // For enums, get the name of the enum
            MAYBE(enum_decl_stmt, ctx.get(*type.body.id()));
            auto enum_name = ctx.identifier(enum_decl_stmt.id);
            return "Union[" + enum_name + ",int]";
        }
        case ebm::TypeKind::ENCODER_RETURN:
        case ebm::TypeKind::DECODER_RETURN:
            return "None";                  // Or some other appropriate type for return values
        case ebm::TypeKind::ENCODER_INPUT:  // Add this case
        case ebm::TypeKind::DECODER_INPUT:  // Add this case
            return "BinaryIO";              // Map encoder/decoder input to bytes
        case ebm::TypeKind::FUNCTION: {
            // For functions, return a Callable type hint
            MAYBE(return_type_str, type_to_python_str(type.body.func_desc()->return_type));
            std::string params_str = "";  // Reverted: params_str is empty here
            return "Callable[[" + params_str + "], " + return_type_str + "]";
        }
        case ebm::TypeKind::VARIANT: {
            // For variants, return Union of member types
            std::string members_str = "";
            for (auto& member_type_ref : type.body.variant_desc()->members.container) {
                MAYBE(member_str, type_to_python_str(member_type_ref));
                if (!members_str.empty()) {
                    members_str += ", ";
                }
                members_str += member_str;
            }
            return "Union[" + members_str + "]";
        }
        case ebm::TypeKind::RANGE: {
            // For ranges, return a tuple or a custom Range type
            MAYBE(base_type_str, type_to_python_str(*type.body.base_type()));
            return "tuple[" + base_type_str + ", " + base_type_str + "]";
        }
        case ebm::TypeKind::OPTIONAL: {
            // For optional types, return Optional type hint
            MAYBE(inner_type_str, type_to_python_str(*type.body.inner_type()));
            return "Optional[" + inner_type_str + "]";
        }
        case ebm::TypeKind::PTR: {
            // For pointers, return Any or a specific type if context allows
            MAYBE(pointee_type_str, type_to_python_str(*type.body.pointee_type()));
            return "Optional[" + pointee_type_str + "]";  // Using Optional to represent nullable pointers
        }
        case ebm::TypeKind::PROPERTY_SETTER_RETURN: {
            return "bool";
        }
        case ebm::TypeKind::USIZE:
            return "int";
        default:
            return unexpect_error("Unhandled TypeKind: {}", to_string(type.body.kind));  // Return an error for unhandled types
    }
}