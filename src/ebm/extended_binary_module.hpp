//Code generated by json2cpp2
#pragma once
#include <cstdint>
#include <vector>
#include <array>
#include <optional>
#include <variant>
#include <string_view>

#include <binary/flags.h>
#include <binary/float.h>
#include <view/iovec.h>
#include <binary/number.h>
#include <memory>
#include <error/error.h>
#include <string>
#ifndef EBM_API
#ifdef _WIN32
#define EBM_API __declspec(dllimport)
#else
#define EBM_API
#endif
#endif
namespace ebm {
    enum class GenerateType {
        Normal = 0,
        Encode = 1,
        Decode = 2,
    };
    constexpr const char* to_string(GenerateType e, bool origin_form = false) {
        switch(e) {
            case GenerateType::Normal: return origin_form ? "Normal":"Normal" ;
            case GenerateType::Encode: return origin_form ? "Encode":"Encode" ;
            case GenerateType::Decode: return origin_form ? "Decode":"Decode" ;
        }
        return "";
    }
    
    constexpr std::optional<GenerateType> GenerateType_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "Normal") {
            return GenerateType::Normal;
        }
        if (str == "Encode") {
            return GenerateType::Encode;
        }
        if (str == "Decode") {
            return GenerateType::Decode;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(GenerateType) {
        return "GenerateType";
    }
    enum class BinaryOp : std::uint8_t {
        mul = 0,
        div = 1,
        mod = 2,
        left_shift = 3,
        right_shift = 4,
        bit_and = 5,
        add = 6,
        sub = 7,
        bit_or = 8,
        bit_xor = 9,
        equal = 10,
        not_equal = 11,
        less = 12,
        less_or_eq = 13,
        greater = 14,
        greater_or_eq = 15,
        logical_and = 16,
        logical_or = 17,
    };
    constexpr const char* to_string(BinaryOp e, bool origin_form = false) {
        switch(e) {
            case BinaryOp::mul: return origin_form ? "mul":"*" ;
            case BinaryOp::div: return origin_form ? "div":"/" ;
            case BinaryOp::mod: return origin_form ? "mod":"%" ;
            case BinaryOp::left_shift: return origin_form ? "left_shift":"<<" ;
            case BinaryOp::right_shift: return origin_form ? "right_shift":">>" ;
            case BinaryOp::bit_and: return origin_form ? "bit_and":"&" ;
            case BinaryOp::add: return origin_form ? "add":"+" ;
            case BinaryOp::sub: return origin_form ? "sub":"-" ;
            case BinaryOp::bit_or: return origin_form ? "bit_or":"|" ;
            case BinaryOp::bit_xor: return origin_form ? "bit_xor":"^" ;
            case BinaryOp::equal: return origin_form ? "equal":"==" ;
            case BinaryOp::not_equal: return origin_form ? "not_equal":"!=" ;
            case BinaryOp::less: return origin_form ? "less":"<" ;
            case BinaryOp::less_or_eq: return origin_form ? "less_or_eq":"<=" ;
            case BinaryOp::greater: return origin_form ? "greater":">" ;
            case BinaryOp::greater_or_eq: return origin_form ? "greater_or_eq":">=" ;
            case BinaryOp::logical_and: return origin_form ? "logical_and":"&&" ;
            case BinaryOp::logical_or: return origin_form ? "logical_or":"||" ;
        }
        return "";
    }
    
    constexpr std::optional<BinaryOp> BinaryOp_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "*") {
            return BinaryOp::mul;
        }
        if (str == "/") {
            return BinaryOp::div;
        }
        if (str == "%") {
            return BinaryOp::mod;
        }
        if (str == "<<") {
            return BinaryOp::left_shift;
        }
        if (str == ">>") {
            return BinaryOp::right_shift;
        }
        if (str == "&") {
            return BinaryOp::bit_and;
        }
        if (str == "+") {
            return BinaryOp::add;
        }
        if (str == "-") {
            return BinaryOp::sub;
        }
        if (str == "|") {
            return BinaryOp::bit_or;
        }
        if (str == "^") {
            return BinaryOp::bit_xor;
        }
        if (str == "==") {
            return BinaryOp::equal;
        }
        if (str == "!=") {
            return BinaryOp::not_equal;
        }
        if (str == "<") {
            return BinaryOp::less;
        }
        if (str == "<=") {
            return BinaryOp::less_or_eq;
        }
        if (str == ">") {
            return BinaryOp::greater;
        }
        if (str == ">=") {
            return BinaryOp::greater_or_eq;
        }
        if (str == "&&") {
            return BinaryOp::logical_and;
        }
        if (str == "||") {
            return BinaryOp::logical_or;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(BinaryOp) {
        return "BinaryOp";
    }
    enum class BinaryOpKind : std::uint8_t {
        ARITHMETIC = 0,
        BITWISE = 1,
        COMPARISON = 2,
        LOGICAL = 3,
    };
    constexpr const char* to_string(BinaryOpKind e, bool origin_form = false) {
        switch(e) {
            case BinaryOpKind::ARITHMETIC: return origin_form ? "ARITHMETIC":"ARITHMETIC" ;
            case BinaryOpKind::BITWISE: return origin_form ? "BITWISE":"BITWISE" ;
            case BinaryOpKind::COMPARISON: return origin_form ? "COMPARISON":"COMPARISON" ;
            case BinaryOpKind::LOGICAL: return origin_form ? "LOGICAL":"LOGICAL" ;
        }
        return "";
    }
    
    constexpr std::optional<BinaryOpKind> BinaryOpKind_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "ARITHMETIC") {
            return BinaryOpKind::ARITHMETIC;
        }
        if (str == "BITWISE") {
            return BinaryOpKind::BITWISE;
        }
        if (str == "COMPARISON") {
            return BinaryOpKind::COMPARISON;
        }
        if (str == "LOGICAL") {
            return BinaryOpKind::LOGICAL;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(BinaryOpKind) {
        return "BinaryOpKind";
    }
    enum class UnaryOp : std::uint8_t {
        logical_not = 0,
        minus_sign = 1,
        bit_not = 2,
    };
    constexpr const char* to_string(UnaryOp e, bool origin_form = false) {
        switch(e) {
            case UnaryOp::logical_not: return origin_form ? "logical_not":"!" ;
            case UnaryOp::minus_sign: return origin_form ? "minus_sign":"-" ;
            case UnaryOp::bit_not: return origin_form ? "bit_not":"~" ;
        }
        return "";
    }
    
    constexpr std::optional<UnaryOp> UnaryOp_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "!") {
            return UnaryOp::logical_not;
        }
        if (str == "-") {
            return UnaryOp::minus_sign;
        }
        if (str == "~") {
            return UnaryOp::bit_not;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(UnaryOp) {
        return "UnaryOp";
    }
    enum class Endian : std::uint8_t {
        unspec = 0,
        big = 1,
        little = 2,
        dynamic = 3,
        native = 4,
    };
    constexpr const char* to_string(Endian e, bool origin_form = false) {
        switch(e) {
            case Endian::unspec: return origin_form ? "unspec":"unspec" ;
            case Endian::big: return origin_form ? "big":"big" ;
            case Endian::little: return origin_form ? "little":"little" ;
            case Endian::dynamic: return origin_form ? "dynamic":"dynamic" ;
            case Endian::native: return origin_form ? "native":"native" ;
        }
        return "";
    }
    
    constexpr std::optional<Endian> Endian_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "unspec") {
            return Endian::unspec;
        }
        if (str == "big") {
            return Endian::big;
        }
        if (str == "little") {
            return Endian::little;
        }
        if (str == "dynamic") {
            return Endian::dynamic;
        }
        if (str == "native") {
            return Endian::native;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(Endian) {
        return "Endian";
    }
    enum class ExpressionKind : std::uint8_t {
        LITERAL_INT = 0,
        LITERAL_INT64 = 1,
        LITERAL_BOOL = 2,
        LITERAL_STRING = 3,
        LITERAL_TYPE = 4,
        LITERAL_CHAR = 5,
        IDENTIFIER = 6,
        BINARY_OP = 7,
        UNARY_OP = 8,
        CALL = 9,
        INDEX_ACCESS = 10,
        MEMBER_ACCESS = 11,
        ENUM_MEMBER = 12,
        TYPE_CAST = 13,
        RANGE = 14,
        DEFAULT_VALUE = 15,
        IS_LITTLE_ENDIAN = 16,
        GET_STREAM_OFFSET = 17,
        GET_REMAINING_BYTES = 18,
        CAN_READ_STREAM = 19,
        ARRAY_SIZE = 20,
        ENUM_IS_DEFINED = 21,
        IS_ERROR = 22,
        MAX_VALUE = 23,
        READ_DATA = 24,
        WRITE_DATA = 25,
        CONDITIONAL_STATEMENT = 26,
        CONDITIONAL = 27,
        AVAILABLE = 28,
        SIZEOF = 29,
        SUB_RANGE_INIT = 30,
        OR_COND = 31,
        ADDRESS_OF = 32,
        OPTIONAL_OF = 33,
        SETTER_STATUS = 34,
        SELF = 35,
        AS_ARG = 36,
    };
    constexpr const char* to_string(ExpressionKind e, bool origin_form = false) {
        switch(e) {
            case ExpressionKind::LITERAL_INT: return origin_form ? "LITERAL_INT":"LITERAL_INT" ;
            case ExpressionKind::LITERAL_INT64: return origin_form ? "LITERAL_INT64":"LITERAL_INT64" ;
            case ExpressionKind::LITERAL_BOOL: return origin_form ? "LITERAL_BOOL":"LITERAL_BOOL" ;
            case ExpressionKind::LITERAL_STRING: return origin_form ? "LITERAL_STRING":"LITERAL_STRING" ;
            case ExpressionKind::LITERAL_TYPE: return origin_form ? "LITERAL_TYPE":"LITERAL_TYPE" ;
            case ExpressionKind::LITERAL_CHAR: return origin_form ? "LITERAL_CHAR":"LITERAL_CHAR" ;
            case ExpressionKind::IDENTIFIER: return origin_form ? "IDENTIFIER":"IDENTIFIER" ;
            case ExpressionKind::BINARY_OP: return origin_form ? "BINARY_OP":"BINARY_OP" ;
            case ExpressionKind::UNARY_OP: return origin_form ? "UNARY_OP":"UNARY_OP" ;
            case ExpressionKind::CALL: return origin_form ? "CALL":"CALL" ;
            case ExpressionKind::INDEX_ACCESS: return origin_form ? "INDEX_ACCESS":"INDEX_ACCESS" ;
            case ExpressionKind::MEMBER_ACCESS: return origin_form ? "MEMBER_ACCESS":"MEMBER_ACCESS" ;
            case ExpressionKind::ENUM_MEMBER: return origin_form ? "ENUM_MEMBER":"ENUM_MEMBER" ;
            case ExpressionKind::TYPE_CAST: return origin_form ? "TYPE_CAST":"TYPE_CAST" ;
            case ExpressionKind::RANGE: return origin_form ? "RANGE":"RANGE" ;
            case ExpressionKind::DEFAULT_VALUE: return origin_form ? "DEFAULT_VALUE":"DEFAULT_VALUE" ;
            case ExpressionKind::IS_LITTLE_ENDIAN: return origin_form ? "IS_LITTLE_ENDIAN":"IS_LITTLE_ENDIAN" ;
            case ExpressionKind::GET_STREAM_OFFSET: return origin_form ? "GET_STREAM_OFFSET":"GET_STREAM_OFFSET" ;
            case ExpressionKind::GET_REMAINING_BYTES: return origin_form ? "GET_REMAINING_BYTES":"GET_REMAINING_BYTES" ;
            case ExpressionKind::CAN_READ_STREAM: return origin_form ? "CAN_READ_STREAM":"CAN_READ_STREAM" ;
            case ExpressionKind::ARRAY_SIZE: return origin_form ? "ARRAY_SIZE":"ARRAY_SIZE" ;
            case ExpressionKind::ENUM_IS_DEFINED: return origin_form ? "ENUM_IS_DEFINED":"ENUM_IS_DEFINED" ;
            case ExpressionKind::IS_ERROR: return origin_form ? "IS_ERROR":"IS_ERROR" ;
            case ExpressionKind::MAX_VALUE: return origin_form ? "MAX_VALUE":"MAX_VALUE" ;
            case ExpressionKind::READ_DATA: return origin_form ? "READ_DATA":"READ_DATA" ;
            case ExpressionKind::WRITE_DATA: return origin_form ? "WRITE_DATA":"WRITE_DATA" ;
            case ExpressionKind::CONDITIONAL_STATEMENT: return origin_form ? "CONDITIONAL_STATEMENT":"CONDITIONAL_STATEMENT" ;
            case ExpressionKind::CONDITIONAL: return origin_form ? "CONDITIONAL":"CONDITIONAL" ;
            case ExpressionKind::AVAILABLE: return origin_form ? "AVAILABLE":"AVAILABLE" ;
            case ExpressionKind::SIZEOF: return origin_form ? "SIZEOF":"SIZEOF" ;
            case ExpressionKind::SUB_RANGE_INIT: return origin_form ? "SUB_RANGE_INIT":"SUB_RANGE_INIT" ;
            case ExpressionKind::OR_COND: return origin_form ? "OR_COND":"OR_COND" ;
            case ExpressionKind::ADDRESS_OF: return origin_form ? "ADDRESS_OF":"ADDRESS_OF" ;
            case ExpressionKind::OPTIONAL_OF: return origin_form ? "OPTIONAL_OF":"OPTIONAL_OF" ;
            case ExpressionKind::SETTER_STATUS: return origin_form ? "SETTER_STATUS":"SETTER_STATUS" ;
            case ExpressionKind::SELF: return origin_form ? "SELF":"SELF" ;
            case ExpressionKind::AS_ARG: return origin_form ? "AS_ARG":"AS_ARG" ;
        }
        return "";
    }
    
    constexpr std::optional<ExpressionKind> ExpressionKind_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "LITERAL_INT") {
            return ExpressionKind::LITERAL_INT;
        }
        if (str == "LITERAL_INT64") {
            return ExpressionKind::LITERAL_INT64;
        }
        if (str == "LITERAL_BOOL") {
            return ExpressionKind::LITERAL_BOOL;
        }
        if (str == "LITERAL_STRING") {
            return ExpressionKind::LITERAL_STRING;
        }
        if (str == "LITERAL_TYPE") {
            return ExpressionKind::LITERAL_TYPE;
        }
        if (str == "LITERAL_CHAR") {
            return ExpressionKind::LITERAL_CHAR;
        }
        if (str == "IDENTIFIER") {
            return ExpressionKind::IDENTIFIER;
        }
        if (str == "BINARY_OP") {
            return ExpressionKind::BINARY_OP;
        }
        if (str == "UNARY_OP") {
            return ExpressionKind::UNARY_OP;
        }
        if (str == "CALL") {
            return ExpressionKind::CALL;
        }
        if (str == "INDEX_ACCESS") {
            return ExpressionKind::INDEX_ACCESS;
        }
        if (str == "MEMBER_ACCESS") {
            return ExpressionKind::MEMBER_ACCESS;
        }
        if (str == "ENUM_MEMBER") {
            return ExpressionKind::ENUM_MEMBER;
        }
        if (str == "TYPE_CAST") {
            return ExpressionKind::TYPE_CAST;
        }
        if (str == "RANGE") {
            return ExpressionKind::RANGE;
        }
        if (str == "DEFAULT_VALUE") {
            return ExpressionKind::DEFAULT_VALUE;
        }
        if (str == "IS_LITTLE_ENDIAN") {
            return ExpressionKind::IS_LITTLE_ENDIAN;
        }
        if (str == "GET_STREAM_OFFSET") {
            return ExpressionKind::GET_STREAM_OFFSET;
        }
        if (str == "GET_REMAINING_BYTES") {
            return ExpressionKind::GET_REMAINING_BYTES;
        }
        if (str == "CAN_READ_STREAM") {
            return ExpressionKind::CAN_READ_STREAM;
        }
        if (str == "ARRAY_SIZE") {
            return ExpressionKind::ARRAY_SIZE;
        }
        if (str == "ENUM_IS_DEFINED") {
            return ExpressionKind::ENUM_IS_DEFINED;
        }
        if (str == "IS_ERROR") {
            return ExpressionKind::IS_ERROR;
        }
        if (str == "MAX_VALUE") {
            return ExpressionKind::MAX_VALUE;
        }
        if (str == "READ_DATA") {
            return ExpressionKind::READ_DATA;
        }
        if (str == "WRITE_DATA") {
            return ExpressionKind::WRITE_DATA;
        }
        if (str == "CONDITIONAL_STATEMENT") {
            return ExpressionKind::CONDITIONAL_STATEMENT;
        }
        if (str == "CONDITIONAL") {
            return ExpressionKind::CONDITIONAL;
        }
        if (str == "AVAILABLE") {
            return ExpressionKind::AVAILABLE;
        }
        if (str == "SIZEOF") {
            return ExpressionKind::SIZEOF;
        }
        if (str == "SUB_RANGE_INIT") {
            return ExpressionKind::SUB_RANGE_INIT;
        }
        if (str == "OR_COND") {
            return ExpressionKind::OR_COND;
        }
        if (str == "ADDRESS_OF") {
            return ExpressionKind::ADDRESS_OF;
        }
        if (str == "OPTIONAL_OF") {
            return ExpressionKind::OPTIONAL_OF;
        }
        if (str == "SETTER_STATUS") {
            return ExpressionKind::SETTER_STATUS;
        }
        if (str == "SELF") {
            return ExpressionKind::SELF;
        }
        if (str == "AS_ARG") {
            return ExpressionKind::AS_ARG;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(ExpressionKind) {
        return "ExpressionKind";
    }
    enum class SetterStatus : std::uint8_t {
        SUCCESS = 0,
        FAILED = 1,
    };
    constexpr const char* to_string(SetterStatus e, bool origin_form = false) {
        switch(e) {
            case SetterStatus::SUCCESS: return origin_form ? "SUCCESS":"SUCCESS" ;
            case SetterStatus::FAILED: return origin_form ? "FAILED":"FAILED" ;
        }
        return "";
    }
    
    constexpr std::optional<SetterStatus> SetterStatus_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "SUCCESS") {
            return SetterStatus::SUCCESS;
        }
        if (str == "FAILED") {
            return SetterStatus::FAILED;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(SetterStatus) {
        return "SetterStatus";
    }
    enum class LoopType : std::uint8_t {
        INFINITE = 0,
        WHILE = 1,
        FOR_EACH = 2,
        FOR = 3,
    };
    constexpr const char* to_string(LoopType e, bool origin_form = false) {
        switch(e) {
            case LoopType::INFINITE: return origin_form ? "INFINITE":"INFINITE" ;
            case LoopType::WHILE: return origin_form ? "WHILE":"WHILE" ;
            case LoopType::FOR_EACH: return origin_form ? "FOR_EACH":"FOR_EACH" ;
            case LoopType::FOR: return origin_form ? "FOR":"FOR" ;
        }
        return "";
    }
    
    constexpr std::optional<LoopType> LoopType_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "INFINITE") {
            return LoopType::INFINITE;
        }
        if (str == "WHILE") {
            return LoopType::WHILE;
        }
        if (str == "FOR_EACH") {
            return LoopType::FOR_EACH;
        }
        if (str == "FOR") {
            return LoopType::FOR;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(LoopType) {
        return "LoopType";
    }
    enum class VariableDeclKind : std::uint8_t {
        MUTABLE = 0,
        IMMUTABLE = 1,
        CONSTANT = 2,
    };
    constexpr const char* to_string(VariableDeclKind e, bool origin_form = false) {
        switch(e) {
            case VariableDeclKind::MUTABLE: return origin_form ? "MUTABLE":"MUTABLE" ;
            case VariableDeclKind::IMMUTABLE: return origin_form ? "IMMUTABLE":"IMMUTABLE" ;
            case VariableDeclKind::CONSTANT: return origin_form ? "CONSTANT":"CONSTANT" ;
        }
        return "";
    }
    
    constexpr std::optional<VariableDeclKind> VariableDeclKind_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "MUTABLE") {
            return VariableDeclKind::MUTABLE;
        }
        if (str == "IMMUTABLE") {
            return VariableDeclKind::IMMUTABLE;
        }
        if (str == "CONSTANT") {
            return VariableDeclKind::CONSTANT;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(VariableDeclKind) {
        return "VariableDeclKind";
    }
    enum class FunctionKind : std::uint8_t {
        NORMAL = 0,
        METHOD = 1,
        ENCODE = 2,
        DECODE = 3,
        PROPERTY_GETTER = 4,
        PROPERTY_SETTER = 5,
        COMPOSITE_GETTER = 6,
        COMPOSITE_SETTER = 7,
        CAST = 8,
    };
    constexpr const char* to_string(FunctionKind e, bool origin_form = false) {
        switch(e) {
            case FunctionKind::NORMAL: return origin_form ? "NORMAL":"NORMAL" ;
            case FunctionKind::METHOD: return origin_form ? "METHOD":"METHOD" ;
            case FunctionKind::ENCODE: return origin_form ? "ENCODE":"ENCODE" ;
            case FunctionKind::DECODE: return origin_form ? "DECODE":"DECODE" ;
            case FunctionKind::PROPERTY_GETTER: return origin_form ? "PROPERTY_GETTER":"PROPERTY_GETTER" ;
            case FunctionKind::PROPERTY_SETTER: return origin_form ? "PROPERTY_SETTER":"PROPERTY_SETTER" ;
            case FunctionKind::COMPOSITE_GETTER: return origin_form ? "COMPOSITE_GETTER":"COMPOSITE_GETTER" ;
            case FunctionKind::COMPOSITE_SETTER: return origin_form ? "COMPOSITE_SETTER":"COMPOSITE_SETTER" ;
            case FunctionKind::CAST: return origin_form ? "CAST":"CAST" ;
        }
        return "";
    }
    
    constexpr std::optional<FunctionKind> FunctionKind_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "NORMAL") {
            return FunctionKind::NORMAL;
        }
        if (str == "METHOD") {
            return FunctionKind::METHOD;
        }
        if (str == "ENCODE") {
            return FunctionKind::ENCODE;
        }
        if (str == "DECODE") {
            return FunctionKind::DECODE;
        }
        if (str == "PROPERTY_GETTER") {
            return FunctionKind::PROPERTY_GETTER;
        }
        if (str == "PROPERTY_SETTER") {
            return FunctionKind::PROPERTY_SETTER;
        }
        if (str == "COMPOSITE_GETTER") {
            return FunctionKind::COMPOSITE_GETTER;
        }
        if (str == "COMPOSITE_SETTER") {
            return FunctionKind::COMPOSITE_SETTER;
        }
        if (str == "CAST") {
            return FunctionKind::CAST;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(FunctionKind) {
        return "FunctionKind";
    }
    enum class SubByteRangeType : std::uint8_t {
        bytes = 0,
        seek_bytes = 1,
        expression = 2,
    };
    constexpr const char* to_string(SubByteRangeType e, bool origin_form = false) {
        switch(e) {
            case SubByteRangeType::bytes: return origin_form ? "bytes":"bytes" ;
            case SubByteRangeType::seek_bytes: return origin_form ? "seek_bytes":"seek_bytes" ;
            case SubByteRangeType::expression: return origin_form ? "expression":"expression" ;
        }
        return "";
    }
    
    constexpr std::optional<SubByteRangeType> SubByteRangeType_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "bytes") {
            return SubByteRangeType::bytes;
        }
        if (str == "seek_bytes") {
            return SubByteRangeType::seek_bytes;
        }
        if (str == "expression") {
            return SubByteRangeType::expression;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(SubByteRangeType) {
        return "SubByteRangeType";
    }
    enum class LoweringIOType : std::uint8_t {
        ENUM_UNDERLYING_TO_INT = 0,
        ARRAY_FOR_EACH = 1,
        STRING_FOR_EACH = 2,
        FLOAT_TO_BYTE_ARRAY = 3,
        INT_TO_BYTE_ARRAY = 4,
        STRUCT_CALL = 5,
        BIT_FIELD_TO_BIT_SHIFT = 6,
        MULTI_REPRESENTATION = 7,
        VECTORIZED_IO = 8,
    };
    constexpr const char* to_string(LoweringIOType e, bool origin_form = false) {
        switch(e) {
            case LoweringIOType::ENUM_UNDERLYING_TO_INT: return origin_form ? "ENUM_UNDERLYING_TO_INT":"ENUM_UNDERLYING_TO_INT" ;
            case LoweringIOType::ARRAY_FOR_EACH: return origin_form ? "ARRAY_FOR_EACH":"ARRAY_FOR_EACH" ;
            case LoweringIOType::STRING_FOR_EACH: return origin_form ? "STRING_FOR_EACH":"STRING_FOR_EACH" ;
            case LoweringIOType::FLOAT_TO_BYTE_ARRAY: return origin_form ? "FLOAT_TO_BYTE_ARRAY":"FLOAT_TO_BYTE_ARRAY" ;
            case LoweringIOType::INT_TO_BYTE_ARRAY: return origin_form ? "INT_TO_BYTE_ARRAY":"INT_TO_BYTE_ARRAY" ;
            case LoweringIOType::STRUCT_CALL: return origin_form ? "STRUCT_CALL":"STRUCT_CALL" ;
            case LoweringIOType::BIT_FIELD_TO_BIT_SHIFT: return origin_form ? "BIT_FIELD_TO_BIT_SHIFT":"BIT_FIELD_TO_BIT_SHIFT" ;
            case LoweringIOType::MULTI_REPRESENTATION: return origin_form ? "MULTI_REPRESENTATION":"MULTI_REPRESENTATION" ;
            case LoweringIOType::VECTORIZED_IO: return origin_form ? "VECTORIZED_IO":"VECTORIZED_IO" ;
        }
        return "";
    }
    
    constexpr std::optional<LoweringIOType> LoweringIOType_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "ENUM_UNDERLYING_TO_INT") {
            return LoweringIOType::ENUM_UNDERLYING_TO_INT;
        }
        if (str == "ARRAY_FOR_EACH") {
            return LoweringIOType::ARRAY_FOR_EACH;
        }
        if (str == "STRING_FOR_EACH") {
            return LoweringIOType::STRING_FOR_EACH;
        }
        if (str == "FLOAT_TO_BYTE_ARRAY") {
            return LoweringIOType::FLOAT_TO_BYTE_ARRAY;
        }
        if (str == "INT_TO_BYTE_ARRAY") {
            return LoweringIOType::INT_TO_BYTE_ARRAY;
        }
        if (str == "STRUCT_CALL") {
            return LoweringIOType::STRUCT_CALL;
        }
        if (str == "BIT_FIELD_TO_BIT_SHIFT") {
            return LoweringIOType::BIT_FIELD_TO_BIT_SHIFT;
        }
        if (str == "MULTI_REPRESENTATION") {
            return LoweringIOType::MULTI_REPRESENTATION;
        }
        if (str == "VECTORIZED_IO") {
            return LoweringIOType::VECTORIZED_IO;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(LoweringIOType) {
        return "LoweringIOType";
    }
    enum class StatementKind : std::uint8_t {
        BLOCK = 0,
        ASSIGNMENT = 1,
        YIELD = 2,
        APPEND = 3,
        RETURN = 4,
        ERROR_RETURN = 5,
        ASSERT = 6,
        READ_DATA = 7,
        WRITE_DATA = 8,
        IF_STATEMENT = 9,
        LOOP_STATEMENT = 10,
        MATCH_STATEMENT = 11,
        MATCH_BRANCH = 12,
        BREAK = 13,
        CONTINUE = 14,
        FUNCTION_DECL = 15,
        VARIABLE_DECL = 16,
        PARAMETER_DECL = 17,
        FIELD_DECL = 18,
        COMPOSITE_FIELD_DECL = 19,
        ENUM_DECL = 20,
        ENUM_MEMBER_DECL = 21,
        STRUCT_DECL = 22,
        UNION_DECL = 23,
        UNION_MEMBER_DECL = 24,
        PROGRAM_DECL = 25,
        PROPERTY_DECL = 26,
        PROPERTY_MEMBER_DECL = 27,
        METADATA = 28,
        IMPORT_MODULE = 29,
        EXPRESSION = 30,
        ERROR_REPORT = 31,
        LOWERED_IO_STATEMENTS = 32,
        SUB_BYTE_RANGE = 33,
        INIT_CHECK = 34,
        ENDIAN_VARIABLE = 35,
    };
    constexpr const char* to_string(StatementKind e, bool origin_form = false) {
        switch(e) {
            case StatementKind::BLOCK: return origin_form ? "BLOCK":"BLOCK" ;
            case StatementKind::ASSIGNMENT: return origin_form ? "ASSIGNMENT":"ASSIGNMENT" ;
            case StatementKind::YIELD: return origin_form ? "YIELD":"YIELD" ;
            case StatementKind::APPEND: return origin_form ? "APPEND":"APPEND" ;
            case StatementKind::RETURN: return origin_form ? "RETURN":"RETURN" ;
            case StatementKind::ERROR_RETURN: return origin_form ? "ERROR_RETURN":"ERROR_RETURN" ;
            case StatementKind::ASSERT: return origin_form ? "ASSERT":"ASSERT" ;
            case StatementKind::READ_DATA: return origin_form ? "READ_DATA":"READ_DATA" ;
            case StatementKind::WRITE_DATA: return origin_form ? "WRITE_DATA":"WRITE_DATA" ;
            case StatementKind::IF_STATEMENT: return origin_form ? "IF_STATEMENT":"IF_STATEMENT" ;
            case StatementKind::LOOP_STATEMENT: return origin_form ? "LOOP_STATEMENT":"LOOP_STATEMENT" ;
            case StatementKind::MATCH_STATEMENT: return origin_form ? "MATCH_STATEMENT":"MATCH_STATEMENT" ;
            case StatementKind::MATCH_BRANCH: return origin_form ? "MATCH_BRANCH":"MATCH_BRANCH" ;
            case StatementKind::BREAK: return origin_form ? "BREAK":"BREAK" ;
            case StatementKind::CONTINUE: return origin_form ? "CONTINUE":"CONTINUE" ;
            case StatementKind::FUNCTION_DECL: return origin_form ? "FUNCTION_DECL":"FUNCTION_DECL" ;
            case StatementKind::VARIABLE_DECL: return origin_form ? "VARIABLE_DECL":"VARIABLE_DECL" ;
            case StatementKind::PARAMETER_DECL: return origin_form ? "PARAMETER_DECL":"PARAMETER_DECL" ;
            case StatementKind::FIELD_DECL: return origin_form ? "FIELD_DECL":"FIELD_DECL" ;
            case StatementKind::COMPOSITE_FIELD_DECL: return origin_form ? "COMPOSITE_FIELD_DECL":"COMPOSITE_FIELD_DECL" ;
            case StatementKind::ENUM_DECL: return origin_form ? "ENUM_DECL":"ENUM_DECL" ;
            case StatementKind::ENUM_MEMBER_DECL: return origin_form ? "ENUM_MEMBER_DECL":"ENUM_MEMBER_DECL" ;
            case StatementKind::STRUCT_DECL: return origin_form ? "STRUCT_DECL":"STRUCT_DECL" ;
            case StatementKind::UNION_DECL: return origin_form ? "UNION_DECL":"UNION_DECL" ;
            case StatementKind::UNION_MEMBER_DECL: return origin_form ? "UNION_MEMBER_DECL":"UNION_MEMBER_DECL" ;
            case StatementKind::PROGRAM_DECL: return origin_form ? "PROGRAM_DECL":"PROGRAM_DECL" ;
            case StatementKind::PROPERTY_DECL: return origin_form ? "PROPERTY_DECL":"PROPERTY_DECL" ;
            case StatementKind::PROPERTY_MEMBER_DECL: return origin_form ? "PROPERTY_MEMBER_DECL":"PROPERTY_MEMBER_DECL" ;
            case StatementKind::METADATA: return origin_form ? "METADATA":"METADATA" ;
            case StatementKind::IMPORT_MODULE: return origin_form ? "IMPORT_MODULE":"IMPORT_MODULE" ;
            case StatementKind::EXPRESSION: return origin_form ? "EXPRESSION":"EXPRESSION" ;
            case StatementKind::ERROR_REPORT: return origin_form ? "ERROR_REPORT":"ERROR_REPORT" ;
            case StatementKind::LOWERED_IO_STATEMENTS: return origin_form ? "LOWERED_IO_STATEMENTS":"LOWERED_IO_STATEMENTS" ;
            case StatementKind::SUB_BYTE_RANGE: return origin_form ? "SUB_BYTE_RANGE":"SUB_BYTE_RANGE" ;
            case StatementKind::INIT_CHECK: return origin_form ? "INIT_CHECK":"INIT_CHECK" ;
            case StatementKind::ENDIAN_VARIABLE: return origin_form ? "ENDIAN_VARIABLE":"ENDIAN_VARIABLE" ;
        }
        return "";
    }
    
    constexpr std::optional<StatementKind> StatementKind_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "BLOCK") {
            return StatementKind::BLOCK;
        }
        if (str == "ASSIGNMENT") {
            return StatementKind::ASSIGNMENT;
        }
        if (str == "YIELD") {
            return StatementKind::YIELD;
        }
        if (str == "APPEND") {
            return StatementKind::APPEND;
        }
        if (str == "RETURN") {
            return StatementKind::RETURN;
        }
        if (str == "ERROR_RETURN") {
            return StatementKind::ERROR_RETURN;
        }
        if (str == "ASSERT") {
            return StatementKind::ASSERT;
        }
        if (str == "READ_DATA") {
            return StatementKind::READ_DATA;
        }
        if (str == "WRITE_DATA") {
            return StatementKind::WRITE_DATA;
        }
        if (str == "IF_STATEMENT") {
            return StatementKind::IF_STATEMENT;
        }
        if (str == "LOOP_STATEMENT") {
            return StatementKind::LOOP_STATEMENT;
        }
        if (str == "MATCH_STATEMENT") {
            return StatementKind::MATCH_STATEMENT;
        }
        if (str == "MATCH_BRANCH") {
            return StatementKind::MATCH_BRANCH;
        }
        if (str == "BREAK") {
            return StatementKind::BREAK;
        }
        if (str == "CONTINUE") {
            return StatementKind::CONTINUE;
        }
        if (str == "FUNCTION_DECL") {
            return StatementKind::FUNCTION_DECL;
        }
        if (str == "VARIABLE_DECL") {
            return StatementKind::VARIABLE_DECL;
        }
        if (str == "PARAMETER_DECL") {
            return StatementKind::PARAMETER_DECL;
        }
        if (str == "FIELD_DECL") {
            return StatementKind::FIELD_DECL;
        }
        if (str == "COMPOSITE_FIELD_DECL") {
            return StatementKind::COMPOSITE_FIELD_DECL;
        }
        if (str == "ENUM_DECL") {
            return StatementKind::ENUM_DECL;
        }
        if (str == "ENUM_MEMBER_DECL") {
            return StatementKind::ENUM_MEMBER_DECL;
        }
        if (str == "STRUCT_DECL") {
            return StatementKind::STRUCT_DECL;
        }
        if (str == "UNION_DECL") {
            return StatementKind::UNION_DECL;
        }
        if (str == "UNION_MEMBER_DECL") {
            return StatementKind::UNION_MEMBER_DECL;
        }
        if (str == "PROGRAM_DECL") {
            return StatementKind::PROGRAM_DECL;
        }
        if (str == "PROPERTY_DECL") {
            return StatementKind::PROPERTY_DECL;
        }
        if (str == "PROPERTY_MEMBER_DECL") {
            return StatementKind::PROPERTY_MEMBER_DECL;
        }
        if (str == "METADATA") {
            return StatementKind::METADATA;
        }
        if (str == "IMPORT_MODULE") {
            return StatementKind::IMPORT_MODULE;
        }
        if (str == "EXPRESSION") {
            return StatementKind::EXPRESSION;
        }
        if (str == "ERROR_REPORT") {
            return StatementKind::ERROR_REPORT;
        }
        if (str == "LOWERED_IO_STATEMENTS") {
            return StatementKind::LOWERED_IO_STATEMENTS;
        }
        if (str == "SUB_BYTE_RANGE") {
            return StatementKind::SUB_BYTE_RANGE;
        }
        if (str == "INIT_CHECK") {
            return StatementKind::INIT_CHECK;
        }
        if (str == "ENDIAN_VARIABLE") {
            return StatementKind::ENDIAN_VARIABLE;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(StatementKind) {
        return "StatementKind";
    }
    enum class StreamType : std::uint8_t {
        INPUT = 0,
        OUTPUT = 1,
    };
    constexpr const char* to_string(StreamType e, bool origin_form = false) {
        switch(e) {
            case StreamType::INPUT: return origin_form ? "INPUT":"INPUT" ;
            case StreamType::OUTPUT: return origin_form ? "OUTPUT":"OUTPUT" ;
        }
        return "";
    }
    
    constexpr std::optional<StreamType> StreamType_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "INPUT") {
            return StreamType::INPUT;
        }
        if (str == "OUTPUT") {
            return StreamType::OUTPUT;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(StreamType) {
        return "StreamType";
    }
    enum class SizeUnit : std::uint8_t {
        UNKNOWN = 0,
        BIT_FIXED = 1,
        BYTE_FIXED = 2,
        ELEMENT_FIXED = 3,
        BIT_DYNAMIC = 4,
        BYTE_DYNAMIC = 5,
        ELEMENT_DYNAMIC = 6,
        DYNAMIC = 7,
    };
    constexpr const char* to_string(SizeUnit e, bool origin_form = false) {
        switch(e) {
            case SizeUnit::UNKNOWN: return origin_form ? "UNKNOWN":"UNKNOWN" ;
            case SizeUnit::BIT_FIXED: return origin_form ? "BIT_FIXED":"BIT_FIXED" ;
            case SizeUnit::BYTE_FIXED: return origin_form ? "BYTE_FIXED":"BYTE_FIXED" ;
            case SizeUnit::ELEMENT_FIXED: return origin_form ? "ELEMENT_FIXED":"ELEMENT_FIXED" ;
            case SizeUnit::BIT_DYNAMIC: return origin_form ? "BIT_DYNAMIC":"BIT_DYNAMIC" ;
            case SizeUnit::BYTE_DYNAMIC: return origin_form ? "BYTE_DYNAMIC":"BYTE_DYNAMIC" ;
            case SizeUnit::ELEMENT_DYNAMIC: return origin_form ? "ELEMENT_DYNAMIC":"ELEMENT_DYNAMIC" ;
            case SizeUnit::DYNAMIC: return origin_form ? "DYNAMIC":"DYNAMIC" ;
        }
        return "";
    }
    
    constexpr std::optional<SizeUnit> SizeUnit_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "UNKNOWN") {
            return SizeUnit::UNKNOWN;
        }
        if (str == "BIT_FIXED") {
            return SizeUnit::BIT_FIXED;
        }
        if (str == "BYTE_FIXED") {
            return SizeUnit::BYTE_FIXED;
        }
        if (str == "ELEMENT_FIXED") {
            return SizeUnit::ELEMENT_FIXED;
        }
        if (str == "BIT_DYNAMIC") {
            return SizeUnit::BIT_DYNAMIC;
        }
        if (str == "BYTE_DYNAMIC") {
            return SizeUnit::BYTE_DYNAMIC;
        }
        if (str == "ELEMENT_DYNAMIC") {
            return SizeUnit::ELEMENT_DYNAMIC;
        }
        if (str == "DYNAMIC") {
            return SizeUnit::DYNAMIC;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(SizeUnit) {
        return "SizeUnit";
    }
    enum class InitCheckType : std::uint8_t {
        encode = 0,
        decode = 1,
        union_get = 2,
        union_set = 3,
    };
    constexpr const char* to_string(InitCheckType e, bool origin_form = false) {
        switch(e) {
            case InitCheckType::encode: return origin_form ? "encode":"encode" ;
            case InitCheckType::decode: return origin_form ? "decode":"decode" ;
            case InitCheckType::union_get: return origin_form ? "union_get":"union_get" ;
            case InitCheckType::union_set: return origin_form ? "union_set":"union_set" ;
        }
        return "";
    }
    
    constexpr std::optional<InitCheckType> InitCheckType_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "encode") {
            return InitCheckType::encode;
        }
        if (str == "decode") {
            return InitCheckType::decode;
        }
        if (str == "union_get") {
            return InitCheckType::union_get;
        }
        if (str == "union_set") {
            return InitCheckType::union_set;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(InitCheckType) {
        return "InitCheckType";
    }
    enum class CastType : std::uint8_t {
        ENUM_TO_INT = 0,
        INT_TO_ENUM = 1,
        USIZE_TO_INT = 2,
        INT_TO_USIZE = 3,
        FLOAT_TO_INT_BIT = 4,
        INT_TO_FLOAT_BIT = 5,
        VECTOR_TO_ARRAY = 6,
        ARRAY_TO_VECTOR = 7,
        INT_TO_VECTOR = 8,
        INT_TO_ARRAY = 9,
        SMALL_INT_TO_LARGE_INT = 10,
        LARGE_INT_TO_SMALL_INT = 11,
        SIGNED_TO_UNSIGNED = 12,
        UNSIGNED_TO_SIGNED = 13,
        BOOL_TO_INT = 14,
        INT_TO_BOOL = 15,
        STRUCT_TO_RECURSIVE_STRUCT = 16,
        RECURSIVE_STRUCT_TO_STRUCT = 17,
        OTHER = 18,
    };
    constexpr const char* to_string(CastType e, bool origin_form = false) {
        switch(e) {
            case CastType::ENUM_TO_INT: return origin_form ? "ENUM_TO_INT":"ENUM_TO_INT" ;
            case CastType::INT_TO_ENUM: return origin_form ? "INT_TO_ENUM":"INT_TO_ENUM" ;
            case CastType::USIZE_TO_INT: return origin_form ? "USIZE_TO_INT":"USIZE_TO_INT" ;
            case CastType::INT_TO_USIZE: return origin_form ? "INT_TO_USIZE":"INT_TO_USIZE" ;
            case CastType::FLOAT_TO_INT_BIT: return origin_form ? "FLOAT_TO_INT_BIT":"FLOAT_TO_INT_BIT" ;
            case CastType::INT_TO_FLOAT_BIT: return origin_form ? "INT_TO_FLOAT_BIT":"INT_TO_FLOAT_BIT" ;
            case CastType::VECTOR_TO_ARRAY: return origin_form ? "VECTOR_TO_ARRAY":"VECTOR_TO_ARRAY" ;
            case CastType::ARRAY_TO_VECTOR: return origin_form ? "ARRAY_TO_VECTOR":"ARRAY_TO_VECTOR" ;
            case CastType::INT_TO_VECTOR: return origin_form ? "INT_TO_VECTOR":"INT_TO_VECTOR" ;
            case CastType::INT_TO_ARRAY: return origin_form ? "INT_TO_ARRAY":"INT_TO_ARRAY" ;
            case CastType::SMALL_INT_TO_LARGE_INT: return origin_form ? "SMALL_INT_TO_LARGE_INT":"SMALL_INT_TO_LARGE_INT" ;
            case CastType::LARGE_INT_TO_SMALL_INT: return origin_form ? "LARGE_INT_TO_SMALL_INT":"LARGE_INT_TO_SMALL_INT" ;
            case CastType::SIGNED_TO_UNSIGNED: return origin_form ? "SIGNED_TO_UNSIGNED":"SIGNED_TO_UNSIGNED" ;
            case CastType::UNSIGNED_TO_SIGNED: return origin_form ? "UNSIGNED_TO_SIGNED":"UNSIGNED_TO_SIGNED" ;
            case CastType::BOOL_TO_INT: return origin_form ? "BOOL_TO_INT":"BOOL_TO_INT" ;
            case CastType::INT_TO_BOOL: return origin_form ? "INT_TO_BOOL":"INT_TO_BOOL" ;
            case CastType::STRUCT_TO_RECURSIVE_STRUCT: return origin_form ? "STRUCT_TO_RECURSIVE_STRUCT":"STRUCT_TO_RECURSIVE_STRUCT" ;
            case CastType::RECURSIVE_STRUCT_TO_STRUCT: return origin_form ? "RECURSIVE_STRUCT_TO_STRUCT":"RECURSIVE_STRUCT_TO_STRUCT" ;
            case CastType::OTHER: return origin_form ? "OTHER":"OTHER" ;
        }
        return "";
    }
    
    constexpr std::optional<CastType> CastType_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "ENUM_TO_INT") {
            return CastType::ENUM_TO_INT;
        }
        if (str == "INT_TO_ENUM") {
            return CastType::INT_TO_ENUM;
        }
        if (str == "USIZE_TO_INT") {
            return CastType::USIZE_TO_INT;
        }
        if (str == "INT_TO_USIZE") {
            return CastType::INT_TO_USIZE;
        }
        if (str == "FLOAT_TO_INT_BIT") {
            return CastType::FLOAT_TO_INT_BIT;
        }
        if (str == "INT_TO_FLOAT_BIT") {
            return CastType::INT_TO_FLOAT_BIT;
        }
        if (str == "VECTOR_TO_ARRAY") {
            return CastType::VECTOR_TO_ARRAY;
        }
        if (str == "ARRAY_TO_VECTOR") {
            return CastType::ARRAY_TO_VECTOR;
        }
        if (str == "INT_TO_VECTOR") {
            return CastType::INT_TO_VECTOR;
        }
        if (str == "INT_TO_ARRAY") {
            return CastType::INT_TO_ARRAY;
        }
        if (str == "SMALL_INT_TO_LARGE_INT") {
            return CastType::SMALL_INT_TO_LARGE_INT;
        }
        if (str == "LARGE_INT_TO_SMALL_INT") {
            return CastType::LARGE_INT_TO_SMALL_INT;
        }
        if (str == "SIGNED_TO_UNSIGNED") {
            return CastType::SIGNED_TO_UNSIGNED;
        }
        if (str == "UNSIGNED_TO_SIGNED") {
            return CastType::UNSIGNED_TO_SIGNED;
        }
        if (str == "BOOL_TO_INT") {
            return CastType::BOOL_TO_INT;
        }
        if (str == "INT_TO_BOOL") {
            return CastType::INT_TO_BOOL;
        }
        if (str == "STRUCT_TO_RECURSIVE_STRUCT") {
            return CastType::STRUCT_TO_RECURSIVE_STRUCT;
        }
        if (str == "RECURSIVE_STRUCT_TO_STRUCT") {
            return CastType::RECURSIVE_STRUCT_TO_STRUCT;
        }
        if (str == "OTHER") {
            return CastType::OTHER;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(CastType) {
        return "CastType";
    }
    enum class MergeMode : std::uint8_t {
        UNCOMMON_TYPE = 0,
        COMMON_TYPE = 1,
        STRICT_TYPE = 2,
    };
    constexpr const char* to_string(MergeMode e, bool origin_form = false) {
        switch(e) {
            case MergeMode::UNCOMMON_TYPE: return origin_form ? "UNCOMMON_TYPE":"UNCOMMON_TYPE" ;
            case MergeMode::COMMON_TYPE: return origin_form ? "COMMON_TYPE":"COMMON_TYPE" ;
            case MergeMode::STRICT_TYPE: return origin_form ? "STRICT_TYPE":"STRICT_TYPE" ;
        }
        return "";
    }
    
    constexpr std::optional<MergeMode> MergeMode_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "UNCOMMON_TYPE") {
            return MergeMode::UNCOMMON_TYPE;
        }
        if (str == "COMMON_TYPE") {
            return MergeMode::COMMON_TYPE;
        }
        if (str == "STRICT_TYPE") {
            return MergeMode::STRICT_TYPE;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(MergeMode) {
        return "MergeMode";
    }
    enum class TypeKind : std::uint8_t {
        INT = 0,
        UINT = 1,
        USIZE = 2,
        FLOAT = 3,
        STRUCT = 4,
        RECURSIVE_STRUCT = 5,
        BOOL = 6,
        VOID = 7,
        META = 8,
        ENUM = 9,
        ARRAY = 10,
        VECTOR = 11,
        VARIANT = 12,
        RANGE = 13,
        ENCODER_RETURN = 14,
        DECODER_RETURN = 15,
        ENCODER_INPUT = 16,
        DECODER_INPUT = 17,
        PROPERTY_SETTER_RETURN = 18,
        OPTIONAL = 19,
        PTR = 20,
        FUNCTION = 21,
    };
    constexpr const char* to_string(TypeKind e, bool origin_form = false) {
        switch(e) {
            case TypeKind::INT: return origin_form ? "INT":"INT" ;
            case TypeKind::UINT: return origin_form ? "UINT":"UINT" ;
            case TypeKind::USIZE: return origin_form ? "USIZE":"USIZE" ;
            case TypeKind::FLOAT: return origin_form ? "FLOAT":"FLOAT" ;
            case TypeKind::STRUCT: return origin_form ? "STRUCT":"STRUCT" ;
            case TypeKind::RECURSIVE_STRUCT: return origin_form ? "RECURSIVE_STRUCT":"RECURSIVE_STRUCT" ;
            case TypeKind::BOOL: return origin_form ? "BOOL":"BOOL" ;
            case TypeKind::VOID: return origin_form ? "VOID":"VOID" ;
            case TypeKind::META: return origin_form ? "META":"META" ;
            case TypeKind::ENUM: return origin_form ? "ENUM":"ENUM" ;
            case TypeKind::ARRAY: return origin_form ? "ARRAY":"ARRAY" ;
            case TypeKind::VECTOR: return origin_form ? "VECTOR":"VECTOR" ;
            case TypeKind::VARIANT: return origin_form ? "VARIANT":"VARIANT" ;
            case TypeKind::RANGE: return origin_form ? "RANGE":"RANGE" ;
            case TypeKind::ENCODER_RETURN: return origin_form ? "ENCODER_RETURN":"ENCODER_RETURN" ;
            case TypeKind::DECODER_RETURN: return origin_form ? "DECODER_RETURN":"DECODER_RETURN" ;
            case TypeKind::ENCODER_INPUT: return origin_form ? "ENCODER_INPUT":"ENCODER_INPUT" ;
            case TypeKind::DECODER_INPUT: return origin_form ? "DECODER_INPUT":"DECODER_INPUT" ;
            case TypeKind::PROPERTY_SETTER_RETURN: return origin_form ? "PROPERTY_SETTER_RETURN":"PROPERTY_SETTER_RETURN" ;
            case TypeKind::OPTIONAL: return origin_form ? "OPTIONAL":"OPTIONAL" ;
            case TypeKind::PTR: return origin_form ? "PTR":"PTR" ;
            case TypeKind::FUNCTION: return origin_form ? "FUNCTION":"FUNCTION" ;
        }
        return "";
    }
    
    constexpr std::optional<TypeKind> TypeKind_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "INT") {
            return TypeKind::INT;
        }
        if (str == "UINT") {
            return TypeKind::UINT;
        }
        if (str == "USIZE") {
            return TypeKind::USIZE;
        }
        if (str == "FLOAT") {
            return TypeKind::FLOAT;
        }
        if (str == "STRUCT") {
            return TypeKind::STRUCT;
        }
        if (str == "RECURSIVE_STRUCT") {
            return TypeKind::RECURSIVE_STRUCT;
        }
        if (str == "BOOL") {
            return TypeKind::BOOL;
        }
        if (str == "VOID") {
            return TypeKind::VOID;
        }
        if (str == "META") {
            return TypeKind::META;
        }
        if (str == "ENUM") {
            return TypeKind::ENUM;
        }
        if (str == "ARRAY") {
            return TypeKind::ARRAY;
        }
        if (str == "VECTOR") {
            return TypeKind::VECTOR;
        }
        if (str == "VARIANT") {
            return TypeKind::VARIANT;
        }
        if (str == "RANGE") {
            return TypeKind::RANGE;
        }
        if (str == "ENCODER_RETURN") {
            return TypeKind::ENCODER_RETURN;
        }
        if (str == "DECODER_RETURN") {
            return TypeKind::DECODER_RETURN;
        }
        if (str == "ENCODER_INPUT") {
            return TypeKind::ENCODER_INPUT;
        }
        if (str == "DECODER_INPUT") {
            return TypeKind::DECODER_INPUT;
        }
        if (str == "PROPERTY_SETTER_RETURN") {
            return TypeKind::PROPERTY_SETTER_RETURN;
        }
        if (str == "OPTIONAL") {
            return TypeKind::OPTIONAL;
        }
        if (str == "PTR") {
            return TypeKind::PTR;
        }
        if (str == "FUNCTION") {
            return TypeKind::FUNCTION;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(TypeKind) {
        return "TypeKind";
    }
    enum class AliasHint : std::uint8_t {
        IDENTIFIER = 0,
        STRING = 1,
        TYPE = 2,
        EXPRESSION = 3,
        STATEMENT = 4,
        ALIAS = 5,
    };
    constexpr const char* to_string(AliasHint e, bool origin_form = false) {
        switch(e) {
            case AliasHint::IDENTIFIER: return origin_form ? "IDENTIFIER":"IDENTIFIER" ;
            case AliasHint::STRING: return origin_form ? "STRING":"STRING" ;
            case AliasHint::TYPE: return origin_form ? "TYPE":"TYPE" ;
            case AliasHint::EXPRESSION: return origin_form ? "EXPRESSION":"EXPRESSION" ;
            case AliasHint::STATEMENT: return origin_form ? "STATEMENT":"STATEMENT" ;
            case AliasHint::ALIAS: return origin_form ? "ALIAS":"ALIAS" ;
        }
        return "";
    }
    
    constexpr std::optional<AliasHint> AliasHint_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "IDENTIFIER") {
            return AliasHint::IDENTIFIER;
        }
        if (str == "STRING") {
            return AliasHint::STRING;
        }
        if (str == "TYPE") {
            return AliasHint::TYPE;
        }
        if (str == "EXPRESSION") {
            return AliasHint::EXPRESSION;
        }
        if (str == "STATEMENT") {
            return AliasHint::STATEMENT;
        }
        if (str == "ALIAS") {
            return AliasHint::ALIAS;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(AliasHint) {
        return "AliasHint";
    }
    enum class OpCode : std::uint8_t {
        NOP = 0x00,
        HALT = 0x01,
        JUMP = 0x02,
        JUMP_IF_TRUE = 0x03,
        JUMP_IF_FALSE = 0x04,
        CALL = 0x05,
        RET = 0x06,
        ERROR = 0x07,
        ASSERT = 0x08,
        POP = 0x10,
        DUP = 0x11,
        SWAP = 0x12,
        PUSH_NULL = 0x13,
        PUSH_IMM_INT = 0x14,
        PUSH_IMM_STR = 0x15,
        LOAD_LOCAL = 0x16,
        STORE_LOCAL = 0x17,
        LOAD_PARAM = 0x18,
        LOAD_SELF = 0x19,
        STORE_REF = 0x1A,
        ADD = 0x20,
        SUB = 0x21,
        MUL = 0x22,
        DIV = 0x23,
        MOD = 0x24,
        NEG = 0x25,
        BIT_AND = 0x26,
        BIT_OR = 0x27,
        BIT_XOR = 0x28,
        BIT_NOT = 0x29,
        LSHIFT = 0x2A,
        RSHIFT = 0x2B,
        LOGICAL_AND = 0x2C,
        LOGICAL_OR = 0x2D,
        LOGICAL_NOT = 0x2E,
        EQ = 0x30,
        NEQ = 0x31,
        LT = 0x32,
        LE = 0x33,
        GT = 0x34,
        GE = 0x35,
        CAST = 0x40,
        READ_U8 = 0x50,
        READ_U16 = 0x51,
        READ_U32 = 0x52,
        READ_U64 = 0x53,
        READ_I8 = 0x54,
        READ_I16 = 0x55,
        READ_I32 = 0x56,
        READ_I64 = 0x57,
        READ_F32 = 0x58,
        READ_F64 = 0x59,
        READ_BITS_U = 0x60,
        READ_BITS_I = 0x61,
        READ_BYTES = 0x62,
        PEEK_U8 = 0x65,
        SEEK_REL = 0x66,
        SEEK_ABS = 0x67,
        AVAILABLE = 0x68,
        GET_OFFSET = 0x69,
        SET_ENDIAN = 0x6A,
        WRITE_U8 = 0x70,
        WRITE_U16 = 0x71,
        WRITE_U32 = 0x72,
        WRITE_U64 = 0x73,
        WRITE_BYTES = 0x74,
        WRITE_BITS = 0x75,
        NEW_STRUCT = 0x90,
        LOAD_MEMBER = 0x92,
        NEW_ARRAY = 0x93,
        ARRAY_SET = 0x94,
        ARRAY_GET = 0x95,
        ARRAY_LEN = 0x96,
        NEW_BYTES = 0x97,
        VECTOR_PUSH = 0x98,
        MAX_OPCODE = 0xFF,
    };
    constexpr const char* to_string(OpCode e, bool origin_form = false) {
        switch(e) {
            case OpCode::NOP: return origin_form ? "NOP":"NOP" ;
            case OpCode::HALT: return origin_form ? "HALT":"HALT" ;
            case OpCode::JUMP: return origin_form ? "JUMP":"JUMP" ;
            case OpCode::JUMP_IF_TRUE: return origin_form ? "JUMP_IF_TRUE":"JUMP_IF_TRUE" ;
            case OpCode::JUMP_IF_FALSE: return origin_form ? "JUMP_IF_FALSE":"JUMP_IF_FALSE" ;
            case OpCode::CALL: return origin_form ? "CALL":"CALL" ;
            case OpCode::RET: return origin_form ? "RET":"RET" ;
            case OpCode::ERROR: return origin_form ? "ERROR":"ERROR" ;
            case OpCode::ASSERT: return origin_form ? "ASSERT":"ASSERT" ;
            case OpCode::POP: return origin_form ? "POP":"POP" ;
            case OpCode::DUP: return origin_form ? "DUP":"DUP" ;
            case OpCode::SWAP: return origin_form ? "SWAP":"SWAP" ;
            case OpCode::PUSH_NULL: return origin_form ? "PUSH_NULL":"PUSH_NULL" ;
            case OpCode::PUSH_IMM_INT: return origin_form ? "PUSH_IMM_INT":"PUSH_IMM_INT" ;
            case OpCode::PUSH_IMM_STR: return origin_form ? "PUSH_IMM_STR":"PUSH_IMM_STR" ;
            case OpCode::LOAD_LOCAL: return origin_form ? "LOAD_LOCAL":"LOAD_LOCAL" ;
            case OpCode::STORE_LOCAL: return origin_form ? "STORE_LOCAL":"STORE_LOCAL" ;
            case OpCode::LOAD_PARAM: return origin_form ? "LOAD_PARAM":"LOAD_PARAM" ;
            case OpCode::LOAD_SELF: return origin_form ? "LOAD_SELF":"LOAD_SELF" ;
            case OpCode::STORE_REF: return origin_form ? "STORE_REF":"STORE_REF" ;
            case OpCode::ADD: return origin_form ? "ADD":"add" ;
            case OpCode::SUB: return origin_form ? "SUB":"sub" ;
            case OpCode::MUL: return origin_form ? "MUL":"mul" ;
            case OpCode::DIV: return origin_form ? "DIV":"div" ;
            case OpCode::MOD: return origin_form ? "MOD":"mod" ;
            case OpCode::NEG: return origin_form ? "NEG":"minus_sign" ;
            case OpCode::BIT_AND: return origin_form ? "BIT_AND":"bit_and" ;
            case OpCode::BIT_OR: return origin_form ? "BIT_OR":"bit_or" ;
            case OpCode::BIT_XOR: return origin_form ? "BIT_XOR":"bit_xor" ;
            case OpCode::BIT_NOT: return origin_form ? "BIT_NOT":"bit_not" ;
            case OpCode::LSHIFT: return origin_form ? "LSHIFT":"left_shift" ;
            case OpCode::RSHIFT: return origin_form ? "RSHIFT":"right_shift" ;
            case OpCode::LOGICAL_AND: return origin_form ? "LOGICAL_AND":"logical_and" ;
            case OpCode::LOGICAL_OR: return origin_form ? "LOGICAL_OR":"logical_or" ;
            case OpCode::LOGICAL_NOT: return origin_form ? "LOGICAL_NOT":"logical_not" ;
            case OpCode::EQ: return origin_form ? "EQ":"equal" ;
            case OpCode::NEQ: return origin_form ? "NEQ":"not_equal" ;
            case OpCode::LT: return origin_form ? "LT":"less" ;
            case OpCode::LE: return origin_form ? "LE":"less_or_eq" ;
            case OpCode::GT: return origin_form ? "GT":"greater" ;
            case OpCode::GE: return origin_form ? "GE":"greater_or_eq" ;
            case OpCode::CAST: return origin_form ? "CAST":"CAST" ;
            case OpCode::READ_U8: return origin_form ? "READ_U8":"READ_U8" ;
            case OpCode::READ_U16: return origin_form ? "READ_U16":"READ_U16" ;
            case OpCode::READ_U32: return origin_form ? "READ_U32":"READ_U32" ;
            case OpCode::READ_U64: return origin_form ? "READ_U64":"READ_U64" ;
            case OpCode::READ_I8: return origin_form ? "READ_I8":"READ_I8" ;
            case OpCode::READ_I16: return origin_form ? "READ_I16":"READ_I16" ;
            case OpCode::READ_I32: return origin_form ? "READ_I32":"READ_I32" ;
            case OpCode::READ_I64: return origin_form ? "READ_I64":"READ_I64" ;
            case OpCode::READ_F32: return origin_form ? "READ_F32":"READ_F32" ;
            case OpCode::READ_F64: return origin_form ? "READ_F64":"READ_F64" ;
            case OpCode::READ_BITS_U: return origin_form ? "READ_BITS_U":"READ_BITS_U" ;
            case OpCode::READ_BITS_I: return origin_form ? "READ_BITS_I":"READ_BITS_I" ;
            case OpCode::READ_BYTES: return origin_form ? "READ_BYTES":"READ_BYTES" ;
            case OpCode::PEEK_U8: return origin_form ? "PEEK_U8":"PEEK_U8" ;
            case OpCode::SEEK_REL: return origin_form ? "SEEK_REL":"SEEK_REL" ;
            case OpCode::SEEK_ABS: return origin_form ? "SEEK_ABS":"SEEK_ABS" ;
            case OpCode::AVAILABLE: return origin_form ? "AVAILABLE":"AVAILABLE" ;
            case OpCode::GET_OFFSET: return origin_form ? "GET_OFFSET":"GET_OFFSET" ;
            case OpCode::SET_ENDIAN: return origin_form ? "SET_ENDIAN":"SET_ENDIAN" ;
            case OpCode::WRITE_U8: return origin_form ? "WRITE_U8":"WRITE_U8" ;
            case OpCode::WRITE_U16: return origin_form ? "WRITE_U16":"WRITE_U16" ;
            case OpCode::WRITE_U32: return origin_form ? "WRITE_U32":"WRITE_U32" ;
            case OpCode::WRITE_U64: return origin_form ? "WRITE_U64":"WRITE_U64" ;
            case OpCode::WRITE_BYTES: return origin_form ? "WRITE_BYTES":"WRITE_BYTES" ;
            case OpCode::WRITE_BITS: return origin_form ? "WRITE_BITS":"WRITE_BITS" ;
            case OpCode::NEW_STRUCT: return origin_form ? "NEW_STRUCT":"NEW_STRUCT" ;
            case OpCode::LOAD_MEMBER: return origin_form ? "LOAD_MEMBER":"LOAD_MEMBER" ;
            case OpCode::NEW_ARRAY: return origin_form ? "NEW_ARRAY":"NEW_ARRAY" ;
            case OpCode::ARRAY_SET: return origin_form ? "ARRAY_SET":"ARRAY_SET" ;
            case OpCode::ARRAY_GET: return origin_form ? "ARRAY_GET":"ARRAY_GET" ;
            case OpCode::ARRAY_LEN: return origin_form ? "ARRAY_LEN":"ARRAY_LEN" ;
            case OpCode::NEW_BYTES: return origin_form ? "NEW_BYTES":"NEW_BYTES" ;
            case OpCode::VECTOR_PUSH: return origin_form ? "VECTOR_PUSH":"VECTOR_PUSH" ;
            case OpCode::MAX_OPCODE: return origin_form ? "MAX_OPCODE":"MAX_OPCODE" ;
        }
        return "";
    }
    
    constexpr std::optional<OpCode> OpCode_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "NOP") {
            return OpCode::NOP;
        }
        if (str == "HALT") {
            return OpCode::HALT;
        }
        if (str == "JUMP") {
            return OpCode::JUMP;
        }
        if (str == "JUMP_IF_TRUE") {
            return OpCode::JUMP_IF_TRUE;
        }
        if (str == "JUMP_IF_FALSE") {
            return OpCode::JUMP_IF_FALSE;
        }
        if (str == "CALL") {
            return OpCode::CALL;
        }
        if (str == "RET") {
            return OpCode::RET;
        }
        if (str == "ERROR") {
            return OpCode::ERROR;
        }
        if (str == "ASSERT") {
            return OpCode::ASSERT;
        }
        if (str == "POP") {
            return OpCode::POP;
        }
        if (str == "DUP") {
            return OpCode::DUP;
        }
        if (str == "SWAP") {
            return OpCode::SWAP;
        }
        if (str == "PUSH_NULL") {
            return OpCode::PUSH_NULL;
        }
        if (str == "PUSH_IMM_INT") {
            return OpCode::PUSH_IMM_INT;
        }
        if (str == "PUSH_IMM_STR") {
            return OpCode::PUSH_IMM_STR;
        }
        if (str == "LOAD_LOCAL") {
            return OpCode::LOAD_LOCAL;
        }
        if (str == "STORE_LOCAL") {
            return OpCode::STORE_LOCAL;
        }
        if (str == "LOAD_PARAM") {
            return OpCode::LOAD_PARAM;
        }
        if (str == "LOAD_SELF") {
            return OpCode::LOAD_SELF;
        }
        if (str == "STORE_REF") {
            return OpCode::STORE_REF;
        }
        if (str == "add") {
            return OpCode::ADD;
        }
        if (str == "sub") {
            return OpCode::SUB;
        }
        if (str == "mul") {
            return OpCode::MUL;
        }
        if (str == "div") {
            return OpCode::DIV;
        }
        if (str == "mod") {
            return OpCode::MOD;
        }
        if (str == "minus_sign") {
            return OpCode::NEG;
        }
        if (str == "bit_and") {
            return OpCode::BIT_AND;
        }
        if (str == "bit_or") {
            return OpCode::BIT_OR;
        }
        if (str == "bit_xor") {
            return OpCode::BIT_XOR;
        }
        if (str == "bit_not") {
            return OpCode::BIT_NOT;
        }
        if (str == "left_shift") {
            return OpCode::LSHIFT;
        }
        if (str == "right_shift") {
            return OpCode::RSHIFT;
        }
        if (str == "logical_and") {
            return OpCode::LOGICAL_AND;
        }
        if (str == "logical_or") {
            return OpCode::LOGICAL_OR;
        }
        if (str == "logical_not") {
            return OpCode::LOGICAL_NOT;
        }
        if (str == "equal") {
            return OpCode::EQ;
        }
        if (str == "not_equal") {
            return OpCode::NEQ;
        }
        if (str == "less") {
            return OpCode::LT;
        }
        if (str == "less_or_eq") {
            return OpCode::LE;
        }
        if (str == "greater") {
            return OpCode::GT;
        }
        if (str == "greater_or_eq") {
            return OpCode::GE;
        }
        if (str == "CAST") {
            return OpCode::CAST;
        }
        if (str == "READ_U8") {
            return OpCode::READ_U8;
        }
        if (str == "READ_U16") {
            return OpCode::READ_U16;
        }
        if (str == "READ_U32") {
            return OpCode::READ_U32;
        }
        if (str == "READ_U64") {
            return OpCode::READ_U64;
        }
        if (str == "READ_I8") {
            return OpCode::READ_I8;
        }
        if (str == "READ_I16") {
            return OpCode::READ_I16;
        }
        if (str == "READ_I32") {
            return OpCode::READ_I32;
        }
        if (str == "READ_I64") {
            return OpCode::READ_I64;
        }
        if (str == "READ_F32") {
            return OpCode::READ_F32;
        }
        if (str == "READ_F64") {
            return OpCode::READ_F64;
        }
        if (str == "READ_BITS_U") {
            return OpCode::READ_BITS_U;
        }
        if (str == "READ_BITS_I") {
            return OpCode::READ_BITS_I;
        }
        if (str == "READ_BYTES") {
            return OpCode::READ_BYTES;
        }
        if (str == "PEEK_U8") {
            return OpCode::PEEK_U8;
        }
        if (str == "SEEK_REL") {
            return OpCode::SEEK_REL;
        }
        if (str == "SEEK_ABS") {
            return OpCode::SEEK_ABS;
        }
        if (str == "AVAILABLE") {
            return OpCode::AVAILABLE;
        }
        if (str == "GET_OFFSET") {
            return OpCode::GET_OFFSET;
        }
        if (str == "SET_ENDIAN") {
            return OpCode::SET_ENDIAN;
        }
        if (str == "WRITE_U8") {
            return OpCode::WRITE_U8;
        }
        if (str == "WRITE_U16") {
            return OpCode::WRITE_U16;
        }
        if (str == "WRITE_U32") {
            return OpCode::WRITE_U32;
        }
        if (str == "WRITE_U64") {
            return OpCode::WRITE_U64;
        }
        if (str == "WRITE_BYTES") {
            return OpCode::WRITE_BYTES;
        }
        if (str == "WRITE_BITS") {
            return OpCode::WRITE_BITS;
        }
        if (str == "NEW_STRUCT") {
            return OpCode::NEW_STRUCT;
        }
        if (str == "LOAD_MEMBER") {
            return OpCode::LOAD_MEMBER;
        }
        if (str == "NEW_ARRAY") {
            return OpCode::NEW_ARRAY;
        }
        if (str == "ARRAY_SET") {
            return OpCode::ARRAY_SET;
        }
        if (str == "ARRAY_GET") {
            return OpCode::ARRAY_GET;
        }
        if (str == "ARRAY_LEN") {
            return OpCode::ARRAY_LEN;
        }
        if (str == "NEW_BYTES") {
            return OpCode::NEW_BYTES;
        }
        if (str == "VECTOR_PUSH") {
            return OpCode::VECTOR_PUSH;
        }
        if (str == "MAX_OPCODE") {
            return OpCode::MAX_OPCODE;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(OpCode) {
        return "OpCode";
    }
    struct Varint;
    struct SetEndian;
    struct StatementRef;
    struct IOAttribute;
    struct ExpressionRef;
    struct EndianVariable;
    struct String;
    struct IdentifierRef;
    struct TypeRef;
    struct StringRef;
    struct LoweredStatementRef;
    struct LoweredExpressionRef;
    struct LoweredIOStatement;
    struct LoopFlowControl;
    struct Condition;
    struct InitCheck;
    struct AnyRef;
    struct RefAlias;
    struct JumpOffset;
    struct RegisterIndex;
    struct OptionalImmediateSize;
    struct Expressions;
    struct CallDesc;
    struct Size;
    struct ExpressionBody;
    struct Expression;
    struct IfStatement;
    struct ParameterDecl;
    struct PropertyMemberDecl;
    struct Block;
    struct CompositeFieldDecl;
    struct SubByteRange;
    struct Metadata;
    struct LoweredIOStatements;
    struct AssertDesc;
    struct IOData;
    struct LoopStatement;
    struct MatchStatement;
    struct MatchBranch;
    struct FunctionDecl;
    struct VariableDecl;
    struct FieldDecl;
    struct EnumDecl;
    struct EnumMemberDecl;
    struct StructDecl;
    struct PropertyDecl;
    struct ImportDecl;
    struct ErrorReport;
    struct StatementBody;
    struct Statement;
    struct Types;
    struct TypeBody;
    struct Type;
    struct Loc;
    struct Identifier;
    struct StringLiteral;
    struct DebugInfo;
    struct Instruction;
    struct ExtendedBinaryModule;
    struct EBM_API Varint{
        ::futils::binary::flags_t<std::uint64_t,2,62> flags_1_;
        bits_flag_alias_method(flags_1_,0,prefix);
        bits_flag_alias_method(flags_1_,1,value);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 0;
        constexpr static const char* visitor_name = "Varint";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "prefix",(*this).prefix());
            v(v, "value",(*this).value());
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "prefix",(*this).prefix());
            v(v, "value",(*this).value());
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "prefix",visitor_tag<decltype(std::declval<Varint>().prefix()),true>{});
            v(v, "value",visitor_tag<decltype(std::declval<Varint>().value()),true>{});
        }
    };
    struct EBM_API SetEndian{
        ::futils::binary::flags_t<std::uint8_t, 3, 5> flags_2_;
        bits_flag_alias_method_with_enum(flags_2_,0,endian,Endian);
        bits_flag_alias_method(flags_2_,1,reserved);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
        constexpr static const char* visitor_name = "SetEndian";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "endian",(*this).endian());
            v(v, "reserved",(*this).reserved());
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "endian",(*this).endian());
            v(v, "reserved",(*this).reserved());
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "endian",visitor_tag<decltype(std::declval<SetEndian>().endian()),true>{});
            v(v, "reserved",visitor_tag<decltype(std::declval<SetEndian>().reserved()),true>{});
        }
    };
    struct EBM_API StatementRef{
        Varint id;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "StatementRef";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "id",(*this).id);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "id",(*this).id);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "id",visitor_tag<decltype(std::declval<StatementRef>().id),false>{});
        }
    };
    struct EBM_API IOAttribute{
        ::futils::binary::flags_t<std::uint8_t, 3, 1, 1, 1, 2> flags_3_;
        bits_flag_alias_method_with_enum(flags_3_,0,endian,Endian);
        bits_flag_alias_method(flags_3_,1,sign);
        bits_flag_alias_method(flags_3_,2,is_peek);
        bits_flag_alias_method(flags_3_,3,has_lowered_statement);
        bits_flag_alias_method(flags_3_,4,reserved);
        struct EBM_API union_struct_6{
            StatementRef dynamic_ref;
        };
        std::variant<std::monostate, union_struct_6> union_variant_5;
        const StatementRef* dynamic_ref() const;
        StatementRef* dynamic_ref();
        bool dynamic_ref(StatementRef&& v);
        bool dynamic_ref(const StatementRef& v);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
        constexpr static const char* visitor_name = "IOAttribute";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "endian",(*this).endian());
            v(v, "sign",(*this).sign());
            v(v, "is_peek",(*this).is_peek());
            v(v, "has_lowered_statement",(*this).has_lowered_statement());
            v(v, "reserved",(*this).reserved());
            v(v, "dynamic_ref",(*this).dynamic_ref());
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "endian",(*this).endian());
            v(v, "sign",(*this).sign());
            v(v, "is_peek",(*this).is_peek());
            v(v, "has_lowered_statement",(*this).has_lowered_statement());
            v(v, "reserved",(*this).reserved());
            v(v, "dynamic_ref",(*this).dynamic_ref());
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "endian",visitor_tag<decltype(std::declval<IOAttribute>().endian()),true>{});
            v(v, "sign",visitor_tag<decltype(std::declval<IOAttribute>().sign()),true>{});
            v(v, "is_peek",visitor_tag<decltype(std::declval<IOAttribute>().is_peek()),true>{});
            v(v, "has_lowered_statement",visitor_tag<decltype(std::declval<IOAttribute>().has_lowered_statement()),true>{});
            v(v, "reserved",visitor_tag<decltype(std::declval<IOAttribute>().reserved()),true>{});
            v(v, "dynamic_ref",visitor_tag<decltype(std::declval<IOAttribute>().dynamic_ref()),false>{});
        }
    };
    struct EBM_API ExpressionRef{
        Varint id;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "ExpressionRef";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "id",(*this).id);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "id",(*this).id);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "id",visitor_tag<decltype(std::declval<ExpressionRef>().id),false>{});
        }
    };
    struct EBM_API EndianVariable{
        ::futils::binary::flags_t<std::uint8_t, 3, 5> flags_7_;
        bits_flag_alias_method_with_enum(flags_7_,0,endian,Endian);
        bits_flag_alias_method(flags_7_,1,reserved);
        struct EBM_API union_struct_10{
            ExpressionRef dynamic_expr;
        };
        std::variant<std::monostate, union_struct_10> union_variant_9;
        const ExpressionRef* dynamic_expr() const;
        ExpressionRef* dynamic_expr();
        bool dynamic_expr(ExpressionRef&& v);
        bool dynamic_expr(const ExpressionRef& v);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
        constexpr static const char* visitor_name = "EndianVariable";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "endian",(*this).endian());
            v(v, "reserved",(*this).reserved());
            v(v, "dynamic_expr",(*this).dynamic_expr());
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "endian",(*this).endian());
            v(v, "reserved",(*this).reserved());
            v(v, "dynamic_expr",(*this).dynamic_expr());
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "endian",visitor_tag<decltype(std::declval<EndianVariable>().endian()),true>{});
            v(v, "reserved",visitor_tag<decltype(std::declval<EndianVariable>().reserved()),true>{});
            v(v, "dynamic_expr",visitor_tag<decltype(std::declval<EndianVariable>().dynamic_expr()),false>{});
        }
    };
    struct EBM_API String{
        Varint length;
        std::string data;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "String";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "length",(*this).length);
            v(v, "data",(*this).data);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "length",(*this).length);
            v(v, "data",(*this).data);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "length",visitor_tag<decltype(std::declval<String>().length),false>{});
            v(v, "data",visitor_tag<decltype(std::declval<String>().data),false>{});
        }
    };
    struct EBM_API IdentifierRef{
        Varint id;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "IdentifierRef";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "id",(*this).id);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "id",(*this).id);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "id",visitor_tag<decltype(std::declval<IdentifierRef>().id),false>{});
        }
    };
    struct EBM_API TypeRef{
        Varint id;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "TypeRef";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "id",(*this).id);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "id",(*this).id);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "id",visitor_tag<decltype(std::declval<TypeRef>().id),false>{});
        }
    };
    struct EBM_API StringRef{
        Varint id;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "StringRef";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "id",(*this).id);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "id",(*this).id);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "id",visitor_tag<decltype(std::declval<StringRef>().id),false>{});
        }
    };
    struct EBM_API LoweredStatementRef{
        StatementRef id;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "LoweredStatementRef";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "id",(*this).id);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "id",(*this).id);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "id",visitor_tag<decltype(std::declval<LoweredStatementRef>().id),false>{});
        }
    };
    struct EBM_API LoweredExpressionRef{
        ExpressionRef id;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "LoweredExpressionRef";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "id",(*this).id);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "id",(*this).id);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "id",visitor_tag<decltype(std::declval<LoweredExpressionRef>().id),false>{});
        }
    };
    struct EBM_API LoweredIOStatement{
        LoweringIOType lowering_type{};
        LoweredStatementRef io_statement;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
        constexpr static const char* visitor_name = "LoweredIOStatement";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "lowering_type",(*this).lowering_type);
            v(v, "io_statement",(*this).io_statement);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "lowering_type",(*this).lowering_type);
            v(v, "io_statement",(*this).io_statement);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "lowering_type",visitor_tag<decltype(std::declval<LoweredIOStatement>().lowering_type),false>{});
            v(v, "io_statement",visitor_tag<decltype(std::declval<LoweredIOStatement>().io_statement),false>{});
        }
    };
    struct EBM_API LoopFlowControl{
        StatementRef related_statement;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "LoopFlowControl";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "related_statement",(*this).related_statement);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "related_statement",(*this).related_statement);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "related_statement",visitor_tag<decltype(std::declval<LoopFlowControl>().related_statement),false>{});
        }
    };
    struct EBM_API Condition{
        ExpressionRef cond;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "Condition";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "cond",(*this).cond);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "cond",(*this).cond);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "cond",visitor_tag<decltype(std::declval<Condition>().cond),false>{});
        }
    };
    struct EBM_API InitCheck{
        InitCheckType init_check_type{};
        ExpressionRef target_field;
        ExpressionRef expect_value;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
        constexpr static const char* visitor_name = "InitCheck";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "init_check_type",(*this).init_check_type);
            v(v, "target_field",(*this).target_field);
            v(v, "expect_value",(*this).expect_value);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "init_check_type",(*this).init_check_type);
            v(v, "target_field",(*this).target_field);
            v(v, "expect_value",(*this).expect_value);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "init_check_type",visitor_tag<decltype(std::declval<InitCheck>().init_check_type),false>{});
            v(v, "target_field",visitor_tag<decltype(std::declval<InitCheck>().target_field),false>{});
            v(v, "expect_value",visitor_tag<decltype(std::declval<InitCheck>().expect_value),false>{});
        }
    };
    struct EBM_API AnyRef{
        Varint id;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "AnyRef";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "id",(*this).id);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "id",(*this).id);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "id",visitor_tag<decltype(std::declval<AnyRef>().id),false>{});
        }
    };
    struct EBM_API RefAlias{
        AliasHint hint{};
        AnyRef from;
        AnyRef to;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
        constexpr static const char* visitor_name = "RefAlias";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "hint",(*this).hint);
            v(v, "from",(*this).from);
            v(v, "to",(*this).to);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "hint",(*this).hint);
            v(v, "from",(*this).from);
            v(v, "to",(*this).to);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "hint",visitor_tag<decltype(std::declval<RefAlias>().hint),false>{});
            v(v, "from",visitor_tag<decltype(std::declval<RefAlias>().from),false>{});
            v(v, "to",visitor_tag<decltype(std::declval<RefAlias>().to),false>{});
        }
    };
    struct EBM_API JumpOffset{
        Varint offset;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "JumpOffset";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "offset",(*this).offset);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "offset",(*this).offset);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "offset",visitor_tag<decltype(std::declval<JumpOffset>().offset),false>{});
        }
    };
    struct EBM_API RegisterIndex{
        StatementRef index;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "RegisterIndex";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "index",(*this).index);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "index",(*this).index);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "index",visitor_tag<decltype(std::declval<RegisterIndex>().index),false>{});
        }
    };
    struct EBM_API OptionalImmediateSize{
        ::futils::binary::flags_t<std::uint8_t, 1, 7> flags_11_;
        bits_flag_alias_method(flags_11_,0,is_immediate);
        bits_flag_alias_method(flags_11_,1,reserved);
        struct EBM_API union_struct_14{
            Varint size;
        };
        std::variant<std::monostate, union_struct_14> union_variant_13;
        const Varint* size() const;
        Varint* size();
        bool size(Varint&& v);
        bool size(const Varint& v);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
        constexpr static const char* visitor_name = "OptionalImmediateSize";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "is_immediate",(*this).is_immediate());
            v(v, "reserved",(*this).reserved());
            v(v, "size",(*this).size());
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "is_immediate",(*this).is_immediate());
            v(v, "reserved",(*this).reserved());
            v(v, "size",(*this).size());
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "is_immediate",visitor_tag<decltype(std::declval<OptionalImmediateSize>().is_immediate()),true>{});
            v(v, "reserved",visitor_tag<decltype(std::declval<OptionalImmediateSize>().reserved()),true>{});
            v(v, "size",visitor_tag<decltype(std::declval<OptionalImmediateSize>().size()),false>{});
        }
    };
    struct EBM_API Expressions{
        Varint len;
        std::vector<ExpressionRef> container;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "Expressions";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "len",(*this).len);
            v(v, "container",(*this).container);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "len",(*this).len);
            v(v, "container",(*this).container);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "len",visitor_tag<decltype(std::declval<Expressions>().len),false>{});
            v(v, "container",visitor_tag<decltype(std::declval<Expressions>().container),false>{});
        }
    };
    struct EBM_API CallDesc{
        ExpressionRef callee;
        Expressions arguments;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "CallDesc";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "callee",(*this).callee);
            v(v, "arguments",(*this).arguments);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "callee",(*this).callee);
            v(v, "arguments",(*this).arguments);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "callee",visitor_tag<decltype(std::declval<CallDesc>().callee),false>{});
            v(v, "arguments",visitor_tag<decltype(std::declval<CallDesc>().arguments),false>{});
        }
    };
    struct EBM_API Size{
        SizeUnit unit{};
        struct EBM_API union_struct_17{
        };
        struct EBM_API union_struct_18{
            Varint size;
        };
        struct EBM_API union_struct_19{
            Varint size;
        };
        struct EBM_API union_struct_20{
            Varint size;
        };
        struct EBM_API union_struct_21{
            ExpressionRef ref;
        };
        struct EBM_API union_struct_22{
            ExpressionRef ref;
        };
        struct EBM_API union_struct_23{
            ExpressionRef ref;
        };
        std::variant<std::monostate, union_struct_17, union_struct_18, union_struct_19, union_struct_20, union_struct_21, union_struct_22, union_struct_23> union_variant_16;
        const ExpressionRef* ref() const;
        ExpressionRef* ref();
        bool ref(ExpressionRef&& v);
        bool ref(const ExpressionRef& v);
        const Varint* size() const;
        Varint* size();
        bool size(Varint&& v);
        bool size(const Varint& v);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
        constexpr static const char* visitor_name = "Size";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "unit",(*this).unit);
            v(v, "ref",(*this).ref());
            v(v, "size",(*this).size());
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "unit",(*this).unit);
            v(v, "ref",(*this).ref());
            v(v, "size",(*this).size());
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "unit",visitor_tag<decltype(std::declval<Size>().unit),false>{});
            v(v, "ref",visitor_tag<decltype(std::declval<Size>().ref()),false>{});
            v(v, "size",visitor_tag<decltype(std::declval<Size>().size()),false>{});
        }
    };
    struct EBM_API ExpressionBody{
        TypeRef type;
        ExpressionKind kind{};
        struct EBM_API union_struct_26{
            Varint int_value;
        };
        struct EBM_API union_struct_27{
            std::uint64_t int64_value = 0;
        };
        struct EBM_API union_struct_28{
            std::uint8_t bool_value = 0;
        };
        struct EBM_API union_struct_29{
            StringRef string_value;
        };
        struct EBM_API union_struct_30{
            TypeRef type_ref;
        };
        struct EBM_API union_struct_31{
            Varint char_value;
        };
        struct EBM_API union_struct_32{
            StatementRef id;
        };
        struct EBM_API union_struct_33{
            BinaryOp bop{};
            ExpressionRef left;
            ExpressionRef right;
        };
        struct EBM_API union_struct_34{
            UnaryOp uop{};
            ExpressionRef operand;
        };
        struct EBM_API union_struct_35{
            CallDesc call_desc;
        };
        struct EBM_API union_struct_36{
            ExpressionRef base;
            ExpressionRef index;
        };
        struct EBM_API union_struct_37{
            ExpressionRef base;
            ExpressionRef member;
        };
        struct EBM_API union_struct_38{
            StatementRef enum_decl;
            ExpressionRef member;
        };
        struct EBM_API union_struct_39{
            TypeRef from_type;
            ExpressionRef source_expr;
            CastType cast_kind{};
        };
        struct EBM_API union_struct_40{
            ExpressionRef start;
            ExpressionRef end;
        };
        struct EBM_API union_struct_41{
            StatementRef endian_expr;
        };
        struct EBM_API union_struct_42{
            StreamType stream_type{};
            SizeUnit unit{};
        };
        struct EBM_API union_struct_43{
            StreamType stream_type{};
        };
        struct EBM_API union_struct_44{
            StreamType stream_type{};
            Size num_bytes;
            StatementRef io_ref;
        };
        struct EBM_API union_struct_45{
            ExpressionRef array_expr;
        };
        struct EBM_API union_struct_46{
            ExpressionRef target_expr;
        };
        struct EBM_API union_struct_47{
            LoweredExpressionRef lowered_expr;
        };
        struct EBM_API union_struct_48{
            StatementRef target_stmt;
            StatementRef io_statement;
        };
        struct EBM_API union_struct_49{
            ExpressionRef target_expr;
            StatementRef io_statement;
        };
        struct EBM_API union_struct_50{
            StatementRef target_stmt;
            StatementRef conditional_stmt;
        };
        struct EBM_API union_struct_51{
            ExpressionRef condition;
            ExpressionRef then;
            ExpressionRef else_;
            LoweredExpressionRef lowered_expr;
        };
        struct EBM_API union_struct_52{
            ExpressionRef target_expr;
            LoweredExpressionRef lowered_expr;
        };
        struct EBM_API union_struct_53{
            ExpressionRef target_expr;
            LoweredExpressionRef lowered_expr;
        };
        struct EBM_API union_struct_54{
            ExpressionRef target_expr;
            LoweredExpressionRef lowered_expr;
        };
        struct EBM_API union_struct_55{
            StatementRef sub_range;
        };
        struct EBM_API union_struct_56{
            Expressions or_cond;
        };
        struct EBM_API union_struct_57{
            ExpressionRef target_expr;
        };
        struct EBM_API union_struct_58{
            ExpressionRef target_expr;
        };
        struct EBM_API union_struct_59{
            SetterStatus setter_status{};
        };
        struct EBM_API union_struct_60{
            ExpressionRef target_expr;
        };
        std::variant<std::monostate, union_struct_26, union_struct_27, union_struct_28, union_struct_29, union_struct_30, union_struct_31, union_struct_32, union_struct_33, union_struct_34, union_struct_35, union_struct_36, union_struct_37, union_struct_38, union_struct_39, union_struct_40, union_struct_41, union_struct_42, union_struct_43, union_struct_44, union_struct_45, union_struct_46, union_struct_47, union_struct_48, union_struct_49, union_struct_50, union_struct_51, union_struct_52, union_struct_53, union_struct_54, union_struct_55, union_struct_56, union_struct_57, union_struct_58, union_struct_59, union_struct_60> union_variant_25;
        const ExpressionRef* array_expr() const;
        ExpressionRef* array_expr();
        bool array_expr(ExpressionRef&& v);
        bool array_expr(const ExpressionRef& v);
        const ExpressionRef* base() const;
        ExpressionRef* base();
        bool base(ExpressionRef&& v);
        bool base(const ExpressionRef& v);
        const std::uint8_t* bool_value() const;
        std::uint8_t* bool_value();
        bool bool_value(std::uint8_t&& v);
        bool bool_value(const std::uint8_t& v);
        const BinaryOp* bop() const;
        BinaryOp* bop();
        bool bop(BinaryOp&& v);
        bool bop(const BinaryOp& v);
        const CallDesc* call_desc() const;
        CallDesc* call_desc();
        bool call_desc(CallDesc&& v);
        bool call_desc(const CallDesc& v);
        const CastType* cast_kind() const;
        CastType* cast_kind();
        bool cast_kind(CastType&& v);
        bool cast_kind(const CastType& v);
        const Varint* char_value() const;
        Varint* char_value();
        bool char_value(Varint&& v);
        bool char_value(const Varint& v);
        const ExpressionRef* condition() const;
        ExpressionRef* condition();
        bool condition(ExpressionRef&& v);
        bool condition(const ExpressionRef& v);
        const StatementRef* conditional_stmt() const;
        StatementRef* conditional_stmt();
        bool conditional_stmt(StatementRef&& v);
        bool conditional_stmt(const StatementRef& v);
        const ExpressionRef* else_() const;
        ExpressionRef* else_();
        bool else_(ExpressionRef&& v);
        bool else_(const ExpressionRef& v);
        const ExpressionRef* end() const;
        ExpressionRef* end();
        bool end(ExpressionRef&& v);
        bool end(const ExpressionRef& v);
        const StatementRef* endian_expr() const;
        StatementRef* endian_expr();
        bool endian_expr(StatementRef&& v);
        bool endian_expr(const StatementRef& v);
        const StatementRef* enum_decl() const;
        StatementRef* enum_decl();
        bool enum_decl(StatementRef&& v);
        bool enum_decl(const StatementRef& v);
        const TypeRef* from_type() const;
        TypeRef* from_type();
        bool from_type(TypeRef&& v);
        bool from_type(const TypeRef& v);
        const StatementRef* id() const;
        StatementRef* id();
        bool id(StatementRef&& v);
        bool id(const StatementRef& v);
        const ExpressionRef* index() const;
        ExpressionRef* index();
        bool index(ExpressionRef&& v);
        bool index(const ExpressionRef& v);
        const std::uint64_t* int64_value() const;
        std::uint64_t* int64_value();
        bool int64_value(std::uint64_t&& v);
        bool int64_value(const std::uint64_t& v);
        const Varint* int_value() const;
        Varint* int_value();
        bool int_value(Varint&& v);
        bool int_value(const Varint& v);
        const StatementRef* io_ref() const;
        StatementRef* io_ref();
        bool io_ref(StatementRef&& v);
        bool io_ref(const StatementRef& v);
        const StatementRef* io_statement() const;
        StatementRef* io_statement();
        bool io_statement(StatementRef&& v);
        bool io_statement(const StatementRef& v);
        const ExpressionRef* left() const;
        ExpressionRef* left();
        bool left(ExpressionRef&& v);
        bool left(const ExpressionRef& v);
        const LoweredExpressionRef* lowered_expr() const;
        LoweredExpressionRef* lowered_expr();
        bool lowered_expr(LoweredExpressionRef&& v);
        bool lowered_expr(const LoweredExpressionRef& v);
        const ExpressionRef* member() const;
        ExpressionRef* member();
        bool member(ExpressionRef&& v);
        bool member(const ExpressionRef& v);
        const Size* num_bytes() const;
        Size* num_bytes();
        bool num_bytes(Size&& v);
        bool num_bytes(const Size& v);
        const ExpressionRef* operand() const;
        ExpressionRef* operand();
        bool operand(ExpressionRef&& v);
        bool operand(const ExpressionRef& v);
        const Expressions* or_cond() const;
        Expressions* or_cond();
        bool or_cond(Expressions&& v);
        bool or_cond(const Expressions& v);
        const ExpressionRef* right() const;
        ExpressionRef* right();
        bool right(ExpressionRef&& v);
        bool right(const ExpressionRef& v);
        const SetterStatus* setter_status() const;
        SetterStatus* setter_status();
        bool setter_status(SetterStatus&& v);
        bool setter_status(const SetterStatus& v);
        const ExpressionRef* source_expr() const;
        ExpressionRef* source_expr();
        bool source_expr(ExpressionRef&& v);
        bool source_expr(const ExpressionRef& v);
        const ExpressionRef* start() const;
        ExpressionRef* start();
        bool start(ExpressionRef&& v);
        bool start(const ExpressionRef& v);
        const StreamType* stream_type() const;
        StreamType* stream_type();
        bool stream_type(StreamType&& v);
        bool stream_type(const StreamType& v);
        const StringRef* string_value() const;
        StringRef* string_value();
        bool string_value(StringRef&& v);
        bool string_value(const StringRef& v);
        const StatementRef* sub_range() const;
        StatementRef* sub_range();
        bool sub_range(StatementRef&& v);
        bool sub_range(const StatementRef& v);
        const ExpressionRef* target_expr() const;
        ExpressionRef* target_expr();
        bool target_expr(ExpressionRef&& v);
        bool target_expr(const ExpressionRef& v);
        const StatementRef* target_stmt() const;
        StatementRef* target_stmt();
        bool target_stmt(StatementRef&& v);
        bool target_stmt(const StatementRef& v);
        const ExpressionRef* then() const;
        ExpressionRef* then();
        bool then(ExpressionRef&& v);
        bool then(const ExpressionRef& v);
        const TypeRef* type_ref() const;
        TypeRef* type_ref();
        bool type_ref(TypeRef&& v);
        bool type_ref(const TypeRef& v);
        const SizeUnit* unit() const;
        SizeUnit* unit();
        bool unit(SizeUnit&& v);
        bool unit(const SizeUnit& v);
        const UnaryOp* uop() const;
        UnaryOp* uop();
        bool uop(UnaryOp&& v);
        bool uop(const UnaryOp& v);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "ExpressionBody";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "type",(*this).type);
            v(v, "kind",(*this).kind);
            v(v, "array_expr",(*this).array_expr());
            v(v, "base",(*this).base());
            v(v, "bool_value",(*this).bool_value());
            v(v, "bop",(*this).bop());
            v(v, "call_desc",(*this).call_desc());
            v(v, "cast_kind",(*this).cast_kind());
            v(v, "char_value",(*this).char_value());
            v(v, "condition",(*this).condition());
            v(v, "conditional_stmt",(*this).conditional_stmt());
            v(v, "else_",(*this).else_());
            v(v, "end",(*this).end());
            v(v, "endian_expr",(*this).endian_expr());
            v(v, "enum_decl",(*this).enum_decl());
            v(v, "from_type",(*this).from_type());
            v(v, "id",(*this).id());
            v(v, "index",(*this).index());
            v(v, "int64_value",(*this).int64_value());
            v(v, "int_value",(*this).int_value());
            v(v, "io_ref",(*this).io_ref());
            v(v, "io_statement",(*this).io_statement());
            v(v, "left",(*this).left());
            v(v, "lowered_expr",(*this).lowered_expr());
            v(v, "member",(*this).member());
            v(v, "num_bytes",(*this).num_bytes());
            v(v, "operand",(*this).operand());
            v(v, "or_cond",(*this).or_cond());
            v(v, "right",(*this).right());
            v(v, "setter_status",(*this).setter_status());
            v(v, "source_expr",(*this).source_expr());
            v(v, "start",(*this).start());
            v(v, "stream_type",(*this).stream_type());
            v(v, "string_value",(*this).string_value());
            v(v, "sub_range",(*this).sub_range());
            v(v, "target_expr",(*this).target_expr());
            v(v, "target_stmt",(*this).target_stmt());
            v(v, "then",(*this).then());
            v(v, "type_ref",(*this).type_ref());
            v(v, "unit",(*this).unit());
            v(v, "uop",(*this).uop());
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "type",(*this).type);
            v(v, "kind",(*this).kind);
            v(v, "array_expr",(*this).array_expr());
            v(v, "base",(*this).base());
            v(v, "bool_value",(*this).bool_value());
            v(v, "bop",(*this).bop());
            v(v, "call_desc",(*this).call_desc());
            v(v, "cast_kind",(*this).cast_kind());
            v(v, "char_value",(*this).char_value());
            v(v, "condition",(*this).condition());
            v(v, "conditional_stmt",(*this).conditional_stmt());
            v(v, "else_",(*this).else_());
            v(v, "end",(*this).end());
            v(v, "endian_expr",(*this).endian_expr());
            v(v, "enum_decl",(*this).enum_decl());
            v(v, "from_type",(*this).from_type());
            v(v, "id",(*this).id());
            v(v, "index",(*this).index());
            v(v, "int64_value",(*this).int64_value());
            v(v, "int_value",(*this).int_value());
            v(v, "io_ref",(*this).io_ref());
            v(v, "io_statement",(*this).io_statement());
            v(v, "left",(*this).left());
            v(v, "lowered_expr",(*this).lowered_expr());
            v(v, "member",(*this).member());
            v(v, "num_bytes",(*this).num_bytes());
            v(v, "operand",(*this).operand());
            v(v, "or_cond",(*this).or_cond());
            v(v, "right",(*this).right());
            v(v, "setter_status",(*this).setter_status());
            v(v, "source_expr",(*this).source_expr());
            v(v, "start",(*this).start());
            v(v, "stream_type",(*this).stream_type());
            v(v, "string_value",(*this).string_value());
            v(v, "sub_range",(*this).sub_range());
            v(v, "target_expr",(*this).target_expr());
            v(v, "target_stmt",(*this).target_stmt());
            v(v, "then",(*this).then());
            v(v, "type_ref",(*this).type_ref());
            v(v, "unit",(*this).unit());
            v(v, "uop",(*this).uop());
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "type",visitor_tag<decltype(std::declval<ExpressionBody>().type),false>{});
            v(v, "kind",visitor_tag<decltype(std::declval<ExpressionBody>().kind),false>{});
            v(v, "array_expr",visitor_tag<decltype(std::declval<ExpressionBody>().array_expr()),false>{});
            v(v, "base",visitor_tag<decltype(std::declval<ExpressionBody>().base()),false>{});
            v(v, "bool_value",visitor_tag<decltype(std::declval<ExpressionBody>().bool_value()),false>{});
            v(v, "bop",visitor_tag<decltype(std::declval<ExpressionBody>().bop()),false>{});
            v(v, "call_desc",visitor_tag<decltype(std::declval<ExpressionBody>().call_desc()),false>{});
            v(v, "cast_kind",visitor_tag<decltype(std::declval<ExpressionBody>().cast_kind()),false>{});
            v(v, "char_value",visitor_tag<decltype(std::declval<ExpressionBody>().char_value()),false>{});
            v(v, "condition",visitor_tag<decltype(std::declval<ExpressionBody>().condition()),false>{});
            v(v, "conditional_stmt",visitor_tag<decltype(std::declval<ExpressionBody>().conditional_stmt()),false>{});
            v(v, "else_",visitor_tag<decltype(std::declval<ExpressionBody>().else_()),false>{});
            v(v, "end",visitor_tag<decltype(std::declval<ExpressionBody>().end()),false>{});
            v(v, "endian_expr",visitor_tag<decltype(std::declval<ExpressionBody>().endian_expr()),false>{});
            v(v, "enum_decl",visitor_tag<decltype(std::declval<ExpressionBody>().enum_decl()),false>{});
            v(v, "from_type",visitor_tag<decltype(std::declval<ExpressionBody>().from_type()),false>{});
            v(v, "id",visitor_tag<decltype(std::declval<ExpressionBody>().id()),false>{});
            v(v, "index",visitor_tag<decltype(std::declval<ExpressionBody>().index()),false>{});
            v(v, "int64_value",visitor_tag<decltype(std::declval<ExpressionBody>().int64_value()),false>{});
            v(v, "int_value",visitor_tag<decltype(std::declval<ExpressionBody>().int_value()),false>{});
            v(v, "io_ref",visitor_tag<decltype(std::declval<ExpressionBody>().io_ref()),false>{});
            v(v, "io_statement",visitor_tag<decltype(std::declval<ExpressionBody>().io_statement()),false>{});
            v(v, "left",visitor_tag<decltype(std::declval<ExpressionBody>().left()),false>{});
            v(v, "lowered_expr",visitor_tag<decltype(std::declval<ExpressionBody>().lowered_expr()),false>{});
            v(v, "member",visitor_tag<decltype(std::declval<ExpressionBody>().member()),false>{});
            v(v, "num_bytes",visitor_tag<decltype(std::declval<ExpressionBody>().num_bytes()),false>{});
            v(v, "operand",visitor_tag<decltype(std::declval<ExpressionBody>().operand()),false>{});
            v(v, "or_cond",visitor_tag<decltype(std::declval<ExpressionBody>().or_cond()),false>{});
            v(v, "right",visitor_tag<decltype(std::declval<ExpressionBody>().right()),false>{});
            v(v, "setter_status",visitor_tag<decltype(std::declval<ExpressionBody>().setter_status()),false>{});
            v(v, "source_expr",visitor_tag<decltype(std::declval<ExpressionBody>().source_expr()),false>{});
            v(v, "start",visitor_tag<decltype(std::declval<ExpressionBody>().start()),false>{});
            v(v, "stream_type",visitor_tag<decltype(std::declval<ExpressionBody>().stream_type()),false>{});
            v(v, "string_value",visitor_tag<decltype(std::declval<ExpressionBody>().string_value()),false>{});
            v(v, "sub_range",visitor_tag<decltype(std::declval<ExpressionBody>().sub_range()),false>{});
            v(v, "target_expr",visitor_tag<decltype(std::declval<ExpressionBody>().target_expr()),false>{});
            v(v, "target_stmt",visitor_tag<decltype(std::declval<ExpressionBody>().target_stmt()),false>{});
            v(v, "then",visitor_tag<decltype(std::declval<ExpressionBody>().then()),false>{});
            v(v, "type_ref",visitor_tag<decltype(std::declval<ExpressionBody>().type_ref()),false>{});
            v(v, "unit",visitor_tag<decltype(std::declval<ExpressionBody>().unit()),false>{});
            v(v, "uop",visitor_tag<decltype(std::declval<ExpressionBody>().uop()),false>{});
        }
    };
    struct EBM_API Expression{
        ExpressionRef id;
        ExpressionBody body;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "Expression";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "id",(*this).id);
            v(v, "body",(*this).body);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "id",(*this).id);
            v(v, "body",(*this).body);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "id",visitor_tag<decltype(std::declval<Expression>().id),false>{});
            v(v, "body",visitor_tag<decltype(std::declval<Expression>().body),false>{});
        }
    };
    struct EBM_API IfStatement{
        Condition condition;
        StatementRef then_block;
        StatementRef else_block;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "IfStatement";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "condition",(*this).condition);
            v(v, "then_block",(*this).then_block);
            v(v, "else_block",(*this).else_block);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "condition",(*this).condition);
            v(v, "then_block",(*this).then_block);
            v(v, "else_block",(*this).else_block);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "condition",visitor_tag<decltype(std::declval<IfStatement>().condition),false>{});
            v(v, "then_block",visitor_tag<decltype(std::declval<IfStatement>().then_block),false>{});
            v(v, "else_block",visitor_tag<decltype(std::declval<IfStatement>().else_block),false>{});
        }
    };
    struct EBM_API ParameterDecl{
        IdentifierRef name;
        TypeRef param_type;
        ::futils::binary::flags_t<std::uint8_t, 1, 7> flags_61_;
        bits_flag_alias_method(flags_61_,0,is_state_variable);
        bits_flag_alias_method(flags_61_,1,reserved);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "ParameterDecl";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "name",(*this).name);
            v(v, "param_type",(*this).param_type);
            v(v, "is_state_variable",(*this).is_state_variable());
            v(v, "reserved",(*this).reserved());
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "name",(*this).name);
            v(v, "param_type",(*this).param_type);
            v(v, "is_state_variable",(*this).is_state_variable());
            v(v, "reserved",(*this).reserved());
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "name",visitor_tag<decltype(std::declval<ParameterDecl>().name),false>{});
            v(v, "param_type",visitor_tag<decltype(std::declval<ParameterDecl>().param_type),false>{});
            v(v, "is_state_variable",visitor_tag<decltype(std::declval<ParameterDecl>().is_state_variable()),true>{});
            v(v, "reserved",visitor_tag<decltype(std::declval<ParameterDecl>().reserved()),true>{});
        }
    };
    struct EBM_API PropertyMemberDecl{
        ExpressionRef condition;
        StatementRef field;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "PropertyMemberDecl";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "condition",(*this).condition);
            v(v, "field",(*this).field);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "condition",(*this).condition);
            v(v, "field",(*this).field);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "condition",visitor_tag<decltype(std::declval<PropertyMemberDecl>().condition),false>{});
            v(v, "field",visitor_tag<decltype(std::declval<PropertyMemberDecl>().field),false>{});
        }
    };
    struct EBM_API Block{
        Varint len;
        std::vector<StatementRef> container;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "Block";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "len",(*this).len);
            v(v, "container",(*this).container);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "len",(*this).len);
            v(v, "container",(*this).container);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "len",visitor_tag<decltype(std::declval<Block>().len),false>{});
            v(v, "container",visitor_tag<decltype(std::declval<Block>().container),false>{});
        }
    };
    struct EBM_API CompositeFieldDecl{
        Block fields;
        TypeRef composite_type;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "CompositeFieldDecl";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "fields",(*this).fields);
            v(v, "composite_type",(*this).composite_type);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "fields",(*this).fields);
            v(v, "composite_type",(*this).composite_type);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "fields",visitor_tag<decltype(std::declval<CompositeFieldDecl>().fields),false>{});
            v(v, "composite_type",visitor_tag<decltype(std::declval<CompositeFieldDecl>().composite_type),false>{});
        }
    };
    struct EBM_API SubByteRange{
        StreamType stream_type{};
        SubByteRangeType range_type{};
        struct EBM_API union_struct_64{
            ExpressionRef length;
        };
        struct EBM_API union_struct_65{
            ExpressionRef offset;
            ExpressionRef length;
        };
        struct EBM_API union_struct_66{
            ExpressionRef expression;
        };
        std::variant<std::monostate, union_struct_64, union_struct_65, union_struct_66> union_variant_63;
        const ExpressionRef* expression() const;
        ExpressionRef* expression();
        bool expression(ExpressionRef&& v);
        bool expression(const ExpressionRef& v);
        const ExpressionRef* length() const;
        ExpressionRef* length();
        bool length(ExpressionRef&& v);
        bool length(const ExpressionRef& v);
        const ExpressionRef* offset() const;
        ExpressionRef* offset();
        bool offset(ExpressionRef&& v);
        bool offset(const ExpressionRef& v);
        StatementRef io_ref;
        StatementRef parent_io_ref;
        StatementRef io_statement;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 2;
        constexpr static const char* visitor_name = "SubByteRange";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "stream_type",(*this).stream_type);
            v(v, "range_type",(*this).range_type);
            v(v, "expression",(*this).expression());
            v(v, "length",(*this).length());
            v(v, "offset",(*this).offset());
            v(v, "io_ref",(*this).io_ref);
            v(v, "parent_io_ref",(*this).parent_io_ref);
            v(v, "io_statement",(*this).io_statement);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "stream_type",(*this).stream_type);
            v(v, "range_type",(*this).range_type);
            v(v, "expression",(*this).expression());
            v(v, "length",(*this).length());
            v(v, "offset",(*this).offset());
            v(v, "io_ref",(*this).io_ref);
            v(v, "parent_io_ref",(*this).parent_io_ref);
            v(v, "io_statement",(*this).io_statement);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "stream_type",visitor_tag<decltype(std::declval<SubByteRange>().stream_type),false>{});
            v(v, "range_type",visitor_tag<decltype(std::declval<SubByteRange>().range_type),false>{});
            v(v, "expression",visitor_tag<decltype(std::declval<SubByteRange>().expression()),false>{});
            v(v, "length",visitor_tag<decltype(std::declval<SubByteRange>().length()),false>{});
            v(v, "offset",visitor_tag<decltype(std::declval<SubByteRange>().offset()),false>{});
            v(v, "io_ref",visitor_tag<decltype(std::declval<SubByteRange>().io_ref),false>{});
            v(v, "parent_io_ref",visitor_tag<decltype(std::declval<SubByteRange>().parent_io_ref),false>{});
            v(v, "io_statement",visitor_tag<decltype(std::declval<SubByteRange>().io_statement),false>{});
        }
    };
    struct EBM_API Metadata{
        IdentifierRef name;
        Expressions values;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "Metadata";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "name",(*this).name);
            v(v, "values",(*this).values);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "name",(*this).name);
            v(v, "values",(*this).values);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "name",visitor_tag<decltype(std::declval<Metadata>().name),false>{});
            v(v, "values",visitor_tag<decltype(std::declval<Metadata>().values),false>{});
        }
    };
    struct EBM_API LoweredIOStatements{
        Varint len;
        std::vector<LoweredIOStatement> container;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "LoweredIOStatements";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "len",(*this).len);
            v(v, "container",(*this).container);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "len",(*this).len);
            v(v, "container",(*this).container);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "len",visitor_tag<decltype(std::declval<LoweredIOStatements>().len),false>{});
            v(v, "container",visitor_tag<decltype(std::declval<LoweredIOStatements>().container),false>{});
        }
    };
    struct EBM_API AssertDesc{
        Condition condition;
        LoweredStatementRef lowered_statement;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "AssertDesc";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "condition",(*this).condition);
            v(v, "lowered_statement",(*this).lowered_statement);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "condition",(*this).condition);
            v(v, "lowered_statement",(*this).lowered_statement);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "condition",visitor_tag<decltype(std::declval<AssertDesc>().condition),false>{});
            v(v, "lowered_statement",visitor_tag<decltype(std::declval<AssertDesc>().lowered_statement),false>{});
        }
    };
    struct EBM_API IOData{
        StatementRef io_ref;
        ExpressionRef target;
        TypeRef data_type;
        IOAttribute attribute;
        Size size;
        struct EBM_API union_struct_69{
            LoweredIOStatement lowered_statement;
        };
        std::variant<std::monostate, union_struct_69> union_variant_68;
        const LoweredIOStatement* lowered_statement() const;
        LoweredIOStatement* lowered_statement();
        bool lowered_statement(LoweredIOStatement&& v);
        bool lowered_statement(const LoweredIOStatement& v);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "IOData";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "io_ref",(*this).io_ref);
            v(v, "target",(*this).target);
            v(v, "data_type",(*this).data_type);
            v(v, "attribute",(*this).attribute);
            v(v, "size",(*this).size);
            v(v, "lowered_statement",(*this).lowered_statement());
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "io_ref",(*this).io_ref);
            v(v, "target",(*this).target);
            v(v, "data_type",(*this).data_type);
            v(v, "attribute",(*this).attribute);
            v(v, "size",(*this).size);
            v(v, "lowered_statement",(*this).lowered_statement());
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "io_ref",visitor_tag<decltype(std::declval<IOData>().io_ref),false>{});
            v(v, "target",visitor_tag<decltype(std::declval<IOData>().target),false>{});
            v(v, "data_type",visitor_tag<decltype(std::declval<IOData>().data_type),false>{});
            v(v, "attribute",visitor_tag<decltype(std::declval<IOData>().attribute),false>{});
            v(v, "size",visitor_tag<decltype(std::declval<IOData>().size),false>{});
            v(v, "lowered_statement",visitor_tag<decltype(std::declval<IOData>().lowered_statement()),false>{});
        }
    };
    struct EBM_API LoopStatement{
        LoopType loop_type{};
        struct EBM_API union_struct_72{
        };
        struct EBM_API union_struct_73{
            Condition condition;
        };
        struct EBM_API union_struct_74{
            StatementRef item_var;
            ExpressionRef collection;
        };
        struct EBM_API union_struct_75{
            StatementRef init;
            Condition condition;
            StatementRef increment;
        };
        std::variant<std::monostate, union_struct_72, union_struct_73, union_struct_74, union_struct_75> union_variant_71;
        const ExpressionRef* collection() const;
        ExpressionRef* collection();
        bool collection(ExpressionRef&& v);
        bool collection(const ExpressionRef& v);
        const Condition* condition() const;
        Condition* condition();
        bool condition(Condition&& v);
        bool condition(const Condition& v);
        const StatementRef* increment() const;
        StatementRef* increment();
        bool increment(StatementRef&& v);
        bool increment(const StatementRef& v);
        const StatementRef* init() const;
        StatementRef* init();
        bool init(StatementRef&& v);
        bool init(const StatementRef& v);
        const StatementRef* item_var() const;
        StatementRef* item_var();
        bool item_var(StatementRef&& v);
        bool item_var(const StatementRef& v);
        StatementRef body;
        LoweredStatementRef lowered_statement;
        LoweredStatementRef next_lowered_loop;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
        constexpr static const char* visitor_name = "LoopStatement";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "loop_type",(*this).loop_type);
            v(v, "collection",(*this).collection());
            v(v, "condition",(*this).condition());
            v(v, "increment",(*this).increment());
            v(v, "init",(*this).init());
            v(v, "item_var",(*this).item_var());
            v(v, "body",(*this).body);
            v(v, "lowered_statement",(*this).lowered_statement);
            v(v, "next_lowered_loop",(*this).next_lowered_loop);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "loop_type",(*this).loop_type);
            v(v, "collection",(*this).collection());
            v(v, "condition",(*this).condition());
            v(v, "increment",(*this).increment());
            v(v, "init",(*this).init());
            v(v, "item_var",(*this).item_var());
            v(v, "body",(*this).body);
            v(v, "lowered_statement",(*this).lowered_statement);
            v(v, "next_lowered_loop",(*this).next_lowered_loop);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "loop_type",visitor_tag<decltype(std::declval<LoopStatement>().loop_type),false>{});
            v(v, "collection",visitor_tag<decltype(std::declval<LoopStatement>().collection()),false>{});
            v(v, "condition",visitor_tag<decltype(std::declval<LoopStatement>().condition()),false>{});
            v(v, "increment",visitor_tag<decltype(std::declval<LoopStatement>().increment()),false>{});
            v(v, "init",visitor_tag<decltype(std::declval<LoopStatement>().init()),false>{});
            v(v, "item_var",visitor_tag<decltype(std::declval<LoopStatement>().item_var()),false>{});
            v(v, "body",visitor_tag<decltype(std::declval<LoopStatement>().body),false>{});
            v(v, "lowered_statement",visitor_tag<decltype(std::declval<LoopStatement>().lowered_statement),false>{});
            v(v, "next_lowered_loop",visitor_tag<decltype(std::declval<LoopStatement>().next_lowered_loop),false>{});
        }
    };
    struct EBM_API MatchStatement{
        ExpressionRef target;
        ::futils::binary::flags_t<std::uint8_t, 1, 7> flags_76_;
        bits_flag_alias_method(flags_76_,0,is_exhaustive);
        bits_flag_alias_method(flags_76_,1,reserved);
        Block branches;
        LoweredStatementRef lowered_if_statement;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "MatchStatement";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "target",(*this).target);
            v(v, "is_exhaustive",(*this).is_exhaustive());
            v(v, "reserved",(*this).reserved());
            v(v, "branches",(*this).branches);
            v(v, "lowered_if_statement",(*this).lowered_if_statement);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "target",(*this).target);
            v(v, "is_exhaustive",(*this).is_exhaustive());
            v(v, "reserved",(*this).reserved());
            v(v, "branches",(*this).branches);
            v(v, "lowered_if_statement",(*this).lowered_if_statement);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "target",visitor_tag<decltype(std::declval<MatchStatement>().target),false>{});
            v(v, "is_exhaustive",visitor_tag<decltype(std::declval<MatchStatement>().is_exhaustive()),true>{});
            v(v, "reserved",visitor_tag<decltype(std::declval<MatchStatement>().reserved()),true>{});
            v(v, "branches",visitor_tag<decltype(std::declval<MatchStatement>().branches),false>{});
            v(v, "lowered_if_statement",visitor_tag<decltype(std::declval<MatchStatement>().lowered_if_statement),false>{});
        }
    };
    struct EBM_API MatchBranch{
        Condition condition;
        StatementRef body;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "MatchBranch";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "condition",(*this).condition);
            v(v, "body",(*this).body);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "condition",(*this).condition);
            v(v, "body",(*this).body);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "condition",visitor_tag<decltype(std::declval<MatchBranch>().condition),false>{});
            v(v, "body",visitor_tag<decltype(std::declval<MatchBranch>().body),false>{});
        }
    };
    struct EBM_API FunctionDecl{
        IdentifierRef name;
        TypeRef return_type;
        Block params;
        StatementRef parent_format;
        FunctionKind kind{};
        StatementRef body;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "FunctionDecl";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "name",(*this).name);
            v(v, "return_type",(*this).return_type);
            v(v, "params",(*this).params);
            v(v, "parent_format",(*this).parent_format);
            v(v, "kind",(*this).kind);
            v(v, "body",(*this).body);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "name",(*this).name);
            v(v, "return_type",(*this).return_type);
            v(v, "params",(*this).params);
            v(v, "parent_format",(*this).parent_format);
            v(v, "kind",(*this).kind);
            v(v, "body",(*this).body);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "name",visitor_tag<decltype(std::declval<FunctionDecl>().name),false>{});
            v(v, "return_type",visitor_tag<decltype(std::declval<FunctionDecl>().return_type),false>{});
            v(v, "params",visitor_tag<decltype(std::declval<FunctionDecl>().params),false>{});
            v(v, "parent_format",visitor_tag<decltype(std::declval<FunctionDecl>().parent_format),false>{});
            v(v, "kind",visitor_tag<decltype(std::declval<FunctionDecl>().kind),false>{});
            v(v, "body",visitor_tag<decltype(std::declval<FunctionDecl>().body),false>{});
        }
    };
    struct EBM_API VariableDecl{
        IdentifierRef name;
        TypeRef var_type;
        ExpressionRef initial_value;
        ::futils::binary::flags_t<std::uint8_t, 2, 1, 5> flags_77_;
        bits_flag_alias_method_with_enum(flags_77_,0,decl_kind,VariableDeclKind);
        bits_flag_alias_method(flags_77_,1,is_reference);
        bits_flag_alias_method(flags_77_,2,reserved);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "VariableDecl";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "name",(*this).name);
            v(v, "var_type",(*this).var_type);
            v(v, "initial_value",(*this).initial_value);
            v(v, "decl_kind",(*this).decl_kind());
            v(v, "is_reference",(*this).is_reference());
            v(v, "reserved",(*this).reserved());
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "name",(*this).name);
            v(v, "var_type",(*this).var_type);
            v(v, "initial_value",(*this).initial_value);
            v(v, "decl_kind",(*this).decl_kind());
            v(v, "is_reference",(*this).is_reference());
            v(v, "reserved",(*this).reserved());
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "name",visitor_tag<decltype(std::declval<VariableDecl>().name),false>{});
            v(v, "var_type",visitor_tag<decltype(std::declval<VariableDecl>().var_type),false>{});
            v(v, "initial_value",visitor_tag<decltype(std::declval<VariableDecl>().initial_value),false>{});
            v(v, "decl_kind",visitor_tag<decltype(std::declval<VariableDecl>().decl_kind()),true>{});
            v(v, "is_reference",visitor_tag<decltype(std::declval<VariableDecl>().is_reference()),true>{});
            v(v, "reserved",visitor_tag<decltype(std::declval<VariableDecl>().reserved()),true>{});
        }
    };
    struct EBM_API FieldDecl{
        IdentifierRef name;
        TypeRef field_type;
        StatementRef parent_struct;
        ::futils::binary::flags_t<std::uint8_t, 1, 1, 6> flags_78_;
        bits_flag_alias_method(flags_78_,0,is_state_variable);
        bits_flag_alias_method(flags_78_,1,inner_composite);
        bits_flag_alias_method(flags_78_,2,reserved);
        struct EBM_API union_struct_81{
            StatementRef composite_field;
            LoweredStatementRef composite_getter;
            LoweredStatementRef composite_setter;
        };
        std::variant<std::monostate, union_struct_81> union_variant_80;
        const StatementRef* composite_field() const;
        StatementRef* composite_field();
        bool composite_field(StatementRef&& v);
        bool composite_field(const StatementRef& v);
        const LoweredStatementRef* composite_getter() const;
        LoweredStatementRef* composite_getter();
        bool composite_getter(LoweredStatementRef&& v);
        bool composite_getter(const LoweredStatementRef& v);
        const LoweredStatementRef* composite_setter() const;
        LoweredStatementRef* composite_setter();
        bool composite_setter(LoweredStatementRef&& v);
        bool composite_setter(const LoweredStatementRef& v);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "FieldDecl";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "name",(*this).name);
            v(v, "field_type",(*this).field_type);
            v(v, "parent_struct",(*this).parent_struct);
            v(v, "is_state_variable",(*this).is_state_variable());
            v(v, "inner_composite",(*this).inner_composite());
            v(v, "reserved",(*this).reserved());
            v(v, "composite_field",(*this).composite_field());
            v(v, "composite_getter",(*this).composite_getter());
            v(v, "composite_setter",(*this).composite_setter());
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "name",(*this).name);
            v(v, "field_type",(*this).field_type);
            v(v, "parent_struct",(*this).parent_struct);
            v(v, "is_state_variable",(*this).is_state_variable());
            v(v, "inner_composite",(*this).inner_composite());
            v(v, "reserved",(*this).reserved());
            v(v, "composite_field",(*this).composite_field());
            v(v, "composite_getter",(*this).composite_getter());
            v(v, "composite_setter",(*this).composite_setter());
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "name",visitor_tag<decltype(std::declval<FieldDecl>().name),false>{});
            v(v, "field_type",visitor_tag<decltype(std::declval<FieldDecl>().field_type),false>{});
            v(v, "parent_struct",visitor_tag<decltype(std::declval<FieldDecl>().parent_struct),false>{});
            v(v, "is_state_variable",visitor_tag<decltype(std::declval<FieldDecl>().is_state_variable()),true>{});
            v(v, "inner_composite",visitor_tag<decltype(std::declval<FieldDecl>().inner_composite()),true>{});
            v(v, "reserved",visitor_tag<decltype(std::declval<FieldDecl>().reserved()),true>{});
            v(v, "composite_field",visitor_tag<decltype(std::declval<FieldDecl>().composite_field()),false>{});
            v(v, "composite_getter",visitor_tag<decltype(std::declval<FieldDecl>().composite_getter()),false>{});
            v(v, "composite_setter",visitor_tag<decltype(std::declval<FieldDecl>().composite_setter()),false>{});
        }
    };
    struct EBM_API EnumDecl{
        IdentifierRef name;
        TypeRef base_type;
        Block members;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "EnumDecl";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "name",(*this).name);
            v(v, "base_type",(*this).base_type);
            v(v, "members",(*this).members);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "name",(*this).name);
            v(v, "base_type",(*this).base_type);
            v(v, "members",(*this).members);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "name",visitor_tag<decltype(std::declval<EnumDecl>().name),false>{});
            v(v, "base_type",visitor_tag<decltype(std::declval<EnumDecl>().base_type),false>{});
            v(v, "members",visitor_tag<decltype(std::declval<EnumDecl>().members),false>{});
        }
    };
    struct EBM_API EnumMemberDecl{
        IdentifierRef name;
        StatementRef enum_decl;
        ExpressionRef value;
        StringRef string_repr;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "EnumMemberDecl";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "name",(*this).name);
            v(v, "enum_decl",(*this).enum_decl);
            v(v, "value",(*this).value);
            v(v, "string_repr",(*this).string_repr);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "name",(*this).name);
            v(v, "enum_decl",(*this).enum_decl);
            v(v, "value",(*this).value);
            v(v, "string_repr",(*this).string_repr);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "name",visitor_tag<decltype(std::declval<EnumMemberDecl>().name),false>{});
            v(v, "enum_decl",visitor_tag<decltype(std::declval<EnumMemberDecl>().enum_decl),false>{});
            v(v, "value",visitor_tag<decltype(std::declval<EnumMemberDecl>().value),false>{});
            v(v, "string_repr",visitor_tag<decltype(std::declval<EnumMemberDecl>().string_repr),false>{});
        }
    };
    struct EBM_API StructDecl{
        IdentifierRef name;
        Block fields;
        ::futils::binary::flags_t<std::uint8_t, 1, 1, 1, 1, 1, 3> flags_82_;
        bits_flag_alias_method(flags_82_,0,is_recursive);
        bits_flag_alias_method(flags_82_,1,is_fixed_size);
        bits_flag_alias_method(flags_82_,2,has_related_variant);
        bits_flag_alias_method(flags_82_,3,has_encode_decode);
        bits_flag_alias_method(flags_82_,4,has_functions);
        bits_flag_alias_method(flags_82_,5,reserved);
        struct EBM_API union_struct_85{
            TypeRef related_variant;
        };
        std::variant<std::monostate, union_struct_85> union_variant_84;
        const TypeRef* related_variant() const;
        TypeRef* related_variant();
        bool related_variant(TypeRef&& v);
        bool related_variant(const TypeRef& v);
        struct EBM_API union_struct_88{
            Size size;
        };
        std::variant<std::monostate, union_struct_88> union_variant_87;
        const Size* size() const;
        Size* size();
        bool size(Size&& v);
        bool size(const Size& v);
        struct EBM_API union_struct_91{
            StatementRef encode_fn;
            StatementRef decode_fn;
        };
        std::variant<std::monostate, union_struct_91> union_variant_90;
        const StatementRef* decode_fn() const;
        StatementRef* decode_fn();
        bool decode_fn(StatementRef&& v);
        bool decode_fn(const StatementRef& v);
        const StatementRef* encode_fn() const;
        StatementRef* encode_fn();
        bool encode_fn(StatementRef&& v);
        bool encode_fn(const StatementRef& v);
        struct EBM_API union_struct_94{
            Block methods;
        };
        std::variant<std::monostate, union_struct_94> union_variant_93;
        const Block* methods() const;
        Block* methods();
        bool methods(Block&& v);
        bool methods(const Block& v);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "StructDecl";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "name",(*this).name);
            v(v, "fields",(*this).fields);
            v(v, "is_recursive",(*this).is_recursive());
            v(v, "is_fixed_size",(*this).is_fixed_size());
            v(v, "has_related_variant",(*this).has_related_variant());
            v(v, "has_encode_decode",(*this).has_encode_decode());
            v(v, "has_functions",(*this).has_functions());
            v(v, "reserved",(*this).reserved());
            v(v, "related_variant",(*this).related_variant());
            v(v, "size",(*this).size());
            v(v, "decode_fn",(*this).decode_fn());
            v(v, "encode_fn",(*this).encode_fn());
            v(v, "methods",(*this).methods());
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "name",(*this).name);
            v(v, "fields",(*this).fields);
            v(v, "is_recursive",(*this).is_recursive());
            v(v, "is_fixed_size",(*this).is_fixed_size());
            v(v, "has_related_variant",(*this).has_related_variant());
            v(v, "has_encode_decode",(*this).has_encode_decode());
            v(v, "has_functions",(*this).has_functions());
            v(v, "reserved",(*this).reserved());
            v(v, "related_variant",(*this).related_variant());
            v(v, "size",(*this).size());
            v(v, "decode_fn",(*this).decode_fn());
            v(v, "encode_fn",(*this).encode_fn());
            v(v, "methods",(*this).methods());
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "name",visitor_tag<decltype(std::declval<StructDecl>().name),false>{});
            v(v, "fields",visitor_tag<decltype(std::declval<StructDecl>().fields),false>{});
            v(v, "is_recursive",visitor_tag<decltype(std::declval<StructDecl>().is_recursive()),true>{});
            v(v, "is_fixed_size",visitor_tag<decltype(std::declval<StructDecl>().is_fixed_size()),true>{});
            v(v, "has_related_variant",visitor_tag<decltype(std::declval<StructDecl>().has_related_variant()),true>{});
            v(v, "has_encode_decode",visitor_tag<decltype(std::declval<StructDecl>().has_encode_decode()),true>{});
            v(v, "has_functions",visitor_tag<decltype(std::declval<StructDecl>().has_functions()),true>{});
            v(v, "reserved",visitor_tag<decltype(std::declval<StructDecl>().reserved()),true>{});
            v(v, "related_variant",visitor_tag<decltype(std::declval<StructDecl>().related_variant()),false>{});
            v(v, "size",visitor_tag<decltype(std::declval<StructDecl>().size()),false>{});
            v(v, "decode_fn",visitor_tag<decltype(std::declval<StructDecl>().decode_fn()),false>{});
            v(v, "encode_fn",visitor_tag<decltype(std::declval<StructDecl>().encode_fn()),false>{});
            v(v, "methods",visitor_tag<decltype(std::declval<StructDecl>().methods()),false>{});
        }
    };
    struct EBM_API PropertyDecl{
        IdentifierRef name;
        StatementRef parent_format;
        TypeRef property_type;
        MergeMode merge_mode{};
        ExpressionRef cond;
        Block members;
        LoweredStatementRef setter_function;
        LoweredStatementRef getter_function;
        struct EBM_API union_struct_97{
            Block derived_from;
        };
        std::variant<std::monostate, union_struct_97> union_variant_96;
        const Block* derived_from() const;
        Block* derived_from();
        bool derived_from(Block&& v);
        bool derived_from(const Block& v);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "PropertyDecl";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "name",(*this).name);
            v(v, "parent_format",(*this).parent_format);
            v(v, "property_type",(*this).property_type);
            v(v, "merge_mode",(*this).merge_mode);
            v(v, "cond",(*this).cond);
            v(v, "members",(*this).members);
            v(v, "setter_function",(*this).setter_function);
            v(v, "getter_function",(*this).getter_function);
            v(v, "derived_from",(*this).derived_from());
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "name",(*this).name);
            v(v, "parent_format",(*this).parent_format);
            v(v, "property_type",(*this).property_type);
            v(v, "merge_mode",(*this).merge_mode);
            v(v, "cond",(*this).cond);
            v(v, "members",(*this).members);
            v(v, "setter_function",(*this).setter_function);
            v(v, "getter_function",(*this).getter_function);
            v(v, "derived_from",(*this).derived_from());
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "name",visitor_tag<decltype(std::declval<PropertyDecl>().name),false>{});
            v(v, "parent_format",visitor_tag<decltype(std::declval<PropertyDecl>().parent_format),false>{});
            v(v, "property_type",visitor_tag<decltype(std::declval<PropertyDecl>().property_type),false>{});
            v(v, "merge_mode",visitor_tag<decltype(std::declval<PropertyDecl>().merge_mode),false>{});
            v(v, "cond",visitor_tag<decltype(std::declval<PropertyDecl>().cond),false>{});
            v(v, "members",visitor_tag<decltype(std::declval<PropertyDecl>().members),false>{});
            v(v, "setter_function",visitor_tag<decltype(std::declval<PropertyDecl>().setter_function),false>{});
            v(v, "getter_function",visitor_tag<decltype(std::declval<PropertyDecl>().getter_function),false>{});
            v(v, "derived_from",visitor_tag<decltype(std::declval<PropertyDecl>().derived_from()),false>{});
        }
    };
    struct EBM_API ImportDecl{
        IdentifierRef name;
        StringRef path;
        StatementRef program;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "ImportDecl";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "name",(*this).name);
            v(v, "path",(*this).path);
            v(v, "program",(*this).program);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "name",(*this).name);
            v(v, "path",(*this).path);
            v(v, "program",(*this).program);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "name",visitor_tag<decltype(std::declval<ImportDecl>().name),false>{});
            v(v, "path",visitor_tag<decltype(std::declval<ImportDecl>().path),false>{});
            v(v, "program",visitor_tag<decltype(std::declval<ImportDecl>().program),false>{});
        }
    };
    struct EBM_API ErrorReport{
        StringRef message;
        Expressions arguments;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "ErrorReport";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "message",(*this).message);
            v(v, "arguments",(*this).arguments);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "message",(*this).message);
            v(v, "arguments",(*this).arguments);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "message",visitor_tag<decltype(std::declval<ErrorReport>().message),false>{});
            v(v, "arguments",visitor_tag<decltype(std::declval<ErrorReport>().arguments),false>{});
        }
    };
    struct EBM_API StatementBody{
        StatementKind kind{};
        struct EBM_API union_struct_100{
            Block block;
        };
        struct EBM_API union_struct_101{
            ExpressionRef target;
            ExpressionRef value;
            StatementRef previous_assignment;
        };
        struct EBM_API union_struct_102{
            ExpressionRef target;
            ExpressionRef value;
            StatementRef previous_assignment;
        };
        struct EBM_API union_struct_103{
            ExpressionRef target;
            ExpressionRef value;
        };
        struct EBM_API union_struct_104{
            ExpressionRef value;
        };
        struct EBM_API union_struct_105{
            ExpressionRef value;
        };
        struct EBM_API union_struct_106{
            AssertDesc assert_desc;
        };
        struct EBM_API union_struct_107{
            IOData read_data;
        };
        struct EBM_API union_struct_108{
            IOData write_data;
        };
        struct EBM_API union_struct_109{
            IfStatement if_statement;
        };
        struct EBM_API union_struct_110{
            LoopStatement loop;
        };
        struct EBM_API union_struct_111{
            MatchStatement match_statement;
        };
        struct EBM_API union_struct_112{
            MatchBranch match_branch;
        };
        struct EBM_API union_struct_113{
            LoopFlowControl break_;
        };
        struct EBM_API union_struct_114{
            LoopFlowControl continue_;
        };
        struct EBM_API union_struct_115{
            FunctionDecl func_decl;
        };
        struct EBM_API union_struct_116{
            VariableDecl var_decl;
        };
        struct EBM_API union_struct_117{
            ParameterDecl param_decl;
        };
        struct EBM_API union_struct_118{
            FieldDecl field_decl;
        };
        struct EBM_API union_struct_119{
            CompositeFieldDecl composite_field_decl;
        };
        struct EBM_API union_struct_120{
            EnumDecl enum_decl;
        };
        struct EBM_API union_struct_121{
            EnumMemberDecl enum_member_decl;
        };
        struct EBM_API union_struct_122{
            StructDecl struct_decl;
        };
        struct EBM_API union_struct_123{
            Block block;
        };
        struct EBM_API union_struct_124{
            PropertyDecl property_decl;
        };
        struct EBM_API union_struct_125{
            PropertyMemberDecl property_member_decl;
        };
        struct EBM_API union_struct_126{
            Metadata metadata;
        };
        struct EBM_API union_struct_127{
            ImportDecl import_decl;
        };
        struct EBM_API union_struct_128{
            ErrorReport error_report;
        };
        struct EBM_API union_struct_129{
            ExpressionRef expression;
        };
        struct EBM_API union_struct_130{
            SubByteRange sub_byte_range;
        };
        struct EBM_API union_struct_131{
            InitCheck init_check;
        };
        struct EBM_API union_struct_132{
            EndianVariable endian_variable;
        };
        struct EBM_API union_struct_133{
            LoweredIOStatements lowered_io_statements;
        };
        std::variant<std::monostate, union_struct_100, union_struct_101, union_struct_102, union_struct_103, union_struct_104, union_struct_105, union_struct_106, union_struct_107, union_struct_108, union_struct_109, union_struct_110, union_struct_111, union_struct_112, union_struct_113, union_struct_114, union_struct_115, union_struct_116, union_struct_117, union_struct_118, union_struct_119, union_struct_120, union_struct_121, union_struct_122, union_struct_123, union_struct_124, union_struct_125, union_struct_126, union_struct_127, union_struct_128, union_struct_129, union_struct_130, union_struct_131, union_struct_132, union_struct_133> union_variant_99;
        const AssertDesc* assert_desc() const;
        AssertDesc* assert_desc();
        bool assert_desc(AssertDesc&& v);
        bool assert_desc(const AssertDesc& v);
        const Block* block() const;
        Block* block();
        bool block(Block&& v);
        bool block(const Block& v);
        const LoopFlowControl* break_() const;
        LoopFlowControl* break_();
        bool break_(LoopFlowControl&& v);
        bool break_(const LoopFlowControl& v);
        const CompositeFieldDecl* composite_field_decl() const;
        CompositeFieldDecl* composite_field_decl();
        bool composite_field_decl(CompositeFieldDecl&& v);
        bool composite_field_decl(const CompositeFieldDecl& v);
        const LoopFlowControl* continue_() const;
        LoopFlowControl* continue_();
        bool continue_(LoopFlowControl&& v);
        bool continue_(const LoopFlowControl& v);
        const EndianVariable* endian_variable() const;
        EndianVariable* endian_variable();
        bool endian_variable(EndianVariable&& v);
        bool endian_variable(const EndianVariable& v);
        const EnumDecl* enum_decl() const;
        EnumDecl* enum_decl();
        bool enum_decl(EnumDecl&& v);
        bool enum_decl(const EnumDecl& v);
        const EnumMemberDecl* enum_member_decl() const;
        EnumMemberDecl* enum_member_decl();
        bool enum_member_decl(EnumMemberDecl&& v);
        bool enum_member_decl(const EnumMemberDecl& v);
        const ErrorReport* error_report() const;
        ErrorReport* error_report();
        bool error_report(ErrorReport&& v);
        bool error_report(const ErrorReport& v);
        const ExpressionRef* expression() const;
        ExpressionRef* expression();
        bool expression(ExpressionRef&& v);
        bool expression(const ExpressionRef& v);
        const FieldDecl* field_decl() const;
        FieldDecl* field_decl();
        bool field_decl(FieldDecl&& v);
        bool field_decl(const FieldDecl& v);
        const FunctionDecl* func_decl() const;
        FunctionDecl* func_decl();
        bool func_decl(FunctionDecl&& v);
        bool func_decl(const FunctionDecl& v);
        const IfStatement* if_statement() const;
        IfStatement* if_statement();
        bool if_statement(IfStatement&& v);
        bool if_statement(const IfStatement& v);
        const ImportDecl* import_decl() const;
        ImportDecl* import_decl();
        bool import_decl(ImportDecl&& v);
        bool import_decl(const ImportDecl& v);
        const InitCheck* init_check() const;
        InitCheck* init_check();
        bool init_check(InitCheck&& v);
        bool init_check(const InitCheck& v);
        const LoopStatement* loop() const;
        LoopStatement* loop();
        bool loop(LoopStatement&& v);
        bool loop(const LoopStatement& v);
        const LoweredIOStatements* lowered_io_statements() const;
        LoweredIOStatements* lowered_io_statements();
        bool lowered_io_statements(LoweredIOStatements&& v);
        bool lowered_io_statements(const LoweredIOStatements& v);
        const MatchBranch* match_branch() const;
        MatchBranch* match_branch();
        bool match_branch(MatchBranch&& v);
        bool match_branch(const MatchBranch& v);
        const MatchStatement* match_statement() const;
        MatchStatement* match_statement();
        bool match_statement(MatchStatement&& v);
        bool match_statement(const MatchStatement& v);
        const Metadata* metadata() const;
        Metadata* metadata();
        bool metadata(Metadata&& v);
        bool metadata(const Metadata& v);
        const ParameterDecl* param_decl() const;
        ParameterDecl* param_decl();
        bool param_decl(ParameterDecl&& v);
        bool param_decl(const ParameterDecl& v);
        const StatementRef* previous_assignment() const;
        StatementRef* previous_assignment();
        bool previous_assignment(StatementRef&& v);
        bool previous_assignment(const StatementRef& v);
        const PropertyDecl* property_decl() const;
        PropertyDecl* property_decl();
        bool property_decl(PropertyDecl&& v);
        bool property_decl(const PropertyDecl& v);
        const PropertyMemberDecl* property_member_decl() const;
        PropertyMemberDecl* property_member_decl();
        bool property_member_decl(PropertyMemberDecl&& v);
        bool property_member_decl(const PropertyMemberDecl& v);
        const IOData* read_data() const;
        IOData* read_data();
        bool read_data(IOData&& v);
        bool read_data(const IOData& v);
        const StructDecl* struct_decl() const;
        StructDecl* struct_decl();
        bool struct_decl(StructDecl&& v);
        bool struct_decl(const StructDecl& v);
        const SubByteRange* sub_byte_range() const;
        SubByteRange* sub_byte_range();
        bool sub_byte_range(SubByteRange&& v);
        bool sub_byte_range(const SubByteRange& v);
        const ExpressionRef* target() const;
        ExpressionRef* target();
        bool target(ExpressionRef&& v);
        bool target(const ExpressionRef& v);
        const ExpressionRef* value() const;
        ExpressionRef* value();
        bool value(ExpressionRef&& v);
        bool value(const ExpressionRef& v);
        const VariableDecl* var_decl() const;
        VariableDecl* var_decl();
        bool var_decl(VariableDecl&& v);
        bool var_decl(const VariableDecl& v);
        const IOData* write_data() const;
        IOData* write_data();
        bool write_data(IOData&& v);
        bool write_data(const IOData& v);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
        constexpr static const char* visitor_name = "StatementBody";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "kind",(*this).kind);
            v(v, "assert_desc",(*this).assert_desc());
            v(v, "block",(*this).block());
            v(v, "break_",(*this).break_());
            v(v, "composite_field_decl",(*this).composite_field_decl());
            v(v, "continue_",(*this).continue_());
            v(v, "endian_variable",(*this).endian_variable());
            v(v, "enum_decl",(*this).enum_decl());
            v(v, "enum_member_decl",(*this).enum_member_decl());
            v(v, "error_report",(*this).error_report());
            v(v, "expression",(*this).expression());
            v(v, "field_decl",(*this).field_decl());
            v(v, "func_decl",(*this).func_decl());
            v(v, "if_statement",(*this).if_statement());
            v(v, "import_decl",(*this).import_decl());
            v(v, "init_check",(*this).init_check());
            v(v, "loop",(*this).loop());
            v(v, "lowered_io_statements",(*this).lowered_io_statements());
            v(v, "match_branch",(*this).match_branch());
            v(v, "match_statement",(*this).match_statement());
            v(v, "metadata",(*this).metadata());
            v(v, "param_decl",(*this).param_decl());
            v(v, "previous_assignment",(*this).previous_assignment());
            v(v, "property_decl",(*this).property_decl());
            v(v, "property_member_decl",(*this).property_member_decl());
            v(v, "read_data",(*this).read_data());
            v(v, "struct_decl",(*this).struct_decl());
            v(v, "sub_byte_range",(*this).sub_byte_range());
            v(v, "target",(*this).target());
            v(v, "value",(*this).value());
            v(v, "var_decl",(*this).var_decl());
            v(v, "write_data",(*this).write_data());
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "kind",(*this).kind);
            v(v, "assert_desc",(*this).assert_desc());
            v(v, "block",(*this).block());
            v(v, "break_",(*this).break_());
            v(v, "composite_field_decl",(*this).composite_field_decl());
            v(v, "continue_",(*this).continue_());
            v(v, "endian_variable",(*this).endian_variable());
            v(v, "enum_decl",(*this).enum_decl());
            v(v, "enum_member_decl",(*this).enum_member_decl());
            v(v, "error_report",(*this).error_report());
            v(v, "expression",(*this).expression());
            v(v, "field_decl",(*this).field_decl());
            v(v, "func_decl",(*this).func_decl());
            v(v, "if_statement",(*this).if_statement());
            v(v, "import_decl",(*this).import_decl());
            v(v, "init_check",(*this).init_check());
            v(v, "loop",(*this).loop());
            v(v, "lowered_io_statements",(*this).lowered_io_statements());
            v(v, "match_branch",(*this).match_branch());
            v(v, "match_statement",(*this).match_statement());
            v(v, "metadata",(*this).metadata());
            v(v, "param_decl",(*this).param_decl());
            v(v, "previous_assignment",(*this).previous_assignment());
            v(v, "property_decl",(*this).property_decl());
            v(v, "property_member_decl",(*this).property_member_decl());
            v(v, "read_data",(*this).read_data());
            v(v, "struct_decl",(*this).struct_decl());
            v(v, "sub_byte_range",(*this).sub_byte_range());
            v(v, "target",(*this).target());
            v(v, "value",(*this).value());
            v(v, "var_decl",(*this).var_decl());
            v(v, "write_data",(*this).write_data());
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "kind",visitor_tag<decltype(std::declval<StatementBody>().kind),false>{});
            v(v, "assert_desc",visitor_tag<decltype(std::declval<StatementBody>().assert_desc()),false>{});
            v(v, "block",visitor_tag<decltype(std::declval<StatementBody>().block()),false>{});
            v(v, "break_",visitor_tag<decltype(std::declval<StatementBody>().break_()),false>{});
            v(v, "composite_field_decl",visitor_tag<decltype(std::declval<StatementBody>().composite_field_decl()),false>{});
            v(v, "continue_",visitor_tag<decltype(std::declval<StatementBody>().continue_()),false>{});
            v(v, "endian_variable",visitor_tag<decltype(std::declval<StatementBody>().endian_variable()),false>{});
            v(v, "enum_decl",visitor_tag<decltype(std::declval<StatementBody>().enum_decl()),false>{});
            v(v, "enum_member_decl",visitor_tag<decltype(std::declval<StatementBody>().enum_member_decl()),false>{});
            v(v, "error_report",visitor_tag<decltype(std::declval<StatementBody>().error_report()),false>{});
            v(v, "expression",visitor_tag<decltype(std::declval<StatementBody>().expression()),false>{});
            v(v, "field_decl",visitor_tag<decltype(std::declval<StatementBody>().field_decl()),false>{});
            v(v, "func_decl",visitor_tag<decltype(std::declval<StatementBody>().func_decl()),false>{});
            v(v, "if_statement",visitor_tag<decltype(std::declval<StatementBody>().if_statement()),false>{});
            v(v, "import_decl",visitor_tag<decltype(std::declval<StatementBody>().import_decl()),false>{});
            v(v, "init_check",visitor_tag<decltype(std::declval<StatementBody>().init_check()),false>{});
            v(v, "loop",visitor_tag<decltype(std::declval<StatementBody>().loop()),false>{});
            v(v, "lowered_io_statements",visitor_tag<decltype(std::declval<StatementBody>().lowered_io_statements()),false>{});
            v(v, "match_branch",visitor_tag<decltype(std::declval<StatementBody>().match_branch()),false>{});
            v(v, "match_statement",visitor_tag<decltype(std::declval<StatementBody>().match_statement()),false>{});
            v(v, "metadata",visitor_tag<decltype(std::declval<StatementBody>().metadata()),false>{});
            v(v, "param_decl",visitor_tag<decltype(std::declval<StatementBody>().param_decl()),false>{});
            v(v, "previous_assignment",visitor_tag<decltype(std::declval<StatementBody>().previous_assignment()),false>{});
            v(v, "property_decl",visitor_tag<decltype(std::declval<StatementBody>().property_decl()),false>{});
            v(v, "property_member_decl",visitor_tag<decltype(std::declval<StatementBody>().property_member_decl()),false>{});
            v(v, "read_data",visitor_tag<decltype(std::declval<StatementBody>().read_data()),false>{});
            v(v, "struct_decl",visitor_tag<decltype(std::declval<StatementBody>().struct_decl()),false>{});
            v(v, "sub_byte_range",visitor_tag<decltype(std::declval<StatementBody>().sub_byte_range()),false>{});
            v(v, "target",visitor_tag<decltype(std::declval<StatementBody>().target()),false>{});
            v(v, "value",visitor_tag<decltype(std::declval<StatementBody>().value()),false>{});
            v(v, "var_decl",visitor_tag<decltype(std::declval<StatementBody>().var_decl()),false>{});
            v(v, "write_data",visitor_tag<decltype(std::declval<StatementBody>().write_data()),false>{});
        }
    };
    struct EBM_API Statement{
        StatementRef id;
        StatementBody body;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "Statement";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "id",(*this).id);
            v(v, "body",(*this).body);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "id",(*this).id);
            v(v, "body",(*this).body);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "id",visitor_tag<decltype(std::declval<Statement>().id),false>{});
            v(v, "body",visitor_tag<decltype(std::declval<Statement>().body),false>{});
        }
    };
    struct EBM_API Types{
        Varint len;
        std::vector<TypeRef> container;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "Types";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "len",(*this).len);
            v(v, "container",(*this).container);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "len",(*this).len);
            v(v, "container",(*this).container);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "len",visitor_tag<decltype(std::declval<Types>().len),false>{});
            v(v, "container",visitor_tag<decltype(std::declval<Types>().container),false>{});
        }
    };
    struct EBM_API TypeBody{
        TypeKind kind{};
        struct EBM_API union_struct_136{
            Varint size;
        };
        struct EBM_API union_struct_137{
            Varint size;
        };
        struct EBM_API union_struct_138{
            Varint size;
        };
        struct EBM_API union_struct_139{
        };
        struct EBM_API union_struct_140{
            TypeRef element_type;
            Varint length;
        };
        struct EBM_API union_struct_141{
            TypeRef element_type;
        };
        struct EBM_API union_struct_142{
            StatementRef id;
        };
        struct EBM_API union_struct_143{
            StatementRef id;
        };
        struct EBM_API union_struct_144{
            StatementRef id;
            TypeRef base_type;
        };
        struct EBM_API union_struct_145{
            TypeRef common_type;
            Types members;
            StatementRef related_field;
        };
        struct EBM_API union_struct_146{
            TypeRef inner_type;
        };
        struct EBM_API union_struct_147{
            TypeRef pointee_type;
        };
        struct EBM_API union_struct_148{
            TypeRef base_type;
        };
        struct EBM_API union_struct_149{
            TypeRef return_type;
            Types params;
        };
        std::variant<std::monostate, union_struct_136, union_struct_137, union_struct_138, union_struct_139, union_struct_140, union_struct_141, union_struct_142, union_struct_143, union_struct_144, union_struct_145, union_struct_146, union_struct_147, union_struct_148, union_struct_149> union_variant_135;
        const TypeRef* base_type() const;
        TypeRef* base_type();
        bool base_type(TypeRef&& v);
        bool base_type(const TypeRef& v);
        const TypeRef* common_type() const;
        TypeRef* common_type();
        bool common_type(TypeRef&& v);
        bool common_type(const TypeRef& v);
        const TypeRef* element_type() const;
        TypeRef* element_type();
        bool element_type(TypeRef&& v);
        bool element_type(const TypeRef& v);
        const StatementRef* id() const;
        StatementRef* id();
        bool id(StatementRef&& v);
        bool id(const StatementRef& v);
        const TypeRef* inner_type() const;
        TypeRef* inner_type();
        bool inner_type(TypeRef&& v);
        bool inner_type(const TypeRef& v);
        const Varint* length() const;
        Varint* length();
        bool length(Varint&& v);
        bool length(const Varint& v);
        const Types* members() const;
        Types* members();
        bool members(Types&& v);
        bool members(const Types& v);
        const Types* params() const;
        Types* params();
        bool params(Types&& v);
        bool params(const Types& v);
        const TypeRef* pointee_type() const;
        TypeRef* pointee_type();
        bool pointee_type(TypeRef&& v);
        bool pointee_type(const TypeRef& v);
        const StatementRef* related_field() const;
        StatementRef* related_field();
        bool related_field(StatementRef&& v);
        bool related_field(const StatementRef& v);
        const TypeRef* return_type() const;
        TypeRef* return_type();
        bool return_type(TypeRef&& v);
        bool return_type(const TypeRef& v);
        const Varint* size() const;
        Varint* size();
        bool size(Varint&& v);
        bool size(const Varint& v);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
        constexpr static const char* visitor_name = "TypeBody";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "kind",(*this).kind);
            v(v, "base_type",(*this).base_type());
            v(v, "common_type",(*this).common_type());
            v(v, "element_type",(*this).element_type());
            v(v, "id",(*this).id());
            v(v, "inner_type",(*this).inner_type());
            v(v, "length",(*this).length());
            v(v, "members",(*this).members());
            v(v, "params",(*this).params());
            v(v, "pointee_type",(*this).pointee_type());
            v(v, "related_field",(*this).related_field());
            v(v, "return_type",(*this).return_type());
            v(v, "size",(*this).size());
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "kind",(*this).kind);
            v(v, "base_type",(*this).base_type());
            v(v, "common_type",(*this).common_type());
            v(v, "element_type",(*this).element_type());
            v(v, "id",(*this).id());
            v(v, "inner_type",(*this).inner_type());
            v(v, "length",(*this).length());
            v(v, "members",(*this).members());
            v(v, "params",(*this).params());
            v(v, "pointee_type",(*this).pointee_type());
            v(v, "related_field",(*this).related_field());
            v(v, "return_type",(*this).return_type());
            v(v, "size",(*this).size());
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "kind",visitor_tag<decltype(std::declval<TypeBody>().kind),false>{});
            v(v, "base_type",visitor_tag<decltype(std::declval<TypeBody>().base_type()),false>{});
            v(v, "common_type",visitor_tag<decltype(std::declval<TypeBody>().common_type()),false>{});
            v(v, "element_type",visitor_tag<decltype(std::declval<TypeBody>().element_type()),false>{});
            v(v, "id",visitor_tag<decltype(std::declval<TypeBody>().id()),false>{});
            v(v, "inner_type",visitor_tag<decltype(std::declval<TypeBody>().inner_type()),false>{});
            v(v, "length",visitor_tag<decltype(std::declval<TypeBody>().length()),false>{});
            v(v, "members",visitor_tag<decltype(std::declval<TypeBody>().members()),false>{});
            v(v, "params",visitor_tag<decltype(std::declval<TypeBody>().params()),false>{});
            v(v, "pointee_type",visitor_tag<decltype(std::declval<TypeBody>().pointee_type()),false>{});
            v(v, "related_field",visitor_tag<decltype(std::declval<TypeBody>().related_field()),false>{});
            v(v, "return_type",visitor_tag<decltype(std::declval<TypeBody>().return_type()),false>{});
            v(v, "size",visitor_tag<decltype(std::declval<TypeBody>().size()),false>{});
        }
    };
    struct EBM_API Type{
        TypeRef id;
        TypeBody body;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "Type";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "id",(*this).id);
            v(v, "body",(*this).body);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "id",(*this).id);
            v(v, "body",(*this).body);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "id",visitor_tag<decltype(std::declval<Type>().id),false>{});
            v(v, "body",visitor_tag<decltype(std::declval<Type>().body),false>{});
        }
    };
    struct EBM_API Loc{
        AnyRef ident;
        Varint file_id;
        Varint line;
        Varint column;
        Varint start;
        Varint end;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "Loc";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "ident",(*this).ident);
            v(v, "file_id",(*this).file_id);
            v(v, "line",(*this).line);
            v(v, "column",(*this).column);
            v(v, "start",(*this).start);
            v(v, "end",(*this).end);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "ident",(*this).ident);
            v(v, "file_id",(*this).file_id);
            v(v, "line",(*this).line);
            v(v, "column",(*this).column);
            v(v, "start",(*this).start);
            v(v, "end",(*this).end);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "ident",visitor_tag<decltype(std::declval<Loc>().ident),false>{});
            v(v, "file_id",visitor_tag<decltype(std::declval<Loc>().file_id),false>{});
            v(v, "line",visitor_tag<decltype(std::declval<Loc>().line),false>{});
            v(v, "column",visitor_tag<decltype(std::declval<Loc>().column),false>{});
            v(v, "start",visitor_tag<decltype(std::declval<Loc>().start),false>{});
            v(v, "end",visitor_tag<decltype(std::declval<Loc>().end),false>{});
        }
    };
    struct EBM_API Identifier{
        IdentifierRef id;
        String body;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "Identifier";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "id",(*this).id);
            v(v, "body",(*this).body);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "id",(*this).id);
            v(v, "body",(*this).body);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "id",visitor_tag<decltype(std::declval<Identifier>().id),false>{});
            v(v, "body",visitor_tag<decltype(std::declval<Identifier>().body),false>{});
        }
    };
    struct EBM_API StringLiteral{
        StringRef id;
        String body;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "StringLiteral";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "id",(*this).id);
            v(v, "body",(*this).body);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "id",(*this).id);
            v(v, "body",(*this).body);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "id",visitor_tag<decltype(std::declval<StringLiteral>().id),false>{});
            v(v, "body",visitor_tag<decltype(std::declval<StringLiteral>().body),false>{});
        }
    };
    struct EBM_API DebugInfo{
        Varint len_files;
        std::vector<StringRef> files;
        Varint len_locs;
        std::vector<Loc> locs;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "DebugInfo";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "len_files",(*this).len_files);
            v(v, "files",(*this).files);
            v(v, "len_locs",(*this).len_locs);
            v(v, "locs",(*this).locs);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "len_files",(*this).len_files);
            v(v, "files",(*this).files);
            v(v, "len_locs",(*this).len_locs);
            v(v, "locs",(*this).locs);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "len_files",visitor_tag<decltype(std::declval<DebugInfo>().len_files),false>{});
            v(v, "files",visitor_tag<decltype(std::declval<DebugInfo>().files),false>{});
            v(v, "len_locs",visitor_tag<decltype(std::declval<DebugInfo>().len_locs),false>{});
            v(v, "locs",visitor_tag<decltype(std::declval<DebugInfo>().locs),false>{});
        }
    };
    struct EBM_API Instruction{
        OpCode op{};
        struct EBM_API union_struct_152{
            JumpOffset target;
        };
        struct EBM_API union_struct_153{
            JumpOffset target;
        };
        struct EBM_API union_struct_154{
            JumpOffset target;
        };
        struct EBM_API union_struct_155{
            Varint arg_num;
        };
        struct EBM_API union_struct_156{
            StringRef msg_id;
        };
        struct EBM_API union_struct_157{
            StringRef msg_id;
        };
        struct EBM_API union_struct_158{
            Varint value;
        };
        struct EBM_API union_struct_159{
            StringRef str_id;
        };
        struct EBM_API union_struct_160{
            RegisterIndex reg;
        };
        struct EBM_API union_struct_161{
            RegisterIndex reg;
        };
        struct EBM_API union_struct_162{
            RegisterIndex reg;
        };
        struct EBM_API union_struct_163{
            OptionalImmediateSize imm;
        };
        struct EBM_API union_struct_164{
            OptionalImmediateSize imm;
        };
        struct EBM_API union_struct_165{
            OptionalImmediateSize imm;
        };
        struct EBM_API union_struct_166{
            SetEndian set_endian;
        };
        struct EBM_API union_struct_167{
            CastType cast_type{};
        };
        struct EBM_API union_struct_168{
            TypeRef type_id;
        };
        struct EBM_API union_struct_169{
            IdentifierRef member_id;
        };
        struct EBM_API union_struct_170{
            OptionalImmediateSize imm;
        };
        std::variant<std::monostate, union_struct_152, union_struct_153, union_struct_154, union_struct_155, union_struct_156, union_struct_157, union_struct_158, union_struct_159, union_struct_160, union_struct_161, union_struct_162, union_struct_163, union_struct_164, union_struct_165, union_struct_166, union_struct_167, union_struct_168, union_struct_169, union_struct_170> union_variant_151;
        const Varint* arg_num() const;
        Varint* arg_num();
        bool arg_num(Varint&& v);
        bool arg_num(const Varint& v);
        const CastType* cast_type() const;
        CastType* cast_type();
        bool cast_type(CastType&& v);
        bool cast_type(const CastType& v);
        const OptionalImmediateSize* imm() const;
        OptionalImmediateSize* imm();
        bool imm(OptionalImmediateSize&& v);
        bool imm(const OptionalImmediateSize& v);
        const IdentifierRef* member_id() const;
        IdentifierRef* member_id();
        bool member_id(IdentifierRef&& v);
        bool member_id(const IdentifierRef& v);
        const StringRef* msg_id() const;
        StringRef* msg_id();
        bool msg_id(StringRef&& v);
        bool msg_id(const StringRef& v);
        const RegisterIndex* reg() const;
        RegisterIndex* reg();
        bool reg(RegisterIndex&& v);
        bool reg(const RegisterIndex& v);
        const SetEndian* set_endian() const;
        SetEndian* set_endian();
        bool set_endian(SetEndian&& v);
        bool set_endian(const SetEndian& v);
        const StringRef* str_id() const;
        StringRef* str_id();
        bool str_id(StringRef&& v);
        bool str_id(const StringRef& v);
        const JumpOffset* target() const;
        JumpOffset* target();
        bool target(JumpOffset&& v);
        bool target(const JumpOffset& v);
        const TypeRef* type_id() const;
        TypeRef* type_id();
        bool type_id(TypeRef&& v);
        bool type_id(const TypeRef& v);
        const Varint* value() const;
        Varint* value();
        bool value(Varint&& v);
        bool value(const Varint& v);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
        constexpr static const char* visitor_name = "Instruction";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "op",(*this).op);
            v(v, "arg_num",(*this).arg_num());
            v(v, "cast_type",(*this).cast_type());
            v(v, "imm",(*this).imm());
            v(v, "member_id",(*this).member_id());
            v(v, "msg_id",(*this).msg_id());
            v(v, "reg",(*this).reg());
            v(v, "set_endian",(*this).set_endian());
            v(v, "str_id",(*this).str_id());
            v(v, "target",(*this).target());
            v(v, "type_id",(*this).type_id());
            v(v, "value",(*this).value());
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "op",(*this).op);
            v(v, "arg_num",(*this).arg_num());
            v(v, "cast_type",(*this).cast_type());
            v(v, "imm",(*this).imm());
            v(v, "member_id",(*this).member_id());
            v(v, "msg_id",(*this).msg_id());
            v(v, "reg",(*this).reg());
            v(v, "set_endian",(*this).set_endian());
            v(v, "str_id",(*this).str_id());
            v(v, "target",(*this).target());
            v(v, "type_id",(*this).type_id());
            v(v, "value",(*this).value());
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "op",visitor_tag<decltype(std::declval<Instruction>().op),false>{});
            v(v, "arg_num",visitor_tag<decltype(std::declval<Instruction>().arg_num()),false>{});
            v(v, "cast_type",visitor_tag<decltype(std::declval<Instruction>().cast_type()),false>{});
            v(v, "imm",visitor_tag<decltype(std::declval<Instruction>().imm()),false>{});
            v(v, "member_id",visitor_tag<decltype(std::declval<Instruction>().member_id()),false>{});
            v(v, "msg_id",visitor_tag<decltype(std::declval<Instruction>().msg_id()),false>{});
            v(v, "reg",visitor_tag<decltype(std::declval<Instruction>().reg()),false>{});
            v(v, "set_endian",visitor_tag<decltype(std::declval<Instruction>().set_endian()),false>{});
            v(v, "str_id",visitor_tag<decltype(std::declval<Instruction>().str_id()),false>{});
            v(v, "target",visitor_tag<decltype(std::declval<Instruction>().target()),false>{});
            v(v, "type_id",visitor_tag<decltype(std::declval<Instruction>().type_id()),false>{});
            v(v, "value",visitor_tag<decltype(std::declval<Instruction>().value()),false>{});
        }
    };
    struct EBM_API ExtendedBinaryModule{
        //"EBMG" (4 bytes)
        std::uint8_t version = 0;
        AnyRef max_id;
        Varint identifiers_len;
        std::vector<Identifier> identifiers;
        Varint strings_len;
        std::vector<StringLiteral> strings;
        Varint types_len;
        std::vector<Type> types;
        Varint statements_len;
        std::vector<Statement> statements;
        Varint expressions_len;
        std::vector<Expression> expressions;
        Varint aliases_len;
        std::vector<RefAlias> aliases;
        DebugInfo debug_info;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 5;
        constexpr static const char* visitor_name = "ExtendedBinaryModule";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "magic","EBMG");
            v(v, "version",(*this).version);
            v(v, "max_id",(*this).max_id);
            v(v, "identifiers_len",(*this).identifiers_len);
            v(v, "identifiers",(*this).identifiers);
            v(v, "strings_len",(*this).strings_len);
            v(v, "strings",(*this).strings);
            v(v, "types_len",(*this).types_len);
            v(v, "types",(*this).types);
            v(v, "statements_len",(*this).statements_len);
            v(v, "statements",(*this).statements);
            v(v, "expressions_len",(*this).expressions_len);
            v(v, "expressions",(*this).expressions);
            v(v, "aliases_len",(*this).aliases_len);
            v(v, "aliases",(*this).aliases);
            v(v, "debug_info",(*this).debug_info);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "magic","EBMG");
            v(v, "version",(*this).version);
            v(v, "max_id",(*this).max_id);
            v(v, "identifiers_len",(*this).identifiers_len);
            v(v, "identifiers",(*this).identifiers);
            v(v, "strings_len",(*this).strings_len);
            v(v, "strings",(*this).strings);
            v(v, "types_len",(*this).types_len);
            v(v, "types",(*this).types);
            v(v, "statements_len",(*this).statements_len);
            v(v, "statements",(*this).statements);
            v(v, "expressions_len",(*this).expressions_len);
            v(v, "expressions",(*this).expressions);
            v(v, "aliases_len",(*this).aliases_len);
            v(v, "aliases",(*this).aliases);
            v(v, "debug_info",(*this).debug_info);
        }
        template<typename T,bool rvalue = false>
        struct visitor_tag {
            using type = T;
            static constexpr bool is_rvalue = rvalue;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "magic",visitor_tag<decltype("EBMG"),false>{});
            v(v, "version",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().version),false>{});
            v(v, "max_id",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().max_id),false>{});
            v(v, "identifiers_len",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().identifiers_len),false>{});
            v(v, "identifiers",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().identifiers),false>{});
            v(v, "strings_len",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().strings_len),false>{});
            v(v, "strings",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().strings),false>{});
            v(v, "types_len",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().types_len),false>{});
            v(v, "types",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().types),false>{});
            v(v, "statements_len",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().statements_len),false>{});
            v(v, "statements",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().statements),false>{});
            v(v, "expressions_len",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().expressions_len),false>{});
            v(v, "expressions",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().expressions),false>{});
            v(v, "aliases_len",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().aliases_len),false>{});
            v(v, "aliases",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().aliases),false>{});
            v(v, "debug_info",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().debug_info),false>{});
        }
    };
} // namespace ebm

