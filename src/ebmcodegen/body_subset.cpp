/*license*/
// Code generated by ebmcodegen at https://github.com/on-keyday/rebrgen
#include <ebm/extended_binary_module.hpp>
#include <set>
#include <map>
namespace ebmcodegen {
    std::map<ebm::StatementOp,std::set<std::string_view>> body_subset_StatementBody() {
        std::map<ebm::StatementOp,std::set<std::string_view>> subset_map;
        for(size_t i = 0;to_string(ebm::StatementOp(i))[0];i++) {
            ebm::StatementBody body;
            body.kind = ebm::StatementOp(i);
            body.alias({});
            body.assert_desc({});
            body.bit_field_decl({});
            body.block({});
            body.break_({});
            body.continue_({});
            body.enum_decl({});
            body.enum_member_decl({});
            body.error_report({});
            body.expression({});
            body.field_decl({});
            body.func_decl({});
            body.if_statement({});
            body.loop({});
            body.lowered_statements({});
            body.match_branch({});
            body.match_statement({});
            body.metadata({});
            body.module_name({});
            body.offset({});
            body.params({});
            body.params_len({});
            body.previous_assignment({});
            body.property_decl({});
            body.read_data({});
            body.stream_type({});
            body.struct_decl({});
            body.target({});
            body.target_var({});
            body.union_decl({});
            body.union_member_decl({});
            body.value({});
            body.var_decl({});
            body.write_data({});
            std::set<std::string_view> subset;
            body.visit([&](auto&& visitor,const char* name,auto&& value) {
                using T = std::decay_t<decltype(value)>;
                if constexpr (std::is_pointer_v<T>) {
                    if (value) { subset.insert(name); }
                }
                else {
                    subset.insert(name);
                }
            });
            subset_map[ebm::StatementOp(i)] = std::move(subset);
        }
        return subset_map;
    }
    std::map<ebm::ExpressionOp,std::set<std::string_view>> body_subset_ExpressionBody() {
        std::map<ebm::ExpressionOp,std::set<std::string_view>> subset_map;
        for(size_t i = 0;to_string(ebm::ExpressionOp(i))[0];i++) {
            ebm::ExpressionBody body;
            body.kind = ebm::ExpressionOp(i);
            body.array_expr({});
            body.base({});
            body.bool_value({});
            body.bop({});
            body.call_desc({});
            body.cast_kind({});
            body.end({});
            body.endian_expr({});
            body.from_type({});
            body.id({});
            body.index({});
            body.int64_value({});
            body.int_value({});
            body.io_statement({});
            body.left({});
            body.lowered_expr({});
            body.member({});
            body.num_bytes({});
            body.operand({});
            body.right({});
            body.source_expr({});
            body.start({});
            body.stream_type({});
            body.string_value({});
            body.target_expr({});
            body.target_stmt({});
            body.type_ref({});
            body.unit({});
            body.uop({});
            std::set<std::string_view> subset;
            body.visit([&](auto&& visitor,const char* name,auto&& value) {
                using T = std::decay_t<decltype(value)>;
                if constexpr (std::is_pointer_v<T>) {
                    if (value) { subset.insert(name); }
                }
                else {
                    subset.insert(name);
                }
            });
            subset_map[ebm::ExpressionOp(i)] = std::move(subset);
        }
        return subset_map;
    }
    std::map<ebm::TypeKind,std::set<std::string_view>> body_subset_TypeBody() {
        std::map<ebm::TypeKind,std::set<std::string_view>> subset_map;
        for(size_t i = 0;to_string(ebm::TypeKind(i))[0];i++) {
            ebm::TypeBody body;
            body.kind = ebm::TypeKind(i);
            body.base_type({});
            body.common_type({});
            body.element_type({});
            body.id({});
            body.inner_type({});
            body.length({});
            body.members({});
            body.params({});
            body.pointee_type({});
            body.property_type({});
            body.return_type({});
            body.size({});
            std::set<std::string_view> subset;
            body.visit([&](auto&& visitor,const char* name,auto&& value) {
                using T = std::decay_t<decltype(value)>;
                if constexpr (std::is_pointer_v<T>) {
                    if (value) { subset.insert(name); }
                }
                else {
                    subset.insert(name);
                }
            });
            subset_map[ebm::TypeKind(i)] = std::move(subset);
        }
        return subset_map;
    }
} // namespace ebmcodegen
