## 4. Code Generation Logic (Visitor Hooks)

### 4.1 Visitor Hook Overview
A visitor hook is a `.hpp` file containing a C++ code snippet. It is **not** a class definition. Instead, it's the literal body of a function that is dynamically generated by `ebmcodegen`. `ebmcodegen` generates functions like `visit_Statement_WRITE_DATA(...)`, and the content of your `.hpp` file (e.g., `visitor/Statement_WRITE_DATA.hpp`) is `#include`d directly into the body of that function. The function, and therefore your hook code, **must** return a value of type `expected<Result>`. The `Result` struct holds the generated code string in its `value` member.

### 4.2 Managing Visitor Hooks with `ebmtemplate.py`
The `script/ebmtemplate.py` script is a wrapper around `ebmcodegen` that simplifies the lifecycle of visitor hooks.
-   **`python script/ebmtemplate.py`**: Displays help.
-   **`python script/ebmtemplate.py interactive`**: Start an interactive guide through the script features.
-   **`python script/ebmtemplate.py <template_target>`**: Outputs a summary of the hook file to stdout.
-   **`python script/ebmtemplate.py <template_target> <lang>`**: Generates a new hook file (`.hpp`) in `src/ebmcg/ebm2<lang>/visitor/`.
-   **`python script/ebmtemplate.py update <lang>`**: Updates the auto-generated comment blocks (listing available variables) in all existing hooks for a given language.
-   **`python script/ebmtemplate.py test`**: Tests the generation of all available template targets.
-   **`python script/ebmtemplate.py list <lang>`**: List all defined templates in the specified [lang] directory.

### 4.3 Workflow for Implementing a Visitor Hook
1.  **Find the Target**: Decide which EBM node you want to handle. Use `tool/ebmcodegen --mode hooklist` to list available hooks.
2.  **Create the File**: Generate the hook file using `python script/ebmtemplate.py <template_target> <lang>`.
3.  **Implement the Logic**: Open the newly created file (`src/ebmcg/ebm2<lang>/visitor/<template_target>.hpp`). Replace the `/*here to write the hook*/` comment with your C++ implementation.
4.  **Build and Verify**: After implementing the hook, run `python script/unictest.py` (or `python script/unictest.py --print-stdout` for debugging) to build and verify your changes. This will trigger the build process and run the tests defined in the `unictest` framework. Also, remember to update `src/ebmcg/ebm2<lang>/main.cpp`'s Last updated time at creation of hook file to make the build system recognize the new file.

### 4.4 DSL (Domain Specific Language) for Visitor Hooks
The `ebmcodegen` tool supports a Domain Specific Language (DSL) for writing visitor hooks, offering a more concise and readable way to define code generation logic. This DSL is processed by `ebmcodegen` when invoked with `--mode dsl` and `--dsl-file=FILE`.

**DSL Syntax Overview:**
The DSL mixes C++ code, EBM node processing, and control flow constructs using special markers:
-   **`{% C++_CODE %}`**: Embeds C++ literal code directly into the generated output. (e.g., `{% int a = 0; %}`)
-   **`{{ C++_EXPRESSION }}`**: Embeds a C++ expression whose result is written to the output. (e.g., `{{ a }} += 1;`)
-   **`{* EBM_NODE_EXPRESSION *}`**: Processes an EBM node (e.g., `ExpressionRef`, `StatementRef`) by calling `visit_Object` and writing its generated output. (e.g., `{* expr *}`)
-   **`{& IDENTIFIER_EXPRESSION &}`**: Retrieves an identifier and writes it to the output. (e.g., `{& item_id &}`)
-   **`{! SPECIAL_MARKER !}`**: Used for advanced control flow and variable definitions within the DSL itself. The content inside these markers is parsed by a nested DSL.
    -   **`transfer_and_reset_writer`**: Generates C++ code to transfer the current `CodeWriter` content and reset it.
    -   **`for IDENT in (range(BEGIN, END, STEP) | COLLECTION)`**: Generates C++ `for` loops. Supports both numeric ranges and iteration over collections.
    -   **`endfor`**: Closes a `for` loop block.
    -   **`if (CONDITION)` / `elif (CONDITION)` / `else`**: Generates C++ `if`/`else if`/`else` blocks.
    -   **`endif`**: Closes an `if` block.
    -   **`VARIABLE := VALUE`**: Defines a C++ variable within the generated code. (e.g., `my_var := 42`)

Text outside these markers is treated as target language code and is escaped before being written to the output. The DSL also handles automatic indentation and dedentation based on the source formatting.
