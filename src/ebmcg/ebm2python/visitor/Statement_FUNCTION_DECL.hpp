/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_FUNCTION_DECL
  Available variables:
    *this: Visitor
    module_: MappingTable
    item_id: StatementRef
    kind: StatementKind
    func_decl: FunctionDecl
      name: IdentifierRef
      return_type: TypeRef
      params: Block
        len: Varint
        container: std::vector<StatementRef>
      parent_format: StatementRef
      body: StatementRef
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/
// This code is included within the visit_Statement_FUNCTION_DECL function.
// We can use variables like `visitor` and `func_decl` directly.
CodeWriter w;
auto func_name = this->module_.get_identifier_or(func_decl.name, item_id, "function");
MAYBE(return_type_str, visit_Type(*this, func_decl.return_type));

std::string params_str = "";
if (!is_nil(func_decl.parent_format)) {
    params_str += "self";
}
if (func_decl.params.container.empty() == false) {
    for (auto& param_stmt_ref : func_decl.params.container) {
        MAYBE(param_stmt, this->module_.get_statement(param_stmt_ref));
        if (param_stmt.body.kind == ebm::StatementKind::VARIABLE_DECL) {
            auto& var_decl = *param_stmt.body.var_decl();
            auto param_name = this->module_.get_identifier_or(param_stmt_ref, "param");
            MAYBE(param_type_str, visit_Type(*this, var_decl.var_type));  // Correctly extract the string value
            if (!params_str.empty()) {
                params_str += ", ";
            }
            params_str += param_name + ": " + param_type_str.value;
        }
        else {
            return unexpect_error("Function parameter is not a VARIABLE_DECL: {}", to_string(param_stmt.body.kind));
        }
    }
}

w.writeln("def ", func_name, "(", params_str, ") -> ", return_type_str.value, ":");
auto scope = w.indent_scope();
MAYBE(res, visit_Statement(*this, func_decl.body));
if (res.value.empty()) {
    w.writeln("pass");  // If the body is empty, we just pass
}
else {
    w.write_unformatted(res.value);
}

return w.out();