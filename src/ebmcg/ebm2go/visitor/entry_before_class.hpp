/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: entry_before_class
  Available Variables:
    ctx: Context_entry_before<Result>
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        module_: ebmgen::MappingTable
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
      main_logic: ebmcodegen::util::MainLogicWrapper<Result>
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include <cctype>
#include <string>
#include "../codegen.hpp"
#include "ebm/extended_binary_module.hpp"
#include "ebmcodegen/stub/util.hpp"
#include "ebmgen/common.hpp"
#include "escape/escape.h"
#include "json/stringer.h"
#include "number/parse.h"

namespace CODEGEN_NAMESPACE {
    inline std::optional<ebm2go::ArrayLengthInfo> is_setter_target(Context_Statement_WRITE_DATA& wctx) {
        if (is_nil(wctx.write_data.field)) {
            return std::nullopt;
        }
        auto length_field = wctx.get_field<"member.body.id.field_decl">(wctx.write_data.size.ref());
        if (!length_field) {
            return std::nullopt;
        }
        auto length_type = wctx.get_field<"field_type.instance">(length_field);
        if (!length_type) {
            return std::nullopt;
        }
        // length must be int or uint
        if (length_type->body.kind != ebm::TypeKind::INT &&
            length_type->body.kind != ebm::TypeKind::UINT) {
            return std::nullopt;
        }
        auto array_field = wctx.get_field<"member.body.id.field_decl">(wctx.write_data.target);
        if (!array_field) {
            return std::nullopt;
        }
        auto array_type = wctx.get_field<"field_type.instance">(array_field);
        if (!array_type) {
            return std::nullopt;
        }
        if (array_type->body.kind != ebm::TypeKind::VECTOR) {
            return std::nullopt;
        }
        return ebm2go::ArrayLengthInfo{
            &wctx.write_data,
            array_field,
            length_field,
            array_type,
            length_type,
        };
    }

    struct ArraySetterDetector {
        TRAVERSAL_VISITOR_BASE_WITHOUT_FUNC(ArraySetterDetector, BaseVisitor);
        expected<void> visit(Context_Statement_WRITE_DATA& ctx) {
            if (auto info = is_setter_target(ctx); info) {
                ctx.config().array_length_setters[get_id(ctx.write_data.field)] = *info;
            }
            return {};
        }
        MetadataSet meta;

        expected<void> visit(Context_Statement_METADATA& ctx) {
            return meta.try_add_metadata(ctx, &ctx.metadata);
        }

        template <typename Ctx>
        expected<void> visit(Ctx&& ctx) {
            if (ctx.is_before_or_after()) {
                return pass;
            }
            if (ctx.context_name.contains("Type")) {
                return {};
            }
            return traverse_children<void>(*this, std::forward<Ctx>(ctx));
        }
    };
    static_assert(HasVisitor<void, ArraySetterDetector, Context_Statement_WRITE_DATA&>);

}  // namespace CODEGEN_NAMESPACE

DEFINE_VISITOR(entry_before) {
    using namespace CODEGEN_NAMESPACE;
    ctx.config().io_mode.slice_io = !ctx.flags().no_slice_io;
    ctx.config().io_mode.std_io = !ctx.flags().no_std_io;
    ctx.config().io_mode.bytes_io = ctx.flags().bytes_io;
    ctx.config().array_type_wrapper = [&](Result r, size_t size, ebm::ArrayAnnotation anno) -> expected<Result> {
        if (!ctx.config().use_io_reader_writer && anno != ebm::ArrayAnnotation::none) {
            // In *[]byte mode, annotated arrays are slices (they borrow from the IO buffer)
            return CODE("[]", r.to_writer());
        }
        // In io.Writer mode, all arrays are fixed-size (including annotated ones for lowered IO)
        return CODE("[", std::to_string(size), "]", r.to_writer());
    };
    ctx.config().vector_type_wrapper = [](Result r) -> expected<Result> {
        return CODE("[]", r.to_writer());
    };
    ctx.config().field_name_prior_to_type = true;
    ctx.config().int_prefix = "int";
    ctx.config().uint_prefix = "uint";
    ctx.config().float_prefix = "float";
    ctx.config().struct_definition_start_wrapper = [&](Context_Statement_STRUCT_DECL& sctx) -> expected<Result> {
        CodeWriter w;
        auto name = sctx.identifier();
        w.writeln_with_loc(to_any_ref(sctx.item_id), "type ", name, " struct ", ctx.config().begin_block);
        ctx.config().no_heap_mode.push_back(false);
        if (auto enc = sctx.struct_decl.encode_fn()) {
            ArraySetterDetector detector{ctx.visitor};
            MAYBE_VOID(detected, ctx.visit<void>(detector, *enc));
            if (auto conf = detector.meta.get_first("config.go.union")) {
                if (conf->get_string(ctx, 0) == "noheap") {
                    ctx.config().no_heap_mode.back() = true;
                }
            }
        }
        if (!is_nil(sctx.struct_decl.name)) {
            ctx.output().struct_names.push_back(name);
        }
        return w;
    };
    ctx.config().struct_definition_end_wrapper = [](Context_Statement_STRUCT_DECL& ctx, CodeWriter& result) {
        ctx.config().no_heap_mode.pop_back();
        return result;
    };
    ctx.config().function_define_keyword = "func";
    ctx.config().function_return_type_separator = "";
    ctx.config().encoder_return_type = "error";
    ctx.config().decoder_return_type = "error";
    ctx.config().param_visitor = [](Context_Statement_PARAMETER_DECL& ctx, Result type) -> expected<Result> {
        auto kind = ctx.get_kind(ctx.param_decl.param_type);
        if (!ctx.config().use_io_reader_writer &&
            !ctx.config().append_io &&
            (kind == ebm::TypeKind::ENCODER_INPUT ||
             kind == ebm::TypeKind::DECODER_INPUT)) {
            return CODE(ctx.identifier(), " ", type.to_writer(), ", ", offset_var(ctx.identifier()), " *int");
        }
        return CODE(ctx.identifier(), " ", type.to_writer());
    };
    ctx.config().as_arg_visitor = [](Context_Expression_AS_ARG& ctx) -> expected<Result> {
        MAYBE(target, ctx.visit(ctx.target_expr));
        auto kind = ctx.get_kind(ctx.type);
        if (!ctx.config().use_io_reader_writer &&
            !ctx.config().append_io &&
            (kind == ebm::TypeKind::ENCODER_INPUT ||
             kind == ebm::TypeKind::DECODER_INPUT)) {
            return CODE(target.to_writer(), ", ", offset_var(target.to_string()));
        }
        return target;
    };
    ctx.config().struct_encode_start_wrapper = [](Context_Statement_STRUCT_DECL& sctx, ebm::StatementRef encode_fn) -> expected<Result> {
        CodeWriter w;
        if (sctx.config().io_mode.bytes_io) {
            sctx.config().encoder_input_type = "*bytes.Buffer";
            sctx.config().imports.insert("bytes");
            sctx.config().encode_fn_name = "WriteBuffer";
            sctx.config().use_io_reader_writer = true;
            MAYBE(enc, sctx.visit(encode_fn));
            w.write(std::move(enc.to_writer()));
            auto name = sctx.identifier();
            w.writeln("func (s *", name, ") EncodeBuffer(reserved []byte) ([]byte,error) {");
            {
                auto scope = w.indent_scope();
                sctx.config().imports.insert("bytes");
                w.writeln("buf := bytes.NewBuffer(reserved)");
                w.writeln("err := s.WriteBuffer(buf)");
                w.writeln("if err != nil {");
                w.indent_writeln("return nil,err");
                w.writeln("}");
                w.writeln("return buf.Bytes(), nil");
            }
            w.writeln("}");
            w.writeln("func (s *", name, ") MustEncodeBuffer(reserved []byte) []byte {");
            {
                auto scope = w.indent_scope();
                w.writeln("buf,err := s.EncodeBuffer(reserved)");
                w.writeln("if err != nil {");
                w.indent_writeln("panic(err)");
                w.writeln("}");
                w.writeln("return buf");
            }
            w.writeln("}");
        }
        if (sctx.config().io_mode.std_io) {
            sctx.config().encoder_input_type = "io.Writer";
            sctx.config().imports.insert("io");
            sctx.config().encode_fn_name = "Write";
            sctx.config().use_io_reader_writer = true;
            MAYBE(enc, sctx.visit(encode_fn));
            w.write(std::move(enc.to_writer()));
            auto name = sctx.identifier();
            w.writeln("func (s *", name, ") EncodeCopy(reserved []byte) ([]byte,error) {");
            {
                auto scope = w.indent_scope();
                sctx.config().imports.insert("bytes");
                w.writeln("buf := bytes.NewBuffer(reserved)");
                w.writeln("err := s.Write(buf)");
                w.writeln("if err != nil {");
                w.indent_writeln("return nil,err");
                w.writeln("}");
                w.writeln("return buf.Bytes(), nil");
            }
            w.writeln("}");
            w.writeln("func (s *", name, ") MustEncodeCopy(reserved []byte) []byte {");
            {
                auto scope = w.indent_scope();
                w.writeln("buf,err := s.EncodeCopy(reserved)");
                w.writeln("if err != nil {");
                w.indent_writeln("panic(err)");
                w.writeln("}");
                w.writeln("return buf");
            }
            w.writeln("}");
        }
        if (sctx.config().io_mode.slice_io) {
            sctx.config().encoder_input_type = "[]byte";
            sctx.config().encode_fn_name = "EncodeSlice";
            sctx.config().use_io_reader_writer = false;
            sctx.config().append_io = false;
            MAYBE(enc, sctx.visit(encode_fn));
            w.write(std::move(enc.to_writer()));
            auto name = sctx.identifier();
            w.writeln("func (s *", name, ") Encode(buf []byte) ([]byte,error) {");
            {
                auto scope = w.indent_scope();
                w.writeln("var offset int");
                w.writeln("err := s.EncodeSlice(buf,&offset)");
                w.writeln("if err != nil {");
                w.indent_writeln("return nil,err");
                w.writeln("}");
                w.writeln("return buf[:offset], nil");
            }
            w.writeln("}");
            w.writeln("func (s *", name, ") MustEncode(reserved []byte) []byte {");
            {
                auto scope = w.indent_scope();
                w.writeln("buf,err := s.Encode(reserved)");
                w.writeln("if err != nil {");
                w.indent_writeln("panic(err)");
                w.writeln("}");
                w.writeln("return buf");
            }
            w.writeln("}");
            sctx.config().encoder_input_type = "[]byte";
            sctx.config().encoder_return_type = "([]byte,error)";
            sctx.config().encode_fn_name = "Append";
            sctx.config().use_io_reader_writer = false;
            sctx.config().append_io = true;
            MAYBE(enc2, sctx.visit(encode_fn));
            w.write(std::move(enc2.to_writer()));
            sctx.config().encoder_return_type = "error";
            sctx.config().append_io = false;
            w.writeln("func (s *", name, ") MustAppend(buf []byte) []byte {");
            {
                auto scope = w.indent_scope();
                w.writeln("var err error");
                w.writeln("buf,err = s.Append(buf)");
                w.writeln("if err != nil {");
                w.indent_writeln("panic(err)");
                w.writeln("}");
                w.writeln("return buf");
            }
            w.writeln("}");
        }
        return w;
    };

    ctx.config().struct_decode_start_wrapper = [](Context_Statement_STRUCT_DECL& sctx, ebm::StatementRef decode_fn) -> expected<Result> {
        CodeWriter w;
        if (sctx.config().io_mode.bytes_io) {
            sctx.config().decoder_input_type = "*bytes.Reader";
            sctx.config().imports.insert("bytes");
            sctx.config().decode_fn_name = "ReadBuffer";
            sctx.config().use_io_reader_writer = true;
            MAYBE(enc, sctx.visit(decode_fn));
            w.write(std::move(enc.to_writer()));
            auto name = sctx.identifier();
            w.writeln("func (s *", name, ") DecodeBuffer(buf []byte) ([]byte,error) {");
            {
                auto scope = w.indent_scope();
                sctx.config().imports.insert("bytes");
                w.writeln("r := bytes.NewReader(buf)");
                w.writeln("err := s.ReadBuffer(r)");
                w.writeln("if err != nil {");
                w.indent_writeln("return nil,err");
                w.writeln("}");
                w.writeln("return buf[int(r.Size()) - r.Len():], nil");
            }
            w.writeln("}");
            w.writeln("func (s *", name, ") DecodeExactBuffer(buf []byte) error {");
            {
                auto scope = w.indent_scope();
                w.writeln("remain,err := s.DecodeBuffer(buf)");
                w.writeln("if err != nil {");
                w.indent_writeln("return err");
                w.writeln("}");
                w.writeln("if len(remain) != 0 {");
                sctx.config().imports.insert("fmt");
                w.indent_writeln("return fmt.Errorf(\"expect no remaining bytes but got %d bytes\",len(remain))");
                w.writeln("}");
                w.writeln("return nil");
            }
            w.writeln("}");
        }
        if (sctx.config().io_mode.std_io) {
            sctx.config().decoder_input_type = "io.Reader";
            sctx.config().imports.insert("io");
            sctx.config().decode_fn_name = "Read";
            sctx.config().use_io_reader_writer = true;
            MAYBE(enc, sctx.visit(decode_fn));
            w.write(std::move(enc.to_writer()));
            auto name = sctx.identifier();
            w.writeln("func (s *", name, ") DecodeCopy(buf []byte) ([]byte,error) {");
            {
                auto scope = w.indent_scope();
                sctx.config().imports.insert("bytes");
                w.writeln("r := bytes.NewReader(buf)");
                w.writeln("err := s.Read(r)");
                w.writeln("if err != nil {");
                w.indent_writeln("return nil,err");
                w.writeln("}");
                w.writeln("return buf[int(r.Size()) - r.Len():], nil");
            }
            w.writeln("}");
            w.writeln("func (s *", name, ") DecodeExactCopy(buf []byte) error {");
            {
                auto scope = w.indent_scope();
                w.writeln("remain,err := s.DecodeCopy(buf)");
                w.writeln("if err != nil {");
                w.indent_writeln("return err");
                w.writeln("}");
                w.writeln("if len(remain) != 0 {");
                sctx.config().imports.insert("fmt");
                w.indent_writeln("return fmt.Errorf(\"expect no remaining bytes but got %d bytes\",len(remain))");
                w.writeln("}");
                w.writeln("return nil");
            }
            w.writeln("}");
        }
        if (sctx.config().io_mode.slice_io) {
            sctx.config().decoder_input_type = "[]byte";
            sctx.config().decode_fn_name = "DecodeSlice";
            sctx.config().use_io_reader_writer = false;
            MAYBE(enc, sctx.visit(decode_fn));
            w.write(std::move(enc.to_writer()));
            auto name = sctx.identifier();
            w.writeln("func (s *", name, ") Decode(buf []byte) ([]byte,error) {");
            {
                auto scope = w.indent_scope();
                w.writeln("var offset int");
                w.writeln("err := s.DecodeSlice(buf,&offset)");
                w.writeln("if err != nil {");
                w.indent_writeln("return nil,err");
                w.writeln("}");
                w.writeln("return buf[offset:], nil");
            }
            w.writeln("}");
            w.writeln("func (s *", name, ") DecodeExact(buf []byte) error {");
            {
                auto scope = w.indent_scope();
                w.writeln("remain,err := s.Decode(buf)");
                w.writeln("if err != nil {");
                w.indent_writeln("return err");
                w.writeln("}");
                w.writeln("if len(remain) != 0 {");
                sctx.config().imports.insert("fmt");
                w.indent_writeln("return fmt.Errorf(\"expect no remaining bytes but got %d bytes\",len(remain))");
                w.writeln("}");
                w.writeln("return nil");
            }
            w.writeln("}");
        }
        return w;
    };

    ctx.config().function_definition_start_wrapper = [&](Result return_type, std::string_view name, CodeWriter params, Context_Statement_FUNCTION_DECL& fctx) -> expected<Result> {
        CodeWriter w;
        std::string_view name_prefix;
        ctx.config().inner_prop_setter = false;
        if (is_setter_func(fctx.func_decl.kind)) {
            if (fctx.func_decl.kind == ebm::FunctionKind::PROPERTY_SETTER) {
                ctx.config().inner_prop_setter = true;
            }
            name_prefix = "Set";
            if (is_nil(fctx.func_decl.name)) {
                name_prefix = "set";  // unexported
            }
            // first parameter is u1, change to value type
            MAYBE(param_type, fctx.get_field<"param_decl.param_type.instance">(fctx.func_decl.params.container[0]));
            if (auto size = param_type.body.size()) {
                if (size->value() == 1) {
                    if (name_prefix == "Set") {
                        name_prefix = "set";
                        ctx.config().bool_mapped_func.insert(get_id(fctx.item_id));
                        w.writeln("func (", ctx.config().self_value, " *", ctx.identifier(fctx.func_decl.parent_format), ") Set", name, "(value bool) ", ctx.config().function_return_type_separator, " ", return_type.to_writer(), " ", ctx.config().begin_block);
                        {
                            auto scope = w.indent_scope();
                            w.writeln("var intVal uint8");
                            w.writeln("if value {");
                            w.indent_writeln("intVal = 1");
                            w.writeln("} else {");
                            w.indent_writeln("intVal = 0");
                            w.writeln("}");
                            w.writeln("return ", ctx.config().self_value, ".", name_prefix, name, "(intVal)");
                        }
                        w.writeln("}");
                    }
                }
            }
        }
        std::string tmp_buffer;
        if (is_getter_func(fctx.func_decl.kind)) {
            // if return type is u1, change to bool
            MAYBE(ret_type, fctx.get_field<"func_decl.return_type.instance">(fctx.item_id));
            if (auto size = ret_type.body.size()) {
                if (size->value() == 1) {
                    tmp_buffer = std::string(name);
                    tmp_buffer[0] = std::tolower(tmp_buffer[0]);
                    w.writeln("func (", ctx.config().self_value, " *", ctx.identifier(fctx.func_decl.parent_format), ") ", name, "() ", ctx.config().function_return_type_separator, " bool ", ctx.config().begin_block);
                    {
                        auto scope = w.indent_scope();
                        w.writeln("intVal := ", ctx.config().self_value, ".", tmp_buffer, "()");
                        w.writeln("return intVal != 0");
                    }
                    w.writeln("}");
                    ctx.config().bool_mapped_func.insert(get_id(fctx.item_id));
                    name = tmp_buffer;
                }
            }
        }
        if (is_composite_func(fctx.func_decl.kind)) {
            // may change return type or params
            if (fctx.func_decl.kind == ebm::FunctionKind::COMPOSITE_GETTER) {
                auto got = ctx.get_field<"variant_desc">(fctx.func_decl.return_type);
                if (got && !is_nil(got->common_type)) {
                    MAYBE(typ, ctx.visit(got->common_type));
                    return_type = typ;
                }
            }
            else {
                auto got = ctx.get_field<"param_decl.param_type.variant_desc">(fctx.func_decl.params.container[0]);
                if (got && !is_nil(got->common_type)) {
                    MAYBE(typ, ctx.visit(got->common_type));
                    auto param_name = ctx.identifier(fctx.func_decl.params.container[0]);
                    params = CODE(param_name, " ", typ.to_writer());
                }
            }
        }
        if (fctx.func_decl.kind == ebm::FunctionKind::ENCODE) {
            name = fctx.config().encode_fn_name;
        }
        else if (fctx.func_decl.kind == ebm::FunctionKind::DECODE) {
            name = fctx.config().decode_fn_name;
        }
        if (!is_nil(fctx.func_decl.parent_format)) {
            auto struct_name = ctx.identifier(fctx.func_decl.parent_format);
            ctx.config().self_value = std::string(1, std::tolower(struct_name[0]));
            w.writeln(ctx.config().function_define_keyword, " (", ctx.config().self_value, " *", struct_name, ") ", name_prefix, name, "(", params, ") ", ctx.config().function_return_type_separator, " ", return_type.to_writer(), " ", ctx.config().begin_block);
        }
        else {
            w.writeln(ctx.config().function_define_keyword, " ", name_prefix, name, "(", params, ") ", ctx.config().function_return_type_separator, return_type.to_writer(), " ", ctx.config().begin_block);
        }
        return w;
    };
    ctx.config().composite_field_decl_visitor = [&](Context_Statement_COMPOSITE_FIELD_DECL& cctx) -> expected<Result> {
        if (cctx.composite_field_decl.kind == ebm::CompositeFieldKind::BULK_PRIMITIVE ||
            cctx.composite_field_decl.kind == ebm::CompositeFieldKind::PREFIXED_UNION_PRIMITIVE) {
            auto ident = cctx.identifier();
            MAYBE(typ, ctx.visit(cctx.composite_field_decl.composite_type));
            auto res = CODELINE(ident, " ", typ.to_writer());
            // for each field, generate getter and setter
            for (auto& field : cctx.composite_field_decl.fields.container) {
                MAYBE(field_decl, cctx.get_field<"field_decl">(field));
                auto getter = field_decl.composite_getter();
                auto setter = field_decl.composite_setter();
                if (getter) {
                    MAYBE(getter, ctx.visit(getter->id));
                    ctx.config().decl_toplevel.push_back(getter.to_writer());
                }
                if (setter) {
                    MAYBE(setter, ctx.visit(setter->id));
                    ctx.config().decl_toplevel.push_back(setter.to_writer());
                }
            }
            return res;
        }
        return cctx.visit(cctx.composite_field_decl.fields);
    };
    ctx.config().reserve_data_visitor = [&](Context_Statement_RESERVE_DATA& rctx) -> expected<Result> {
        MAYBE(write_data, ctx.get_field<"write_data">(rctx.reserve_data.write_data));
        MAYBE(size_str, get_size_str(ctx, rctx.reserve_data.size));
        auto io_ref = ctx.identifier(write_data.io_ref);
        MAYBE(target, ctx.visit(write_data.target));
        MAYBE(field_name, get_identifier_layer_str(ctx, from_weak(write_data.field)));
        field_name = "\\\"" + field_name + "\\\"";
        CodeWriter w;
        if (ctx.config().use_io_reader_writer) {
            // In io.Writer mode: no-op. The fixed array declaration provides storage.
            return "";
        }
        else if (ctx.config().append_io) {
            w.writeln(rctx.identifier(), " := len(", io_ref, ")");
            w.writeln(io_ref, " = append(", io_ref, ", make([]byte,", size_str, ")...)");
            w.writeln(target.to_writer(), " = ", io_ref, "[", rctx.identifier(), ":]");
        }
        else {
            rctx.config().imports.insert("errors");
            w.writeln("if len(", io_ref, ") - ", offset_ref(io_ref), " < int(", size_str, ") {");
            {
                auto scope = w.indent_scope();
                w.indent_writeln("return errors.New(\"not enough space to reserve data for field ", field_name, "\")");
            }
            w.writeln("}");
            w.writeln(target.to_writer(), " = ", io_ref, "[", offset_ref(io_ref), ":", offset_ref(io_ref), "+ int(", size_str, ")]");
        }
        return w;
    };
    ctx.config().is_error_visitor = [&](Context_Expression_IS_ERROR& ectx) -> expected<Result> {
        MAYBE(err, ctx.visit(ectx.target_expr));
        return CODE(err.to_writer(), " != nil");
    };
    ctx.config().error_return_visitor = [&](Context_Statement_ERROR_RETURN& rctx) -> expected<Result> {
        MAYBE(err_expr, ctx.visit(rctx.value));
        CodeWriter w;
        if (rctx.config().use_io_reader_writer && rctx.config().on_until_eof_loop) {
            w.writeln("if ", err_expr.to_writer(), " == io.EOF {");
            w.writeln("break");
            w.writeln("}");
        }
        if (ctx.config().append_io) {
            w.writeln("return nil,", err_expr.to_writer());
        }
        else {
            w.writeln("return ", err_expr.to_writer());
        }
        return w;
    };
    ctx.config().error_report_visitor = [&](Context_Statement_ERROR_REPORT& rptctx) -> expected<Result> {
        MAYBE(err_expr, ctx.get(rptctx.error_report.message));
        auto escaped_msg = futils::escape::escape_str<std::string>(err_expr.body.data);
        CodeWriter w;
        rptctx.config().imports.insert("errors");
        if (ctx.config().append_io) {
            w.writeln("return nil, errors.New(\"", escaped_msg, "\")");
        }
        else {
            w.writeln("return errors.New(\"", escaped_msg, "\")");
        }
        return w;
    };
    ctx.config().variable_type_separator = "";
    ctx.config().variable_with_type = false;
    ctx.config().variable_initializer = ":=";
    ctx.config().constant_define_keyword = "const";
    ctx.config().constant_initializer = "=";
    ctx.config().enum_decl_visitor = [&](Context_Statement_ENUM_DECL& ectx) -> expected<Result> {
        CodeWriter w;
        auto name = ectx.identifier();
        if (is_nil(ectx.enum_decl.base_type)) {
            w.writeln("type ", name, " int");
        }
        else {
            MAYBE(type, ctx.visit(ectx.enum_decl.base_type));
            w.writeln("type ", name, " ", type.to_writer());
        }
        w.writeln("");
        w.writeln("const (");
        {
            auto scope = w.indent_scope();
            for (auto& member_ref : ectx.enum_decl.members.container) {
                MAYBE(member, ectx.visit(member_ref));
                w.write(member.to_writer());
            }
        }
        w.writeln(")");
        w.writeln("func (e ", name, ") String() string {");
        {
            auto scope = w.indent_scope();
            w.writeln("switch e {");
            {
                auto scope = w.indent_scope();
                for (auto& member_ref : ectx.enum_decl.members.container) {
                    MAYBE(member, ectx.get_field<"enum_member_decl">(member_ref));
                    w.writeln("case ", name, "_", ectx.identifier(member_ref), ":");
                    if (!is_nil(member.string_repr)) {
                        MAYBE(lit, ctx.get(member.string_repr));
                        w.indent_writeln("return \"", futils::escape::escape_str<std::string>(lit.body.data), "\"");
                    }
                    else {
                        w.indent_writeln("return \"", ectx.identifier(member_ref), "\"");
                    }
                }
                ectx.config().imports.insert("fmt");
                w.writeln("default:");
                w.indent_writeln("return fmt.Sprintf(\"", name, "(%d)\",e)");
            }
            w.writeln("}");
        }
        w.writeln("}");
        return w;
    };
    ctx.config().enum_member_decl_visitor = [&](Context_Statement_ENUM_MEMBER_DECL& mctx) -> expected<Result> {
        auto enum_name = ctx.identifier(mctx.enum_member_decl.enum_decl);
        auto member_name = mctx.identifier();
        MAYBE(value_expr, ctx.visit(mctx.enum_member_decl.value));
        return CODELINE(enum_name, "_", member_name, " ", enum_name, " = ", value_expr.to_writer());
    };
    ctx.config().enum_member_accessor = "_";
    ctx.config().init_check_visitor = [&](Context_Statement_INIT_CHECK& ictx) -> expected<Result> {
        if (ictx.init_check.init_check_type == ebm::InitCheckType::union_init_encode ||
            ictx.init_check.init_check_type == ebm::InitCheckType::union_init_decode ||
            ictx.init_check.init_check_type == ebm::InitCheckType::union_get ||
            ictx.init_check.init_check_type == ebm::InitCheckType::union_set) {
            MAYBE(type, ictx.get_field<"type">(ictx.init_check.expect_value));
            if (get_composite_field(ctx, ctx.get_field<"member">(ictx.init_check.target_field))) {
                ctx.config().bulk_primitive.insert(get_id(type));
                return "";
            }
            if (ctx.config().no_heap_mode.back()) {
                return "";
            }
            MAYBE(field_txt, ictx.visit(ictx.init_check.target_field));
            auto tmpname = std::format("tmp{}", get_id(type));
            MAYBE(type_txt, ictx.visit(type));
            // tmp,ok := field_txt.(*type_txt)
            CodeWriter w;
            w.writeln(tmpname, ", ok := ", field_txt.to_writer(), ".(*", type_txt.to_writer(), ")");
            w.writeln("if !ok {");
            {
                auto scope = w.indent_scope();
                if (ictx.init_check.init_check_type == ebm::InitCheckType::union_init_encode) {
                    ictx.config().imports.insert("errors");
                    w.writeln("return errors.New(\"invalid union type for encoding\")");
                }
                else if (ictx.init_check.init_check_type == ebm::InitCheckType::union_get) {
                    MAYBE(func_decl, ictx.get_field<"id.func_decl">(ictx.init_check.related_function));
                    MAYBE(default_, as_DEFAULT_VALUE(ctx, func_decl.return_type));
                    w.writeln("return ", default_.to_writer());
                }
                else {
                    w.writeln(tmpname, " = &", type_txt.to_writer(), "{}");
                    w.writeln(field_txt.to_writer(), " = ", tmpname);
                }
            }
            w.writeln("}");
            w.writeln("_ = ", tmpname, " // to prevent unused warnings");
            return w;
        }
        return "";
    };
    ctx.config().variant_type_custom = [&](Context_Type_VARIANT& vctx) -> expected<Result> {
        if (is_nil(vctx.variant_desc.related_field) &&
            is_nil(vctx.variant_desc.common_type)) {
            ctx.config().any_variant.insert(get_id(vctx.item_id));
            return CODE("any");
        }
        return pass;
    };
    ctx.config().default_value_custom = [&](Context_Expression_DEFAULT_VALUE& dctx) -> expected<Result> {
        MAYBE(type, dctx.get(dctx.type));
        if (type.body.kind == ebm::TypeKind::ARRAY || type.body.kind == ebm::TypeKind::VECTOR ||
            type.body.kind == ebm::TypeKind::STRUCT || type.body.kind == ebm::TypeKind::RECURSIVE_STRUCT) {
            MAYBE(typ_txt, dctx.visit(dctx.type));
            return CODE(typ_txt.to_string(), "{}");
        }
        // integers and floats default to 0 with type
        if (type.body.kind == ebm::TypeKind::INT || type.body.kind == ebm::TypeKind::UINT ||
            type.body.kind == ebm::TypeKind::FLOAT || type.body.kind == ebm::TypeKind::ENUM) {
            MAYBE(typ_txt, dctx.visit(dctx.type));
            return CODE(typ_txt.to_string(), "(0)");
        }
        if (type.body.kind == ebm::TypeKind::VARIANT) {
            if (auto memb = type.body.variant_desc(); memb && !is_nil(memb->common_type)) {
                return as_DEFAULT_VALUE(dctx, memb->common_type);
            }
            return CODE("nil");
        }
        // currently, optional uses inner type default
        if (type.body.kind == ebm::TypeKind::OPTIONAL) {
            MAYBE(inner_type, type.body.inner_type());
            return as_DEFAULT_VALUE(dctx, inner_type);
        }

        return pass;
    };
    ctx.config().append_visitor = [&](Context_Statement_APPEND& actx) -> expected<Result> {
        MAYBE(target, actx.visit(actx.target));
        MAYBE(value, actx.visit(actx.value));
        return CODELINE(target.to_writer(), " = append(", target.to_writer(), ", ", value.to_writer(), ")");
    };
    ctx.config().can_read_stream_visitor = [&](Context_Expression_CAN_READ_STREAM& cctx) -> expected<Result> {
        auto stream = cctx.identifier(cctx.io_ref);
        MAYBE(size_str, get_size_str(cctx, cctx.num_bytes));
        if (ctx.config().use_io_reader_writer) {
            if (size_str.to_string() == "1") {
                // In io.Reader mode, we cannot check remaining bytes without consuming.
                // For now, always return true and let io.ReadFull fail with io.ErrUnexpectedEOF.
                return CODE("true");
            }
            return CODE("true");
        }
        return CODE("len(", stream, ") >= ", size_str);
    };
    ctx.config().pointer_type_wrapper = [](Result r) -> expected<Result> {
        return CODE("*", r.to_writer());
    };
    ctx.config().make_pointer_wrapper = [](Result r) -> expected<Result> {
        return CODE("&", r.to_writer());
    };
    ctx.config().default_value_option.pointer_init = "nil";
    ctx.config().default_value_option.decoder_return_init = "nil";
    ctx.config().default_value_option.encoder_return_init = "nil";
    ctx.config().conditional_loop_keyword = "for";
    ctx.config().infinity_loop_keyword = "for";

    ctx.config().append_function = "append";
    ctx.config().usize_type_name = "int";
    ctx.config().surrounded_array_size = true;
    ctx.config().use_brace_for_condition = false;

    ctx.config().alt_unary_op[ebm::UnaryOp::bit_not] = "^";

    ctx.config().conditional_visitor = [&](Context_Expression_CONDITIONAL& cctx) -> expected<Result> {
        MAYBE(cond_str, ctx.visit(cctx.condition));
        MAYBE(then_str, ctx.visit(cctx.then));
        MAYBE(else_str, ctx.visit(cctx.else_));
        MAYBE(type_str, ctx.visit(cctx.type));
        return CODE("func() ", type_str.to_writer(), " { if ", tidy_condition_brace(cond_str.to_string()),
                    " { return ", tidy_condition_brace(then_str.to_string()),
                    " } else { return ", tidy_condition_brace(else_str.to_string()), " } }()");
    };
    ctx.config().expression_memoization_config.enable = true;
    ctx.config().expression_memoization_config.target_kinds = {
        ebm::ExpressionKind::BINARY_OP,
        ebm::ExpressionKind::UNARY_OP,
        ebm::ExpressionKind::LITERAL_INT,
        ebm::ExpressionKind::LITERAL_INT64,
    };
    ctx.config().type_memoization_config.enable = true;
    ctx.config().type_memoization_config.target_kind_as_exclusive = true;
    ctx.config().type_memoization_config.target_kinds = {
        ebm::TypeKind::ARRAY,
        ebm::TypeKind::ENCODER_INPUT,
        ebm::TypeKind::DECODER_INPUT,
        ebm::TypeKind::ENCODER_RETURN,
    };
    return pass;
}
