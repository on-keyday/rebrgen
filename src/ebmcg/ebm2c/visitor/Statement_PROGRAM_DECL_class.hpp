/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_PROGRAM_DECL_class
  Available Variables:
    ctx: Context_Statement_PROGRAM_DECL
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        module_: ebmgen::MappingTable
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
      item_id: ebm::StatementRef
      kind: const ebm::StatementKind&
      block: const ebm::Block&
        len: Varint
        container: std::vector<StatementRef>
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include "../codegen.hpp"
DEFINE_VISITOR_CLASS(Statement_PROGRAM_DECL) {
    using Context = CODEGEN_CONTEXT(Statement_PROGRAM_DECL);
    DEFINE_VISITOR_FUNCTION(Statement_PROGRAM_DECL) {
        using namespace CODEGEN_NAMESPACE;
        std::vector<ebm2c::Struct> structs;
        collect_structs(ctx, structs);
        CodeWriter w;
        for (auto& s : structs) {
            auto ident = ctx.identifier(s.id);
            w.writeln("struct ", ident, " {");
            for (auto& f : s.fields) {
                auto field_ident = ctx.identifier(f.id);
                w.writeln("    int ", field_ident, ";");
            }
            w.writeln("};");
            w.writeln("");
        }
        /*here to write the hook*/
        return w;
    };

    void collect_structs(Context & ctx, std::vector<ebm2c::Struct> & structs) {
        for (auto stmt_ref : ctx.block.container) {
            auto struct_ = ctx.get_field<"struct_decl">(stmt_ref);
            if (!struct_) {
                continue;
            }
            ebm2c::Struct s{.id = stmt_ref};
            for (auto field_ref : struct_->fields.container) {
                ebm2c::Field f;
                f.id = field_ref;
                s.fields.push_back(f);
            }
            structs.push_back(s);
        }
        for (auto& s : ctx.module().module().types) {
        }
    }
};
