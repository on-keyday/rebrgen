/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_FUNCTION_DECL_class
  Available Variables:
    ctx: Context_Statement_FUNCTION_DECL
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
        module_: ebmgen::MappingTable
      item_id: ebm::StatementRef
      kind: const ebm::StatementKind&
      func_decl: const ebm::FunctionDecl&
        name: IdentifierRef
        return_type: TypeRef
        params: Block
          len: Varint
          container: std::vector<StatementRef>
        parent_format: WeakStatementRef
        kind: FunctionKind
        property: *WeakStatementRef
        body: StatementRef
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include "../codegen.hpp"
DEFINE_VISITOR(Statement_FUNCTION_DECL) {
    CodeWriter w;
    auto func_name = ctx.identifier(ctx.item_id);
    MAYBE(return_type_str, ctx.visit(ctx.func_decl.return_type));

    std::string params_str = "self";

    std::vector<ebm::StatementRef> state_params;
    std::string multi_arg;

    for (auto& param_stmt_ref : ctx.func_decl.params.container) {
        MAYBE(param_stmt, ctx.get(param_stmt_ref));
        MAYBE(param_decl, param_stmt.body.param_decl());

        auto param_name = ctx.identifier(param_stmt_ref);
        MAYBE(param_type_str, ctx.visit(param_decl.param_type));

        if (param_decl.is_state_variable()) {
            state_params.push_back(param_stmt_ref);
            if (multi_arg != "") {
                multi_arg += ",";
            }
            multi_arg += param_name;
            params_str += ", " + std::string(param_name) + ": \"" + param_type_str.to_string() + "| None\" = None";
        }
        else {
            params_str += ", " + std::string(param_name) + ": \"" + param_type_str.to_string() + "\"";
        }
    }

    if (multi_arg.empty()) {
        if (ctx.func_decl.kind == ebm::FunctionKind::PROPERTY_GETTER) {
            w.writeln("@property");
        }
        else if (ctx.func_decl.kind == ebm::FunctionKind::PROPERTY_SETTER) {
            w.writeln("@", func_name, ".setter");
        }
    }
    else {
        if (auto prop = ctx.func_decl.property()) {
            ctx.config().multi_arg_property[get_id(*prop)] = multi_arg;
        }
        if (ctx.func_decl.kind == ebm::FunctionKind::PROPERTY_SETTER) {
            func_name = "set_" + func_name;
        }
    }
    w.writeln("def ", func_name, "(", params_str, ") -> \"", return_type_str.to_writer(), "\":");
    auto scope = w.indent_scope();

    for (auto& param_stmt_ref : state_params) {
        auto state_name = ctx.identifier(param_stmt_ref);
        MAYBE(param_stmt, ctx.get(param_stmt_ref));
        MAYBE(param_decl, param_stmt.body.param_decl());
        MAYBE(type_res, ctx.visit(param_decl.param_type));
        w.writeln("if ", state_name, " is None:");
        w.indent_writeln(state_name, " = ", type_res.to_writer(), "()");
    }

    MAYBE(res, ctx.visit(ctx.func_decl.body));
    if (res.to_writer().empty()) {
        w.writeln("pass");
    }
    else {
        w.write(res.to_writer());
    }

    return w;
}