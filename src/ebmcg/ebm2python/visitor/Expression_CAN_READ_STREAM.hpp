/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Expression_CAN_READ_STREAM
  Available variables:
    *this: Visitor
    module_: MappingTable
    item_id: ExpressionRef
    type: TypeRef
    kind: ExpressionKind
    io_ref: StatementRef
    num_bytes: Size
      unit: SizeUnit
      ref: *ExpressionRef
      size: *Varint
    stream_type: StreamType
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

/*here to write the hook*/
auto io_val = module_.get_associated_identifier(io_ref);

MAYBE(size_str, get_size_str(*this, num_bytes));

bool only_one_byte = size_str == "1";
auto tmp_id = std::format("{}", get_id(item_id));
auto current_offset = std::format("current_offset_{}", tmp_id);
auto end_offset = std::format("end_offset_{}", tmp_id);
auto result = std::format("result_{}", tmp_id);

auto peek_pattern = CODELINE(result, " = builtins.len(", io_val, ".peek(", size_str, "))");
auto seek_pattern = CODE(
    current_offset, " = ", io_val, ".tell()", CODELINE(),
    end_offset, " = ", io_val, ".seek(0,2)", CODELINE(),
    io_val, ".seek(", current_offset, ")", CODELINE(),
    result, " = ", end_offset, " - ", current_offset, CODELINE());

CodeWriter w;
w.writeln("if isinstance(", io_val, ", io.BytesIO) and ", io_val, ".seekable():");
{
    auto scope = w.indent_scope();
    w.writeln(seek_pattern);
}
w.writeln("elif isinstance(", io_val, ", io.BufferedReader):");
{
    auto scope = w.indent_scope();
    w.writeln(peek_pattern);
}
w.writeln("else:");
{
    auto scope = w.indent_scope();
    w.writeln("raise ValueError(\"Unsupported stream type for CAN_READ_STREAM\")");
}
MAYBE(got_writer, get_writer());
got_writer.write(std::move(w));

return CODE("bool(", result, " >= ", size_str, ")");
