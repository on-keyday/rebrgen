/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Expression_CALL_before_class
  Available Variables:
    ctx: Context_Expression_CALL_before<Result>
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        module_: ebmgen::MappingTable
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
      item_id: ebm::ExpressionRef
      type: const ebm::TypeRef&
      kind: const ebm::ExpressionKind&
      call_desc: const ebm::CallDesc&
        callee: ExpressionRef
        arguments: Expressions
          len: Varint
          container: std::vector<ExpressionRef>
      main_logic: ebmcodegen::util::MainLogicWrapper<Result>
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include "../codegen.hpp"
DEFINE_VISITOR(Expression_CALL_before) {
    using namespace CODEGEN_NAMESPACE;
    MAYBE(callee, ctx.get_field<"call_desc.callee.instance">());
    if (auto member = callee.body.member()) {
        MAYBE(base, callee.body.base());
        MAYBE(base_type, ctx.get_field<"type.instance">(base))
        MAYBE(ident, ctx.identifier(*member));
        MAYBE(base_type_name, ctx.identifier(base_type.id));
        MAYBE(base_str, ctx.visit(base));
        if (ctx.config().on_destructor_generation && ident == "encode") {
            ident = "free";
        }
        auto func_name = std::format("{}_{}", base_type_name, ident);
        CodeWriter w;
        std::string address = base_type.body.kind == ebm::TypeKind::RECURSIVE_STRUCT ? "" : "&";
        w.write(func_name, "(", address, base_str.to_writer());
        for (const auto& arg_ref : ctx.call_desc.arguments.container) {
            MAYBE(arg, ctx.visit(arg_ref));
            w.write(", ", arg.to_writer());
        }
        w.write(")");
        return w;
    }
    return pass;
}
