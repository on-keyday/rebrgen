/*license*/
// Code generated by ebmcodegen at https://github.com/on-keyday/rebrgen
// DO NOT EDIT THIS FILE MANUALLY. you should edit visitor implementation files instead.
#include <ebmcodegen/stub/context.hpp>
#include <ebmcodegen/stub/visitor.hpp>
#include <ebmgen/common.hpp>
#include <ebmgen/convert/helper.hpp>
#include <ebmgen/mapping.hpp>
#include <code/code_writer.h>
#include <ebmcodegen/stub/code_writer.hpp>
#include <ebmcodegen/stub/writer_manager.hpp>
#include <ebmcodegen/stub/writer_manager.hpp>
#include <concepts>
#include <strutil/append.h>
// This is a measure to prevent any impact on compilation even if a user mistakenly changes something like #include "lang/codegen.hpp" to #include "other_lang/codegen.hpp".
#ifndef EBM_CODEGEN_COMMON_INCLUDE_GUARD
#define EBM_CODEGEN_COMMON_INCLUDE_GUARD 1
namespace ebmgen::visitor {
    using namespace ebmgen;
    using namespace ebmcodegen::util;
    
    struct Result {
    };
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_entry(Context&& ctx);
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_entry(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_pre_visitor(Context&& ctx,ebm::ExtendedBinaryModule& ebm);
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_pre_visitor(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_post_entry(Context&& ctx,expected<Result>& entry_result);
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_post_entry(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_BLOCK(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_BLOCK(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_ASSIGNMENT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ASSIGNMENT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_YIELD(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_YIELD(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_APPEND(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_APPEND(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_RETURN(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_RETURN(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_ERROR_RETURN(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ERROR_RETURN(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_ASSERT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ASSERT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_READ_DATA(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_READ_DATA(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_WRITE_DATA(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_WRITE_DATA(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_RESERVE_DATA(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_RESERVE_DATA(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_IF_STATEMENT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_IF_STATEMENT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_LOOP_STATEMENT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_LOOP_STATEMENT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_MATCH_STATEMENT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_MATCH_STATEMENT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_MATCH_BRANCH(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_MATCH_BRANCH(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_BREAK(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_BREAK(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_CONTINUE(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_CONTINUE(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_FUNCTION_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_FUNCTION_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_VARIABLE_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_VARIABLE_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_PARAMETER_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_PARAMETER_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_FIELD_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_FIELD_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_COMPOSITE_FIELD_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_COMPOSITE_FIELD_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_ENUM_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ENUM_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_ENUM_MEMBER_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ENUM_MEMBER_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_STRUCT_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_STRUCT_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_UNION_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_UNION_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_UNION_MEMBER_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_UNION_MEMBER_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_PROGRAM_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_PROGRAM_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_PROPERTY_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_PROPERTY_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_PROPERTY_MEMBER_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_PROPERTY_MEMBER_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_METADATA(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_METADATA(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_IMPORT_MODULE(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_IMPORT_MODULE(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_EXPRESSION(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_EXPRESSION(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_ERROR_REPORT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ERROR_REPORT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_LOWERED_IO_STATEMENTS(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_LOWERED_IO_STATEMENTS(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_SUB_BYTE_RANGE(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_SUB_BYTE_RANGE(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_INIT_CHECK(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_INIT_CHECK(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_ENDIAN_VARIABLE(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ENDIAN_VARIABLE(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_ARRAY_TO_INT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ARRAY_TO_INT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_INT_TO_ARRAY(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_INT_TO_ARRAY(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename Context>
    expected<Result> dispatch_Statement_default(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {}) {
        switch(in.body.kind) {
            case ebm::StatementKind::BLOCK: {
                return dispatch_Statement_BLOCK<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::ASSIGNMENT: {
                return dispatch_Statement_ASSIGNMENT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::YIELD: {
                return dispatch_Statement_YIELD<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::APPEND: {
                return dispatch_Statement_APPEND<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::RETURN: {
                return dispatch_Statement_RETURN<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::ERROR_RETURN: {
                return dispatch_Statement_ERROR_RETURN<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::ASSERT: {
                return dispatch_Statement_ASSERT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::READ_DATA: {
                return dispatch_Statement_READ_DATA<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::WRITE_DATA: {
                return dispatch_Statement_WRITE_DATA<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::RESERVE_DATA: {
                return dispatch_Statement_RESERVE_DATA<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::IF_STATEMENT: {
                return dispatch_Statement_IF_STATEMENT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::LOOP_STATEMENT: {
                return dispatch_Statement_LOOP_STATEMENT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::MATCH_STATEMENT: {
                return dispatch_Statement_MATCH_STATEMENT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::MATCH_BRANCH: {
                return dispatch_Statement_MATCH_BRANCH<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::BREAK: {
                return dispatch_Statement_BREAK<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::CONTINUE: {
                return dispatch_Statement_CONTINUE<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::FUNCTION_DECL: {
                return dispatch_Statement_FUNCTION_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::VARIABLE_DECL: {
                return dispatch_Statement_VARIABLE_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::PARAMETER_DECL: {
                return dispatch_Statement_PARAMETER_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::FIELD_DECL: {
                return dispatch_Statement_FIELD_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::COMPOSITE_FIELD_DECL: {
                return dispatch_Statement_COMPOSITE_FIELD_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::ENUM_DECL: {
                return dispatch_Statement_ENUM_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::ENUM_MEMBER_DECL: {
                return dispatch_Statement_ENUM_MEMBER_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::STRUCT_DECL: {
                return dispatch_Statement_STRUCT_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::UNION_DECL: {
                return dispatch_Statement_UNION_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::UNION_MEMBER_DECL: {
                return dispatch_Statement_UNION_MEMBER_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::PROGRAM_DECL: {
                return dispatch_Statement_PROGRAM_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::PROPERTY_DECL: {
                return dispatch_Statement_PROPERTY_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::PROPERTY_MEMBER_DECL: {
                return dispatch_Statement_PROPERTY_MEMBER_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::METADATA: {
                return dispatch_Statement_METADATA<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::IMPORT_MODULE: {
                return dispatch_Statement_IMPORT_MODULE<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::EXPRESSION: {
                return dispatch_Statement_EXPRESSION<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::ERROR_REPORT: {
                return dispatch_Statement_ERROR_REPORT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::LOWERED_IO_STATEMENTS: {
                return dispatch_Statement_LOWERED_IO_STATEMENTS<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::SUB_BYTE_RANGE: {
                return dispatch_Statement_SUB_BYTE_RANGE<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::INIT_CHECK: {
                return dispatch_Statement_INIT_CHECK<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::ENDIAN_VARIABLE: {
                return dispatch_Statement_ENDIAN_VARIABLE<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::ARRAY_TO_INT: {
                return dispatch_Statement_ARRAY_TO_INT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::INT_TO_ARRAY: {
                return dispatch_Statement_INT_TO_ARRAY<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            default: {
                return unexpect_error("Unknown Statement kind: {}", to_string(in.body.kind));
            }
        }
    }
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Block(Context&& ctx,const ebm::Block& in);
    template<typename Result>
    struct ListDispatcher_Block {
        template<typename Context>
        expected<void> on_dispatch(Context&& ctx,const ebm::Block& in,expected<Result>&& result) {
            if (!result) {
                return unexpect_error(std::move(result.error()));
            }
            return {}; // Default no-op implementation
        }
        template<typename Context>
        expected<Result> finalize(Context&& ctx, const ebm::Block& in) {
            return {}; // Default no-op implementation
        }
    };
    
    template<typename Result = Result, typename Context>
    expected<Result> dispatch_Block_default(Context&& ctx,const ebm::Block& in) {
        ListDispatcher_Block<Result> dispatcher;
        for(auto& elem:in.container) {
            auto result = visit_Statement<Result>(ctx,elem);
            MAYBE_VOID(dispatch,dispatcher.on_dispatch(std::forward<Context>(ctx),in,std::move(result)));
        }
        return dispatcher.finalize(std::forward<Context>(ctx),in);
    }
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Block(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_LITERAL_INT(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_LITERAL_INT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_LITERAL_INT64(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_LITERAL_INT64(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_LITERAL_BOOL(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_LITERAL_BOOL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_LITERAL_STRING(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_LITERAL_STRING(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_LITERAL_TYPE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_LITERAL_TYPE(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_LITERAL_CHAR(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_LITERAL_CHAR(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_IDENTIFIER(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_IDENTIFIER(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_BINARY_OP(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_BINARY_OP(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_UNARY_OP(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_UNARY_OP(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_CALL(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_CALL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_INDEX_ACCESS(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_INDEX_ACCESS(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_MEMBER_ACCESS(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_MEMBER_ACCESS(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_ENUM_MEMBER(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_ENUM_MEMBER(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_TYPE_CAST(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_TYPE_CAST(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_RANGE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_RANGE(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_DEFAULT_VALUE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_DEFAULT_VALUE(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_IS_LITTLE_ENDIAN(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_IS_LITTLE_ENDIAN(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_GET_STREAM_OFFSET(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_GET_STREAM_OFFSET(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_GET_REMAINING_BYTES(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_GET_REMAINING_BYTES(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_CAN_READ_STREAM(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_CAN_READ_STREAM(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_ARRAY_SIZE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_ARRAY_SIZE(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_ENUM_IS_DEFINED(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_ENUM_IS_DEFINED(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_IS_ERROR(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_IS_ERROR(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_MAX_VALUE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_MAX_VALUE(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_READ_DATA(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_READ_DATA(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_WRITE_DATA(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_WRITE_DATA(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_CONDITIONAL_STATEMENT(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_CONDITIONAL_STATEMENT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_CONDITIONAL(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_CONDITIONAL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_AVAILABLE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_AVAILABLE(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_SIZEOF(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_SIZEOF(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_SUB_RANGE_INIT(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_SUB_RANGE_INIT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_OR_COND(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_OR_COND(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_ADDRESS_OF(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_ADDRESS_OF(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_OPTIONAL_OF(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_OPTIONAL_OF(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_SETTER_STATUS(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_SETTER_STATUS(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_SELF(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_SELF(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_AS_ARG(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_AS_ARG(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename Context>
    expected<Result> dispatch_Expression_default(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {}) {
        switch(in.body.kind) {
            case ebm::ExpressionKind::LITERAL_INT: {
                return dispatch_Expression_LITERAL_INT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::LITERAL_INT64: {
                return dispatch_Expression_LITERAL_INT64<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::LITERAL_BOOL: {
                return dispatch_Expression_LITERAL_BOOL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::LITERAL_STRING: {
                return dispatch_Expression_LITERAL_STRING<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::LITERAL_TYPE: {
                return dispatch_Expression_LITERAL_TYPE<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::LITERAL_CHAR: {
                return dispatch_Expression_LITERAL_CHAR<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::IDENTIFIER: {
                return dispatch_Expression_IDENTIFIER<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::BINARY_OP: {
                return dispatch_Expression_BINARY_OP<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::UNARY_OP: {
                return dispatch_Expression_UNARY_OP<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::CALL: {
                return dispatch_Expression_CALL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::INDEX_ACCESS: {
                return dispatch_Expression_INDEX_ACCESS<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::MEMBER_ACCESS: {
                return dispatch_Expression_MEMBER_ACCESS<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::ENUM_MEMBER: {
                return dispatch_Expression_ENUM_MEMBER<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::TYPE_CAST: {
                return dispatch_Expression_TYPE_CAST<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::RANGE: {
                return dispatch_Expression_RANGE<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::DEFAULT_VALUE: {
                return dispatch_Expression_DEFAULT_VALUE<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::IS_LITTLE_ENDIAN: {
                return dispatch_Expression_IS_LITTLE_ENDIAN<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::GET_STREAM_OFFSET: {
                return dispatch_Expression_GET_STREAM_OFFSET<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::GET_REMAINING_BYTES: {
                return dispatch_Expression_GET_REMAINING_BYTES<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::CAN_READ_STREAM: {
                return dispatch_Expression_CAN_READ_STREAM<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::ARRAY_SIZE: {
                return dispatch_Expression_ARRAY_SIZE<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::ENUM_IS_DEFINED: {
                return dispatch_Expression_ENUM_IS_DEFINED<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::IS_ERROR: {
                return dispatch_Expression_IS_ERROR<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::MAX_VALUE: {
                return dispatch_Expression_MAX_VALUE<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::READ_DATA: {
                return dispatch_Expression_READ_DATA<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::WRITE_DATA: {
                return dispatch_Expression_WRITE_DATA<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::CONDITIONAL_STATEMENT: {
                return dispatch_Expression_CONDITIONAL_STATEMENT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::CONDITIONAL: {
                return dispatch_Expression_CONDITIONAL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::AVAILABLE: {
                return dispatch_Expression_AVAILABLE<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::SIZEOF: {
                return dispatch_Expression_SIZEOF<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::SUB_RANGE_INIT: {
                return dispatch_Expression_SUB_RANGE_INIT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::OR_COND: {
                return dispatch_Expression_OR_COND<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::ADDRESS_OF: {
                return dispatch_Expression_ADDRESS_OF<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::OPTIONAL_OF: {
                return dispatch_Expression_OPTIONAL_OF<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::SETTER_STATUS: {
                return dispatch_Expression_SETTER_STATUS<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::SELF: {
                return dispatch_Expression_SELF<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::AS_ARG: {
                return dispatch_Expression_AS_ARG<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            default: {
                return unexpect_error("Unknown Expression kind: {}", to_string(in.body.kind));
            }
        }
    }
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expressions(Context&& ctx,const ebm::Expressions& in);
    template<typename Result>
    struct ListDispatcher_Expressions {
        template<typename Context>
        expected<void> on_dispatch(Context&& ctx,const ebm::Expressions& in,expected<Result>&& result) {
            if (!result) {
                return unexpect_error(std::move(result.error()));
            }
            return {}; // Default no-op implementation
        }
        template<typename Context>
        expected<Result> finalize(Context&& ctx, const ebm::Expressions& in) {
            return {}; // Default no-op implementation
        }
    };
    
    template<typename Result = Result, typename Context>
    expected<Result> dispatch_Expressions_default(Context&& ctx,const ebm::Expressions& in) {
        ListDispatcher_Expressions<Result> dispatcher;
        for(auto& elem:in.container) {
            auto result = visit_Expression<Result>(ctx,elem);
            MAYBE_VOID(dispatch,dispatcher.on_dispatch(std::forward<Context>(ctx),in,std::move(result)));
        }
        return dispatcher.finalize(std::forward<Context>(ctx),in);
    }
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expressions(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_INT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_INT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_UINT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_UINT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_USIZE(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_USIZE(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_FLOAT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_FLOAT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_STRUCT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_STRUCT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_RECURSIVE_STRUCT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_RECURSIVE_STRUCT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_BOOL(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_BOOL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_VOID(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_VOID(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_META(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_META(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_ENUM(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_ENUM(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_ARRAY(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_ARRAY(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_VECTOR(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_VECTOR(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_VARIANT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_VARIANT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_RANGE(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_RANGE(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_ENCODER_RETURN(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_ENCODER_RETURN(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_DECODER_RETURN(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_DECODER_RETURN(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_ENCODER_INPUT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_ENCODER_INPUT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_DECODER_INPUT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_DECODER_INPUT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_PROPERTY_SETTER_RETURN(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_PROPERTY_SETTER_RETURN(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_OPTIONAL(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_OPTIONAL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_PTR(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_PTR(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_FUNCTION(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_FUNCTION(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename Context>
    expected<Result> dispatch_Type_default(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {}) {
        switch(in.body.kind) {
            case ebm::TypeKind::INT: {
                return dispatch_Type_INT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::UINT: {
                return dispatch_Type_UINT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::USIZE: {
                return dispatch_Type_USIZE<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::FLOAT: {
                return dispatch_Type_FLOAT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::STRUCT: {
                return dispatch_Type_STRUCT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::RECURSIVE_STRUCT: {
                return dispatch_Type_RECURSIVE_STRUCT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::BOOL: {
                return dispatch_Type_BOOL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::VOID: {
                return dispatch_Type_VOID<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::META: {
                return dispatch_Type_META<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::ENUM: {
                return dispatch_Type_ENUM<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::ARRAY: {
                return dispatch_Type_ARRAY<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::VECTOR: {
                return dispatch_Type_VECTOR<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::VARIANT: {
                return dispatch_Type_VARIANT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::RANGE: {
                return dispatch_Type_RANGE<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::ENCODER_RETURN: {
                return dispatch_Type_ENCODER_RETURN<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::DECODER_RETURN: {
                return dispatch_Type_DECODER_RETURN<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::ENCODER_INPUT: {
                return dispatch_Type_ENCODER_INPUT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::DECODER_INPUT: {
                return dispatch_Type_DECODER_INPUT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::PROPERTY_SETTER_RETURN: {
                return dispatch_Type_PROPERTY_SETTER_RETURN<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::OPTIONAL: {
                return dispatch_Type_OPTIONAL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::PTR: {
                return dispatch_Type_PTR<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::FUNCTION: {
                return dispatch_Type_FUNCTION<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            default: {
                return unexpect_error("Unknown Type kind: {}", to_string(in.body.kind));
            }
        }
    }
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Types(Context&& ctx,const ebm::Types& in);
    template<typename Result>
    struct ListDispatcher_Types {
        template<typename Context>
        expected<void> on_dispatch(Context&& ctx,const ebm::Types& in,expected<Result>&& result) {
            if (!result) {
                return unexpect_error(std::move(result.error()));
            }
            return {}; // Default no-op implementation
        }
        template<typename Context>
        expected<Result> finalize(Context&& ctx, const ebm::Types& in) {
            return {}; // Default no-op implementation
        }
    };
    
    template<typename Result = Result, typename Context>
    expected<Result> dispatch_Types_default(Context&& ctx,const ebm::Types& in) {
        ListDispatcher_Types<Result> dispatcher;
        for(auto& elem:in.container) {
            auto result = visit_Type<Result>(ctx,elem);
            MAYBE_VOID(dispatch,dispatcher.on_dispatch(std::forward<Context>(ctx),in,std::move(result)));
        }
        return dispatcher.finalize(std::forward<Context>(ctx),in);
    }
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Types(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result, typename UserContext, typename TypeContext>
    expected<Result> traverse_children(UserContext&& uctx, TypeContext&& type_ctx);
    // for backward compatibility
    
    // generic visitor for Statement
    template<typename Result = Result, typename Context>
    expected<Result> visit_Statement(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {}) {
        return dispatch_Statement<Result>(std::forward<Context>(ctx),in,alias_ref);
    }
    // short-hand visitor for Statement
    template<typename Result = Result, typename Context>
    expected<Result> visit_Statement(Context&& ctx,const ebm::StatementRef& ref) {
        MAYBE(elem, get_visitor_arg_from_context(ctx).module_.get_statement(ref));
        return dispatch_Statement<Result>(std::forward<Context>(ctx),elem,ref);
    }
    // for DSL convenience
    template<typename Result = Result, typename Context>
    expected<Result> visit_Object(Context&& ctx,const ebm::Statement& in, ebm::StatementRef alias_ref = {})  {
        return visit_Statement<Result>(std::forward<Context>(ctx),in,alias_ref);
    }
    // for DSL convenience
    template<typename Result = Result, typename Context>
    expected<Result> visit_Object(Context&& ctx, ebm::StatementRef ref)  {
        return visit_Statement<Result>(std::forward<Context>(ctx),ref);
    }
    // list visitor for Block
    template<typename Result = Result, typename Context>
    expected<Result> visit_Block(Context&& ctx,const ebm::Block& in) {
        return dispatch_Block<Result>(std::forward<Context>(ctx),in);
    }
    // for DSL convenience
    template<typename Result = Result, typename Context>
    expected<Result> visit_Object(Context&& ctx,const ebm::Block& in)  {
        return visit_Block<Result>(std::forward<Context>(ctx),in);
    }
    // generic visitor for Expression
    template<typename Result = Result, typename Context>
    expected<Result> visit_Expression(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {}) {
        return dispatch_Expression<Result>(std::forward<Context>(ctx),in,alias_ref);
    }
    // short-hand visitor for Expression
    template<typename Result = Result, typename Context>
    expected<Result> visit_Expression(Context&& ctx,const ebm::ExpressionRef& ref) {
        MAYBE(elem, get_visitor_arg_from_context(ctx).module_.get_expression(ref));
        return dispatch_Expression<Result>(std::forward<Context>(ctx),elem,ref);
    }
    // for DSL convenience
    template<typename Result = Result, typename Context>
    expected<Result> visit_Object(Context&& ctx,const ebm::Expression& in, ebm::ExpressionRef alias_ref = {})  {
        return visit_Expression<Result>(std::forward<Context>(ctx),in,alias_ref);
    }
    // for DSL convenience
    template<typename Result = Result, typename Context>
    expected<Result> visit_Object(Context&& ctx, ebm::ExpressionRef ref)  {
        return visit_Expression<Result>(std::forward<Context>(ctx),ref);
    }
    // list visitor for Expressions
    template<typename Result = Result, typename Context>
    expected<Result> visit_Expressions(Context&& ctx,const ebm::Expressions& in) {
        return dispatch_Expressions<Result>(std::forward<Context>(ctx),in);
    }
    // for DSL convenience
    template<typename Result = Result, typename Context>
    expected<Result> visit_Object(Context&& ctx,const ebm::Expressions& in)  {
        return visit_Expressions<Result>(std::forward<Context>(ctx),in);
    }
    // generic visitor for Type
    template<typename Result = Result, typename Context>
    expected<Result> visit_Type(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {}) {
        return dispatch_Type<Result>(std::forward<Context>(ctx),in,alias_ref);
    }
    // short-hand visitor for Type
    template<typename Result = Result, typename Context>
    expected<Result> visit_Type(Context&& ctx,const ebm::TypeRef& ref) {
        MAYBE(elem, get_visitor_arg_from_context(ctx).module_.get_type(ref));
        return dispatch_Type<Result>(std::forward<Context>(ctx),elem,ref);
    }
    // for DSL convenience
    template<typename Result = Result, typename Context>
    expected<Result> visit_Object(Context&& ctx,const ebm::Type& in, ebm::TypeRef alias_ref = {})  {
        return visit_Type<Result>(std::forward<Context>(ctx),in,alias_ref);
    }
    // for DSL convenience
    template<typename Result = Result, typename Context>
    expected<Result> visit_Object(Context&& ctx, ebm::TypeRef ref)  {
        return visit_Type<Result>(std::forward<Context>(ctx),ref);
    }
    // list visitor for Types
    template<typename Result = Result, typename Context>
    expected<Result> visit_Types(Context&& ctx,const ebm::Types& in) {
        return dispatch_Types<Result>(std::forward<Context>(ctx),in);
    }
    // for DSL convenience
    template<typename Result = Result, typename Context>
    expected<Result> visit_Object(Context&& ctx,const ebm::Types& in)  {
        return visit_Types<Result>(std::forward<Context>(ctx),in);
    }
    template<class R = void, typename Context,typename Callback>
    R get_visitor_impl(Context&& ctx,Callback&& cb);
    struct BaseVisitor {
        BaseVisitor(ebmgen::EBMProxy module_) :module_(module_, ebmgen::lazy_init){}
        ebmgen::MappingTable module_;
    };
    template<typename V>
    concept BaseVisitorLike = std::derived_from<V,BaseVisitor>;
    struct InitialContext : ebmcodegen::util::ContextBase<InitialContext> {
        BaseVisitor& visitor;
    };
    template<typename Tag>
    struct Visitor; // Customization point struct
    struct Context_entry : ebmcodegen::util::ContextBase<Context_entry> {
        constexpr static std::string_view context_name = "entry";
        BaseVisitor& visitor;
    };
    template <typename Result>
    struct Context_entry_before : ebmcodegen::util::ContextBase<Context_entry_before<Result>> {
        constexpr static std::string_view context_name = "entry_before";
        BaseVisitor& visitor;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_entry_after : ebmcodegen::util::ContextBase<Context_entry_after<Result>> {
        constexpr static std::string_view context_name = "entry_after";
        BaseVisitor& visitor;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_pre_visitor : ebmcodegen::util::ContextBase<Context_pre_visitor> {
        constexpr static std::string_view context_name = "pre_visitor";
        BaseVisitor& visitor;
        ebm::ExtendedBinaryModule& ebm;
    };
    template <typename Result>
    struct Context_pre_visitor_before : ebmcodegen::util::ContextBase<Context_pre_visitor_before<Result>> {
        constexpr static std::string_view context_name = "pre_visitor_before";
        BaseVisitor& visitor;
        ebm::ExtendedBinaryModule& ebm;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_pre_visitor_after : ebmcodegen::util::ContextBase<Context_pre_visitor_after<Result>> {
        constexpr static std::string_view context_name = "pre_visitor_after";
        BaseVisitor& visitor;
        ebm::ExtendedBinaryModule& ebm;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    template <typename Result>
    struct Context_post_entry : ebmcodegen::util::ContextBase<Context_post_entry<Result>> {
        constexpr static std::string_view context_name = "post_entry";
        BaseVisitor& visitor;
        expected<Result>& entry_result;
    };
    template <typename Result>
    struct Context_post_entry_before : ebmcodegen::util::ContextBase<Context_post_entry_before<Result>> {
        constexpr static std::string_view context_name = "post_entry_before";
        BaseVisitor& visitor;
        expected<Result>& entry_result;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_post_entry_after : ebmcodegen::util::ContextBase<Context_post_entry_after<Result>> {
        constexpr static std::string_view context_name = "post_entry_after";
        BaseVisitor& visitor;
        expected<Result>& entry_result;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_BLOCK : ebmcodegen::util::ContextBase<Context_Statement_BLOCK> {
        constexpr static std::string_view context_name = "Statement_BLOCK";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Block& block;
    };
    template <typename Result>
    struct Context_Statement_BLOCK_before : ebmcodegen::util::ContextBase<Context_Statement_BLOCK_before<Result>> {
        constexpr static std::string_view context_name = "Statement_BLOCK_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Block& block;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_BLOCK_after : ebmcodegen::util::ContextBase<Context_Statement_BLOCK_after<Result>> {
        constexpr static std::string_view context_name = "Statement_BLOCK_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Block& block;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_ASSIGNMENT : ebmcodegen::util::ContextBase<Context_Statement_ASSIGNMENT> {
        constexpr static std::string_view context_name = "Statement_ASSIGNMENT";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::WeakStatementRef& previous_assignment;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
    };
    template <typename Result>
    struct Context_Statement_ASSIGNMENT_before : ebmcodegen::util::ContextBase<Context_Statement_ASSIGNMENT_before<Result>> {
        constexpr static std::string_view context_name = "Statement_ASSIGNMENT_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::WeakStatementRef& previous_assignment;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_ASSIGNMENT_after : ebmcodegen::util::ContextBase<Context_Statement_ASSIGNMENT_after<Result>> {
        constexpr static std::string_view context_name = "Statement_ASSIGNMENT_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::WeakStatementRef& previous_assignment;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_YIELD : ebmcodegen::util::ContextBase<Context_Statement_YIELD> {
        constexpr static std::string_view context_name = "Statement_YIELD";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::WeakStatementRef& previous_assignment;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
    };
    template <typename Result>
    struct Context_Statement_YIELD_before : ebmcodegen::util::ContextBase<Context_Statement_YIELD_before<Result>> {
        constexpr static std::string_view context_name = "Statement_YIELD_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::WeakStatementRef& previous_assignment;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_YIELD_after : ebmcodegen::util::ContextBase<Context_Statement_YIELD_after<Result>> {
        constexpr static std::string_view context_name = "Statement_YIELD_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::WeakStatementRef& previous_assignment;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_APPEND : ebmcodegen::util::ContextBase<Context_Statement_APPEND> {
        constexpr static std::string_view context_name = "Statement_APPEND";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
    };
    template <typename Result>
    struct Context_Statement_APPEND_before : ebmcodegen::util::ContextBase<Context_Statement_APPEND_before<Result>> {
        constexpr static std::string_view context_name = "Statement_APPEND_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_APPEND_after : ebmcodegen::util::ContextBase<Context_Statement_APPEND_after<Result>> {
        constexpr static std::string_view context_name = "Statement_APPEND_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_RETURN : ebmcodegen::util::ContextBase<Context_Statement_RETURN> {
        constexpr static std::string_view context_name = "Statement_RETURN";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::WeakStatementRef& related_function;
        const ebm::ExpressionRef& value;
    };
    template <typename Result>
    struct Context_Statement_RETURN_before : ebmcodegen::util::ContextBase<Context_Statement_RETURN_before<Result>> {
        constexpr static std::string_view context_name = "Statement_RETURN_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::WeakStatementRef& related_function;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_RETURN_after : ebmcodegen::util::ContextBase<Context_Statement_RETURN_after<Result>> {
        constexpr static std::string_view context_name = "Statement_RETURN_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::WeakStatementRef& related_function;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_ERROR_RETURN : ebmcodegen::util::ContextBase<Context_Statement_ERROR_RETURN> {
        constexpr static std::string_view context_name = "Statement_ERROR_RETURN";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::WeakStatementRef& related_field;
        const ebm::WeakStatementRef& related_function;
        const ebm::ExpressionRef& value;
    };
    template <typename Result>
    struct Context_Statement_ERROR_RETURN_before : ebmcodegen::util::ContextBase<Context_Statement_ERROR_RETURN_before<Result>> {
        constexpr static std::string_view context_name = "Statement_ERROR_RETURN_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::WeakStatementRef& related_field;
        const ebm::WeakStatementRef& related_function;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_ERROR_RETURN_after : ebmcodegen::util::ContextBase<Context_Statement_ERROR_RETURN_after<Result>> {
        constexpr static std::string_view context_name = "Statement_ERROR_RETURN_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::WeakStatementRef& related_field;
        const ebm::WeakStatementRef& related_function;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_ASSERT : ebmcodegen::util::ContextBase<Context_Statement_ASSERT> {
        constexpr static std::string_view context_name = "Statement_ASSERT";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::AssertDesc& assert_desc;
    };
    template <typename Result>
    struct Context_Statement_ASSERT_before : ebmcodegen::util::ContextBase<Context_Statement_ASSERT_before<Result>> {
        constexpr static std::string_view context_name = "Statement_ASSERT_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::AssertDesc& assert_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_ASSERT_after : ebmcodegen::util::ContextBase<Context_Statement_ASSERT_after<Result>> {
        constexpr static std::string_view context_name = "Statement_ASSERT_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::AssertDesc& assert_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_READ_DATA : ebmcodegen::util::ContextBase<Context_Statement_READ_DATA> {
        constexpr static std::string_view context_name = "Statement_READ_DATA";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IOData& read_data;
    };
    template <typename Result>
    struct Context_Statement_READ_DATA_before : ebmcodegen::util::ContextBase<Context_Statement_READ_DATA_before<Result>> {
        constexpr static std::string_view context_name = "Statement_READ_DATA_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IOData& read_data;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_READ_DATA_after : ebmcodegen::util::ContextBase<Context_Statement_READ_DATA_after<Result>> {
        constexpr static std::string_view context_name = "Statement_READ_DATA_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IOData& read_data;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_WRITE_DATA : ebmcodegen::util::ContextBase<Context_Statement_WRITE_DATA> {
        constexpr static std::string_view context_name = "Statement_WRITE_DATA";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IOData& write_data;
    };
    template <typename Result>
    struct Context_Statement_WRITE_DATA_before : ebmcodegen::util::ContextBase<Context_Statement_WRITE_DATA_before<Result>> {
        constexpr static std::string_view context_name = "Statement_WRITE_DATA_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IOData& write_data;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_WRITE_DATA_after : ebmcodegen::util::ContextBase<Context_Statement_WRITE_DATA_after<Result>> {
        constexpr static std::string_view context_name = "Statement_WRITE_DATA_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IOData& write_data;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_RESERVE_DATA : ebmcodegen::util::ContextBase<Context_Statement_RESERVE_DATA> {
        constexpr static std::string_view context_name = "Statement_RESERVE_DATA";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ReserveData& reserve_data;
    };
    template <typename Result>
    struct Context_Statement_RESERVE_DATA_before : ebmcodegen::util::ContextBase<Context_Statement_RESERVE_DATA_before<Result>> {
        constexpr static std::string_view context_name = "Statement_RESERVE_DATA_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ReserveData& reserve_data;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_RESERVE_DATA_after : ebmcodegen::util::ContextBase<Context_Statement_RESERVE_DATA_after<Result>> {
        constexpr static std::string_view context_name = "Statement_RESERVE_DATA_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ReserveData& reserve_data;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_IF_STATEMENT : ebmcodegen::util::ContextBase<Context_Statement_IF_STATEMENT> {
        constexpr static std::string_view context_name = "Statement_IF_STATEMENT";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IfStatement& if_statement;
    };
    template <typename Result>
    struct Context_Statement_IF_STATEMENT_before : ebmcodegen::util::ContextBase<Context_Statement_IF_STATEMENT_before<Result>> {
        constexpr static std::string_view context_name = "Statement_IF_STATEMENT_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IfStatement& if_statement;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_IF_STATEMENT_after : ebmcodegen::util::ContextBase<Context_Statement_IF_STATEMENT_after<Result>> {
        constexpr static std::string_view context_name = "Statement_IF_STATEMENT_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IfStatement& if_statement;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_LOOP_STATEMENT : ebmcodegen::util::ContextBase<Context_Statement_LOOP_STATEMENT> {
        constexpr static std::string_view context_name = "Statement_LOOP_STATEMENT";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopStatement& loop;
    };
    template <typename Result>
    struct Context_Statement_LOOP_STATEMENT_before : ebmcodegen::util::ContextBase<Context_Statement_LOOP_STATEMENT_before<Result>> {
        constexpr static std::string_view context_name = "Statement_LOOP_STATEMENT_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopStatement& loop;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_LOOP_STATEMENT_after : ebmcodegen::util::ContextBase<Context_Statement_LOOP_STATEMENT_after<Result>> {
        constexpr static std::string_view context_name = "Statement_LOOP_STATEMENT_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopStatement& loop;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_MATCH_STATEMENT : ebmcodegen::util::ContextBase<Context_Statement_MATCH_STATEMENT> {
        constexpr static std::string_view context_name = "Statement_MATCH_STATEMENT";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::MatchStatement& match_statement;
    };
    template <typename Result>
    struct Context_Statement_MATCH_STATEMENT_before : ebmcodegen::util::ContextBase<Context_Statement_MATCH_STATEMENT_before<Result>> {
        constexpr static std::string_view context_name = "Statement_MATCH_STATEMENT_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::MatchStatement& match_statement;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_MATCH_STATEMENT_after : ebmcodegen::util::ContextBase<Context_Statement_MATCH_STATEMENT_after<Result>> {
        constexpr static std::string_view context_name = "Statement_MATCH_STATEMENT_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::MatchStatement& match_statement;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_MATCH_BRANCH : ebmcodegen::util::ContextBase<Context_Statement_MATCH_BRANCH> {
        constexpr static std::string_view context_name = "Statement_MATCH_BRANCH";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::MatchBranch& match_branch;
    };
    template <typename Result>
    struct Context_Statement_MATCH_BRANCH_before : ebmcodegen::util::ContextBase<Context_Statement_MATCH_BRANCH_before<Result>> {
        constexpr static std::string_view context_name = "Statement_MATCH_BRANCH_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::MatchBranch& match_branch;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_MATCH_BRANCH_after : ebmcodegen::util::ContextBase<Context_Statement_MATCH_BRANCH_after<Result>> {
        constexpr static std::string_view context_name = "Statement_MATCH_BRANCH_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::MatchBranch& match_branch;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_BREAK : ebmcodegen::util::ContextBase<Context_Statement_BREAK> {
        constexpr static std::string_view context_name = "Statement_BREAK";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopFlowControl& break_;
    };
    template <typename Result>
    struct Context_Statement_BREAK_before : ebmcodegen::util::ContextBase<Context_Statement_BREAK_before<Result>> {
        constexpr static std::string_view context_name = "Statement_BREAK_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopFlowControl& break_;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_BREAK_after : ebmcodegen::util::ContextBase<Context_Statement_BREAK_after<Result>> {
        constexpr static std::string_view context_name = "Statement_BREAK_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopFlowControl& break_;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_CONTINUE : ebmcodegen::util::ContextBase<Context_Statement_CONTINUE> {
        constexpr static std::string_view context_name = "Statement_CONTINUE";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopFlowControl& continue_;
    };
    template <typename Result>
    struct Context_Statement_CONTINUE_before : ebmcodegen::util::ContextBase<Context_Statement_CONTINUE_before<Result>> {
        constexpr static std::string_view context_name = "Statement_CONTINUE_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopFlowControl& continue_;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_CONTINUE_after : ebmcodegen::util::ContextBase<Context_Statement_CONTINUE_after<Result>> {
        constexpr static std::string_view context_name = "Statement_CONTINUE_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopFlowControl& continue_;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_FUNCTION_DECL : ebmcodegen::util::ContextBase<Context_Statement_FUNCTION_DECL> {
        constexpr static std::string_view context_name = "Statement_FUNCTION_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::FunctionDecl& func_decl;
    };
    template <typename Result>
    struct Context_Statement_FUNCTION_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_FUNCTION_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_FUNCTION_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::FunctionDecl& func_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_FUNCTION_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_FUNCTION_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_FUNCTION_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::FunctionDecl& func_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_VARIABLE_DECL : ebmcodegen::util::ContextBase<Context_Statement_VARIABLE_DECL> {
        constexpr static std::string_view context_name = "Statement_VARIABLE_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::VariableDecl& var_decl;
    };
    template <typename Result>
    struct Context_Statement_VARIABLE_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_VARIABLE_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_VARIABLE_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::VariableDecl& var_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_VARIABLE_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_VARIABLE_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_VARIABLE_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::VariableDecl& var_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_PARAMETER_DECL : ebmcodegen::util::ContextBase<Context_Statement_PARAMETER_DECL> {
        constexpr static std::string_view context_name = "Statement_PARAMETER_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ParameterDecl& param_decl;
    };
    template <typename Result>
    struct Context_Statement_PARAMETER_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_PARAMETER_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_PARAMETER_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ParameterDecl& param_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_PARAMETER_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_PARAMETER_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_PARAMETER_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ParameterDecl& param_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_FIELD_DECL : ebmcodegen::util::ContextBase<Context_Statement_FIELD_DECL> {
        constexpr static std::string_view context_name = "Statement_FIELD_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::FieldDecl& field_decl;
    };
    template <typename Result>
    struct Context_Statement_FIELD_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_FIELD_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_FIELD_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::FieldDecl& field_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_FIELD_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_FIELD_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_FIELD_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::FieldDecl& field_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_COMPOSITE_FIELD_DECL : ebmcodegen::util::ContextBase<Context_Statement_COMPOSITE_FIELD_DECL> {
        constexpr static std::string_view context_name = "Statement_COMPOSITE_FIELD_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::CompositeFieldDecl& composite_field_decl;
    };
    template <typename Result>
    struct Context_Statement_COMPOSITE_FIELD_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_COMPOSITE_FIELD_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_COMPOSITE_FIELD_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::CompositeFieldDecl& composite_field_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_COMPOSITE_FIELD_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_COMPOSITE_FIELD_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_COMPOSITE_FIELD_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::CompositeFieldDecl& composite_field_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_ENUM_DECL : ebmcodegen::util::ContextBase<Context_Statement_ENUM_DECL> {
        constexpr static std::string_view context_name = "Statement_ENUM_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EnumDecl& enum_decl;
    };
    template <typename Result>
    struct Context_Statement_ENUM_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_ENUM_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_ENUM_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EnumDecl& enum_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_ENUM_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_ENUM_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_ENUM_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EnumDecl& enum_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_ENUM_MEMBER_DECL : ebmcodegen::util::ContextBase<Context_Statement_ENUM_MEMBER_DECL> {
        constexpr static std::string_view context_name = "Statement_ENUM_MEMBER_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EnumMemberDecl& enum_member_decl;
    };
    template <typename Result>
    struct Context_Statement_ENUM_MEMBER_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_ENUM_MEMBER_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_ENUM_MEMBER_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EnumMemberDecl& enum_member_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_ENUM_MEMBER_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_ENUM_MEMBER_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_ENUM_MEMBER_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EnumMemberDecl& enum_member_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_STRUCT_DECL : ebmcodegen::util::ContextBase<Context_Statement_STRUCT_DECL> {
        constexpr static std::string_view context_name = "Statement_STRUCT_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::StructDecl& struct_decl;
    };
    template <typename Result>
    struct Context_Statement_STRUCT_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_STRUCT_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_STRUCT_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::StructDecl& struct_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_STRUCT_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_STRUCT_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_STRUCT_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::StructDecl& struct_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_UNION_DECL : ebmcodegen::util::ContextBase<Context_Statement_UNION_DECL> {
        constexpr static std::string_view context_name = "Statement_UNION_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
    };
    template <typename Result>
    struct Context_Statement_UNION_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_UNION_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_UNION_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_UNION_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_UNION_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_UNION_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_UNION_MEMBER_DECL : ebmcodegen::util::ContextBase<Context_Statement_UNION_MEMBER_DECL> {
        constexpr static std::string_view context_name = "Statement_UNION_MEMBER_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
    };
    template <typename Result>
    struct Context_Statement_UNION_MEMBER_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_UNION_MEMBER_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_UNION_MEMBER_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_UNION_MEMBER_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_UNION_MEMBER_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_UNION_MEMBER_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_PROGRAM_DECL : ebmcodegen::util::ContextBase<Context_Statement_PROGRAM_DECL> {
        constexpr static std::string_view context_name = "Statement_PROGRAM_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Block& block;
    };
    template <typename Result>
    struct Context_Statement_PROGRAM_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_PROGRAM_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_PROGRAM_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Block& block;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_PROGRAM_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_PROGRAM_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_PROGRAM_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Block& block;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_PROPERTY_DECL : ebmcodegen::util::ContextBase<Context_Statement_PROPERTY_DECL> {
        constexpr static std::string_view context_name = "Statement_PROPERTY_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::PropertyDecl& property_decl;
    };
    template <typename Result>
    struct Context_Statement_PROPERTY_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_PROPERTY_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_PROPERTY_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::PropertyDecl& property_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_PROPERTY_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_PROPERTY_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_PROPERTY_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::PropertyDecl& property_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_PROPERTY_MEMBER_DECL : ebmcodegen::util::ContextBase<Context_Statement_PROPERTY_MEMBER_DECL> {
        constexpr static std::string_view context_name = "Statement_PROPERTY_MEMBER_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::PropertyMemberDecl& property_member_decl;
    };
    template <typename Result>
    struct Context_Statement_PROPERTY_MEMBER_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_PROPERTY_MEMBER_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_PROPERTY_MEMBER_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::PropertyMemberDecl& property_member_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_PROPERTY_MEMBER_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_PROPERTY_MEMBER_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_PROPERTY_MEMBER_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::PropertyMemberDecl& property_member_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_METADATA : ebmcodegen::util::ContextBase<Context_Statement_METADATA> {
        constexpr static std::string_view context_name = "Statement_METADATA";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Metadata& metadata;
    };
    template <typename Result>
    struct Context_Statement_METADATA_before : ebmcodegen::util::ContextBase<Context_Statement_METADATA_before<Result>> {
        constexpr static std::string_view context_name = "Statement_METADATA_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Metadata& metadata;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_METADATA_after : ebmcodegen::util::ContextBase<Context_Statement_METADATA_after<Result>> {
        constexpr static std::string_view context_name = "Statement_METADATA_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Metadata& metadata;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_IMPORT_MODULE : ebmcodegen::util::ContextBase<Context_Statement_IMPORT_MODULE> {
        constexpr static std::string_view context_name = "Statement_IMPORT_MODULE";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ImportDecl& import_decl;
    };
    template <typename Result>
    struct Context_Statement_IMPORT_MODULE_before : ebmcodegen::util::ContextBase<Context_Statement_IMPORT_MODULE_before<Result>> {
        constexpr static std::string_view context_name = "Statement_IMPORT_MODULE_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ImportDecl& import_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_IMPORT_MODULE_after : ebmcodegen::util::ContextBase<Context_Statement_IMPORT_MODULE_after<Result>> {
        constexpr static std::string_view context_name = "Statement_IMPORT_MODULE_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ImportDecl& import_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_EXPRESSION : ebmcodegen::util::ContextBase<Context_Statement_EXPRESSION> {
        constexpr static std::string_view context_name = "Statement_EXPRESSION";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ExpressionRef& expression;
    };
    template <typename Result>
    struct Context_Statement_EXPRESSION_before : ebmcodegen::util::ContextBase<Context_Statement_EXPRESSION_before<Result>> {
        constexpr static std::string_view context_name = "Statement_EXPRESSION_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ExpressionRef& expression;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_EXPRESSION_after : ebmcodegen::util::ContextBase<Context_Statement_EXPRESSION_after<Result>> {
        constexpr static std::string_view context_name = "Statement_EXPRESSION_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ExpressionRef& expression;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_ERROR_REPORT : ebmcodegen::util::ContextBase<Context_Statement_ERROR_REPORT> {
        constexpr static std::string_view context_name = "Statement_ERROR_REPORT";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ErrorReport& error_report;
    };
    template <typename Result>
    struct Context_Statement_ERROR_REPORT_before : ebmcodegen::util::ContextBase<Context_Statement_ERROR_REPORT_before<Result>> {
        constexpr static std::string_view context_name = "Statement_ERROR_REPORT_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ErrorReport& error_report;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_ERROR_REPORT_after : ebmcodegen::util::ContextBase<Context_Statement_ERROR_REPORT_after<Result>> {
        constexpr static std::string_view context_name = "Statement_ERROR_REPORT_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ErrorReport& error_report;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_LOWERED_IO_STATEMENTS : ebmcodegen::util::ContextBase<Context_Statement_LOWERED_IO_STATEMENTS> {
        constexpr static std::string_view context_name = "Statement_LOWERED_IO_STATEMENTS";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoweredIOStatements& lowered_io_statements;
    };
    template <typename Result>
    struct Context_Statement_LOWERED_IO_STATEMENTS_before : ebmcodegen::util::ContextBase<Context_Statement_LOWERED_IO_STATEMENTS_before<Result>> {
        constexpr static std::string_view context_name = "Statement_LOWERED_IO_STATEMENTS_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoweredIOStatements& lowered_io_statements;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_LOWERED_IO_STATEMENTS_after : ebmcodegen::util::ContextBase<Context_Statement_LOWERED_IO_STATEMENTS_after<Result>> {
        constexpr static std::string_view context_name = "Statement_LOWERED_IO_STATEMENTS_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoweredIOStatements& lowered_io_statements;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_SUB_BYTE_RANGE : ebmcodegen::util::ContextBase<Context_Statement_SUB_BYTE_RANGE> {
        constexpr static std::string_view context_name = "Statement_SUB_BYTE_RANGE";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::SubByteRange& sub_byte_range;
    };
    template <typename Result>
    struct Context_Statement_SUB_BYTE_RANGE_before : ebmcodegen::util::ContextBase<Context_Statement_SUB_BYTE_RANGE_before<Result>> {
        constexpr static std::string_view context_name = "Statement_SUB_BYTE_RANGE_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::SubByteRange& sub_byte_range;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_SUB_BYTE_RANGE_after : ebmcodegen::util::ContextBase<Context_Statement_SUB_BYTE_RANGE_after<Result>> {
        constexpr static std::string_view context_name = "Statement_SUB_BYTE_RANGE_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::SubByteRange& sub_byte_range;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_INIT_CHECK : ebmcodegen::util::ContextBase<Context_Statement_INIT_CHECK> {
        constexpr static std::string_view context_name = "Statement_INIT_CHECK";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::InitCheck& init_check;
    };
    template <typename Result>
    struct Context_Statement_INIT_CHECK_before : ebmcodegen::util::ContextBase<Context_Statement_INIT_CHECK_before<Result>> {
        constexpr static std::string_view context_name = "Statement_INIT_CHECK_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::InitCheck& init_check;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_INIT_CHECK_after : ebmcodegen::util::ContextBase<Context_Statement_INIT_CHECK_after<Result>> {
        constexpr static std::string_view context_name = "Statement_INIT_CHECK_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::InitCheck& init_check;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_ENDIAN_VARIABLE : ebmcodegen::util::ContextBase<Context_Statement_ENDIAN_VARIABLE> {
        constexpr static std::string_view context_name = "Statement_ENDIAN_VARIABLE";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EndianVariable& endian_variable;
    };
    template <typename Result>
    struct Context_Statement_ENDIAN_VARIABLE_before : ebmcodegen::util::ContextBase<Context_Statement_ENDIAN_VARIABLE_before<Result>> {
        constexpr static std::string_view context_name = "Statement_ENDIAN_VARIABLE_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EndianVariable& endian_variable;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_ENDIAN_VARIABLE_after : ebmcodegen::util::ContextBase<Context_Statement_ENDIAN_VARIABLE_after<Result>> {
        constexpr static std::string_view context_name = "Statement_ENDIAN_VARIABLE_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EndianVariable& endian_variable;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_ARRAY_TO_INT : ebmcodegen::util::ContextBase<Context_Statement_ARRAY_TO_INT> {
        constexpr static std::string_view context_name = "Statement_ARRAY_TO_INT";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EndianConvertDesc& endian_convert;
    };
    template <typename Result>
    struct Context_Statement_ARRAY_TO_INT_before : ebmcodegen::util::ContextBase<Context_Statement_ARRAY_TO_INT_before<Result>> {
        constexpr static std::string_view context_name = "Statement_ARRAY_TO_INT_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EndianConvertDesc& endian_convert;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_ARRAY_TO_INT_after : ebmcodegen::util::ContextBase<Context_Statement_ARRAY_TO_INT_after<Result>> {
        constexpr static std::string_view context_name = "Statement_ARRAY_TO_INT_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EndianConvertDesc& endian_convert;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement_INT_TO_ARRAY : ebmcodegen::util::ContextBase<Context_Statement_INT_TO_ARRAY> {
        constexpr static std::string_view context_name = "Statement_INT_TO_ARRAY";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EndianConvertDesc& endian_convert;
    };
    template <typename Result>
    struct Context_Statement_INT_TO_ARRAY_before : ebmcodegen::util::ContextBase<Context_Statement_INT_TO_ARRAY_before<Result>> {
        constexpr static std::string_view context_name = "Statement_INT_TO_ARRAY_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EndianConvertDesc& endian_convert;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_INT_TO_ARRAY_after : ebmcodegen::util::ContextBase<Context_Statement_INT_TO_ARRAY_after<Result>> {
        constexpr static std::string_view context_name = "Statement_INT_TO_ARRAY_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EndianConvertDesc& endian_convert;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Statement : ebmcodegen::util::ContextBase<Context_Statement> {
        constexpr static std::string_view context_name = "Statement";
        BaseVisitor& visitor;
        const ebm::Statement& in;
        ebm::StatementRef alias_ref;
    };
    template <typename Result>
    struct Context_Statement_before : ebmcodegen::util::ContextBase<Context_Statement_before<Result>> {
        constexpr static std::string_view context_name = "Statement_before";
        BaseVisitor& visitor;
        const ebm::Statement& in;
        ebm::StatementRef alias_ref;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Statement_after : ebmcodegen::util::ContextBase<Context_Statement_after<Result>> {
        constexpr static std::string_view context_name = "Statement_after";
        BaseVisitor& visitor;
        const ebm::Statement& in;
        ebm::StatementRef alias_ref;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Block : ebmcodegen::util::ContextBase<Context_Block> {
        constexpr static std::string_view context_name = "Block";
        BaseVisitor& visitor;
        const ebm::Block& in;
    };
    template <typename Result>
    struct Context_Block_before : ebmcodegen::util::ContextBase<Context_Block_before<Result>> {
        constexpr static std::string_view context_name = "Block_before";
        BaseVisitor& visitor;
        const ebm::Block& in;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Block_after : ebmcodegen::util::ContextBase<Context_Block_after<Result>> {
        constexpr static std::string_view context_name = "Block_after";
        BaseVisitor& visitor;
        const ebm::Block& in;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_LITERAL_INT : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_INT> {
        constexpr static std::string_view context_name = "Expression_LITERAL_INT";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Varint& int_value;
    };
    template <typename Result>
    struct Context_Expression_LITERAL_INT_before : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_INT_before<Result>> {
        constexpr static std::string_view context_name = "Expression_LITERAL_INT_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Varint& int_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_LITERAL_INT_after : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_INT_after<Result>> {
        constexpr static std::string_view context_name = "Expression_LITERAL_INT_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Varint& int_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_LITERAL_INT64 : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_INT64> {
        constexpr static std::string_view context_name = "Expression_LITERAL_INT64";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const std::uint64_t& int64_value;
    };
    template <typename Result>
    struct Context_Expression_LITERAL_INT64_before : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_INT64_before<Result>> {
        constexpr static std::string_view context_name = "Expression_LITERAL_INT64_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const std::uint64_t& int64_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_LITERAL_INT64_after : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_INT64_after<Result>> {
        constexpr static std::string_view context_name = "Expression_LITERAL_INT64_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const std::uint64_t& int64_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_LITERAL_BOOL : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_BOOL> {
        constexpr static std::string_view context_name = "Expression_LITERAL_BOOL";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const std::uint8_t& bool_value;
    };
    template <typename Result>
    struct Context_Expression_LITERAL_BOOL_before : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_BOOL_before<Result>> {
        constexpr static std::string_view context_name = "Expression_LITERAL_BOOL_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const std::uint8_t& bool_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_LITERAL_BOOL_after : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_BOOL_after<Result>> {
        constexpr static std::string_view context_name = "Expression_LITERAL_BOOL_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const std::uint8_t& bool_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_LITERAL_STRING : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_STRING> {
        constexpr static std::string_view context_name = "Expression_LITERAL_STRING";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StringRef& string_value;
    };
    template <typename Result>
    struct Context_Expression_LITERAL_STRING_before : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_STRING_before<Result>> {
        constexpr static std::string_view context_name = "Expression_LITERAL_STRING_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StringRef& string_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_LITERAL_STRING_after : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_STRING_after<Result>> {
        constexpr static std::string_view context_name = "Expression_LITERAL_STRING_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StringRef& string_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_LITERAL_TYPE : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_TYPE> {
        constexpr static std::string_view context_name = "Expression_LITERAL_TYPE";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::TypeRef& type_ref;
    };
    template <typename Result>
    struct Context_Expression_LITERAL_TYPE_before : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_TYPE_before<Result>> {
        constexpr static std::string_view context_name = "Expression_LITERAL_TYPE_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::TypeRef& type_ref;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_LITERAL_TYPE_after : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_TYPE_after<Result>> {
        constexpr static std::string_view context_name = "Expression_LITERAL_TYPE_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::TypeRef& type_ref;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_LITERAL_CHAR : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_CHAR> {
        constexpr static std::string_view context_name = "Expression_LITERAL_CHAR";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Varint& char_value;
    };
    template <typename Result>
    struct Context_Expression_LITERAL_CHAR_before : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_CHAR_before<Result>> {
        constexpr static std::string_view context_name = "Expression_LITERAL_CHAR_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Varint& char_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_LITERAL_CHAR_after : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_CHAR_after<Result>> {
        constexpr static std::string_view context_name = "Expression_LITERAL_CHAR_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Varint& char_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_IDENTIFIER : ebmcodegen::util::ContextBase<Context_Expression_IDENTIFIER> {
        constexpr static std::string_view context_name = "Expression_IDENTIFIER";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::WeakStatementRef& id;
    };
    template <typename Result>
    struct Context_Expression_IDENTIFIER_before : ebmcodegen::util::ContextBase<Context_Expression_IDENTIFIER_before<Result>> {
        constexpr static std::string_view context_name = "Expression_IDENTIFIER_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::WeakStatementRef& id;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_IDENTIFIER_after : ebmcodegen::util::ContextBase<Context_Expression_IDENTIFIER_after<Result>> {
        constexpr static std::string_view context_name = "Expression_IDENTIFIER_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::WeakStatementRef& id;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_BINARY_OP : ebmcodegen::util::ContextBase<Context_Expression_BINARY_OP> {
        constexpr static std::string_view context_name = "Expression_BINARY_OP";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::BinaryOp& bop;
        const ebm::ExpressionRef& left;
        const ebm::ExpressionRef& right;
    };
    template <typename Result>
    struct Context_Expression_BINARY_OP_before : ebmcodegen::util::ContextBase<Context_Expression_BINARY_OP_before<Result>> {
        constexpr static std::string_view context_name = "Expression_BINARY_OP_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::BinaryOp& bop;
        const ebm::ExpressionRef& left;
        const ebm::ExpressionRef& right;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_BINARY_OP_after : ebmcodegen::util::ContextBase<Context_Expression_BINARY_OP_after<Result>> {
        constexpr static std::string_view context_name = "Expression_BINARY_OP_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::BinaryOp& bop;
        const ebm::ExpressionRef& left;
        const ebm::ExpressionRef& right;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_UNARY_OP : ebmcodegen::util::ContextBase<Context_Expression_UNARY_OP> {
        constexpr static std::string_view context_name = "Expression_UNARY_OP";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& operand;
        const ebm::UnaryOp& uop;
    };
    template <typename Result>
    struct Context_Expression_UNARY_OP_before : ebmcodegen::util::ContextBase<Context_Expression_UNARY_OP_before<Result>> {
        constexpr static std::string_view context_name = "Expression_UNARY_OP_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& operand;
        const ebm::UnaryOp& uop;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_UNARY_OP_after : ebmcodegen::util::ContextBase<Context_Expression_UNARY_OP_after<Result>> {
        constexpr static std::string_view context_name = "Expression_UNARY_OP_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& operand;
        const ebm::UnaryOp& uop;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_CALL : ebmcodegen::util::ContextBase<Context_Expression_CALL> {
        constexpr static std::string_view context_name = "Expression_CALL";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::CallDesc& call_desc;
    };
    template <typename Result>
    struct Context_Expression_CALL_before : ebmcodegen::util::ContextBase<Context_Expression_CALL_before<Result>> {
        constexpr static std::string_view context_name = "Expression_CALL_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::CallDesc& call_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_CALL_after : ebmcodegen::util::ContextBase<Context_Expression_CALL_after<Result>> {
        constexpr static std::string_view context_name = "Expression_CALL_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::CallDesc& call_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_INDEX_ACCESS : ebmcodegen::util::ContextBase<Context_Expression_INDEX_ACCESS> {
        constexpr static std::string_view context_name = "Expression_INDEX_ACCESS";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& base;
        const ebm::ExpressionRef& index;
    };
    template <typename Result>
    struct Context_Expression_INDEX_ACCESS_before : ebmcodegen::util::ContextBase<Context_Expression_INDEX_ACCESS_before<Result>> {
        constexpr static std::string_view context_name = "Expression_INDEX_ACCESS_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& base;
        const ebm::ExpressionRef& index;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_INDEX_ACCESS_after : ebmcodegen::util::ContextBase<Context_Expression_INDEX_ACCESS_after<Result>> {
        constexpr static std::string_view context_name = "Expression_INDEX_ACCESS_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& base;
        const ebm::ExpressionRef& index;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_MEMBER_ACCESS : ebmcodegen::util::ContextBase<Context_Expression_MEMBER_ACCESS> {
        constexpr static std::string_view context_name = "Expression_MEMBER_ACCESS";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& base;
        const ebm::ExpressionRef& member;
    };
    template <typename Result>
    struct Context_Expression_MEMBER_ACCESS_before : ebmcodegen::util::ContextBase<Context_Expression_MEMBER_ACCESS_before<Result>> {
        constexpr static std::string_view context_name = "Expression_MEMBER_ACCESS_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& base;
        const ebm::ExpressionRef& member;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_MEMBER_ACCESS_after : ebmcodegen::util::ContextBase<Context_Expression_MEMBER_ACCESS_after<Result>> {
        constexpr static std::string_view context_name = "Expression_MEMBER_ACCESS_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& base;
        const ebm::ExpressionRef& member;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_ENUM_MEMBER : ebmcodegen::util::ContextBase<Context_Expression_ENUM_MEMBER> {
        constexpr static std::string_view context_name = "Expression_ENUM_MEMBER";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& enum_decl;
        const ebm::ExpressionRef& member;
    };
    template <typename Result>
    struct Context_Expression_ENUM_MEMBER_before : ebmcodegen::util::ContextBase<Context_Expression_ENUM_MEMBER_before<Result>> {
        constexpr static std::string_view context_name = "Expression_ENUM_MEMBER_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& enum_decl;
        const ebm::ExpressionRef& member;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_ENUM_MEMBER_after : ebmcodegen::util::ContextBase<Context_Expression_ENUM_MEMBER_after<Result>> {
        constexpr static std::string_view context_name = "Expression_ENUM_MEMBER_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& enum_decl;
        const ebm::ExpressionRef& member;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_TYPE_CAST : ebmcodegen::util::ContextBase<Context_Expression_TYPE_CAST> {
        constexpr static std::string_view context_name = "Expression_TYPE_CAST";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::TypeCastDesc& type_cast_desc;
    };
    template <typename Result>
    struct Context_Expression_TYPE_CAST_before : ebmcodegen::util::ContextBase<Context_Expression_TYPE_CAST_before<Result>> {
        constexpr static std::string_view context_name = "Expression_TYPE_CAST_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::TypeCastDesc& type_cast_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_TYPE_CAST_after : ebmcodegen::util::ContextBase<Context_Expression_TYPE_CAST_after<Result>> {
        constexpr static std::string_view context_name = "Expression_TYPE_CAST_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::TypeCastDesc& type_cast_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_RANGE : ebmcodegen::util::ContextBase<Context_Expression_RANGE> {
        constexpr static std::string_view context_name = "Expression_RANGE";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& end;
        const ebm::ExpressionRef& start;
    };
    template <typename Result>
    struct Context_Expression_RANGE_before : ebmcodegen::util::ContextBase<Context_Expression_RANGE_before<Result>> {
        constexpr static std::string_view context_name = "Expression_RANGE_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& end;
        const ebm::ExpressionRef& start;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_RANGE_after : ebmcodegen::util::ContextBase<Context_Expression_RANGE_after<Result>> {
        constexpr static std::string_view context_name = "Expression_RANGE_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& end;
        const ebm::ExpressionRef& start;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_DEFAULT_VALUE : ebmcodegen::util::ContextBase<Context_Expression_DEFAULT_VALUE> {
        constexpr static std::string_view context_name = "Expression_DEFAULT_VALUE";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
    };
    template <typename Result>
    struct Context_Expression_DEFAULT_VALUE_before : ebmcodegen::util::ContextBase<Context_Expression_DEFAULT_VALUE_before<Result>> {
        constexpr static std::string_view context_name = "Expression_DEFAULT_VALUE_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_DEFAULT_VALUE_after : ebmcodegen::util::ContextBase<Context_Expression_DEFAULT_VALUE_after<Result>> {
        constexpr static std::string_view context_name = "Expression_DEFAULT_VALUE_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_IS_LITTLE_ENDIAN : ebmcodegen::util::ContextBase<Context_Expression_IS_LITTLE_ENDIAN> {
        constexpr static std::string_view context_name = "Expression_IS_LITTLE_ENDIAN";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& endian_expr;
    };
    template <typename Result>
    struct Context_Expression_IS_LITTLE_ENDIAN_before : ebmcodegen::util::ContextBase<Context_Expression_IS_LITTLE_ENDIAN_before<Result>> {
        constexpr static std::string_view context_name = "Expression_IS_LITTLE_ENDIAN_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& endian_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_IS_LITTLE_ENDIAN_after : ebmcodegen::util::ContextBase<Context_Expression_IS_LITTLE_ENDIAN_after<Result>> {
        constexpr static std::string_view context_name = "Expression_IS_LITTLE_ENDIAN_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& endian_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_GET_STREAM_OFFSET : ebmcodegen::util::ContextBase<Context_Expression_GET_STREAM_OFFSET> {
        constexpr static std::string_view context_name = "Expression_GET_STREAM_OFFSET";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_ref;
        const ebm::StreamType& stream_type;
        const ebm::SizeUnit& unit;
    };
    template <typename Result>
    struct Context_Expression_GET_STREAM_OFFSET_before : ebmcodegen::util::ContextBase<Context_Expression_GET_STREAM_OFFSET_before<Result>> {
        constexpr static std::string_view context_name = "Expression_GET_STREAM_OFFSET_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_ref;
        const ebm::StreamType& stream_type;
        const ebm::SizeUnit& unit;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_GET_STREAM_OFFSET_after : ebmcodegen::util::ContextBase<Context_Expression_GET_STREAM_OFFSET_after<Result>> {
        constexpr static std::string_view context_name = "Expression_GET_STREAM_OFFSET_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_ref;
        const ebm::StreamType& stream_type;
        const ebm::SizeUnit& unit;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_GET_REMAINING_BYTES : ebmcodegen::util::ContextBase<Context_Expression_GET_REMAINING_BYTES> {
        constexpr static std::string_view context_name = "Expression_GET_REMAINING_BYTES";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_ref;
        const ebm::StreamType& stream_type;
    };
    template <typename Result>
    struct Context_Expression_GET_REMAINING_BYTES_before : ebmcodegen::util::ContextBase<Context_Expression_GET_REMAINING_BYTES_before<Result>> {
        constexpr static std::string_view context_name = "Expression_GET_REMAINING_BYTES_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_ref;
        const ebm::StreamType& stream_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_GET_REMAINING_BYTES_after : ebmcodegen::util::ContextBase<Context_Expression_GET_REMAINING_BYTES_after<Result>> {
        constexpr static std::string_view context_name = "Expression_GET_REMAINING_BYTES_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_ref;
        const ebm::StreamType& stream_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_CAN_READ_STREAM : ebmcodegen::util::ContextBase<Context_Expression_CAN_READ_STREAM> {
        constexpr static std::string_view context_name = "Expression_CAN_READ_STREAM";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_ref;
        const ebm::Size& num_bytes;
        const ebm::StreamType& stream_type;
    };
    template <typename Result>
    struct Context_Expression_CAN_READ_STREAM_before : ebmcodegen::util::ContextBase<Context_Expression_CAN_READ_STREAM_before<Result>> {
        constexpr static std::string_view context_name = "Expression_CAN_READ_STREAM_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_ref;
        const ebm::Size& num_bytes;
        const ebm::StreamType& stream_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_CAN_READ_STREAM_after : ebmcodegen::util::ContextBase<Context_Expression_CAN_READ_STREAM_after<Result>> {
        constexpr static std::string_view context_name = "Expression_CAN_READ_STREAM_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_ref;
        const ebm::Size& num_bytes;
        const ebm::StreamType& stream_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_ARRAY_SIZE : ebmcodegen::util::ContextBase<Context_Expression_ARRAY_SIZE> {
        constexpr static std::string_view context_name = "Expression_ARRAY_SIZE";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& array_expr;
    };
    template <typename Result>
    struct Context_Expression_ARRAY_SIZE_before : ebmcodegen::util::ContextBase<Context_Expression_ARRAY_SIZE_before<Result>> {
        constexpr static std::string_view context_name = "Expression_ARRAY_SIZE_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& array_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_ARRAY_SIZE_after : ebmcodegen::util::ContextBase<Context_Expression_ARRAY_SIZE_after<Result>> {
        constexpr static std::string_view context_name = "Expression_ARRAY_SIZE_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& array_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_ENUM_IS_DEFINED : ebmcodegen::util::ContextBase<Context_Expression_ENUM_IS_DEFINED> {
        constexpr static std::string_view context_name = "Expression_ENUM_IS_DEFINED";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
    };
    template <typename Result>
    struct Context_Expression_ENUM_IS_DEFINED_before : ebmcodegen::util::ContextBase<Context_Expression_ENUM_IS_DEFINED_before<Result>> {
        constexpr static std::string_view context_name = "Expression_ENUM_IS_DEFINED_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_ENUM_IS_DEFINED_after : ebmcodegen::util::ContextBase<Context_Expression_ENUM_IS_DEFINED_after<Result>> {
        constexpr static std::string_view context_name = "Expression_ENUM_IS_DEFINED_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_IS_ERROR : ebmcodegen::util::ContextBase<Context_Expression_IS_ERROR> {
        constexpr static std::string_view context_name = "Expression_IS_ERROR";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
    };
    template <typename Result>
    struct Context_Expression_IS_ERROR_before : ebmcodegen::util::ContextBase<Context_Expression_IS_ERROR_before<Result>> {
        constexpr static std::string_view context_name = "Expression_IS_ERROR_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_IS_ERROR_after : ebmcodegen::util::ContextBase<Context_Expression_IS_ERROR_after<Result>> {
        constexpr static std::string_view context_name = "Expression_IS_ERROR_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_MAX_VALUE : ebmcodegen::util::ContextBase<Context_Expression_MAX_VALUE> {
        constexpr static std::string_view context_name = "Expression_MAX_VALUE";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
    };
    template <typename Result>
    struct Context_Expression_MAX_VALUE_before : ebmcodegen::util::ContextBase<Context_Expression_MAX_VALUE_before<Result>> {
        constexpr static std::string_view context_name = "Expression_MAX_VALUE_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_MAX_VALUE_after : ebmcodegen::util::ContextBase<Context_Expression_MAX_VALUE_after<Result>> {
        constexpr static std::string_view context_name = "Expression_MAX_VALUE_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_READ_DATA : ebmcodegen::util::ContextBase<Context_Expression_READ_DATA> {
        constexpr static std::string_view context_name = "Expression_READ_DATA";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_statement;
        const ebm::StatementRef& target_stmt;
    };
    template <typename Result>
    struct Context_Expression_READ_DATA_before : ebmcodegen::util::ContextBase<Context_Expression_READ_DATA_before<Result>> {
        constexpr static std::string_view context_name = "Expression_READ_DATA_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_statement;
        const ebm::StatementRef& target_stmt;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_READ_DATA_after : ebmcodegen::util::ContextBase<Context_Expression_READ_DATA_after<Result>> {
        constexpr static std::string_view context_name = "Expression_READ_DATA_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_statement;
        const ebm::StatementRef& target_stmt;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_WRITE_DATA : ebmcodegen::util::ContextBase<Context_Expression_WRITE_DATA> {
        constexpr static std::string_view context_name = "Expression_WRITE_DATA";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_statement;
        const ebm::ExpressionRef& target_expr;
    };
    template <typename Result>
    struct Context_Expression_WRITE_DATA_before : ebmcodegen::util::ContextBase<Context_Expression_WRITE_DATA_before<Result>> {
        constexpr static std::string_view context_name = "Expression_WRITE_DATA_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_statement;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_WRITE_DATA_after : ebmcodegen::util::ContextBase<Context_Expression_WRITE_DATA_after<Result>> {
        constexpr static std::string_view context_name = "Expression_WRITE_DATA_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_statement;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_CONDITIONAL_STATEMENT : ebmcodegen::util::ContextBase<Context_Expression_CONDITIONAL_STATEMENT> {
        constexpr static std::string_view context_name = "Expression_CONDITIONAL_STATEMENT";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& conditional_stmt;
        const ebm::StatementRef& target_stmt;
    };
    template <typename Result>
    struct Context_Expression_CONDITIONAL_STATEMENT_before : ebmcodegen::util::ContextBase<Context_Expression_CONDITIONAL_STATEMENT_before<Result>> {
        constexpr static std::string_view context_name = "Expression_CONDITIONAL_STATEMENT_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& conditional_stmt;
        const ebm::StatementRef& target_stmt;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_CONDITIONAL_STATEMENT_after : ebmcodegen::util::ContextBase<Context_Expression_CONDITIONAL_STATEMENT_after<Result>> {
        constexpr static std::string_view context_name = "Expression_CONDITIONAL_STATEMENT_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& conditional_stmt;
        const ebm::StatementRef& target_stmt;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_CONDITIONAL : ebmcodegen::util::ContextBase<Context_Expression_CONDITIONAL> {
        constexpr static std::string_view context_name = "Expression_CONDITIONAL";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& condition;
        const ebm::ExpressionRef& else_;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& then;
    };
    template <typename Result>
    struct Context_Expression_CONDITIONAL_before : ebmcodegen::util::ContextBase<Context_Expression_CONDITIONAL_before<Result>> {
        constexpr static std::string_view context_name = "Expression_CONDITIONAL_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& condition;
        const ebm::ExpressionRef& else_;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& then;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_CONDITIONAL_after : ebmcodegen::util::ContextBase<Context_Expression_CONDITIONAL_after<Result>> {
        constexpr static std::string_view context_name = "Expression_CONDITIONAL_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& condition;
        const ebm::ExpressionRef& else_;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& then;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_AVAILABLE : ebmcodegen::util::ContextBase<Context_Expression_AVAILABLE> {
        constexpr static std::string_view context_name = "Expression_AVAILABLE";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
    };
    template <typename Result>
    struct Context_Expression_AVAILABLE_before : ebmcodegen::util::ContextBase<Context_Expression_AVAILABLE_before<Result>> {
        constexpr static std::string_view context_name = "Expression_AVAILABLE_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_AVAILABLE_after : ebmcodegen::util::ContextBase<Context_Expression_AVAILABLE_after<Result>> {
        constexpr static std::string_view context_name = "Expression_AVAILABLE_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_SIZEOF : ebmcodegen::util::ContextBase<Context_Expression_SIZEOF> {
        constexpr static std::string_view context_name = "Expression_SIZEOF";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
    };
    template <typename Result>
    struct Context_Expression_SIZEOF_before : ebmcodegen::util::ContextBase<Context_Expression_SIZEOF_before<Result>> {
        constexpr static std::string_view context_name = "Expression_SIZEOF_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_SIZEOF_after : ebmcodegen::util::ContextBase<Context_Expression_SIZEOF_after<Result>> {
        constexpr static std::string_view context_name = "Expression_SIZEOF_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_SUB_RANGE_INIT : ebmcodegen::util::ContextBase<Context_Expression_SUB_RANGE_INIT> {
        constexpr static std::string_view context_name = "Expression_SUB_RANGE_INIT";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::WeakStatementRef& sub_range;
    };
    template <typename Result>
    struct Context_Expression_SUB_RANGE_INIT_before : ebmcodegen::util::ContextBase<Context_Expression_SUB_RANGE_INIT_before<Result>> {
        constexpr static std::string_view context_name = "Expression_SUB_RANGE_INIT_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::WeakStatementRef& sub_range;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_SUB_RANGE_INIT_after : ebmcodegen::util::ContextBase<Context_Expression_SUB_RANGE_INIT_after<Result>> {
        constexpr static std::string_view context_name = "Expression_SUB_RANGE_INIT_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::WeakStatementRef& sub_range;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_OR_COND : ebmcodegen::util::ContextBase<Context_Expression_OR_COND> {
        constexpr static std::string_view context_name = "Expression_OR_COND";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Expressions& or_cond;
    };
    template <typename Result>
    struct Context_Expression_OR_COND_before : ebmcodegen::util::ContextBase<Context_Expression_OR_COND_before<Result>> {
        constexpr static std::string_view context_name = "Expression_OR_COND_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Expressions& or_cond;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_OR_COND_after : ebmcodegen::util::ContextBase<Context_Expression_OR_COND_after<Result>> {
        constexpr static std::string_view context_name = "Expression_OR_COND_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Expressions& or_cond;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_ADDRESS_OF : ebmcodegen::util::ContextBase<Context_Expression_ADDRESS_OF> {
        constexpr static std::string_view context_name = "Expression_ADDRESS_OF";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
    };
    template <typename Result>
    struct Context_Expression_ADDRESS_OF_before : ebmcodegen::util::ContextBase<Context_Expression_ADDRESS_OF_before<Result>> {
        constexpr static std::string_view context_name = "Expression_ADDRESS_OF_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_ADDRESS_OF_after : ebmcodegen::util::ContextBase<Context_Expression_ADDRESS_OF_after<Result>> {
        constexpr static std::string_view context_name = "Expression_ADDRESS_OF_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_OPTIONAL_OF : ebmcodegen::util::ContextBase<Context_Expression_OPTIONAL_OF> {
        constexpr static std::string_view context_name = "Expression_OPTIONAL_OF";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
    };
    template <typename Result>
    struct Context_Expression_OPTIONAL_OF_before : ebmcodegen::util::ContextBase<Context_Expression_OPTIONAL_OF_before<Result>> {
        constexpr static std::string_view context_name = "Expression_OPTIONAL_OF_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_OPTIONAL_OF_after : ebmcodegen::util::ContextBase<Context_Expression_OPTIONAL_OF_after<Result>> {
        constexpr static std::string_view context_name = "Expression_OPTIONAL_OF_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_SETTER_STATUS : ebmcodegen::util::ContextBase<Context_Expression_SETTER_STATUS> {
        constexpr static std::string_view context_name = "Expression_SETTER_STATUS";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::SetterStatus& setter_status;
    };
    template <typename Result>
    struct Context_Expression_SETTER_STATUS_before : ebmcodegen::util::ContextBase<Context_Expression_SETTER_STATUS_before<Result>> {
        constexpr static std::string_view context_name = "Expression_SETTER_STATUS_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::SetterStatus& setter_status;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_SETTER_STATUS_after : ebmcodegen::util::ContextBase<Context_Expression_SETTER_STATUS_after<Result>> {
        constexpr static std::string_view context_name = "Expression_SETTER_STATUS_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::SetterStatus& setter_status;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_SELF : ebmcodegen::util::ContextBase<Context_Expression_SELF> {
        constexpr static std::string_view context_name = "Expression_SELF";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
    };
    template <typename Result>
    struct Context_Expression_SELF_before : ebmcodegen::util::ContextBase<Context_Expression_SELF_before<Result>> {
        constexpr static std::string_view context_name = "Expression_SELF_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_SELF_after : ebmcodegen::util::ContextBase<Context_Expression_SELF_after<Result>> {
        constexpr static std::string_view context_name = "Expression_SELF_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression_AS_ARG : ebmcodegen::util::ContextBase<Context_Expression_AS_ARG> {
        constexpr static std::string_view context_name = "Expression_AS_ARG";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
    };
    template <typename Result>
    struct Context_Expression_AS_ARG_before : ebmcodegen::util::ContextBase<Context_Expression_AS_ARG_before<Result>> {
        constexpr static std::string_view context_name = "Expression_AS_ARG_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_AS_ARG_after : ebmcodegen::util::ContextBase<Context_Expression_AS_ARG_after<Result>> {
        constexpr static std::string_view context_name = "Expression_AS_ARG_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expression : ebmcodegen::util::ContextBase<Context_Expression> {
        constexpr static std::string_view context_name = "Expression";
        BaseVisitor& visitor;
        const ebm::Expression& in;
        ebm::ExpressionRef alias_ref;
    };
    template <typename Result>
    struct Context_Expression_before : ebmcodegen::util::ContextBase<Context_Expression_before<Result>> {
        constexpr static std::string_view context_name = "Expression_before";
        BaseVisitor& visitor;
        const ebm::Expression& in;
        ebm::ExpressionRef alias_ref;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expression_after : ebmcodegen::util::ContextBase<Context_Expression_after<Result>> {
        constexpr static std::string_view context_name = "Expression_after";
        BaseVisitor& visitor;
        const ebm::Expression& in;
        ebm::ExpressionRef alias_ref;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Expressions : ebmcodegen::util::ContextBase<Context_Expressions> {
        constexpr static std::string_view context_name = "Expressions";
        BaseVisitor& visitor;
        const ebm::Expressions& in;
    };
    template <typename Result>
    struct Context_Expressions_before : ebmcodegen::util::ContextBase<Context_Expressions_before<Result>> {
        constexpr static std::string_view context_name = "Expressions_before";
        BaseVisitor& visitor;
        const ebm::Expressions& in;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Expressions_after : ebmcodegen::util::ContextBase<Context_Expressions_after<Result>> {
        constexpr static std::string_view context_name = "Expressions_after";
        BaseVisitor& visitor;
        const ebm::Expressions& in;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Type_INT : ebmcodegen::util::ContextBase<Context_Type_INT> {
        constexpr static std::string_view context_name = "Type_INT";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
    };
    template <typename Result>
    struct Context_Type_INT_before : ebmcodegen::util::ContextBase<Context_Type_INT_before<Result>> {
        constexpr static std::string_view context_name = "Type_INT_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Type_INT_after : ebmcodegen::util::ContextBase<Context_Type_INT_after<Result>> {
        constexpr static std::string_view context_name = "Type_INT_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Type_UINT : ebmcodegen::util::ContextBase<Context_Type_UINT> {
        constexpr static std::string_view context_name = "Type_UINT";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
    };
    template <typename Result>
    struct Context_Type_UINT_before : ebmcodegen::util::ContextBase<Context_Type_UINT_before<Result>> {
        constexpr static std::string_view context_name = "Type_UINT_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Type_UINT_after : ebmcodegen::util::ContextBase<Context_Type_UINT_after<Result>> {
        constexpr static std::string_view context_name = "Type_UINT_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Type_USIZE : ebmcodegen::util::ContextBase<Context_Type_USIZE> {
        constexpr static std::string_view context_name = "Type_USIZE";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    template <typename Result>
    struct Context_Type_USIZE_before : ebmcodegen::util::ContextBase<Context_Type_USIZE_before<Result>> {
        constexpr static std::string_view context_name = "Type_USIZE_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Type_USIZE_after : ebmcodegen::util::ContextBase<Context_Type_USIZE_after<Result>> {
        constexpr static std::string_view context_name = "Type_USIZE_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Type_FLOAT : ebmcodegen::util::ContextBase<Context_Type_FLOAT> {
        constexpr static std::string_view context_name = "Type_FLOAT";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
    };
    template <typename Result>
    struct Context_Type_FLOAT_before : ebmcodegen::util::ContextBase<Context_Type_FLOAT_before<Result>> {
        constexpr static std::string_view context_name = "Type_FLOAT_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Type_FLOAT_after : ebmcodegen::util::ContextBase<Context_Type_FLOAT_after<Result>> {
        constexpr static std::string_view context_name = "Type_FLOAT_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Type_STRUCT : ebmcodegen::util::ContextBase<Context_Type_STRUCT> {
        constexpr static std::string_view context_name = "Type_STRUCT";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::WeakStatementRef& id;
    };
    template <typename Result>
    struct Context_Type_STRUCT_before : ebmcodegen::util::ContextBase<Context_Type_STRUCT_before<Result>> {
        constexpr static std::string_view context_name = "Type_STRUCT_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::WeakStatementRef& id;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Type_STRUCT_after : ebmcodegen::util::ContextBase<Context_Type_STRUCT_after<Result>> {
        constexpr static std::string_view context_name = "Type_STRUCT_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::WeakStatementRef& id;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Type_RECURSIVE_STRUCT : ebmcodegen::util::ContextBase<Context_Type_RECURSIVE_STRUCT> {
        constexpr static std::string_view context_name = "Type_RECURSIVE_STRUCT";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::WeakStatementRef& id;
    };
    template <typename Result>
    struct Context_Type_RECURSIVE_STRUCT_before : ebmcodegen::util::ContextBase<Context_Type_RECURSIVE_STRUCT_before<Result>> {
        constexpr static std::string_view context_name = "Type_RECURSIVE_STRUCT_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::WeakStatementRef& id;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Type_RECURSIVE_STRUCT_after : ebmcodegen::util::ContextBase<Context_Type_RECURSIVE_STRUCT_after<Result>> {
        constexpr static std::string_view context_name = "Type_RECURSIVE_STRUCT_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::WeakStatementRef& id;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Type_BOOL : ebmcodegen::util::ContextBase<Context_Type_BOOL> {
        constexpr static std::string_view context_name = "Type_BOOL";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    template <typename Result>
    struct Context_Type_BOOL_before : ebmcodegen::util::ContextBase<Context_Type_BOOL_before<Result>> {
        constexpr static std::string_view context_name = "Type_BOOL_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Type_BOOL_after : ebmcodegen::util::ContextBase<Context_Type_BOOL_after<Result>> {
        constexpr static std::string_view context_name = "Type_BOOL_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Type_VOID : ebmcodegen::util::ContextBase<Context_Type_VOID> {
        constexpr static std::string_view context_name = "Type_VOID";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    template <typename Result>
    struct Context_Type_VOID_before : ebmcodegen::util::ContextBase<Context_Type_VOID_before<Result>> {
        constexpr static std::string_view context_name = "Type_VOID_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Type_VOID_after : ebmcodegen::util::ContextBase<Context_Type_VOID_after<Result>> {
        constexpr static std::string_view context_name = "Type_VOID_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Type_META : ebmcodegen::util::ContextBase<Context_Type_META> {
        constexpr static std::string_view context_name = "Type_META";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    template <typename Result>
    struct Context_Type_META_before : ebmcodegen::util::ContextBase<Context_Type_META_before<Result>> {
        constexpr static std::string_view context_name = "Type_META_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Type_META_after : ebmcodegen::util::ContextBase<Context_Type_META_after<Result>> {
        constexpr static std::string_view context_name = "Type_META_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Type_ENUM : ebmcodegen::util::ContextBase<Context_Type_ENUM> {
        constexpr static std::string_view context_name = "Type_ENUM";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& base_type;
        const ebm::WeakStatementRef& id;
    };
    template <typename Result>
    struct Context_Type_ENUM_before : ebmcodegen::util::ContextBase<Context_Type_ENUM_before<Result>> {
        constexpr static std::string_view context_name = "Type_ENUM_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& base_type;
        const ebm::WeakStatementRef& id;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Type_ENUM_after : ebmcodegen::util::ContextBase<Context_Type_ENUM_after<Result>> {
        constexpr static std::string_view context_name = "Type_ENUM_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& base_type;
        const ebm::WeakStatementRef& id;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Type_ARRAY : ebmcodegen::util::ContextBase<Context_Type_ARRAY> {
        constexpr static std::string_view context_name = "Type_ARRAY";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::ArrayAnnotation& array_annotation;
        const ebm::TypeRef& element_type;
        const ebm::Varint& length;
    };
    template <typename Result>
    struct Context_Type_ARRAY_before : ebmcodegen::util::ContextBase<Context_Type_ARRAY_before<Result>> {
        constexpr static std::string_view context_name = "Type_ARRAY_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::ArrayAnnotation& array_annotation;
        const ebm::TypeRef& element_type;
        const ebm::Varint& length;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Type_ARRAY_after : ebmcodegen::util::ContextBase<Context_Type_ARRAY_after<Result>> {
        constexpr static std::string_view context_name = "Type_ARRAY_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::ArrayAnnotation& array_annotation;
        const ebm::TypeRef& element_type;
        const ebm::Varint& length;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Type_VECTOR : ebmcodegen::util::ContextBase<Context_Type_VECTOR> {
        constexpr static std::string_view context_name = "Type_VECTOR";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& element_type;
    };
    template <typename Result>
    struct Context_Type_VECTOR_before : ebmcodegen::util::ContextBase<Context_Type_VECTOR_before<Result>> {
        constexpr static std::string_view context_name = "Type_VECTOR_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& element_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Type_VECTOR_after : ebmcodegen::util::ContextBase<Context_Type_VECTOR_after<Result>> {
        constexpr static std::string_view context_name = "Type_VECTOR_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& element_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Type_VARIANT : ebmcodegen::util::ContextBase<Context_Type_VARIANT> {
        constexpr static std::string_view context_name = "Type_VARIANT";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::VariantDesc& variant_desc;
    };
    template <typename Result>
    struct Context_Type_VARIANT_before : ebmcodegen::util::ContextBase<Context_Type_VARIANT_before<Result>> {
        constexpr static std::string_view context_name = "Type_VARIANT_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::VariantDesc& variant_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Type_VARIANT_after : ebmcodegen::util::ContextBase<Context_Type_VARIANT_after<Result>> {
        constexpr static std::string_view context_name = "Type_VARIANT_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::VariantDesc& variant_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Type_RANGE : ebmcodegen::util::ContextBase<Context_Type_RANGE> {
        constexpr static std::string_view context_name = "Type_RANGE";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& base_type;
    };
    template <typename Result>
    struct Context_Type_RANGE_before : ebmcodegen::util::ContextBase<Context_Type_RANGE_before<Result>> {
        constexpr static std::string_view context_name = "Type_RANGE_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& base_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Type_RANGE_after : ebmcodegen::util::ContextBase<Context_Type_RANGE_after<Result>> {
        constexpr static std::string_view context_name = "Type_RANGE_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& base_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Type_ENCODER_RETURN : ebmcodegen::util::ContextBase<Context_Type_ENCODER_RETURN> {
        constexpr static std::string_view context_name = "Type_ENCODER_RETURN";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    template <typename Result>
    struct Context_Type_ENCODER_RETURN_before : ebmcodegen::util::ContextBase<Context_Type_ENCODER_RETURN_before<Result>> {
        constexpr static std::string_view context_name = "Type_ENCODER_RETURN_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Type_ENCODER_RETURN_after : ebmcodegen::util::ContextBase<Context_Type_ENCODER_RETURN_after<Result>> {
        constexpr static std::string_view context_name = "Type_ENCODER_RETURN_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Type_DECODER_RETURN : ebmcodegen::util::ContextBase<Context_Type_DECODER_RETURN> {
        constexpr static std::string_view context_name = "Type_DECODER_RETURN";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    template <typename Result>
    struct Context_Type_DECODER_RETURN_before : ebmcodegen::util::ContextBase<Context_Type_DECODER_RETURN_before<Result>> {
        constexpr static std::string_view context_name = "Type_DECODER_RETURN_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Type_DECODER_RETURN_after : ebmcodegen::util::ContextBase<Context_Type_DECODER_RETURN_after<Result>> {
        constexpr static std::string_view context_name = "Type_DECODER_RETURN_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Type_ENCODER_INPUT : ebmcodegen::util::ContextBase<Context_Type_ENCODER_INPUT> {
        constexpr static std::string_view context_name = "Type_ENCODER_INPUT";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    template <typename Result>
    struct Context_Type_ENCODER_INPUT_before : ebmcodegen::util::ContextBase<Context_Type_ENCODER_INPUT_before<Result>> {
        constexpr static std::string_view context_name = "Type_ENCODER_INPUT_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Type_ENCODER_INPUT_after : ebmcodegen::util::ContextBase<Context_Type_ENCODER_INPUT_after<Result>> {
        constexpr static std::string_view context_name = "Type_ENCODER_INPUT_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Type_DECODER_INPUT : ebmcodegen::util::ContextBase<Context_Type_DECODER_INPUT> {
        constexpr static std::string_view context_name = "Type_DECODER_INPUT";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    template <typename Result>
    struct Context_Type_DECODER_INPUT_before : ebmcodegen::util::ContextBase<Context_Type_DECODER_INPUT_before<Result>> {
        constexpr static std::string_view context_name = "Type_DECODER_INPUT_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Type_DECODER_INPUT_after : ebmcodegen::util::ContextBase<Context_Type_DECODER_INPUT_after<Result>> {
        constexpr static std::string_view context_name = "Type_DECODER_INPUT_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Type_PROPERTY_SETTER_RETURN : ebmcodegen::util::ContextBase<Context_Type_PROPERTY_SETTER_RETURN> {
        constexpr static std::string_view context_name = "Type_PROPERTY_SETTER_RETURN";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    template <typename Result>
    struct Context_Type_PROPERTY_SETTER_RETURN_before : ebmcodegen::util::ContextBase<Context_Type_PROPERTY_SETTER_RETURN_before<Result>> {
        constexpr static std::string_view context_name = "Type_PROPERTY_SETTER_RETURN_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Type_PROPERTY_SETTER_RETURN_after : ebmcodegen::util::ContextBase<Context_Type_PROPERTY_SETTER_RETURN_after<Result>> {
        constexpr static std::string_view context_name = "Type_PROPERTY_SETTER_RETURN_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Type_OPTIONAL : ebmcodegen::util::ContextBase<Context_Type_OPTIONAL> {
        constexpr static std::string_view context_name = "Type_OPTIONAL";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& inner_type;
    };
    template <typename Result>
    struct Context_Type_OPTIONAL_before : ebmcodegen::util::ContextBase<Context_Type_OPTIONAL_before<Result>> {
        constexpr static std::string_view context_name = "Type_OPTIONAL_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& inner_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Type_OPTIONAL_after : ebmcodegen::util::ContextBase<Context_Type_OPTIONAL_after<Result>> {
        constexpr static std::string_view context_name = "Type_OPTIONAL_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& inner_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Type_PTR : ebmcodegen::util::ContextBase<Context_Type_PTR> {
        constexpr static std::string_view context_name = "Type_PTR";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& pointee_type;
    };
    template <typename Result>
    struct Context_Type_PTR_before : ebmcodegen::util::ContextBase<Context_Type_PTR_before<Result>> {
        constexpr static std::string_view context_name = "Type_PTR_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& pointee_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Type_PTR_after : ebmcodegen::util::ContextBase<Context_Type_PTR_after<Result>> {
        constexpr static std::string_view context_name = "Type_PTR_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& pointee_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Type_FUNCTION : ebmcodegen::util::ContextBase<Context_Type_FUNCTION> {
        constexpr static std::string_view context_name = "Type_FUNCTION";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::FuncTypeDesc& func_desc;
    };
    template <typename Result>
    struct Context_Type_FUNCTION_before : ebmcodegen::util::ContextBase<Context_Type_FUNCTION_before<Result>> {
        constexpr static std::string_view context_name = "Type_FUNCTION_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::FuncTypeDesc& func_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Type_FUNCTION_after : ebmcodegen::util::ContextBase<Context_Type_FUNCTION_after<Result>> {
        constexpr static std::string_view context_name = "Type_FUNCTION_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::FuncTypeDesc& func_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Type : ebmcodegen::util::ContextBase<Context_Type> {
        constexpr static std::string_view context_name = "Type";
        BaseVisitor& visitor;
        const ebm::Type& in;
        ebm::TypeRef alias_ref;
    };
    template <typename Result>
    struct Context_Type_before : ebmcodegen::util::ContextBase<Context_Type_before<Result>> {
        constexpr static std::string_view context_name = "Type_before";
        BaseVisitor& visitor;
        const ebm::Type& in;
        ebm::TypeRef alias_ref;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Type_after : ebmcodegen::util::ContextBase<Context_Type_after<Result>> {
        constexpr static std::string_view context_name = "Type_after";
        BaseVisitor& visitor;
        const ebm::Type& in;
        ebm::TypeRef alias_ref;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct Context_Types : ebmcodegen::util::ContextBase<Context_Types> {
        constexpr static std::string_view context_name = "Types";
        BaseVisitor& visitor;
        const ebm::Types& in;
    };
    template <typename Result>
    struct Context_Types_before : ebmcodegen::util::ContextBase<Context_Types_before<Result>> {
        constexpr static std::string_view context_name = "Types_before";
        BaseVisitor& visitor;
        const ebm::Types& in;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    template <typename Result>
    struct Context_Types_after : ebmcodegen::util::ContextBase<Context_Types_after<Result>> {
        constexpr static std::string_view context_name = "Types_after";
        BaseVisitor& visitor;
        const ebm::Types& in;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
#define CODEGEN_MAY_HIJACK(value) \
    if (ebmcodegen::util::needs_return(value)) { \
        return ebmcodegen::util::wrap_return(std::move(value)); \
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_entry(Context&& ctx){
        auto main_logic = [&]() -> expected<Result>{
            Context_entry new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_entry_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_entry_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_entry(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_pre_visitor(Context&& ctx,ebm::ExtendedBinaryModule& ebm){
        auto main_logic = [&]() -> expected<Result>{
            Context_pre_visitor new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .ebm = ebm,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_pre_visitor_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .ebm = ebm,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_pre_visitor_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .ebm = ebm,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_pre_visitor(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_post_entry(Context&& ctx,expected<Result>& entry_result){
        auto main_logic = [&]() -> expected<Result>{
            Context_post_entry<Result> new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .entry_result = entry_result,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_post_entry_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .entry_result = entry_result,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_post_entry_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .entry_result = entry_result,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_post_entry(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_BLOCK(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.block()) {
            return unexpect_error("Unexpected null pointer for StatementBody::block");
        }
        auto& block = *in.body.block();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_BLOCK new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .block = block,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_BLOCK_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .block = block,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_BLOCK_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .block = block,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_BLOCK(UserContext&& ctx,TypeContext&& type_ctx) {
        auto result_block = dispatch_Block_default<Result>(std::forward<UserContext>(ctx),type_ctx.block);
        if (!result_block) {
            return unexpect_error(std::move(result_block.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_ASSIGNMENT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.previous_assignment()) {
            return unexpect_error("Unexpected null pointer for StatementBody::previous_assignment");
        }
        auto& previous_assignment = *in.body.previous_assignment();
        if (!in.body.target()) {
            return unexpect_error("Unexpected null pointer for StatementBody::target");
        }
        auto& target = *in.body.target();
        if (!in.body.value()) {
            return unexpect_error("Unexpected null pointer for StatementBody::value");
        }
        auto& value = *in.body.value();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_ASSIGNMENT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .previous_assignment = previous_assignment,
                .target = target,
                .value = value,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_ASSIGNMENT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .previous_assignment = previous_assignment,
            .target = target,
            .value = value,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_ASSIGNMENT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .previous_assignment = previous_assignment,
            .target = target,
            .value = value,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ASSIGNMENT(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.target)) {
            auto result_target = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target);
            if (!result_target) {
                return unexpect_error(std::move(result_target.error()));
            }
        }
        if (!is_nil(type_ctx.value)) {
            auto result_value = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.value);
            if (!result_value) {
                return unexpect_error(std::move(result_value.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_YIELD(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.previous_assignment()) {
            return unexpect_error("Unexpected null pointer for StatementBody::previous_assignment");
        }
        auto& previous_assignment = *in.body.previous_assignment();
        if (!in.body.target()) {
            return unexpect_error("Unexpected null pointer for StatementBody::target");
        }
        auto& target = *in.body.target();
        if (!in.body.value()) {
            return unexpect_error("Unexpected null pointer for StatementBody::value");
        }
        auto& value = *in.body.value();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_YIELD new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .previous_assignment = previous_assignment,
                .target = target,
                .value = value,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_YIELD_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .previous_assignment = previous_assignment,
            .target = target,
            .value = value,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_YIELD_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .previous_assignment = previous_assignment,
            .target = target,
            .value = value,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_YIELD(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.target)) {
            auto result_target = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target);
            if (!result_target) {
                return unexpect_error(std::move(result_target.error()));
            }
        }
        if (!is_nil(type_ctx.value)) {
            auto result_value = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.value);
            if (!result_value) {
                return unexpect_error(std::move(result_value.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_APPEND(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.target()) {
            return unexpect_error("Unexpected null pointer for StatementBody::target");
        }
        auto& target = *in.body.target();
        if (!in.body.value()) {
            return unexpect_error("Unexpected null pointer for StatementBody::value");
        }
        auto& value = *in.body.value();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_APPEND new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .target = target,
                .value = value,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_APPEND_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .target = target,
            .value = value,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_APPEND_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .target = target,
            .value = value,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_APPEND(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.target)) {
            auto result_target = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target);
            if (!result_target) {
                return unexpect_error(std::move(result_target.error()));
            }
        }
        if (!is_nil(type_ctx.value)) {
            auto result_value = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.value);
            if (!result_value) {
                return unexpect_error(std::move(result_value.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_RETURN(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.related_function()) {
            return unexpect_error("Unexpected null pointer for StatementBody::related_function");
        }
        auto& related_function = *in.body.related_function();
        if (!in.body.value()) {
            return unexpect_error("Unexpected null pointer for StatementBody::value");
        }
        auto& value = *in.body.value();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_RETURN new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .related_function = related_function,
                .value = value,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_RETURN_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .related_function = related_function,
            .value = value,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_RETURN_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .related_function = related_function,
            .value = value,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_RETURN(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.value)) {
            auto result_value = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.value);
            if (!result_value) {
                return unexpect_error(std::move(result_value.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_ERROR_RETURN(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.related_field()) {
            return unexpect_error("Unexpected null pointer for StatementBody::related_field");
        }
        auto& related_field = *in.body.related_field();
        if (!in.body.related_function()) {
            return unexpect_error("Unexpected null pointer for StatementBody::related_function");
        }
        auto& related_function = *in.body.related_function();
        if (!in.body.value()) {
            return unexpect_error("Unexpected null pointer for StatementBody::value");
        }
        auto& value = *in.body.value();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_ERROR_RETURN new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .related_field = related_field,
                .related_function = related_function,
                .value = value,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_ERROR_RETURN_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .related_field = related_field,
            .related_function = related_function,
            .value = value,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_ERROR_RETURN_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .related_field = related_field,
            .related_function = related_function,
            .value = value,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ERROR_RETURN(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.value)) {
            auto result_value = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.value);
            if (!result_value) {
                return unexpect_error(std::move(result_value.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_ASSERT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.assert_desc()) {
            return unexpect_error("Unexpected null pointer for StatementBody::assert_desc");
        }
        auto& assert_desc = *in.body.assert_desc();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_ASSERT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .assert_desc = assert_desc,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_ASSERT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .assert_desc = assert_desc,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_ASSERT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .assert_desc = assert_desc,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ASSERT(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.assert_desc.condition.cond)) {
            auto result_cond = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.assert_desc.condition.cond);
            if (!result_cond) {
                return unexpect_error(std::move(result_cond.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_READ_DATA(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.read_data()) {
            return unexpect_error("Unexpected null pointer for StatementBody::read_data");
        }
        auto& read_data = *in.body.read_data();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_READ_DATA new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .read_data = read_data,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_READ_DATA_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .read_data = read_data,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_READ_DATA_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .read_data = read_data,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_READ_DATA(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.read_data.io_ref)) {
            auto result_io_ref = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.read_data.io_ref);
            if (!result_io_ref) {
                return unexpect_error(std::move(result_io_ref.error()));
            }
        }
        if (!is_nil(type_ctx.read_data.target)) {
            auto result_target = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.read_data.target);
            if (!result_target) {
                return unexpect_error(std::move(result_target.error()));
            }
        }
        if (!is_nil(type_ctx.read_data.data_type)) {
            auto result_data_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.read_data.data_type);
            if (!result_data_type) {
                return unexpect_error(std::move(result_data_type.error()));
            }
        }
        if (auto ptr = type_ctx.read_data.attribute.dynamic_ref()) {
            if (!is_nil((*ptr))) {
                auto result_dynamic_ref = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_dynamic_ref) {
                    return unexpect_error(std::move(result_dynamic_ref.error()));
                }
            }
        }
        if (auto ptr = type_ctx.read_data.size.ref()) {
            if (!is_nil((*ptr))) {
                auto result_ref = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_ref) {
                    return unexpect_error(std::move(result_ref.error()));
                }
            }
        }
        if (auto ptr_lowered_statement = type_ctx.read_data.lowered_statement()) {
        }
        if (auto ptr = type_ctx.read_data.offset()) {
            if (!is_nil((*ptr))) {
                auto result_offset = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_offset) {
                    return unexpect_error(std::move(result_offset.error()));
                }
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_WRITE_DATA(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.write_data()) {
            return unexpect_error("Unexpected null pointer for StatementBody::write_data");
        }
        auto& write_data = *in.body.write_data();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_WRITE_DATA new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .write_data = write_data,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_WRITE_DATA_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .write_data = write_data,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_WRITE_DATA_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .write_data = write_data,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_WRITE_DATA(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.write_data.io_ref)) {
            auto result_io_ref = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.write_data.io_ref);
            if (!result_io_ref) {
                return unexpect_error(std::move(result_io_ref.error()));
            }
        }
        if (!is_nil(type_ctx.write_data.target)) {
            auto result_target = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.write_data.target);
            if (!result_target) {
                return unexpect_error(std::move(result_target.error()));
            }
        }
        if (!is_nil(type_ctx.write_data.data_type)) {
            auto result_data_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.write_data.data_type);
            if (!result_data_type) {
                return unexpect_error(std::move(result_data_type.error()));
            }
        }
        if (auto ptr = type_ctx.write_data.attribute.dynamic_ref()) {
            if (!is_nil((*ptr))) {
                auto result_dynamic_ref = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_dynamic_ref) {
                    return unexpect_error(std::move(result_dynamic_ref.error()));
                }
            }
        }
        if (auto ptr = type_ctx.write_data.size.ref()) {
            if (!is_nil((*ptr))) {
                auto result_ref = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_ref) {
                    return unexpect_error(std::move(result_ref.error()));
                }
            }
        }
        if (auto ptr_lowered_statement = type_ctx.write_data.lowered_statement()) {
        }
        if (auto ptr = type_ctx.write_data.offset()) {
            if (!is_nil((*ptr))) {
                auto result_offset = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_offset) {
                    return unexpect_error(std::move(result_offset.error()));
                }
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_RESERVE_DATA(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.reserve_data()) {
            return unexpect_error("Unexpected null pointer for StatementBody::reserve_data");
        }
        auto& reserve_data = *in.body.reserve_data();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_RESERVE_DATA new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .reserve_data = reserve_data,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_RESERVE_DATA_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .reserve_data = reserve_data,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_RESERVE_DATA_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .reserve_data = reserve_data,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_RESERVE_DATA(UserContext&& ctx,TypeContext&& type_ctx) {
        if (auto ptr = type_ctx.reserve_data.size.ref()) {
            if (!is_nil((*ptr))) {
                auto result_ref = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_ref) {
                    return unexpect_error(std::move(result_ref.error()));
                }
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_IF_STATEMENT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.if_statement()) {
            return unexpect_error("Unexpected null pointer for StatementBody::if_statement");
        }
        auto& if_statement = *in.body.if_statement();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_IF_STATEMENT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .if_statement = if_statement,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_IF_STATEMENT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .if_statement = if_statement,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_IF_STATEMENT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .if_statement = if_statement,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_IF_STATEMENT(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.if_statement.condition.cond)) {
            auto result_cond = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.if_statement.condition.cond);
            if (!result_cond) {
                return unexpect_error(std::move(result_cond.error()));
            }
        }
        if (!is_nil(type_ctx.if_statement.then_block)) {
            auto result_then_block = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.if_statement.then_block);
            if (!result_then_block) {
                return unexpect_error(std::move(result_then_block.error()));
            }
        }
        if (!is_nil(type_ctx.if_statement.else_block)) {
            auto result_else_block = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.if_statement.else_block);
            if (!result_else_block) {
                return unexpect_error(std::move(result_else_block.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_LOOP_STATEMENT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.loop()) {
            return unexpect_error("Unexpected null pointer for StatementBody::loop");
        }
        auto& loop = *in.body.loop();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_LOOP_STATEMENT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .loop = loop,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_LOOP_STATEMENT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .loop = loop,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_LOOP_STATEMENT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .loop = loop,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_LOOP_STATEMENT(UserContext&& ctx,TypeContext&& type_ctx) {
        if (auto ptr = type_ctx.loop.collection()) {
            if (!is_nil((*ptr))) {
                auto result_collection = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_collection) {
                    return unexpect_error(std::move(result_collection.error()));
                }
            }
        }
        if (auto ptr_condition = type_ctx.loop.condition()) {
            if (!is_nil((*ptr_condition).cond)) {
                auto result_cond = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr_condition).cond);
                if (!result_cond) {
                    return unexpect_error(std::move(result_cond.error()));
                }
            }
        }
        if (auto ptr = type_ctx.loop.increment()) {
            if (!is_nil((*ptr))) {
                auto result_increment = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_increment) {
                    return unexpect_error(std::move(result_increment.error()));
                }
            }
        }
        if (auto ptr = type_ctx.loop.init()) {
            if (!is_nil((*ptr))) {
                auto result_init = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_init) {
                    return unexpect_error(std::move(result_init.error()));
                }
            }
        }
        if (auto ptr = type_ctx.loop.item_var()) {
            if (!is_nil((*ptr))) {
                auto result_item_var = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_item_var) {
                    return unexpect_error(std::move(result_item_var.error()));
                }
            }
        }
        if (!is_nil(type_ctx.loop.body)) {
            auto result_body = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.loop.body);
            if (!result_body) {
                return unexpect_error(std::move(result_body.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_MATCH_STATEMENT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.match_statement()) {
            return unexpect_error("Unexpected null pointer for StatementBody::match_statement");
        }
        auto& match_statement = *in.body.match_statement();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_MATCH_STATEMENT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .match_statement = match_statement,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_MATCH_STATEMENT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .match_statement = match_statement,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_MATCH_STATEMENT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .match_statement = match_statement,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_MATCH_STATEMENT(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.match_statement.target)) {
            auto result_target = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.match_statement.target);
            if (!result_target) {
                return unexpect_error(std::move(result_target.error()));
            }
        }
        auto result_branches = dispatch_Block_default<Result>(std::forward<UserContext>(ctx),type_ctx.match_statement.branches);
        if (!result_branches) {
            return unexpect_error(std::move(result_branches.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_MATCH_BRANCH(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.match_branch()) {
            return unexpect_error("Unexpected null pointer for StatementBody::match_branch");
        }
        auto& match_branch = *in.body.match_branch();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_MATCH_BRANCH new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .match_branch = match_branch,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_MATCH_BRANCH_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .match_branch = match_branch,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_MATCH_BRANCH_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .match_branch = match_branch,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_MATCH_BRANCH(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.match_branch.condition.cond)) {
            auto result_cond = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.match_branch.condition.cond);
            if (!result_cond) {
                return unexpect_error(std::move(result_cond.error()));
            }
        }
        if (!is_nil(type_ctx.match_branch.body)) {
            auto result_body = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.match_branch.body);
            if (!result_body) {
                return unexpect_error(std::move(result_body.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_BREAK(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.break_()) {
            return unexpect_error("Unexpected null pointer for StatementBody::break_");
        }
        auto& break_ = *in.body.break_();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_BREAK new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .break_ = break_,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_BREAK_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .break_ = break_,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_BREAK_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .break_ = break_,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_BREAK(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_CONTINUE(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.continue_()) {
            return unexpect_error("Unexpected null pointer for StatementBody::continue_");
        }
        auto& continue_ = *in.body.continue_();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_CONTINUE new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .continue_ = continue_,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_CONTINUE_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .continue_ = continue_,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_CONTINUE_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .continue_ = continue_,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_CONTINUE(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_FUNCTION_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.func_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::func_decl");
        }
        auto& func_decl = *in.body.func_decl();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_FUNCTION_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .func_decl = func_decl,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_FUNCTION_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .func_decl = func_decl,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_FUNCTION_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .func_decl = func_decl,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_FUNCTION_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.func_decl.return_type)) {
            auto result_return_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.func_decl.return_type);
            if (!result_return_type) {
                return unexpect_error(std::move(result_return_type.error()));
            }
        }
        auto result_params = dispatch_Block_default<Result>(std::forward<UserContext>(ctx),type_ctx.func_decl.params);
        if (!result_params) {
            return unexpect_error(std::move(result_params.error()));
        }
        if (!is_nil(type_ctx.func_decl.body)) {
            auto result_body = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.func_decl.body);
            if (!result_body) {
                return unexpect_error(std::move(result_body.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_VARIABLE_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.var_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::var_decl");
        }
        auto& var_decl = *in.body.var_decl();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_VARIABLE_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .var_decl = var_decl,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_VARIABLE_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .var_decl = var_decl,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_VARIABLE_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .var_decl = var_decl,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_VARIABLE_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.var_decl.var_type)) {
            auto result_var_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.var_decl.var_type);
            if (!result_var_type) {
                return unexpect_error(std::move(result_var_type.error()));
            }
        }
        if (!is_nil(type_ctx.var_decl.initial_value)) {
            auto result_initial_value = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.var_decl.initial_value);
            if (!result_initial_value) {
                return unexpect_error(std::move(result_initial_value.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_PARAMETER_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.param_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::param_decl");
        }
        auto& param_decl = *in.body.param_decl();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_PARAMETER_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .param_decl = param_decl,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_PARAMETER_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .param_decl = param_decl,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_PARAMETER_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .param_decl = param_decl,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_PARAMETER_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.param_decl.param_type)) {
            auto result_param_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.param_decl.param_type);
            if (!result_param_type) {
                return unexpect_error(std::move(result_param_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_FIELD_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.field_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::field_decl");
        }
        auto& field_decl = *in.body.field_decl();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_FIELD_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .field_decl = field_decl,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_FIELD_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .field_decl = field_decl,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_FIELD_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .field_decl = field_decl,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_FIELD_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.field_decl.field_type)) {
            auto result_field_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.field_decl.field_type);
            if (!result_field_type) {
                return unexpect_error(std::move(result_field_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_COMPOSITE_FIELD_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.composite_field_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::composite_field_decl");
        }
        auto& composite_field_decl = *in.body.composite_field_decl();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_COMPOSITE_FIELD_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .composite_field_decl = composite_field_decl,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_COMPOSITE_FIELD_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .composite_field_decl = composite_field_decl,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_COMPOSITE_FIELD_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .composite_field_decl = composite_field_decl,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_COMPOSITE_FIELD_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        auto result_fields = dispatch_Block_default<Result>(std::forward<UserContext>(ctx),type_ctx.composite_field_decl.fields);
        if (!result_fields) {
            return unexpect_error(std::move(result_fields.error()));
        }
        if (!is_nil(type_ctx.composite_field_decl.composite_type)) {
            auto result_composite_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.composite_field_decl.composite_type);
            if (!result_composite_type) {
                return unexpect_error(std::move(result_composite_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_ENUM_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.enum_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::enum_decl");
        }
        auto& enum_decl = *in.body.enum_decl();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_ENUM_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .enum_decl = enum_decl,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_ENUM_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .enum_decl = enum_decl,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_ENUM_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .enum_decl = enum_decl,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ENUM_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.enum_decl.base_type)) {
            auto result_base_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.enum_decl.base_type);
            if (!result_base_type) {
                return unexpect_error(std::move(result_base_type.error()));
            }
        }
        auto result_members = dispatch_Block_default<Result>(std::forward<UserContext>(ctx),type_ctx.enum_decl.members);
        if (!result_members) {
            return unexpect_error(std::move(result_members.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_ENUM_MEMBER_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.enum_member_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::enum_member_decl");
        }
        auto& enum_member_decl = *in.body.enum_member_decl();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_ENUM_MEMBER_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .enum_member_decl = enum_member_decl,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_ENUM_MEMBER_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .enum_member_decl = enum_member_decl,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_ENUM_MEMBER_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .enum_member_decl = enum_member_decl,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ENUM_MEMBER_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.enum_member_decl.value)) {
            auto result_value = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.enum_member_decl.value);
            if (!result_value) {
                return unexpect_error(std::move(result_value.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_STRUCT_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.struct_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::struct_decl");
        }
        auto& struct_decl = *in.body.struct_decl();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_STRUCT_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .struct_decl = struct_decl,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_STRUCT_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .struct_decl = struct_decl,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_STRUCT_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .struct_decl = struct_decl,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_STRUCT_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        auto result_fields = dispatch_Block_default<Result>(std::forward<UserContext>(ctx),type_ctx.struct_decl.fields);
        if (!result_fields) {
            return unexpect_error(std::move(result_fields.error()));
        }
        if (auto ptr = type_ctx.struct_decl.related_variant()) {
            if (!is_nil((*ptr))) {
                auto result_related_variant = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_related_variant) {
                    return unexpect_error(std::move(result_related_variant.error()));
                }
            }
        }
        if (auto ptr_size = type_ctx.struct_decl.size()) {
            if (auto ptr = (*ptr_size).ref()) {
                if (!is_nil((*ptr))) {
                    auto result_ref = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                    if (!result_ref) {
                        return unexpect_error(std::move(result_ref.error()));
                    }
                }
            }
        }
        if (auto ptr = type_ctx.struct_decl.decode_fn()) {
            if (!is_nil((*ptr))) {
                auto result_decode_fn = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_decode_fn) {
                    return unexpect_error(std::move(result_decode_fn.error()));
                }
            }
        }
        if (auto ptr = type_ctx.struct_decl.encode_fn()) {
            if (!is_nil((*ptr))) {
                auto result_encode_fn = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_encode_fn) {
                    return unexpect_error(std::move(result_encode_fn.error()));
                }
            }
        }
        if (auto ptr = type_ctx.struct_decl.methods()) {
            auto result_methods = dispatch_Block_default<Result>(std::forward<UserContext>(ctx),(*ptr));
            if (!result_methods) {
                return unexpect_error(std::move(result_methods.error()));
            }
        }
        if (auto ptr = type_ctx.struct_decl.properties()) {
            auto result_properties = dispatch_Block_default<Result>(std::forward<UserContext>(ctx),(*ptr));
            if (!result_properties) {
                return unexpect_error(std::move(result_properties.error()));
            }
        }
        if (auto ptr = type_ctx.struct_decl.nested_types()) {
            auto result_nested_types = dispatch_Block_default<Result>(std::forward<UserContext>(ctx),(*ptr));
            if (!result_nested_types) {
                return unexpect_error(std::move(result_nested_types.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_UNION_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_UNION_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_UNION_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_UNION_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_UNION_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_UNION_MEMBER_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_UNION_MEMBER_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_UNION_MEMBER_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_UNION_MEMBER_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_UNION_MEMBER_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_PROGRAM_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.block()) {
            return unexpect_error("Unexpected null pointer for StatementBody::block");
        }
        auto& block = *in.body.block();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_PROGRAM_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .block = block,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_PROGRAM_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .block = block,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_PROGRAM_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .block = block,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_PROGRAM_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        auto result_block = dispatch_Block_default<Result>(std::forward<UserContext>(ctx),type_ctx.block);
        if (!result_block) {
            return unexpect_error(std::move(result_block.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_PROPERTY_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.property_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::property_decl");
        }
        auto& property_decl = *in.body.property_decl();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_PROPERTY_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .property_decl = property_decl,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_PROPERTY_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .property_decl = property_decl,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_PROPERTY_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .property_decl = property_decl,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_PROPERTY_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.property_decl.property_type)) {
            auto result_property_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.property_decl.property_type);
            if (!result_property_type) {
                return unexpect_error(std::move(result_property_type.error()));
            }
        }
        if (!is_nil(type_ctx.property_decl.setter_condition)) {
            auto result_setter_condition = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.property_decl.setter_condition);
            if (!result_setter_condition) {
                return unexpect_error(std::move(result_setter_condition.error()));
            }
        }
        if (!is_nil(type_ctx.property_decl.getter_condition)) {
            auto result_getter_condition = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.property_decl.getter_condition);
            if (!result_getter_condition) {
                return unexpect_error(std::move(result_getter_condition.error()));
            }
        }
        auto result_members = dispatch_Block_default<Result>(std::forward<UserContext>(ctx),type_ctx.property_decl.members);
        if (!result_members) {
            return unexpect_error(std::move(result_members.error()));
        }
        if (auto ptr = type_ctx.property_decl.derived_from()) {
            auto result_derived_from = dispatch_Block_default<Result>(std::forward<UserContext>(ctx),(*ptr));
            if (!result_derived_from) {
                return unexpect_error(std::move(result_derived_from.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_PROPERTY_MEMBER_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.property_member_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::property_member_decl");
        }
        auto& property_member_decl = *in.body.property_member_decl();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_PROPERTY_MEMBER_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .property_member_decl = property_member_decl,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_PROPERTY_MEMBER_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .property_member_decl = property_member_decl,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_PROPERTY_MEMBER_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .property_member_decl = property_member_decl,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_PROPERTY_MEMBER_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.property_member_decl.setter_condition)) {
            auto result_setter_condition = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.property_member_decl.setter_condition);
            if (!result_setter_condition) {
                return unexpect_error(std::move(result_setter_condition.error()));
            }
        }
        if (!is_nil(type_ctx.property_member_decl.getter_condition)) {
            auto result_getter_condition = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.property_member_decl.getter_condition);
            if (!result_getter_condition) {
                return unexpect_error(std::move(result_getter_condition.error()));
            }
        }
        if (!is_nil(type_ctx.property_member_decl.field)) {
            auto result_field = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.property_member_decl.field);
            if (!result_field) {
                return unexpect_error(std::move(result_field.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_METADATA(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.metadata()) {
            return unexpect_error("Unexpected null pointer for StatementBody::metadata");
        }
        auto& metadata = *in.body.metadata();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_METADATA new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .metadata = metadata,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_METADATA_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .metadata = metadata,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_METADATA_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .metadata = metadata,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_METADATA(UserContext&& ctx,TypeContext&& type_ctx) {
        auto result_values = dispatch_Expressions_default<Result>(std::forward<UserContext>(ctx),type_ctx.metadata.values);
        if (!result_values) {
            return unexpect_error(std::move(result_values.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_IMPORT_MODULE(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.import_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::import_decl");
        }
        auto& import_decl = *in.body.import_decl();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_IMPORT_MODULE new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .import_decl = import_decl,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_IMPORT_MODULE_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .import_decl = import_decl,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_IMPORT_MODULE_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .import_decl = import_decl,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_IMPORT_MODULE(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.import_decl.program)) {
            auto result_program = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.import_decl.program);
            if (!result_program) {
                return unexpect_error(std::move(result_program.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_EXPRESSION(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.expression()) {
            return unexpect_error("Unexpected null pointer for StatementBody::expression");
        }
        auto& expression = *in.body.expression();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_EXPRESSION new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .expression = expression,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_EXPRESSION_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .expression = expression,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_EXPRESSION_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .expression = expression,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_EXPRESSION(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.expression)) {
            auto result_expression = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.expression);
            if (!result_expression) {
                return unexpect_error(std::move(result_expression.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_ERROR_REPORT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.error_report()) {
            return unexpect_error("Unexpected null pointer for StatementBody::error_report");
        }
        auto& error_report = *in.body.error_report();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_ERROR_REPORT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .error_report = error_report,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_ERROR_REPORT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .error_report = error_report,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_ERROR_REPORT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .error_report = error_report,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ERROR_REPORT(UserContext&& ctx,TypeContext&& type_ctx) {
        auto result_arguments = dispatch_Expressions_default<Result>(std::forward<UserContext>(ctx),type_ctx.error_report.arguments);
        if (!result_arguments) {
            return unexpect_error(std::move(result_arguments.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_LOWERED_IO_STATEMENTS(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.lowered_io_statements()) {
            return unexpect_error("Unexpected null pointer for StatementBody::lowered_io_statements");
        }
        auto& lowered_io_statements = *in.body.lowered_io_statements();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_LOWERED_IO_STATEMENTS new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .lowered_io_statements = lowered_io_statements,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_LOWERED_IO_STATEMENTS_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .lowered_io_statements = lowered_io_statements,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_LOWERED_IO_STATEMENTS_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .lowered_io_statements = lowered_io_statements,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_LOWERED_IO_STATEMENTS(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_SUB_BYTE_RANGE(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.sub_byte_range()) {
            return unexpect_error("Unexpected null pointer for StatementBody::sub_byte_range");
        }
        auto& sub_byte_range = *in.body.sub_byte_range();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_SUB_BYTE_RANGE new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .sub_byte_range = sub_byte_range,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_SUB_BYTE_RANGE_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .sub_byte_range = sub_byte_range,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_SUB_BYTE_RANGE_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .sub_byte_range = sub_byte_range,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_SUB_BYTE_RANGE(UserContext&& ctx,TypeContext&& type_ctx) {
        if (auto ptr = type_ctx.sub_byte_range.expression()) {
            if (!is_nil((*ptr))) {
                auto result_expression = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_expression) {
                    return unexpect_error(std::move(result_expression.error()));
                }
            }
        }
        if (auto ptr = type_ctx.sub_byte_range.length()) {
            if (!is_nil((*ptr))) {
                auto result_length = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_length) {
                    return unexpect_error(std::move(result_length.error()));
                }
            }
        }
        if (auto ptr = type_ctx.sub_byte_range.offset()) {
            if (!is_nil((*ptr))) {
                auto result_offset = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_offset) {
                    return unexpect_error(std::move(result_offset.error()));
                }
            }
        }
        if (!is_nil(type_ctx.sub_byte_range.io_ref)) {
            auto result_io_ref = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.sub_byte_range.io_ref);
            if (!result_io_ref) {
                return unexpect_error(std::move(result_io_ref.error()));
            }
        }
        if (!is_nil(type_ctx.sub_byte_range.io_statement)) {
            auto result_io_statement = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.sub_byte_range.io_statement);
            if (!result_io_statement) {
                return unexpect_error(std::move(result_io_statement.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_INIT_CHECK(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.init_check()) {
            return unexpect_error("Unexpected null pointer for StatementBody::init_check");
        }
        auto& init_check = *in.body.init_check();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_INIT_CHECK new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .init_check = init_check,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_INIT_CHECK_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .init_check = init_check,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_INIT_CHECK_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .init_check = init_check,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_INIT_CHECK(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.init_check.target_field)) {
            auto result_target_field = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.init_check.target_field);
            if (!result_target_field) {
                return unexpect_error(std::move(result_target_field.error()));
            }
        }
        if (!is_nil(type_ctx.init_check.expect_value)) {
            auto result_expect_value = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.init_check.expect_value);
            if (!result_expect_value) {
                return unexpect_error(std::move(result_expect_value.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_ENDIAN_VARIABLE(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.endian_variable()) {
            return unexpect_error("Unexpected null pointer for StatementBody::endian_variable");
        }
        auto& endian_variable = *in.body.endian_variable();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_ENDIAN_VARIABLE new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .endian_variable = endian_variable,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_ENDIAN_VARIABLE_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .endian_variable = endian_variable,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_ENDIAN_VARIABLE_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .endian_variable = endian_variable,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ENDIAN_VARIABLE(UserContext&& ctx,TypeContext&& type_ctx) {
        if (auto ptr = type_ctx.endian_variable.dynamic_expr()) {
            if (!is_nil((*ptr))) {
                auto result_dynamic_expr = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_dynamic_expr) {
                    return unexpect_error(std::move(result_dynamic_expr.error()));
                }
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_ARRAY_TO_INT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.endian_convert()) {
            return unexpect_error("Unexpected null pointer for StatementBody::endian_convert");
        }
        auto& endian_convert = *in.body.endian_convert();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_ARRAY_TO_INT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .endian_convert = endian_convert,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_ARRAY_TO_INT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .endian_convert = endian_convert,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_ARRAY_TO_INT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .endian_convert = endian_convert,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ARRAY_TO_INT(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.endian_convert.target)) {
            auto result_target = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.endian_convert.target);
            if (!result_target) {
                return unexpect_error(std::move(result_target.error()));
            }
        }
        if (!is_nil(type_ctx.endian_convert.source)) {
            auto result_source = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.endian_convert.source);
            if (!result_source) {
                return unexpect_error(std::move(result_source.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_INT_TO_ARRAY(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.endian_convert()) {
            return unexpect_error("Unexpected null pointer for StatementBody::endian_convert");
        }
        auto& endian_convert = *in.body.endian_convert();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_INT_TO_ARRAY new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .endian_convert = endian_convert,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_INT_TO_ARRAY_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .endian_convert = endian_convert,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_INT_TO_ARRAY_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .endian_convert = endian_convert,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_INT_TO_ARRAY(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.endian_convert.target)) {
            auto result_target = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.endian_convert.target);
            if (!result_target) {
                return unexpect_error(std::move(result_target.error()));
            }
        }
        if (!is_nil(type_ctx.endian_convert.source)) {
            auto result_source = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.endian_convert.source);
            if (!result_source) {
                return unexpect_error(std::move(result_source.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .in = in,
                .alias_ref = alias_ref,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .in = in,
            .alias_ref = alias_ref,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Statement_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .in = in,
            .alias_ref = alias_ref,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement(UserContext&& ctx,TypeContext&& type_ctx) {
        auto result_in = dispatch_Statement_default<Result>(std::forward<UserContext>(ctx),type_ctx.in,type_ctx.alias_ref);
        if (!result_in) {
            return unexpect_error(std::move(result_in.error()));
        }
        return result_in;
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Block(Context&& ctx,const ebm::Block& in){
        auto main_logic = [&]() -> expected<Result>{
            Context_Block new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .in = in,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Block_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .in = in,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Block_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .in = in,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Block(UserContext&& ctx,TypeContext&& type_ctx) {
        auto result_in = dispatch_Block_default<Result>(std::forward<UserContext>(ctx),type_ctx.in);
        if (!result_in) {
            return unexpect_error(std::move(result_in.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_LITERAL_INT(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.int_value()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::int_value");
        }
        auto& int_value = *in.body.int_value();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_LITERAL_INT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .int_value = int_value,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_LITERAL_INT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .int_value = int_value,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_LITERAL_INT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .int_value = int_value,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_LITERAL_INT(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_LITERAL_INT64(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.int64_value()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::int64_value");
        }
        auto& int64_value = *in.body.int64_value();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_LITERAL_INT64 new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .int64_value = int64_value,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_LITERAL_INT64_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .int64_value = int64_value,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_LITERAL_INT64_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .int64_value = int64_value,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_LITERAL_INT64(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_LITERAL_BOOL(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.bool_value()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::bool_value");
        }
        auto& bool_value = *in.body.bool_value();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_LITERAL_BOOL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .bool_value = bool_value,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_LITERAL_BOOL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .bool_value = bool_value,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_LITERAL_BOOL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .bool_value = bool_value,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_LITERAL_BOOL(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_LITERAL_STRING(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.string_value()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::string_value");
        }
        auto& string_value = *in.body.string_value();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_LITERAL_STRING new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .string_value = string_value,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_LITERAL_STRING_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .string_value = string_value,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_LITERAL_STRING_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .string_value = string_value,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_LITERAL_STRING(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_LITERAL_TYPE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.type_ref()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::type_ref");
        }
        auto& type_ref = *in.body.type_ref();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_LITERAL_TYPE new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .type_ref = type_ref,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_LITERAL_TYPE_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .type_ref = type_ref,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_LITERAL_TYPE_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .type_ref = type_ref,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_LITERAL_TYPE(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.type_ref)) {
            auto result_type_ref = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type_ref);
            if (!result_type_ref) {
                return unexpect_error(std::move(result_type_ref.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_LITERAL_CHAR(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.char_value()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::char_value");
        }
        auto& char_value = *in.body.char_value();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_LITERAL_CHAR new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .char_value = char_value,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_LITERAL_CHAR_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .char_value = char_value,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_LITERAL_CHAR_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .char_value = char_value,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_LITERAL_CHAR(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_IDENTIFIER(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.id()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::id");
        }
        auto& id = *in.body.id();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_IDENTIFIER new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .id = id,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_IDENTIFIER_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .id = id,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_IDENTIFIER_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .id = id,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_IDENTIFIER(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_BINARY_OP(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.bop()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::bop");
        }
        auto& bop = *in.body.bop();
        if (!in.body.left()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::left");
        }
        auto& left = *in.body.left();
        if (!in.body.right()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::right");
        }
        auto& right = *in.body.right();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_BINARY_OP new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .bop = bop,
                .left = left,
                .right = right,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_BINARY_OP_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .bop = bop,
            .left = left,
            .right = right,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_BINARY_OP_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .bop = bop,
            .left = left,
            .right = right,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_BINARY_OP(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.left)) {
            auto result_left = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.left);
            if (!result_left) {
                return unexpect_error(std::move(result_left.error()));
            }
        }
        if (!is_nil(type_ctx.right)) {
            auto result_right = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.right);
            if (!result_right) {
                return unexpect_error(std::move(result_right.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_UNARY_OP(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.operand()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::operand");
        }
        auto& operand = *in.body.operand();
        if (!in.body.uop()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::uop");
        }
        auto& uop = *in.body.uop();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_UNARY_OP new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .operand = operand,
                .uop = uop,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_UNARY_OP_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .operand = operand,
            .uop = uop,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_UNARY_OP_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .operand = operand,
            .uop = uop,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_UNARY_OP(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.operand)) {
            auto result_operand = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.operand);
            if (!result_operand) {
                return unexpect_error(std::move(result_operand.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_CALL(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.call_desc()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::call_desc");
        }
        auto& call_desc = *in.body.call_desc();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_CALL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .call_desc = call_desc,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_CALL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .call_desc = call_desc,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_CALL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .call_desc = call_desc,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_CALL(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.call_desc.callee)) {
            auto result_callee = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.call_desc.callee);
            if (!result_callee) {
                return unexpect_error(std::move(result_callee.error()));
            }
        }
        auto result_arguments = dispatch_Expressions_default<Result>(std::forward<UserContext>(ctx),type_ctx.call_desc.arguments);
        if (!result_arguments) {
            return unexpect_error(std::move(result_arguments.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_INDEX_ACCESS(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.base()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::base");
        }
        auto& base = *in.body.base();
        if (!in.body.index()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::index");
        }
        auto& index = *in.body.index();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_INDEX_ACCESS new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .base = base,
                .index = index,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_INDEX_ACCESS_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .base = base,
            .index = index,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_INDEX_ACCESS_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .base = base,
            .index = index,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_INDEX_ACCESS(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.base)) {
            auto result_base = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.base);
            if (!result_base) {
                return unexpect_error(std::move(result_base.error()));
            }
        }
        if (!is_nil(type_ctx.index)) {
            auto result_index = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.index);
            if (!result_index) {
                return unexpect_error(std::move(result_index.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_MEMBER_ACCESS(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.base()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::base");
        }
        auto& base = *in.body.base();
        if (!in.body.member()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::member");
        }
        auto& member = *in.body.member();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_MEMBER_ACCESS new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .base = base,
                .member = member,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_MEMBER_ACCESS_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .base = base,
            .member = member,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_MEMBER_ACCESS_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .base = base,
            .member = member,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_MEMBER_ACCESS(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.base)) {
            auto result_base = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.base);
            if (!result_base) {
                return unexpect_error(std::move(result_base.error()));
            }
        }
        if (!is_nil(type_ctx.member)) {
            auto result_member = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.member);
            if (!result_member) {
                return unexpect_error(std::move(result_member.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_ENUM_MEMBER(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.enum_decl()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::enum_decl");
        }
        auto& enum_decl = *in.body.enum_decl();
        if (!in.body.member()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::member");
        }
        auto& member = *in.body.member();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_ENUM_MEMBER new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .enum_decl = enum_decl,
                .member = member,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_ENUM_MEMBER_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .enum_decl = enum_decl,
            .member = member,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_ENUM_MEMBER_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .enum_decl = enum_decl,
            .member = member,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_ENUM_MEMBER(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.enum_decl)) {
            auto result_enum_decl = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.enum_decl);
            if (!result_enum_decl) {
                return unexpect_error(std::move(result_enum_decl.error()));
            }
        }
        if (!is_nil(type_ctx.member)) {
            auto result_member = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.member);
            if (!result_member) {
                return unexpect_error(std::move(result_member.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_TYPE_CAST(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.type_cast_desc()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::type_cast_desc");
        }
        auto& type_cast_desc = *in.body.type_cast_desc();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_TYPE_CAST new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .type_cast_desc = type_cast_desc,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_TYPE_CAST_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .type_cast_desc = type_cast_desc,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_TYPE_CAST_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .type_cast_desc = type_cast_desc,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_TYPE_CAST(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.type_cast_desc.source_expr)) {
            auto result_source_expr = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type_cast_desc.source_expr);
            if (!result_source_expr) {
                return unexpect_error(std::move(result_source_expr.error()));
            }
        }
        if (!is_nil(type_ctx.type_cast_desc.from_type)) {
            auto result_from_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type_cast_desc.from_type);
            if (!result_from_type) {
                return unexpect_error(std::move(result_from_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_RANGE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.end()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::end");
        }
        auto& end = *in.body.end();
        if (!in.body.start()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::start");
        }
        auto& start = *in.body.start();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_RANGE new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .end = end,
                .start = start,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_RANGE_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .end = end,
            .start = start,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_RANGE_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .end = end,
            .start = start,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_RANGE(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.end)) {
            auto result_end = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.end);
            if (!result_end) {
                return unexpect_error(std::move(result_end.error()));
            }
        }
        if (!is_nil(type_ctx.start)) {
            auto result_start = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.start);
            if (!result_start) {
                return unexpect_error(std::move(result_start.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_DEFAULT_VALUE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_DEFAULT_VALUE new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_DEFAULT_VALUE_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_DEFAULT_VALUE_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_DEFAULT_VALUE(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_IS_LITTLE_ENDIAN(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.endian_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::endian_expr");
        }
        auto& endian_expr = *in.body.endian_expr();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_IS_LITTLE_ENDIAN new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .endian_expr = endian_expr,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_IS_LITTLE_ENDIAN_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .endian_expr = endian_expr,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_IS_LITTLE_ENDIAN_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .endian_expr = endian_expr,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_IS_LITTLE_ENDIAN(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.endian_expr)) {
            auto result_endian_expr = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.endian_expr);
            if (!result_endian_expr) {
                return unexpect_error(std::move(result_endian_expr.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_GET_STREAM_OFFSET(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.io_ref()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::io_ref");
        }
        auto& io_ref = *in.body.io_ref();
        if (!in.body.stream_type()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::stream_type");
        }
        auto& stream_type = *in.body.stream_type();
        if (!in.body.unit()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::unit");
        }
        auto& unit = *in.body.unit();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_GET_STREAM_OFFSET new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .io_ref = io_ref,
                .stream_type = stream_type,
                .unit = unit,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_GET_STREAM_OFFSET_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .io_ref = io_ref,
            .stream_type = stream_type,
            .unit = unit,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_GET_STREAM_OFFSET_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .io_ref = io_ref,
            .stream_type = stream_type,
            .unit = unit,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_GET_STREAM_OFFSET(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.io_ref)) {
            auto result_io_ref = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.io_ref);
            if (!result_io_ref) {
                return unexpect_error(std::move(result_io_ref.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_GET_REMAINING_BYTES(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.io_ref()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::io_ref");
        }
        auto& io_ref = *in.body.io_ref();
        if (!in.body.stream_type()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::stream_type");
        }
        auto& stream_type = *in.body.stream_type();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_GET_REMAINING_BYTES new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .io_ref = io_ref,
                .stream_type = stream_type,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_GET_REMAINING_BYTES_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .io_ref = io_ref,
            .stream_type = stream_type,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_GET_REMAINING_BYTES_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .io_ref = io_ref,
            .stream_type = stream_type,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_GET_REMAINING_BYTES(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.io_ref)) {
            auto result_io_ref = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.io_ref);
            if (!result_io_ref) {
                return unexpect_error(std::move(result_io_ref.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_CAN_READ_STREAM(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.io_ref()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::io_ref");
        }
        auto& io_ref = *in.body.io_ref();
        if (!in.body.num_bytes()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::num_bytes");
        }
        auto& num_bytes = *in.body.num_bytes();
        if (!in.body.stream_type()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::stream_type");
        }
        auto& stream_type = *in.body.stream_type();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_CAN_READ_STREAM new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .io_ref = io_ref,
                .num_bytes = num_bytes,
                .stream_type = stream_type,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_CAN_READ_STREAM_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .io_ref = io_ref,
            .num_bytes = num_bytes,
            .stream_type = stream_type,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_CAN_READ_STREAM_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .io_ref = io_ref,
            .num_bytes = num_bytes,
            .stream_type = stream_type,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_CAN_READ_STREAM(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.io_ref)) {
            auto result_io_ref = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.io_ref);
            if (!result_io_ref) {
                return unexpect_error(std::move(result_io_ref.error()));
            }
        }
        if (auto ptr = type_ctx.num_bytes.ref()) {
            if (!is_nil((*ptr))) {
                auto result_ref = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_ref) {
                    return unexpect_error(std::move(result_ref.error()));
                }
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_ARRAY_SIZE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.array_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::array_expr");
        }
        auto& array_expr = *in.body.array_expr();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_ARRAY_SIZE new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .array_expr = array_expr,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_ARRAY_SIZE_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .array_expr = array_expr,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_ARRAY_SIZE_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .array_expr = array_expr,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_ARRAY_SIZE(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.array_expr)) {
            auto result_array_expr = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.array_expr);
            if (!result_array_expr) {
                return unexpect_error(std::move(result_array_expr.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_ENUM_IS_DEFINED(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.lowered_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::lowered_expr");
        }
        auto& lowered_expr = *in.body.lowered_expr();
        if (!in.body.target_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::target_expr");
        }
        auto& target_expr = *in.body.target_expr();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_ENUM_IS_DEFINED new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .lowered_expr = lowered_expr,
                .target_expr = target_expr,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_ENUM_IS_DEFINED_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .lowered_expr = lowered_expr,
            .target_expr = target_expr,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_ENUM_IS_DEFINED_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .lowered_expr = lowered_expr,
            .target_expr = target_expr,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_ENUM_IS_DEFINED(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.target_expr)) {
            auto result_target_expr = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target_expr);
            if (!result_target_expr) {
                return unexpect_error(std::move(result_target_expr.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_IS_ERROR(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.target_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::target_expr");
        }
        auto& target_expr = *in.body.target_expr();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_IS_ERROR new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .target_expr = target_expr,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_IS_ERROR_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .target_expr = target_expr,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_IS_ERROR_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .target_expr = target_expr,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_IS_ERROR(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.target_expr)) {
            auto result_target_expr = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target_expr);
            if (!result_target_expr) {
                return unexpect_error(std::move(result_target_expr.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_MAX_VALUE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.lowered_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::lowered_expr");
        }
        auto& lowered_expr = *in.body.lowered_expr();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_MAX_VALUE new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .lowered_expr = lowered_expr,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_MAX_VALUE_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .lowered_expr = lowered_expr,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_MAX_VALUE_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .lowered_expr = lowered_expr,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_MAX_VALUE(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_READ_DATA(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.io_statement()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::io_statement");
        }
        auto& io_statement = *in.body.io_statement();
        if (!in.body.target_stmt()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::target_stmt");
        }
        auto& target_stmt = *in.body.target_stmt();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_READ_DATA new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .io_statement = io_statement,
                .target_stmt = target_stmt,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_READ_DATA_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .io_statement = io_statement,
            .target_stmt = target_stmt,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_READ_DATA_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .io_statement = io_statement,
            .target_stmt = target_stmt,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_READ_DATA(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.io_statement)) {
            auto result_io_statement = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.io_statement);
            if (!result_io_statement) {
                return unexpect_error(std::move(result_io_statement.error()));
            }
        }
        if (!is_nil(type_ctx.target_stmt)) {
            auto result_target_stmt = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target_stmt);
            if (!result_target_stmt) {
                return unexpect_error(std::move(result_target_stmt.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_WRITE_DATA(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.io_statement()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::io_statement");
        }
        auto& io_statement = *in.body.io_statement();
        if (!in.body.target_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::target_expr");
        }
        auto& target_expr = *in.body.target_expr();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_WRITE_DATA new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .io_statement = io_statement,
                .target_expr = target_expr,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_WRITE_DATA_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .io_statement = io_statement,
            .target_expr = target_expr,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_WRITE_DATA_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .io_statement = io_statement,
            .target_expr = target_expr,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_WRITE_DATA(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.io_statement)) {
            auto result_io_statement = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.io_statement);
            if (!result_io_statement) {
                return unexpect_error(std::move(result_io_statement.error()));
            }
        }
        if (!is_nil(type_ctx.target_expr)) {
            auto result_target_expr = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target_expr);
            if (!result_target_expr) {
                return unexpect_error(std::move(result_target_expr.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_CONDITIONAL_STATEMENT(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.conditional_stmt()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::conditional_stmt");
        }
        auto& conditional_stmt = *in.body.conditional_stmt();
        if (!in.body.target_stmt()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::target_stmt");
        }
        auto& target_stmt = *in.body.target_stmt();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_CONDITIONAL_STATEMENT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .conditional_stmt = conditional_stmt,
                .target_stmt = target_stmt,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_CONDITIONAL_STATEMENT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .conditional_stmt = conditional_stmt,
            .target_stmt = target_stmt,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_CONDITIONAL_STATEMENT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .conditional_stmt = conditional_stmt,
            .target_stmt = target_stmt,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_CONDITIONAL_STATEMENT(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.conditional_stmt)) {
            auto result_conditional_stmt = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.conditional_stmt);
            if (!result_conditional_stmt) {
                return unexpect_error(std::move(result_conditional_stmt.error()));
            }
        }
        if (!is_nil(type_ctx.target_stmt)) {
            auto result_target_stmt = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target_stmt);
            if (!result_target_stmt) {
                return unexpect_error(std::move(result_target_stmt.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_CONDITIONAL(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.condition()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::condition");
        }
        auto& condition = *in.body.condition();
        if (!in.body.else_()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::else_");
        }
        auto& else_ = *in.body.else_();
        if (!in.body.lowered_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::lowered_expr");
        }
        auto& lowered_expr = *in.body.lowered_expr();
        if (!in.body.then()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::then");
        }
        auto& then = *in.body.then();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_CONDITIONAL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .condition = condition,
                .else_ = else_,
                .lowered_expr = lowered_expr,
                .then = then,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_CONDITIONAL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .condition = condition,
            .else_ = else_,
            .lowered_expr = lowered_expr,
            .then = then,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_CONDITIONAL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .condition = condition,
            .else_ = else_,
            .lowered_expr = lowered_expr,
            .then = then,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_CONDITIONAL(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.condition)) {
            auto result_condition = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.condition);
            if (!result_condition) {
                return unexpect_error(std::move(result_condition.error()));
            }
        }
        if (!is_nil(type_ctx.else_)) {
            auto result_else_ = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.else_);
            if (!result_else_) {
                return unexpect_error(std::move(result_else_.error()));
            }
        }
        if (!is_nil(type_ctx.then)) {
            auto result_then = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.then);
            if (!result_then) {
                return unexpect_error(std::move(result_then.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_AVAILABLE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.lowered_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::lowered_expr");
        }
        auto& lowered_expr = *in.body.lowered_expr();
        if (!in.body.target_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::target_expr");
        }
        auto& target_expr = *in.body.target_expr();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_AVAILABLE new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .lowered_expr = lowered_expr,
                .target_expr = target_expr,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_AVAILABLE_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .lowered_expr = lowered_expr,
            .target_expr = target_expr,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_AVAILABLE_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .lowered_expr = lowered_expr,
            .target_expr = target_expr,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_AVAILABLE(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.target_expr)) {
            auto result_target_expr = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target_expr);
            if (!result_target_expr) {
                return unexpect_error(std::move(result_target_expr.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_SIZEOF(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.lowered_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::lowered_expr");
        }
        auto& lowered_expr = *in.body.lowered_expr();
        if (!in.body.target_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::target_expr");
        }
        auto& target_expr = *in.body.target_expr();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_SIZEOF new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .lowered_expr = lowered_expr,
                .target_expr = target_expr,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_SIZEOF_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .lowered_expr = lowered_expr,
            .target_expr = target_expr,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_SIZEOF_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .lowered_expr = lowered_expr,
            .target_expr = target_expr,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_SIZEOF(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.target_expr)) {
            auto result_target_expr = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target_expr);
            if (!result_target_expr) {
                return unexpect_error(std::move(result_target_expr.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_SUB_RANGE_INIT(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.sub_range()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::sub_range");
        }
        auto& sub_range = *in.body.sub_range();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_SUB_RANGE_INIT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .sub_range = sub_range,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_SUB_RANGE_INIT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .sub_range = sub_range,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_SUB_RANGE_INIT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .sub_range = sub_range,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_SUB_RANGE_INIT(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_OR_COND(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.or_cond()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::or_cond");
        }
        auto& or_cond = *in.body.or_cond();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_OR_COND new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .or_cond = or_cond,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_OR_COND_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .or_cond = or_cond,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_OR_COND_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .or_cond = or_cond,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_OR_COND(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        auto result_or_cond = dispatch_Expressions_default<Result>(std::forward<UserContext>(ctx),type_ctx.or_cond);
        if (!result_or_cond) {
            return unexpect_error(std::move(result_or_cond.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_ADDRESS_OF(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.target_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::target_expr");
        }
        auto& target_expr = *in.body.target_expr();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_ADDRESS_OF new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .target_expr = target_expr,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_ADDRESS_OF_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .target_expr = target_expr,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_ADDRESS_OF_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .target_expr = target_expr,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_ADDRESS_OF(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.target_expr)) {
            auto result_target_expr = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target_expr);
            if (!result_target_expr) {
                return unexpect_error(std::move(result_target_expr.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_OPTIONAL_OF(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.target_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::target_expr");
        }
        auto& target_expr = *in.body.target_expr();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_OPTIONAL_OF new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .target_expr = target_expr,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_OPTIONAL_OF_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .target_expr = target_expr,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_OPTIONAL_OF_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .target_expr = target_expr,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_OPTIONAL_OF(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.target_expr)) {
            auto result_target_expr = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target_expr);
            if (!result_target_expr) {
                return unexpect_error(std::move(result_target_expr.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_SETTER_STATUS(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.setter_status()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::setter_status");
        }
        auto& setter_status = *in.body.setter_status();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_SETTER_STATUS new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .setter_status = setter_status,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_SETTER_STATUS_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .setter_status = setter_status,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_SETTER_STATUS_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .setter_status = setter_status,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_SETTER_STATUS(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_SELF(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_SELF new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_SELF_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_SELF_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_SELF(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_AS_ARG(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.target_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::target_expr");
        }
        auto& target_expr = *in.body.target_expr();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_AS_ARG new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .target_expr = target_expr,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_AS_ARG_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .target_expr = target_expr,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_AS_ARG_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .target_expr = target_expr,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_AS_ARG(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.target_expr)) {
            auto result_target_expr = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target_expr);
            if (!result_target_expr) {
                return unexpect_error(std::move(result_target_expr.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .in = in,
                .alias_ref = alias_ref,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .in = in,
            .alias_ref = alias_ref,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expression_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .in = in,
            .alias_ref = alias_ref,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression(UserContext&& ctx,TypeContext&& type_ctx) {
        auto result_in = dispatch_Expression_default<Result>(std::forward<UserContext>(ctx),type_ctx.in,type_ctx.alias_ref);
        if (!result_in) {
            return unexpect_error(std::move(result_in.error()));
        }
        return result_in;
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expressions(Context&& ctx,const ebm::Expressions& in){
        auto main_logic = [&]() -> expected<Result>{
            Context_Expressions new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .in = in,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expressions_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .in = in,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Expressions_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .in = in,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expressions(UserContext&& ctx,TypeContext&& type_ctx) {
        auto result_in = dispatch_Expressions_default<Result>(std::forward<UserContext>(ctx),type_ctx.in);
        if (!result_in) {
            return unexpect_error(std::move(result_in.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_INT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.size()) {
            return unexpect_error("Unexpected null pointer for TypeBody::size");
        }
        auto& size = *in.body.size();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_INT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .size = size,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_INT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .size = size,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Type_INT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .size = size,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_INT(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_UINT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.size()) {
            return unexpect_error("Unexpected null pointer for TypeBody::size");
        }
        auto& size = *in.body.size();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_UINT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .size = size,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_UINT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .size = size,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Type_UINT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .size = size,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_UINT(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_USIZE(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_USIZE new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_USIZE_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Type_USIZE_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_USIZE(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_FLOAT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.size()) {
            return unexpect_error("Unexpected null pointer for TypeBody::size");
        }
        auto& size = *in.body.size();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_FLOAT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .size = size,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_FLOAT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .size = size,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Type_FLOAT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .size = size,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_FLOAT(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_STRUCT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.id()) {
            return unexpect_error("Unexpected null pointer for TypeBody::id");
        }
        auto& id = *in.body.id();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_STRUCT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .id = id,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_STRUCT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .id = id,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Type_STRUCT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .id = id,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_STRUCT(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_RECURSIVE_STRUCT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.id()) {
            return unexpect_error("Unexpected null pointer for TypeBody::id");
        }
        auto& id = *in.body.id();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_RECURSIVE_STRUCT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .id = id,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_RECURSIVE_STRUCT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .id = id,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Type_RECURSIVE_STRUCT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .id = id,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_RECURSIVE_STRUCT(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_BOOL(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_BOOL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_BOOL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Type_BOOL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_BOOL(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_VOID(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_VOID new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_VOID_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Type_VOID_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_VOID(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_META(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_META new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_META_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Type_META_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_META(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_ENUM(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.base_type()) {
            return unexpect_error("Unexpected null pointer for TypeBody::base_type");
        }
        auto& base_type = *in.body.base_type();
        if (!in.body.id()) {
            return unexpect_error("Unexpected null pointer for TypeBody::id");
        }
        auto& id = *in.body.id();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_ENUM new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .base_type = base_type,
                .id = id,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_ENUM_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .base_type = base_type,
            .id = id,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Type_ENUM_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .base_type = base_type,
            .id = id,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_ENUM(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.base_type)) {
            auto result_base_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.base_type);
            if (!result_base_type) {
                return unexpect_error(std::move(result_base_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_ARRAY(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.array_annotation()) {
            return unexpect_error("Unexpected null pointer for TypeBody::array_annotation");
        }
        auto& array_annotation = *in.body.array_annotation();
        if (!in.body.element_type()) {
            return unexpect_error("Unexpected null pointer for TypeBody::element_type");
        }
        auto& element_type = *in.body.element_type();
        if (!in.body.length()) {
            return unexpect_error("Unexpected null pointer for TypeBody::length");
        }
        auto& length = *in.body.length();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_ARRAY new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .array_annotation = array_annotation,
                .element_type = element_type,
                .length = length,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_ARRAY_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .array_annotation = array_annotation,
            .element_type = element_type,
            .length = length,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Type_ARRAY_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .array_annotation = array_annotation,
            .element_type = element_type,
            .length = length,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_ARRAY(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.element_type)) {
            auto result_element_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.element_type);
            if (!result_element_type) {
                return unexpect_error(std::move(result_element_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_VECTOR(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.element_type()) {
            return unexpect_error("Unexpected null pointer for TypeBody::element_type");
        }
        auto& element_type = *in.body.element_type();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_VECTOR new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .element_type = element_type,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_VECTOR_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .element_type = element_type,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Type_VECTOR_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .element_type = element_type,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_VECTOR(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.element_type)) {
            auto result_element_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.element_type);
            if (!result_element_type) {
                return unexpect_error(std::move(result_element_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_VARIANT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.variant_desc()) {
            return unexpect_error("Unexpected null pointer for TypeBody::variant_desc");
        }
        auto& variant_desc = *in.body.variant_desc();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_VARIANT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .variant_desc = variant_desc,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_VARIANT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .variant_desc = variant_desc,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Type_VARIANT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .variant_desc = variant_desc,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_VARIANT(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.variant_desc.common_type)) {
            auto result_common_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.variant_desc.common_type);
            if (!result_common_type) {
                return unexpect_error(std::move(result_common_type.error()));
            }
        }
        auto result_members = dispatch_Types_default<Result>(std::forward<UserContext>(ctx),type_ctx.variant_desc.members);
        if (!result_members) {
            return unexpect_error(std::move(result_members.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_RANGE(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.base_type()) {
            return unexpect_error("Unexpected null pointer for TypeBody::base_type");
        }
        auto& base_type = *in.body.base_type();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_RANGE new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .base_type = base_type,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_RANGE_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .base_type = base_type,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Type_RANGE_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .base_type = base_type,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_RANGE(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.base_type)) {
            auto result_base_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.base_type);
            if (!result_base_type) {
                return unexpect_error(std::move(result_base_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_ENCODER_RETURN(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_ENCODER_RETURN new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_ENCODER_RETURN_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Type_ENCODER_RETURN_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_ENCODER_RETURN(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_DECODER_RETURN(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_DECODER_RETURN new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_DECODER_RETURN_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Type_DECODER_RETURN_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_DECODER_RETURN(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_ENCODER_INPUT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_ENCODER_INPUT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_ENCODER_INPUT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Type_ENCODER_INPUT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_ENCODER_INPUT(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_DECODER_INPUT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_DECODER_INPUT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_DECODER_INPUT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Type_DECODER_INPUT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_DECODER_INPUT(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_PROPERTY_SETTER_RETURN(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_PROPERTY_SETTER_RETURN new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_PROPERTY_SETTER_RETURN_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Type_PROPERTY_SETTER_RETURN_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_PROPERTY_SETTER_RETURN(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_OPTIONAL(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.inner_type()) {
            return unexpect_error("Unexpected null pointer for TypeBody::inner_type");
        }
        auto& inner_type = *in.body.inner_type();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_OPTIONAL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .inner_type = inner_type,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_OPTIONAL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .inner_type = inner_type,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Type_OPTIONAL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .inner_type = inner_type,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_OPTIONAL(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.inner_type)) {
            auto result_inner_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.inner_type);
            if (!result_inner_type) {
                return unexpect_error(std::move(result_inner_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_PTR(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.pointee_type()) {
            return unexpect_error("Unexpected null pointer for TypeBody::pointee_type");
        }
        auto& pointee_type = *in.body.pointee_type();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_PTR new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .pointee_type = pointee_type,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_PTR_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .pointee_type = pointee_type,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Type_PTR_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .pointee_type = pointee_type,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_PTR(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.pointee_type)) {
            auto result_pointee_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.pointee_type);
            if (!result_pointee_type) {
                return unexpect_error(std::move(result_pointee_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_FUNCTION(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.func_desc()) {
            return unexpect_error("Unexpected null pointer for TypeBody::func_desc");
        }
        auto& func_desc = *in.body.func_desc();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_FUNCTION new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .func_desc = func_desc,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_FUNCTION_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .func_desc = func_desc,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Type_FUNCTION_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .func_desc = func_desc,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_FUNCTION(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.func_desc.return_type)) {
            auto result_return_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.func_desc.return_type);
            if (!result_return_type) {
                return unexpect_error(std::move(result_return_type.error()));
            }
        }
        auto result_params = dispatch_Types_default<Result>(std::forward<UserContext>(ctx),type_ctx.func_desc.params);
        if (!result_params) {
            return unexpect_error(std::move(result_params.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto main_logic = [&]() -> expected<Result>{
            Context_Type new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .in = in,
                .alias_ref = alias_ref,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .in = in,
            .alias_ref = alias_ref,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Type_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .in = in,
            .alias_ref = alias_ref,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type(UserContext&& ctx,TypeContext&& type_ctx) {
        auto result_in = dispatch_Type_default<Result>(std::forward<UserContext>(ctx),type_ctx.in,type_ctx.alias_ref);
        if (!result_in) {
            return unexpect_error(std::move(result_in.error()));
        }
        return result_in;
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Types(Context&& ctx,const ebm::Types& in){
        auto main_logic = [&]() -> expected<Result>{
            Context_Types new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .in = in,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Types_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .in = in,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        CODEGEN_MAY_HIJACK(before_result);
        expected<Result> main_result = main_logic();
        Context_Types_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .in = in,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        CODEGEN_MAY_HIJACK(after_result);
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Types(UserContext&& ctx,TypeContext&& type_ctx) {
        auto result_in = dispatch_Types_default<Result>(std::forward<UserContext>(ctx),type_ctx.in);
        if (!result_in) {
            return unexpect_error(std::move(result_in.error()));
        }
        return {};
    }
    template<typename Result, typename UserContext, typename TypeContext>
    expected<Result> traverse_children(UserContext&& uctx, TypeContext&& type_ctx) {
        using TypeContextType = std::decay_t<TypeContext>;
        if constexpr (false) {}
        else if constexpr (std::is_same_v<TypeContextType,Context_entry> || std::is_same_v<TypeContextType,Context_entry_before<Result>> || std::is_same_v<TypeContextType,Context_entry_after<Result>>) {
            return traverse_children_entry<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_pre_visitor> || std::is_same_v<TypeContextType,Context_pre_visitor_before<Result>> || std::is_same_v<TypeContextType,Context_pre_visitor_after<Result>>) {
            return traverse_children_pre_visitor<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_post_entry<Result>> || std::is_same_v<TypeContextType,Context_post_entry_before<Result>> || std::is_same_v<TypeContextType,Context_post_entry_after<Result>>) {
            return traverse_children_post_entry<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_BLOCK> || std::is_same_v<TypeContextType,Context_Statement_BLOCK_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_BLOCK_after<Result>>) {
            return traverse_children_Statement_BLOCK<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_ASSIGNMENT> || std::is_same_v<TypeContextType,Context_Statement_ASSIGNMENT_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_ASSIGNMENT_after<Result>>) {
            return traverse_children_Statement_ASSIGNMENT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_YIELD> || std::is_same_v<TypeContextType,Context_Statement_YIELD_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_YIELD_after<Result>>) {
            return traverse_children_Statement_YIELD<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_APPEND> || std::is_same_v<TypeContextType,Context_Statement_APPEND_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_APPEND_after<Result>>) {
            return traverse_children_Statement_APPEND<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_RETURN> || std::is_same_v<TypeContextType,Context_Statement_RETURN_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_RETURN_after<Result>>) {
            return traverse_children_Statement_RETURN<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_ERROR_RETURN> || std::is_same_v<TypeContextType,Context_Statement_ERROR_RETURN_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_ERROR_RETURN_after<Result>>) {
            return traverse_children_Statement_ERROR_RETURN<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_ASSERT> || std::is_same_v<TypeContextType,Context_Statement_ASSERT_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_ASSERT_after<Result>>) {
            return traverse_children_Statement_ASSERT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_READ_DATA> || std::is_same_v<TypeContextType,Context_Statement_READ_DATA_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_READ_DATA_after<Result>>) {
            return traverse_children_Statement_READ_DATA<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_WRITE_DATA> || std::is_same_v<TypeContextType,Context_Statement_WRITE_DATA_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_WRITE_DATA_after<Result>>) {
            return traverse_children_Statement_WRITE_DATA<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_RESERVE_DATA> || std::is_same_v<TypeContextType,Context_Statement_RESERVE_DATA_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_RESERVE_DATA_after<Result>>) {
            return traverse_children_Statement_RESERVE_DATA<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_IF_STATEMENT> || std::is_same_v<TypeContextType,Context_Statement_IF_STATEMENT_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_IF_STATEMENT_after<Result>>) {
            return traverse_children_Statement_IF_STATEMENT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_LOOP_STATEMENT> || std::is_same_v<TypeContextType,Context_Statement_LOOP_STATEMENT_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_LOOP_STATEMENT_after<Result>>) {
            return traverse_children_Statement_LOOP_STATEMENT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_MATCH_STATEMENT> || std::is_same_v<TypeContextType,Context_Statement_MATCH_STATEMENT_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_MATCH_STATEMENT_after<Result>>) {
            return traverse_children_Statement_MATCH_STATEMENT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_MATCH_BRANCH> || std::is_same_v<TypeContextType,Context_Statement_MATCH_BRANCH_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_MATCH_BRANCH_after<Result>>) {
            return traverse_children_Statement_MATCH_BRANCH<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_BREAK> || std::is_same_v<TypeContextType,Context_Statement_BREAK_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_BREAK_after<Result>>) {
            return traverse_children_Statement_BREAK<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_CONTINUE> || std::is_same_v<TypeContextType,Context_Statement_CONTINUE_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_CONTINUE_after<Result>>) {
            return traverse_children_Statement_CONTINUE<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_FUNCTION_DECL> || std::is_same_v<TypeContextType,Context_Statement_FUNCTION_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_FUNCTION_DECL_after<Result>>) {
            return traverse_children_Statement_FUNCTION_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_VARIABLE_DECL> || std::is_same_v<TypeContextType,Context_Statement_VARIABLE_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_VARIABLE_DECL_after<Result>>) {
            return traverse_children_Statement_VARIABLE_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_PARAMETER_DECL> || std::is_same_v<TypeContextType,Context_Statement_PARAMETER_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_PARAMETER_DECL_after<Result>>) {
            return traverse_children_Statement_PARAMETER_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_FIELD_DECL> || std::is_same_v<TypeContextType,Context_Statement_FIELD_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_FIELD_DECL_after<Result>>) {
            return traverse_children_Statement_FIELD_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_COMPOSITE_FIELD_DECL> || std::is_same_v<TypeContextType,Context_Statement_COMPOSITE_FIELD_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_COMPOSITE_FIELD_DECL_after<Result>>) {
            return traverse_children_Statement_COMPOSITE_FIELD_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_ENUM_DECL> || std::is_same_v<TypeContextType,Context_Statement_ENUM_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_ENUM_DECL_after<Result>>) {
            return traverse_children_Statement_ENUM_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_ENUM_MEMBER_DECL> || std::is_same_v<TypeContextType,Context_Statement_ENUM_MEMBER_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_ENUM_MEMBER_DECL_after<Result>>) {
            return traverse_children_Statement_ENUM_MEMBER_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_STRUCT_DECL> || std::is_same_v<TypeContextType,Context_Statement_STRUCT_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_STRUCT_DECL_after<Result>>) {
            return traverse_children_Statement_STRUCT_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_UNION_DECL> || std::is_same_v<TypeContextType,Context_Statement_UNION_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_UNION_DECL_after<Result>>) {
            return traverse_children_Statement_UNION_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_UNION_MEMBER_DECL> || std::is_same_v<TypeContextType,Context_Statement_UNION_MEMBER_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_UNION_MEMBER_DECL_after<Result>>) {
            return traverse_children_Statement_UNION_MEMBER_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_PROGRAM_DECL> || std::is_same_v<TypeContextType,Context_Statement_PROGRAM_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_PROGRAM_DECL_after<Result>>) {
            return traverse_children_Statement_PROGRAM_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_PROPERTY_DECL> || std::is_same_v<TypeContextType,Context_Statement_PROPERTY_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_PROPERTY_DECL_after<Result>>) {
            return traverse_children_Statement_PROPERTY_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_PROPERTY_MEMBER_DECL> || std::is_same_v<TypeContextType,Context_Statement_PROPERTY_MEMBER_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_PROPERTY_MEMBER_DECL_after<Result>>) {
            return traverse_children_Statement_PROPERTY_MEMBER_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_METADATA> || std::is_same_v<TypeContextType,Context_Statement_METADATA_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_METADATA_after<Result>>) {
            return traverse_children_Statement_METADATA<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_IMPORT_MODULE> || std::is_same_v<TypeContextType,Context_Statement_IMPORT_MODULE_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_IMPORT_MODULE_after<Result>>) {
            return traverse_children_Statement_IMPORT_MODULE<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_EXPRESSION> || std::is_same_v<TypeContextType,Context_Statement_EXPRESSION_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_EXPRESSION_after<Result>>) {
            return traverse_children_Statement_EXPRESSION<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_ERROR_REPORT> || std::is_same_v<TypeContextType,Context_Statement_ERROR_REPORT_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_ERROR_REPORT_after<Result>>) {
            return traverse_children_Statement_ERROR_REPORT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_LOWERED_IO_STATEMENTS> || std::is_same_v<TypeContextType,Context_Statement_LOWERED_IO_STATEMENTS_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_LOWERED_IO_STATEMENTS_after<Result>>) {
            return traverse_children_Statement_LOWERED_IO_STATEMENTS<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_SUB_BYTE_RANGE> || std::is_same_v<TypeContextType,Context_Statement_SUB_BYTE_RANGE_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_SUB_BYTE_RANGE_after<Result>>) {
            return traverse_children_Statement_SUB_BYTE_RANGE<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_INIT_CHECK> || std::is_same_v<TypeContextType,Context_Statement_INIT_CHECK_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_INIT_CHECK_after<Result>>) {
            return traverse_children_Statement_INIT_CHECK<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_ENDIAN_VARIABLE> || std::is_same_v<TypeContextType,Context_Statement_ENDIAN_VARIABLE_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_ENDIAN_VARIABLE_after<Result>>) {
            return traverse_children_Statement_ENDIAN_VARIABLE<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_ARRAY_TO_INT> || std::is_same_v<TypeContextType,Context_Statement_ARRAY_TO_INT_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_ARRAY_TO_INT_after<Result>>) {
            return traverse_children_Statement_ARRAY_TO_INT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_INT_TO_ARRAY> || std::is_same_v<TypeContextType,Context_Statement_INT_TO_ARRAY_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_INT_TO_ARRAY_after<Result>>) {
            return traverse_children_Statement_INT_TO_ARRAY<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement> || std::is_same_v<TypeContextType,Context_Statement_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_after<Result>>) {
            return traverse_children_Statement<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Block> || std::is_same_v<TypeContextType,Context_Block_before<Result>> || std::is_same_v<TypeContextType,Context_Block_after<Result>>) {
            return traverse_children_Block<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_LITERAL_INT> || std::is_same_v<TypeContextType,Context_Expression_LITERAL_INT_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_LITERAL_INT_after<Result>>) {
            return traverse_children_Expression_LITERAL_INT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_LITERAL_INT64> || std::is_same_v<TypeContextType,Context_Expression_LITERAL_INT64_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_LITERAL_INT64_after<Result>>) {
            return traverse_children_Expression_LITERAL_INT64<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_LITERAL_BOOL> || std::is_same_v<TypeContextType,Context_Expression_LITERAL_BOOL_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_LITERAL_BOOL_after<Result>>) {
            return traverse_children_Expression_LITERAL_BOOL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_LITERAL_STRING> || std::is_same_v<TypeContextType,Context_Expression_LITERAL_STRING_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_LITERAL_STRING_after<Result>>) {
            return traverse_children_Expression_LITERAL_STRING<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_LITERAL_TYPE> || std::is_same_v<TypeContextType,Context_Expression_LITERAL_TYPE_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_LITERAL_TYPE_after<Result>>) {
            return traverse_children_Expression_LITERAL_TYPE<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_LITERAL_CHAR> || std::is_same_v<TypeContextType,Context_Expression_LITERAL_CHAR_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_LITERAL_CHAR_after<Result>>) {
            return traverse_children_Expression_LITERAL_CHAR<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_IDENTIFIER> || std::is_same_v<TypeContextType,Context_Expression_IDENTIFIER_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_IDENTIFIER_after<Result>>) {
            return traverse_children_Expression_IDENTIFIER<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_BINARY_OP> || std::is_same_v<TypeContextType,Context_Expression_BINARY_OP_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_BINARY_OP_after<Result>>) {
            return traverse_children_Expression_BINARY_OP<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_UNARY_OP> || std::is_same_v<TypeContextType,Context_Expression_UNARY_OP_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_UNARY_OP_after<Result>>) {
            return traverse_children_Expression_UNARY_OP<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_CALL> || std::is_same_v<TypeContextType,Context_Expression_CALL_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_CALL_after<Result>>) {
            return traverse_children_Expression_CALL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_INDEX_ACCESS> || std::is_same_v<TypeContextType,Context_Expression_INDEX_ACCESS_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_INDEX_ACCESS_after<Result>>) {
            return traverse_children_Expression_INDEX_ACCESS<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_MEMBER_ACCESS> || std::is_same_v<TypeContextType,Context_Expression_MEMBER_ACCESS_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_MEMBER_ACCESS_after<Result>>) {
            return traverse_children_Expression_MEMBER_ACCESS<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_ENUM_MEMBER> || std::is_same_v<TypeContextType,Context_Expression_ENUM_MEMBER_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_ENUM_MEMBER_after<Result>>) {
            return traverse_children_Expression_ENUM_MEMBER<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_TYPE_CAST> || std::is_same_v<TypeContextType,Context_Expression_TYPE_CAST_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_TYPE_CAST_after<Result>>) {
            return traverse_children_Expression_TYPE_CAST<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_RANGE> || std::is_same_v<TypeContextType,Context_Expression_RANGE_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_RANGE_after<Result>>) {
            return traverse_children_Expression_RANGE<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_DEFAULT_VALUE> || std::is_same_v<TypeContextType,Context_Expression_DEFAULT_VALUE_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_DEFAULT_VALUE_after<Result>>) {
            return traverse_children_Expression_DEFAULT_VALUE<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_IS_LITTLE_ENDIAN> || std::is_same_v<TypeContextType,Context_Expression_IS_LITTLE_ENDIAN_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_IS_LITTLE_ENDIAN_after<Result>>) {
            return traverse_children_Expression_IS_LITTLE_ENDIAN<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_GET_STREAM_OFFSET> || std::is_same_v<TypeContextType,Context_Expression_GET_STREAM_OFFSET_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_GET_STREAM_OFFSET_after<Result>>) {
            return traverse_children_Expression_GET_STREAM_OFFSET<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_GET_REMAINING_BYTES> || std::is_same_v<TypeContextType,Context_Expression_GET_REMAINING_BYTES_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_GET_REMAINING_BYTES_after<Result>>) {
            return traverse_children_Expression_GET_REMAINING_BYTES<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_CAN_READ_STREAM> || std::is_same_v<TypeContextType,Context_Expression_CAN_READ_STREAM_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_CAN_READ_STREAM_after<Result>>) {
            return traverse_children_Expression_CAN_READ_STREAM<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_ARRAY_SIZE> || std::is_same_v<TypeContextType,Context_Expression_ARRAY_SIZE_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_ARRAY_SIZE_after<Result>>) {
            return traverse_children_Expression_ARRAY_SIZE<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_ENUM_IS_DEFINED> || std::is_same_v<TypeContextType,Context_Expression_ENUM_IS_DEFINED_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_ENUM_IS_DEFINED_after<Result>>) {
            return traverse_children_Expression_ENUM_IS_DEFINED<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_IS_ERROR> || std::is_same_v<TypeContextType,Context_Expression_IS_ERROR_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_IS_ERROR_after<Result>>) {
            return traverse_children_Expression_IS_ERROR<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_MAX_VALUE> || std::is_same_v<TypeContextType,Context_Expression_MAX_VALUE_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_MAX_VALUE_after<Result>>) {
            return traverse_children_Expression_MAX_VALUE<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_READ_DATA> || std::is_same_v<TypeContextType,Context_Expression_READ_DATA_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_READ_DATA_after<Result>>) {
            return traverse_children_Expression_READ_DATA<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_WRITE_DATA> || std::is_same_v<TypeContextType,Context_Expression_WRITE_DATA_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_WRITE_DATA_after<Result>>) {
            return traverse_children_Expression_WRITE_DATA<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_CONDITIONAL_STATEMENT> || std::is_same_v<TypeContextType,Context_Expression_CONDITIONAL_STATEMENT_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_CONDITIONAL_STATEMENT_after<Result>>) {
            return traverse_children_Expression_CONDITIONAL_STATEMENT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_CONDITIONAL> || std::is_same_v<TypeContextType,Context_Expression_CONDITIONAL_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_CONDITIONAL_after<Result>>) {
            return traverse_children_Expression_CONDITIONAL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_AVAILABLE> || std::is_same_v<TypeContextType,Context_Expression_AVAILABLE_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_AVAILABLE_after<Result>>) {
            return traverse_children_Expression_AVAILABLE<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_SIZEOF> || std::is_same_v<TypeContextType,Context_Expression_SIZEOF_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_SIZEOF_after<Result>>) {
            return traverse_children_Expression_SIZEOF<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_SUB_RANGE_INIT> || std::is_same_v<TypeContextType,Context_Expression_SUB_RANGE_INIT_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_SUB_RANGE_INIT_after<Result>>) {
            return traverse_children_Expression_SUB_RANGE_INIT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_OR_COND> || std::is_same_v<TypeContextType,Context_Expression_OR_COND_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_OR_COND_after<Result>>) {
            return traverse_children_Expression_OR_COND<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_ADDRESS_OF> || std::is_same_v<TypeContextType,Context_Expression_ADDRESS_OF_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_ADDRESS_OF_after<Result>>) {
            return traverse_children_Expression_ADDRESS_OF<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_OPTIONAL_OF> || std::is_same_v<TypeContextType,Context_Expression_OPTIONAL_OF_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_OPTIONAL_OF_after<Result>>) {
            return traverse_children_Expression_OPTIONAL_OF<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_SETTER_STATUS> || std::is_same_v<TypeContextType,Context_Expression_SETTER_STATUS_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_SETTER_STATUS_after<Result>>) {
            return traverse_children_Expression_SETTER_STATUS<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_SELF> || std::is_same_v<TypeContextType,Context_Expression_SELF_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_SELF_after<Result>>) {
            return traverse_children_Expression_SELF<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_AS_ARG> || std::is_same_v<TypeContextType,Context_Expression_AS_ARG_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_AS_ARG_after<Result>>) {
            return traverse_children_Expression_AS_ARG<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression> || std::is_same_v<TypeContextType,Context_Expression_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_after<Result>>) {
            return traverse_children_Expression<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expressions> || std::is_same_v<TypeContextType,Context_Expressions_before<Result>> || std::is_same_v<TypeContextType,Context_Expressions_after<Result>>) {
            return traverse_children_Expressions<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_INT> || std::is_same_v<TypeContextType,Context_Type_INT_before<Result>> || std::is_same_v<TypeContextType,Context_Type_INT_after<Result>>) {
            return traverse_children_Type_INT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_UINT> || std::is_same_v<TypeContextType,Context_Type_UINT_before<Result>> || std::is_same_v<TypeContextType,Context_Type_UINT_after<Result>>) {
            return traverse_children_Type_UINT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_USIZE> || std::is_same_v<TypeContextType,Context_Type_USIZE_before<Result>> || std::is_same_v<TypeContextType,Context_Type_USIZE_after<Result>>) {
            return traverse_children_Type_USIZE<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_FLOAT> || std::is_same_v<TypeContextType,Context_Type_FLOAT_before<Result>> || std::is_same_v<TypeContextType,Context_Type_FLOAT_after<Result>>) {
            return traverse_children_Type_FLOAT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_STRUCT> || std::is_same_v<TypeContextType,Context_Type_STRUCT_before<Result>> || std::is_same_v<TypeContextType,Context_Type_STRUCT_after<Result>>) {
            return traverse_children_Type_STRUCT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_RECURSIVE_STRUCT> || std::is_same_v<TypeContextType,Context_Type_RECURSIVE_STRUCT_before<Result>> || std::is_same_v<TypeContextType,Context_Type_RECURSIVE_STRUCT_after<Result>>) {
            return traverse_children_Type_RECURSIVE_STRUCT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_BOOL> || std::is_same_v<TypeContextType,Context_Type_BOOL_before<Result>> || std::is_same_v<TypeContextType,Context_Type_BOOL_after<Result>>) {
            return traverse_children_Type_BOOL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_VOID> || std::is_same_v<TypeContextType,Context_Type_VOID_before<Result>> || std::is_same_v<TypeContextType,Context_Type_VOID_after<Result>>) {
            return traverse_children_Type_VOID<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_META> || std::is_same_v<TypeContextType,Context_Type_META_before<Result>> || std::is_same_v<TypeContextType,Context_Type_META_after<Result>>) {
            return traverse_children_Type_META<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_ENUM> || std::is_same_v<TypeContextType,Context_Type_ENUM_before<Result>> || std::is_same_v<TypeContextType,Context_Type_ENUM_after<Result>>) {
            return traverse_children_Type_ENUM<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_ARRAY> || std::is_same_v<TypeContextType,Context_Type_ARRAY_before<Result>> || std::is_same_v<TypeContextType,Context_Type_ARRAY_after<Result>>) {
            return traverse_children_Type_ARRAY<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_VECTOR> || std::is_same_v<TypeContextType,Context_Type_VECTOR_before<Result>> || std::is_same_v<TypeContextType,Context_Type_VECTOR_after<Result>>) {
            return traverse_children_Type_VECTOR<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_VARIANT> || std::is_same_v<TypeContextType,Context_Type_VARIANT_before<Result>> || std::is_same_v<TypeContextType,Context_Type_VARIANT_after<Result>>) {
            return traverse_children_Type_VARIANT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_RANGE> || std::is_same_v<TypeContextType,Context_Type_RANGE_before<Result>> || std::is_same_v<TypeContextType,Context_Type_RANGE_after<Result>>) {
            return traverse_children_Type_RANGE<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_ENCODER_RETURN> || std::is_same_v<TypeContextType,Context_Type_ENCODER_RETURN_before<Result>> || std::is_same_v<TypeContextType,Context_Type_ENCODER_RETURN_after<Result>>) {
            return traverse_children_Type_ENCODER_RETURN<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_DECODER_RETURN> || std::is_same_v<TypeContextType,Context_Type_DECODER_RETURN_before<Result>> || std::is_same_v<TypeContextType,Context_Type_DECODER_RETURN_after<Result>>) {
            return traverse_children_Type_DECODER_RETURN<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_ENCODER_INPUT> || std::is_same_v<TypeContextType,Context_Type_ENCODER_INPUT_before<Result>> || std::is_same_v<TypeContextType,Context_Type_ENCODER_INPUT_after<Result>>) {
            return traverse_children_Type_ENCODER_INPUT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_DECODER_INPUT> || std::is_same_v<TypeContextType,Context_Type_DECODER_INPUT_before<Result>> || std::is_same_v<TypeContextType,Context_Type_DECODER_INPUT_after<Result>>) {
            return traverse_children_Type_DECODER_INPUT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_PROPERTY_SETTER_RETURN> || std::is_same_v<TypeContextType,Context_Type_PROPERTY_SETTER_RETURN_before<Result>> || std::is_same_v<TypeContextType,Context_Type_PROPERTY_SETTER_RETURN_after<Result>>) {
            return traverse_children_Type_PROPERTY_SETTER_RETURN<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_OPTIONAL> || std::is_same_v<TypeContextType,Context_Type_OPTIONAL_before<Result>> || std::is_same_v<TypeContextType,Context_Type_OPTIONAL_after<Result>>) {
            return traverse_children_Type_OPTIONAL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_PTR> || std::is_same_v<TypeContextType,Context_Type_PTR_before<Result>> || std::is_same_v<TypeContextType,Context_Type_PTR_after<Result>>) {
            return traverse_children_Type_PTR<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_FUNCTION> || std::is_same_v<TypeContextType,Context_Type_FUNCTION_before<Result>> || std::is_same_v<TypeContextType,Context_Type_FUNCTION_after<Result>>) {
            return traverse_children_Type_FUNCTION<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type> || std::is_same_v<TypeContextType,Context_Type_before<Result>> || std::is_same_v<TypeContextType,Context_Type_after<Result>>) {
            return traverse_children_Type<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Types> || std::is_same_v<TypeContextType,Context_Types_before<Result>> || std::is_same_v<TypeContextType,Context_Types_after<Result>>) {
            return traverse_children_Types<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else {
            static_assert(dependent_false<TypeContext>, "traverse_children not implemented for this context type");
        }
    }
}  // namespace ebmgen::visitor
#endif // EBM_CODEGEN_COMMON_INCLUDE_GUARD
