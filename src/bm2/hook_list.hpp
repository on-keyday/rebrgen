// Code generated by json2cpp2
#pragma once
#include <cstdint>
#include <vector>
#include <array>
#include <optional>
#include <variant>
#include <string_view>

#include <binary/flags.h>
#include <binary/float.h>
#include <view/iovec.h>
#include <binary/number.h>
#include <error/error.h>
namespace bm2 {
    enum class HookFile {
        keyword = 0,
        file_top = 1,
        file_bottom = 2,
        bm_context = 3,
        flags = 4,
        inner_function_start = 5,
        inner_function_each_code = 6,
        inner_block_start = 7,
        inner_block_each_code = 8,
        param_start = 9,
        param_each_code = 10,
        call_param_start = 11,
        call_param_each_code = 12,
        inner_function_op = 13,
        inner_block_op = 14,
        eval_op = 15,
        type_op = 16,
        param_op = 17,
        call_param_op = 18,
        field_accessor_op = 19,
    };
    constexpr const char* to_string(HookFile e) {
        switch (e) {
            case HookFile::keyword:
                return "keywords.txt";
            case HookFile::file_top:
                return "file_top.txt";
            case HookFile::file_bottom:
                return "file_bottom.txt";
            case HookFile::bm_context:
                return "bm_context.txt";
            case HookFile::flags:
                return "flags.txt";
            case HookFile::inner_function_start:
                return "inner_function_start.txt";
            case HookFile::inner_function_each_code:
                return "inner_function_each_code.txt";
            case HookFile::inner_block_start:
                return "inner_block_start.txt";
            case HookFile::inner_block_each_code:
                return "inner_block_each_code.txt";
            case HookFile::param_start:
                return "param_start.txt";
            case HookFile::param_each_code:
                return "param_each_code.txt";
            case HookFile::call_param_start:
                return "call_param_start.txt";
            case HookFile::call_param_each_code:
                return "call_param_each_code.txt";
            case HookFile::inner_function_op:
                return "func_{}.txt";
            case HookFile::inner_block_op:
                return "block_{}.txt";
            case HookFile::eval_op:
                return "eval_{}.txt";
            case HookFile::type_op:
                return "type_{}.txt";
            case HookFile::param_op:
                return "param_{}.txt";
            case HookFile::call_param_op:
                return "call_param_{}.txt";
            case HookFile::field_accessor_op:
                return "field_accessor_{}.txt";
        }
        return "";
    }

    constexpr std::optional<HookFile> HookFile_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "keywords.txt") {
            return HookFile::keyword;
        }
        if (str == "file_top.txt") {
            return HookFile::file_top;
        }
        if (str == "file_bottom.txt") {
            return HookFile::file_bottom;
        }
        if (str == "bm_context.txt") {
            return HookFile::bm_context;
        }
        if (str == "flags.txt") {
            return HookFile::flags;
        }
        if (str == "inner_function_start.txt") {
            return HookFile::inner_function_start;
        }
        if (str == "inner_function_each_code.txt") {
            return HookFile::inner_function_each_code;
        }
        if (str == "inner_block_start.txt") {
            return HookFile::inner_block_start;
        }
        if (str == "inner_block_each_code.txt") {
            return HookFile::inner_block_each_code;
        }
        if (str == "param_start.txt") {
            return HookFile::param_start;
        }
        if (str == "param_each_code.txt") {
            return HookFile::param_each_code;
        }
        if (str == "call_param_start.txt") {
            return HookFile::call_param_start;
        }
        if (str == "call_param_each_code.txt") {
            return HookFile::call_param_each_code;
        }
        if (str == "func_{}.txt") {
            return HookFile::inner_function_op;
        }
        if (str == "block_{}.txt") {
            return HookFile::inner_block_op;
        }
        if (str == "eval_{}.txt") {
            return HookFile::eval_op;
        }
        if (str == "type_{}.txt") {
            return HookFile::type_op;
        }
        if (str == "param_{}.txt") {
            return HookFile::param_op;
        }
        if (str == "call_param_{}.txt") {
            return HookFile::call_param_op;
        }
        if (str == "field_accessor_{}.txt") {
            return HookFile::field_accessor_op;
        }
        return std::nullopt;
    }
    enum class HookFileSub {
        main = 0,
        op = 1,
        empty = 2,
        value = 3,
        self = 4,
        field = 5,
        fallback = 6,
        no_fallback = 7,
        before = 8,
        after = 9,
    };
    constexpr const char* to_string(HookFileSub e) {
        switch (e) {
            case HookFileSub::main:
                return "";
            case HookFileSub::op:
                return "_op";
            case HookFileSub::empty:
                return "_empty";
            case HookFileSub::value:
                return "_value";
            case HookFileSub::self:
                return "_self";
            case HookFileSub::field:
                return "_field";
            case HookFileSub::fallback:
                return "_fallback";
            case HookFileSub::no_fallback:
                return "_no_fallback";
            case HookFileSub::before:
                return "_before";
            case HookFileSub::after:
                return "_after";
        }
        return "";
    }

    constexpr std::optional<HookFileSub> HookFileSub_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "") {
            return HookFileSub::main;
        }
        if (str == "_op") {
            return HookFileSub::op;
        }
        if (str == "_empty") {
            return HookFileSub::empty;
        }
        if (str == "_value") {
            return HookFileSub::value;
        }
        if (str == "_self") {
            return HookFileSub::self;
        }
        if (str == "_field") {
            return HookFileSub::field;
        }
        if (str == "_fallback") {
            return HookFileSub::fallback;
        }
        if (str == "_no_fallback") {
            return HookFileSub::no_fallback;
        }
        if (str == "_before") {
            return HookFileSub::before;
        }
        if (str == "_after") {
            return HookFileSub::after;
        }
        return std::nullopt;
    }
}  // namespace bm2
