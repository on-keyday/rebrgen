/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: includes
  Available variables:
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

/*here to write the hook*/
#pragma once
#include <format>
#include <optional>
#include "ebm/extended_binary_module.hpp"
#include "ebmgen/access.hpp"
#include "ebmgen/mapping.hpp"
namespace ebm2c {
    struct Field {
        ebm::StatementRef id;
    };

    struct Struct {
        ebm::StatementRef id;
        std::vector<Field> fields;
        std::vector<ebm::StatementRef> properties;
        std::optional<ebm::StatementRef> encode_function;
        std::optional<ebm::StatementRef> decode_function;
    };

    struct Enum {
        ebm::StatementRef id;
    };

    struct Union {
        ebm::TypeRef id;
        std::vector<Struct> variants;
    };

    struct VectorType {
        ebm::TypeRef elem_type;
    };

    inline std::string map_decl(std::string&& type_str, std::string&& variable) {
        auto first_dollar = type_str.find('$');
        if (first_dollar == std::string::npos) {
            return std::format("{} {}", type_str, variable);
        }
        // split at first dollar
        auto base = type_str.substr(0, first_dollar);
        auto rest = type_str.substr(first_dollar);
        // remove other dollars
        std::erase(rest, '$');
        return std::format("{} {}{}", base, variable, rest);
    }

    const ebm::FieldDecl* get_composite_field(auto&& ctx, auto target) {
        ebmgen::MappingTable& mapping = get_visitor(ctx).module_;
        const ebm::FieldDecl* comp = ebmgen::access_field<"body.id.field_decl">(mapping, target);
        if (!comp) {
            return nullptr;
        }
        auto comp_type = ebmgen::access_field<"composite_field_decl">(mapping, comp->composite_field());
        if (comp_type && comp_type->kind == ebm::CompositeFieldKind::BULK_PRIMITIVE) {
            return comp;
        }
        return nullptr;
    }
}  // namespace ebm2c
