/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_PROGRAM_DECL_class
  Available Variables:
    ctx: Context_Statement_PROGRAM_DECL
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        module_: ebmgen::MappingTable
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
      item_id: ebm::StatementRef
      kind: const ebm::StatementKind&
      block: const ebm::Block&
        len: Varint
        container: std::vector<StatementRef>
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include <unordered_map>
#include "../codegen.hpp"
#include "ebm/extended_binary_module.hpp"
#include "ebmcg/ebm2c/codegen.hpp"
#include "ebmcodegen/stub/dependency.hpp"
#include "ebmgen/common.hpp"
#include "includes.hpp"
DEFINE_VISITOR_CLASS(Statement_PROGRAM_DECL) {
    using Context = CODEGEN_CONTEXT(Statement_PROGRAM_DECL);
    struct C_Context {
        std::vector<ebm2c::Struct> structs;
        std::unordered_map<std::uint64_t, ebm2c::Union> unions;
        std::vector<ebm2c::VectorType> vector_types;
        std::vector<ebm2c::ArrayType> array_types;
        std::vector<ebm2c::Enum> enums;
        bool has_can_read_stream = false;
    };

    void write_vector_macros(CodeWriter & w) {
        w.writeln("#ifndef VECTOR_APPEND");
        w.writeln("#define VECTOR_APPEND(vector, value) do { \\");
        {
            auto scope = w.indent_scope();
            w.writeln("if (!input->append) {\\");
            w.indent_writeln("return -1; \\");
            w.writeln("} \\");
            w.writeln("int res = input->append(input, (VECTOR_OF(void)*)(void*)&(vector),  &(value), sizeof((value))); \\");
            w.writeln("if (res != 0) { \\");
            w.indent_writeln("return res; \\");
            w.writeln("} \\");
        }
        w.writeln("} while(0)");
        w.writeln("#endif");
        w.writeln("");
    }

    void write_decoder_macros(CodeWriter & w) {
        w.writeln("#ifndef DECODER_CAN_READ");
        w.writeln("#define DECODER_CAN_READ(io, num_bytes) ((io)->can_read ? (io)->can_read(io, num_bytes) : ((io)->data_end - ((io)->data + (io)->offset)) >= (num_bytes))");
        w.writeln("#endif");
        w.writeln("");
        w.writeln("#define EBM_READ_ARRAY_BYTES_TEMPORARY(io, target, size, offset_value) do { \\");
        {
            auto scope = w.indent_scope();
            w.writeln("if (DECODER_CAN_READ((io), (size))) { \\");
            {
                auto inner_scope = w.indent_scope();
                w.writeln("if ((offset_value) == 0) { \\");
                w.indent_writeln("(target) = (uint8_t*)((io)->data + (io)->offset); \\");
                w.writeln("}  \\");
                w.writeln("(io)->offset += (size); \\");
            }
            w.writeln("} else { \\");
            {
                auto inner_scope = w.indent_scope();
                w.writeln("return -1; \\");
            }
            w.writeln("} \\");
        }
        w.writeln("} while(0)");
        w.writeln("");
        w.writeln("#define EBM_READ_BYTES(io, target, size_value, offset_value) do { \\");
        {
            auto scope = w.indent_scope();
            w.writeln("if (DECODER_CAN_READ((io), (size_value))) { \\");
            {
                auto inner_scope = w.indent_scope();
                w.writeln("if ((offset_value) == 0) { \\");
                w.writeln("(target).data = (uint8_t*)((io)->data + (io)->offset); \\");
                w.writeln("(target).size = (size_value); \\");
                w.writeln("(target).capacity = (target).size; \\");
                w.writeln("}  \\");
                w.writeln("(io)->offset += (size_value); \\");
            }
            w.writeln("} else { \\");
            {
                auto inner_scope = w.indent_scope();
                w.writeln("return -1; \\");
            }
            w.writeln("} \\");
        }
        w.writeln("} while(0)");
        w.writeln("");
    }

    void write_encoder_macros(CodeWriter & w) {
        w.writeln("#define EBM_RESERVE_DATA(io,target, size) do { \\");
        {
            auto scope = w.indent_scope();
            w.writeln("if ((io)->offset + (size) > (size_t)((io)->data_end - (io)->data)) { \\");
            w.indent_writeln("return -1; \\");
            w.writeln("} \\");
            w.writeln("target = (uint8_t*)((io)->data + (io)->offset); \\");
        }
        w.writeln("} while(0)");
        w.writeln("");
        w.writeln("#define EBM_WRITE_ARRAY_BYTES_TEMPORARY(io, source, size_value, offset_value) do { \\");
        {
            auto scope = w.indent_scope();
            w.writeln("if ((io)->offset + (size_value) <= (size_t)((io)->data_end - (io)->data)) { \\");
            {
                auto inner_scope = w.indent_scope();
                w.writeln("(io)->offset += (size_value); \\");
            }
            w.writeln("} else { \\");
            {
                auto inner_scope = w.indent_scope();
                w.writeln("return -1; \\");
            }
            w.writeln("} \\");
        }
        w.writeln("} while(0)");
        w.writeln("");
        w.writeln("#ifndef MEMCPY");
        w.writeln("#define MEMCPY(dest, src, size) __builtin_memcpy((dest), (src), (size))");
        w.writeln("#endif");
        w.writeln("");
        w.writeln("#define EBM_WRITE_BYTES(io, source, size_value, offset_value) do { \\");
        {
            auto scope = w.indent_scope();
            w.writeln("if((io)->emit) { \\");
            {
                auto inner_scope = w.indent_scope();
                w.writeln("int res = (io)->emit((io), &(source), (size_value)); \\");
                w.writeln("if (res != 0) { \\");
                {
                    auto inner_inner_scope = w.indent_scope();
                    w.writeln("return res; \\");
                }
                w.writeln("} \\");
            }
            w.writeln("} \\");
            w.writeln("else if ((io)->offset + (size_value) <= (size_t)((io)->data_end - (io)->data)) { \\");
            {
                auto inner_scope = w.indent_scope();
                w.writeln("if((source).size != (size_value)) { \\");
                {
                    auto inner_inner_scope = w.indent_scope();
                    w.writeln("return -1; \\");
                }
                w.writeln("} \\");
                w.writeln("MEMCPY((io)->data + (io)->offset, (source).data, (size_value)); \\");
                w.writeln("(io)->offset += (size_value); \\");
            }
            w.writeln("} else { \\");
            {
                auto inner_scope = w.indent_scope();
                w.writeln("return -1; \\");
            }
            w.writeln("} \\");
        }
        w.writeln("} while(0)");
        w.writeln("");
    }

    DEFINE_VISITOR_FUNCTION(Statement_PROGRAM_DECL) {
        using namespace CODEGEN_NAMESPACE;
        C_Context c_ctx;
        MAYBE_VOID(ok, collect_structs(ctx, c_ctx));

        auto get_field_type = [&](ebm::StatementRef field_ref) -> expected<std::pair<Result, ebm::TypeRef>> {
            if (auto field = ctx.get_field<"field_decl.field_type">(field_ref)) {
                return ctx.visit(*field).transform([&](auto&& x) {
                    return std::make_pair(x, *field);
                });
            }
            else if (auto composite = ctx.get_field<"composite_field_decl.composite_type">(field_ref)) {
                return ctx.visit(*composite).transform([&](auto&& x) {
                    return std::make_pair(x, *composite);
                });
            }
            else {
                return unexpect_error("failed to get field type");
            }
        };
        CodeWriter w;
        w.writeln("#include <stdint.h>");
        w.writeln("#include <stddef.h>");
        w.writeln("");
        w.writeln("// Forward declarations");
        for (auto& s : c_ctx.structs) {
            auto ident = ctx.identifier(s.id);
            w.writeln("typedef struct ", ident, " ", ident, ";");
        }

        // enums first
        for (auto& e : c_ctx.enums) {
            MAYBE(enum_, ctx.visit(e.id));
            w.writeln(enum_.to_writer());
        }
        for (auto& e : c_ctx.enums) {
            auto ident = ctx.identifier(e.id);
            w.writeln("typedef enum ", ident, " ", ident, ";");
        }
        w.writeln("");

        if (c_ctx.vector_types.size() > 0) {
            w.writeln("// Vector type definitions");
            w.writeln("#ifndef VECTOR_OF");
            w.writeln("#define VECTOR_OF(type) type##_vector");
            w.writeln("typedef struct {");
            {
                auto scope = w.indent_scope();
                w.writeln("void* data;");
                w.writeln("size_t size;");
                w.writeln("size_t capacity;");
            }
            w.writeln("} VECTOR_OF(void);");
            for (auto& v : c_ctx.vector_types) {
                MAYBE(elem_type, ctx.visit(v.elem_type));
                w.writeln("typedef struct {");
                {
                    auto scope = w.indent_scope();
                    w.writeln(elem_type.to_writer(), "* data;");
                    w.writeln(ctx.config().usize_type_name, " size;");
                    w.writeln(ctx.config().usize_type_name, " capacity;");
                }
                w.writeln("} VECTOR_OF(", elem_type.to_writer(), ");");
                w.writeln("");
            }
            w.writeln("#endif");
            w.writeln("");
            write_vector_macros(w);
        }
        if (c_ctx.array_types.size() > 0) {
            w.writeln("// Array type definitions");
            w.writeln("#ifndef ARRAY_OF");
            w.writeln("#define ARRAY_OF(type, size) ArrayOf_##type##_##size");
            for (auto& a : c_ctx.array_types) {
                MAYBE(elem_type, ctx.visit(a.elem_type));
                auto size_str = std::to_string(a.size);
                w.writeln("typedef ", elem_type.to_writer(), " ARRAY_OF(", elem_type.to_writer(), ", ", size_str, ")[", size_str, "];");
                w.writeln("");
            }
            w.writeln("#endif");
        }

        w.writeln("typedef struct EncoderInput {");
        {
            auto scope = w.indent_scope();
            w.writeln("uint8_t* data;");
            w.writeln("uint8_t* data_end;");
            w.writeln("size_t offset;");
            w.writeln("int (*emit)(struct EncoderInput* self, const VECTOR_OF(uint8_t)* data, size_t size);");
        }
        w.writeln("} EncoderInput;");
        w.writeln("");

        write_encoder_macros(w);
        w.writeln("typedef struct DecoderInput {");
        {
            auto scope = w.indent_scope();
            w.writeln("const uint8_t* data;");
            w.writeln("const uint8_t* data_end;");
            w.writeln("size_t offset;");
            if (c_ctx.vector_types.size() > 0) {
                w.writeln("int (*append)(struct DecoderInput* self, VECTOR_OF(void)* vector, const void* data,size_t size);");
            }
            if (c_ctx.has_can_read_stream) {
                w.writeln("int (*can_read)(struct DecoderInput* self, size_t num_bytes);");
            }
        }
        w.writeln("} DecoderInput;");
        if (c_ctx.has_can_read_stream) {
            write_decoder_macros(w);
        }
        w.writeln("");
        std::vector<ebm::StatementRef> composite_fns;
        auto collect_composite_fn = [&](ebm::StatementRef composite) -> expected<void> {
            auto comp = ctx.get_field<"composite_field_decl">(composite);
            if (!comp) {
                return {};
            }
            for (auto& f : comp->fields.container) {
                auto decl = ctx.get_field<"field_decl">(f);
                if (!decl) {
                    continue;
                }
                auto getter = decl->composite_getter();
                auto setter = decl->composite_setter();
                if (getter) {
                    composite_fns.push_back(getter->id);
                }
                if (setter) {
                    composite_fns.push_back(setter->id);
                }
            }
            return {};
        };
        auto write_union = [&](Union& u) -> expected<void> {
            auto ident = std::format("Union{}", get_id(u.id));
            w.writeln("union ", ident, " {");
            auto scope = w.indent_scope();
            for (auto& v : u.variants) {
                auto var_ident = ctx.identifier(v.id);
                w.writeln("struct {");
                auto var_scope = w.indent_scope();
                for (auto& f : v.fields) {
                    auto field_ident = ctx.identifier(f.id);
                    MAYBE(typ, get_field_type(f.id));
                    w.writeln(typ.first.to_writer(), " ", field_ident, ";");
                    MAYBE_VOID(ok, collect_composite_fn(f.id));
                }
                var_scope.execute();
                w.writeln("}", var_ident, ";");
            }
            scope.execute();
            w.writeln("};");
            w.writeln("");
            return {};
        };
        for (auto& s : c_ctx.structs) {
            auto ident = ctx.identifier(s.id);
            w.writeln("struct ", ident, " {");
            auto scope = w.indent_scope();
            for (auto& f : s.fields) {
                auto field_ident = ctx.identifier(f.id);
                MAYBE(typ, get_field_type(f.id));
                if (auto found = c_ctx.unions.find(ebmgen::get_id(typ.second)); found != c_ctx.unions.end()) {
                    MAYBE_VOID(ok, write_union(found->second));
                }
                w.writeln(typ.first.to_writer(), " ", field_ident, ";");
                MAYBE_VOID(ok, collect_composite_fn(f.id));
            }
            scope.execute();
            w.writeln("};");
            w.writeln("");
        }
        for (auto& composite_fn_ref : composite_fns) {
            MAYBE(func, ctx.visit(composite_fn_ref));
            w.writeln(func.to_writer());
        }
        // for each properties
        for (auto& s : c_ctx.structs) {
            for (auto& prop_ref : s.properties) {
                MAYBE(prop, ctx.visit(prop_ref));
                w.writeln(prop.to_writer());
            }
        }
        // write encoding/decoding functions if any
        for (auto& s : c_ctx.structs) {
            if (s.encode_function) {
                MAYBE(func, ctx.visit(*s.encode_function));
                w.writeln(func.to_writer());
            }
            if (s.decode_function) {
                MAYBE(func, ctx.visit(*s.decode_function));
                w.writeln(func.to_writer());
            }
        }

        return w;
    };

    ebmgen::expected<void> collect_structs(Context & ctx, C_Context & c_ctx) {
        auto handle_struct_decl = [&](std::vector<ebm2c::Struct>& structs, ebm::StatementRef stmt_ref, bool in_union) {
            auto struct_ = ctx.get_field<"struct_decl">(stmt_ref);
            if (!struct_) {
                return;
            }
            if (is_nil(struct_->name) && !in_union) {
                return;
            }
            Struct s;
            s.id = stmt_ref;
            for (auto& decl_ref : struct_->fields.container) {
                auto composite = ctx.get_field<"composite_field_decl">(decl_ref);
                if (composite && composite->kind != ebm::CompositeFieldKind::BULK_PRIMITIVE) {
                    for (auto& inner_field : composite->fields.container) {
                        s.fields.push_back(Field{.id = inner_field});
                    }
                    continue;
                }
                s.fields.push_back(Field{.id = decl_ref});
            }
            if (auto props = struct_->properties()) {
                for (auto& prop_ref : props->container) {
                    s.properties.push_back(prop_ref);
                }
            }
            if (auto encode_func = struct_->encode_fn()) {
                s.encode_function = *encode_func;
            }
            if (auto decode_func = struct_->decode_fn()) {
                s.decode_function = *decode_func;
            }
            structs.push_back(s);
        };
        MAYBE(sorted, sorted_struct(ctx));
        for (auto stmt_ref : sorted) {
            handle_struct_decl(c_ctx.structs, stmt_ref, false);
        }
        for (auto& e : ctx.module().module().statements) {
            auto enum_decl = ctx.get_field<"enum_decl">(e.id);
            if (!enum_decl) {
                continue;
            }
            ebm2c::Enum en{.id = e.id};
            c_ctx.enums.push_back(en);
        }
        for (auto& s : ctx.module().module().types) {
            if (s.body.kind == ebm::TypeKind::VECTOR) {
                MAYBE(elem_type, s.body.element_type());
                ebm2c::VectorType v{.elem_type = elem_type};
                c_ctx.vector_types.push_back(v);
                continue;
            }
            if (s.body.kind == ebm::TypeKind::ARRAY) {
                MAYBE(elem_type, s.body.element_type());
                MAYBE(length, s.body.length());
                MAYBE(annotation, s.body.array_annotation());
                if (annotation == ebm::ArrayAnnotation::read_temporary || annotation == ebm::ArrayAnnotation::write_temporary) {
                    continue;
                }
                ebm2c::ArrayType a{.elem_type = elem_type, .size = length.value()};
                c_ctx.array_types.push_back(a);
                continue;
            }
            auto variant_desc = s.body.variant_desc();
            if (!variant_desc) {
                continue;
            }
            Union u{.id = s.id};
            for (auto member_type_ref : variant_desc->members.container) {
                auto struct_key = ctx.get_field<"body.id">(member_type_ref);
                if (!struct_key) {
                    continue;
                }
                handle_struct_decl(u.variants, *struct_key, true);
            }
            c_ctx.unions[ebmgen::get_id(s.id)] = u;
        }
        for (auto& exprs : ctx.module().module().expressions) {
            if (exprs.body.kind == ebm::ExpressionKind::CAN_READ_STREAM) {
                c_ctx.has_can_read_stream = true;
                break;
            }
        }
        return {};
    }
};
