/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_SUB_BYTE_RANGE_class
  Available Variables:
    ctx: Context_Statement_SUB_BYTE_RANGE
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        module_: ebmgen::MappingTable
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
      item_id: ebm::StatementRef
      kind: const ebm::StatementKind&
      sub_byte_range: const ebm::SubByteRange&
        stream_type: StreamType
        range_type: SubByteRangeType
        expression: *ExpressionRef
        length: *ExpressionRef
        offset: *ExpressionRef
        io_ref: StatementRef
        parent_io_ref: WeakStatementRef
        io_statement: StatementRef
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

/*here to write the hook*/

#include "../codegen.hpp"
DEFINE_VISITOR(Statement_SUB_BYTE_RANGE) {
    auto io_ = ctx.identifier(ctx.sub_byte_range.io_ref);
    MAYBE(do_io, ctx.visit(ctx.sub_byte_range.io_statement));

    CodeWriter w;
    auto parent_io_ = ctx.identifier(ctx.sub_byte_range.parent_io_ref);
    MAYBE(length, ctx.sub_byte_range.length());
    MAYBE(length_str, ctx.visit(length));

    if (ctx.sub_byte_range.stream_type == ebm::StreamType::INPUT) {
        w.writeln("let mut ", io_, " = Vec::new();");
        w.writeln(io_, ".resize(", length_str.to_writer(), " as usize,0);");
        w.writeln(parent_io_, ".read_exact(&mut ", io_, ")?;");
        w.writeln("let mut ", io_, " = std::io::Cursor::new(", io_, ");");
    }
    else {
        w.writeln("let mut ", io_, " = std::io::Cursor::new(Vec::new());");
    }
    w.write(do_io.to_writer());
    if (ctx.sub_byte_range.stream_type == ebm::StreamType::OUTPUT) {
        w.writeln("if (", length_str.to_writer(), " as usize) != ", io_, ".get_ref().len() {");
        w.indent_writeln("return Err(anyhow::anyhow!(\"written length mismatch: {} != {}\", ", length_str.to_writer(), ", ", io_, ".get_ref().len()));");
        w.writeln("}");
        w.writeln(parent_io_, ".write_all(&", io_, ".get_ref())?;");
    }

    auto& flags = ctx.config().function_markers[get_id(ctx.config().current_function)];
    if (has_flag(flags, ebm2rust::FunctionFlags::HasFillBuf)) {
        ctx.config().use_statements.insert("use std::io::BufRead;");
    }

    return w;
}