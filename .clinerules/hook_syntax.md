# Hook syntax

hook file is template files for code generator-generator.
you can customize generated code behavior more specifically than using `config.json` by writing C++ code of target generator.
each files are piece of C++ code except described below. file suffix is `.txt`

some exception is here:

flags.txt: define command line flags of generated generator. like below

```
async|use_async|bool|false|use async operation
byte-type|byte_type|string|TYPE_NAME|""|specify byte type
```

1. command line option name of without `--`
2. binding variable name (C++ identifier)
3. type of command argument (`bool` or `string`)
4. place holder name if type is not `bool`
5. description of argument

keywords.txt: define keywords of target language for identifier escape

one keyword per line like below:

```
if
else
loop
```

file_top.txt,file_bottom.txt: generated file top and bottom content in target language.

main usage of these files are importing common library and declaring CODE GENERATED notice like this.

```
# Code generated by bm2target. DO NOT EDIT
import library
```

cmptest_build.txt,cmptest_run.txt: defining generated-generator test commands in Python.

at cmptest_build.txt, you have to generate executable file from MAIN,GENERATED variable path to EXEC variable path
at cmptest_run.txt, you have to execute EXEC (same as OUTPUT in cmptest_build.txt) with INPUT (test input binary file path) and EXEC must generate OUTPUT (test output file path, should be same as test input for test success or different if implementation has bug). by default, if cmptest_run.txt not exists, running like `run_command([EXEC,INPUT,OUTPUT])`. you can modify this if EXEC is script like `run_command(["script_interpreter",EXEC,INPUT,OUTPUT])`

sections.txt: described below

## predefined hook

predefined hook are hook loaded by `tool/gen_template` directly.
naming rule may be complex, but generally regular.

for example,

`eval_define_union_after.txt`

means

`eval`: generated code place is function `eval`
`define_union`: hook is about `AbstractOp::DEFINE_UNION`
`after`: this is inserted after main hook(`eval_define_union.txt`)

to see more hooks detail, see `tool/gen_template --print-hooks`

pieces of code are like this

```
if(is_empty_block) {
    w.writeln("pass");
}
```

`is_empty_block` is defined in context of `eval_define_union_after.txt`.
for more detail about variables in hook, see `docs/template_parameters.md`

## Syntax

### !@include file_name

include file content from other file. this is like C/C++ `#include`
when loaded via `!@include` debug log indicates like `loaded hook via include: hook/block_define_format.txt`
when using with sections.txt, loaded from sections.txt contents if exists and debug log indicates like `loaded hook via include: src/bm2python/hook/func_call_code_common.txt (from sections.txt)`

## sections.txt

sections.txt is single file mechanism for hook.
Instead of creating multiple hook files, you can define multiple hooks in sections.txt. This file can contains all kind of hook, including flags.txt, keywords.txt etc.

If a text file with the same name as a section in sections.txt exists, the contents of sections.txt take precedence.

## sections.txt specific Syntax

### !@section hook_name.txt

define hook section. hook name is placed at `hook_name`
this must be end with .txt like file name
you can define both predefined hook (can see by `tool/gen_template --print-hooks`, same as normal hook file name) and custom name hook (also used by `!@include` from predefined hook)
at file top, it is like

```
this content is ignored
!@section hook_name.txt
this will be inserted at hook point
```

result to

```
// load hook: hook_name
this will be inserted at hook point
// end hook: hook_name
```

### !@section_include file_name

include sections from other file. file name is placed at `file_name`. this is loaded before `!@include`.

for example, files like below.

```ls
sections.txt
section_include.txt
include.txt
```

```sections.txt
@section func_if.txt
@section_include section_include.txt
@section func_elif.txt
@include func_if.txt
@include include.txt
```

```section_include.txt
if(is_empty_block) {
    w.writeln("pass");
}
```

```include.txt
w.writeln("# nice comment")
```

then at first, `tool/gen\_template` load sections.txt and interpreted like below.

```sections.txt(internal representation image)
@section func_if.txt
if(is_empty_block) {
    w.writeln("pass");
}
@end_section
@section func_elif.txt
@include func_if.txt
@include include.txt
@end_section
```

then when `func_if.txt` is loaded then code below will be inserted

```inserted code of func_if
// load hook: func_if
if(is_empty_block) {
    w.writeln("pass");
}
// end hook: func_if
```

and when `func_elif.txt` is loaded, then interpreted as below

```func_elif.txt(internal representation image)
if(is_empty_block) {
    w.writeln("pass");
}
w.writeln("# nice comment")
```

then inserted as below

```inserted code of func_elif.txt
// load hook: func_elif.txt
if(is_empty_block) {
    w.writeln("pass");
}
w.writeln("# nice comment")
// end hook: func_elif
```

### !@end_section

end hook section explicitly.
by default, hook is implicitly ended if next `!@section` appears
contents between `!@end_section` and next `!@section` are ignored

```
!@section hoge.txt
shown
!@end_section
ignored
!@section fuga.txt
shown too
```

### !@copy_section file

copy previous section to `file`

for example

```
!@section hoge.txt
print("hello");
!@copy_section huga.txt
```

is same as

```
!@section hoge.txt
print("hello");
!@section huga.txt
print("hello");
```
