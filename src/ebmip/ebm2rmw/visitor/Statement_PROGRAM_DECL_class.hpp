/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_PROGRAM_DECL_class
  Available Variables:
    ctx: Context_Statement_PROGRAM_DECL
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        module_: ebmgen::MappingTable
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
      item_id: ebm::StatementRef
      kind: const ebm::StatementKind&
      block: const ebm::Block&
        len: Varint
        container: std::vector<StatementRef>
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include "../codegen.hpp"
#include <ebmgen/interactive/debugger.hpp>
DEFINE_VISITOR(Statement_PROGRAM_DECL) {
    using namespace CODEGEN_NAMESPACE;
    auto entry_str = ctx.flags().entry_point;
    if (entry_str.empty()) {
        return unexpect_error("Entry point is not specified.");
    }
    auto query = std::format("Statement{{ body.struct_decl.has_encode_decode and id == \"{}\" }}", entry_str);
    MAYBE(query_result, ebmgen::run_query(ctx.module(), query));
    if (query_result.first.size() != 1) {
        return unexpect_error("Entry point not found: {}", entry_str);
    }
    auto entry_stmt_ref = query_result.first[0];
    MAYBE(entry_stmt, ctx.get(ebmgen::from_any_ref<ebm::StatementRef>(entry_stmt_ref)));
    auto entry_decode_fn = *entry_stmt.body.struct_decl()->decode_fn();
    ctx.config().env.init_self();
    auto res = ctx.visit(entry_decode_fn);
    if (!res) {
        return res;
    }
    return res;
}
