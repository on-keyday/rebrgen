/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: entry_before_class
  Available Variables:
    ctx: Context_entry_before
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        module_: ebmgen::MappingTable
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
      main_logic: ebmcodegen::util::MainLogicWrapper<Result>
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include "../codegen.hpp"
DEFINE_VISITOR(entry_before) {
    using namespace CODEGEN_NAMESPACE;
    ctx.config().int_prefix = "int";
    ctx.config().int_suffix = "_t";
    ctx.config().uint_prefix = "uint";
    ctx.config().uint_suffix = "_t";
    ctx.config().variant_prefix = "Union";
    ctx.config().variable_type_separator = " ";
    ctx.config().field_name_prior_to_type = false;
    ctx.config().variable_name_prior_to_type = false;
    ctx.config().array_type_wrapper = [&](Result elem_type, size_t size) -> expected<Result> {
        // placeholder $ will be replaced by declared variable name
        return CODE(elem_type.to_writer(), "$[", std::to_string(size), "]");
    };
    ctx.config().vector_type_wrapper = [&](Result elem_type) -> expected<Result> {
        return CODE("VECTOR_OF(", elem_type.to_writer(), ")");
    };
    ctx.config().param_type_wrapper = [&](Result typ, bool is_state_variable) -> expected<Result> {
        if (is_state_variable) {
            return CODE(typ.to_writer(), "*");  // In C, parameters are passed as pointers
        }
        return typ;
    };
    ctx.config().forward_type_in_function_decl = true;
    ctx.config().function_define_keyword = "";
    ctx.config().self_value = "(*self)";
    ctx.config().default_value_option.vector_init = "{}";
    ctx.config().default_value_option.bytes_init = "{}";
    ctx.config().func_style_cast = false;
    ctx.config().usize_type_name = "size_t";
    ctx.config().endof_statement = ";";
    ctx.config().encoder_return_type = "int";
    ctx.config().decoder_return_type = "int";
    ctx.config().encoder_input_type = "EncoderInput*";
    ctx.config().decoder_input_type = "DecoderInput*";
    ctx.config().default_value_option.decoder_return_init = "0";
    ctx.config().default_value_option.encoder_return_init = "0";
    ctx.config().enum_member_separator = ",";
    ctx.config().endof_enum_definition = ";";
    return pass;
}
