/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: entry_before_class
  Available Variables:
    ctx: Context_entry_before<Result>
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
        module_: ebmgen::MappingTable
      main_logic: ebmcodegen::util::MainLogicWrapper<Result>
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include "../codegen.hpp"
#include "ebm/extended_binary_module.hpp"
DEFINE_VISITOR(entry_before) {
    using namespace CODEGEN_NAMESPACE;
    ctx.config().int_prefix = "int";
    ctx.config().int_suffix = "_t";
    ctx.config().uint_prefix = "uint";
    ctx.config().uint_suffix = "_t";
    ctx.config().variant_prefix = "Union";
    ctx.config().variable_type_separator = " ";
    ctx.config().field_name_prior_to_type = false;
    ctx.config().variable_name_prior_to_type = false;
    ctx.config().array_type_wrapper = [&](Context_Type_ARRAY& ctx) -> expected<Result> {
        bool old_inner = ctx.config().inner_element_type;
        ctx.config().inner_element_type = true;
        auto inner = futils::helper::defer([&] {
            ctx.config().inner_element_type = old_inner;
        });
        MAYBE(elem_type, ctx.visit(ctx.element_type));
        if (ctx.array_annotation == ebm::ArrayAnnotation::read_temporary) {
            // directly reference to original input buffer
            return CODE("const ", elem_type.to_writer(), "*");
        }
        if (ctx.array_annotation == ebm::ArrayAnnotation::write_temporary) {
            // writable temporary array
            return CODE(elem_type.to_writer(), "*");
        }
        if (old_inner) {
            // to avoid parse error, use ArrayOf_<inner_type> form
            return CODE("ArrayOf_", elem_type.to_writer(), "_", std::to_string(ctx.length.value()));
        }
        // placeholder $ will be replaced by declared variable name
        return CODE("ARRAY_OF(", elem_type.to_writer(), ", ", std::to_string(ctx.length.value()), ")");
    };
    ctx.config().vector_type_wrapper = [&](Context_Type_VECTOR& ctx) -> expected<Result> {
        bool old_inner = ctx.config().inner_element_type;
        ctx.config().inner_element_type = true;
        auto inner = futils::helper::defer([&] {
            ctx.config().inner_element_type = old_inner;
        });
        MAYBE(elem_type, ctx.visit(ctx.element_type));
        if (old_inner) {
            // to avoid parse error, use VectorOf_<inner_type> form
            return CODE("VectorOf_", elem_type.to_writer());
        }
        return CODE("VECTOR_OF(", elem_type.to_writer(), ")");
    };
    ctx.config().param_type_wrapper = [&](Context_Statement_PARAMETER_DECL& ctx, Result typ) -> expected<Result> {
        if (ctx.param_decl.is_state_variable()) {
            return CODE(typ.to_writer(), "*");  // In C, parameters are passed as pointers
        }
        return typ;
    };
    // TODO: use floatN_t types if available
    ctx.config().make_float_type = [&](size_t bit_size) -> expected<Result> {
        if (bit_size <= 32) {
            return CODE("float");
        }
        if (bit_size <= 64) {
            return CODE("double");
        }
        return unexpect_error("unsupported float size: {}", bit_size);
    };
    ctx.config().forward_type_in_function_decl = true;
    ctx.config().function_define_keyword = "";
    ctx.config().self_value = "(*self)";
    ctx.config().default_value_option.vector_init = "{}";
    ctx.config().default_value_option.bytes_init = "{}";
    ctx.config().func_style_cast = false;
    ctx.config().usize_type_name = "size_t";
    ctx.config().endof_statement = ";";
    ctx.config().encoder_return_type = "int";
    ctx.config().decoder_return_type = "int";
    ctx.config().encoder_input_type = "EncoderInput*";
    ctx.config().decoder_input_type = "DecoderInput*";
    ctx.config().default_value_option.decoder_return_init = "0";
    ctx.config().default_value_option.encoder_return_init = "0";
    ctx.config().enum_member_separator = ",";
    ctx.config().endof_enum_definition = ";";
    ctx.config().pointer_type_wrapper = [&](Result elem_type) -> expected<Result> {
        if (ctx.config().ptr_to_optional) {
            return CODE("OPTIONAL_OF(", elem_type.to_writer(), ")");
        }
        return CODE(elem_type.to_writer(), "*");
    };
    ctx.config().optional_type_wrapper = [&](Result elem_type) -> expected<Result> {
        return CODE("OPTIONAL_OF(", elem_type.to_writer(), ")");
    };
    ctx.config().recursive_struct_type_wrapper = [&](Result elem_type) -> expected<Result> {
        return CODE(elem_type.to_writer(), "_ptr");
    };
    ctx.config().make_pointer_wrapper = [&](Result elem_type) -> expected<Result> {
        return CODE("(&", elem_type.to_writer(), ")");
    };
    ctx.config().default_value_option.pointer_init = "NULL";
    return pass;
}
