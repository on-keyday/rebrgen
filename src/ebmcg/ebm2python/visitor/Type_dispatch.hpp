/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Type_dispatch
  Available variables:
    visitor: Visitor
      module_: MappingTable
    alias_ref :TypeRef
    in: Type
      id: TypeRef
      body: TypeBody
        kind: TypeKind
        base_type: *TypeRef
        common_type: *TypeRef
        element_type: *TypeRef
        func_desc: *FuncTypeDesc
          return_type: TypeRef
          params: Types
            len: Varint
            container: std::vector<TypeRef>
          annotation: FuncTypeAnnotation
          reserved: std::uint8_t
        id: *StatementRef
        inner_type: *TypeRef
        length: *Varint
        members: *Types
          len: Varint
          container: std::vector<TypeRef>
        pointee_type: *TypeRef
        related_field: *StatementRef
        size: *Varint
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

const auto& type = in;

auto type_to_python_str = [&](ebm::TypeRef type_ref) -> expected<std::string> {
    MAYBE(res, visit_Type(visitor, type_ref));
    return res.to_string();
};

switch (type.body.kind) {
    case ebm::TypeKind::INT:
    case ebm::TypeKind::UINT:
        return "int";
    case ebm::TypeKind::FLOAT:
        return "float";
    case ebm::TypeKind::BOOL:
        return "bool";
    case ebm::TypeKind::STRUCT:
    case ebm::TypeKind::RECURSIVE_STRUCT: {  // Handle RECURSIVE_STRUCT here as well
        // For structs, get the name of the struct
        MAYBE(layers, get_identifier_layer(visitor, *type.body.id()));
        return join(".", layers | std::views::values);
    }
    case ebm::TypeKind::VOID:
        return "None";
    case ebm::TypeKind::META:
        return "Any";
    case ebm::TypeKind::ARRAY:
    case ebm::TypeKind::VECTOR: {  // Handle both ARRAY and VECTOR here
        MAYBE(element_type_obj, module_.get_type(*type.body.element_type()));
        if ((element_type_obj.body.kind == ebm::TypeKind::UINT || element_type_obj.body.kind == ebm::TypeKind::INT) &&
            element_type_obj.body.size() && element_type_obj.body.size()->value() == 8) {
            return "bytearray";
        }
        else {
            MAYBE(element_type_str, type_to_python_str(*type.body.element_type()));  // Recursive call
            return "list[" + element_type_str + "]";
        }
    }
    case ebm::TypeKind::ENUM: {
        // For enums, get the name of the enum
        MAYBE(enum_decl_stmt, module_.get_statement(*type.body.id()));
        auto enum_name = module_.get_associated_identifier(enum_decl_stmt.id);
        return "Union[" + enum_name + ",int]";
    }
    case ebm::TypeKind::ENCODER_RETURN:
    case ebm::TypeKind::DECODER_RETURN:
        return "None";                  // Or some other appropriate type for return values
    case ebm::TypeKind::ENCODER_INPUT:  // Add this case
    case ebm::TypeKind::DECODER_INPUT:  // Add this case
        return "BinaryIO";              // Map encoder/decoder input to bytes
    case ebm::TypeKind::FUNCTION: {
        // For functions, return a Callable type hint
        MAYBE(return_type_str, type_to_python_str(type.body.func_desc()->return_type));
        std::string params_str = "";  // Reverted: params_str is empty here
        return "Callable[[" + params_str + "], " + return_type_str + "]";
    }
    case ebm::TypeKind::VARIANT: {
        // For variants, return Union of member types
        std::string members_str = "";
        for (auto& member_type_ref : type.body.variant_desc()->members.container) {
            MAYBE(member_str, type_to_python_str(member_type_ref));
            if (!members_str.empty()) {
                members_str += ", ";
            }
            members_str += member_str;
        }
        return "Union[" + members_str + "]";
    }
    case ebm::TypeKind::RANGE: {
        // For ranges, return a tuple or a custom Range type
        MAYBE(base_type_str, type_to_python_str(*type.body.base_type()));
        return "tuple[" + base_type_str + ", " + base_type_str + "]";
    }
    case ebm::TypeKind::OPTIONAL: {
        // For optional types, return Optional type hint
        MAYBE(inner_type_str, type_to_python_str(*type.body.inner_type()));
        return "Optional[" + inner_type_str + "]";
    }
    case ebm::TypeKind::PTR: {
        // For pointers, return Any or a specific type if context allows
        MAYBE(pointee_type_str, type_to_python_str(*type.body.pointee_type()));
        return "Optional[" + pointee_type_str + "]";  // Using Optional to represent nullable pointers
    }
    case ebm::TypeKind::PROPERTY_SETTER_RETURN: {
        return "bool";
    }
    case ebm::TypeKind::USIZE:
        return "int";
    default:
        return unexpect_error("Unhandled TypeKind: {}", to_string(type.body.kind));  // Return an error for unhandled types
}