/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_PROGRAM_DECL_class
  Available Variables:
    ctx: Context_Statement_PROGRAM_DECL
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        module_: ebmgen::MappingTable
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
      item_id: ebm::StatementRef
      kind: const ebm::StatementKind&
      block: const ebm::Block&
        len: Varint
        container: std::vector<StatementRef>
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include "../codegen.hpp"
#include <ebmgen/interactive/debugger.hpp>
#include "ebmcodegen/stub/util.hpp"
#include "file/file_view.h"
#include "interpret.hpp"
#include "wrap/cout.h"
DEFINE_VISITOR(Statement_PROGRAM_DECL) {
    using namespace CODEGEN_NAMESPACE;
    auto entry_str = ctx.flags().entry_point;
    if (entry_str.empty()) {
        return unexpect_error("Entry point is not specified.");
    }
    auto query = std::format("Statement{{ body.struct_decl.has_encode_decode and id == \"{}\" }}", entry_str);
    MAYBE(query_result, ebmgen::run_query(ctx.module(), query));
    if (query_result.first.size() != 1) {
        return unexpect_error("Entry point not found: {}", entry_str);
    }
    auto entry_stmt_ref = query_result.first[0];
    MAYBE(entry_stmt, ctx.get(from_any_ref<ebm::StatementRef>(entry_stmt_ref)));
    auto entry_decode_fn = *entry_stmt.body.struct_decl()->decode_fn();
    auto f = ctx.config().env.new_function(entry_decode_fn);
    auto res = ctx.visit(entry_decode_fn);
    if (ctx.flags().debug_unimplemented) {
        for (auto& instr : ctx.config().env.get_instructions()) {
            futils::wrap::cerr_wrap() << to_string(instr.instr.op, true) << " // " << tidy_condition_brace(instr.str_repr) << "\n";
        }
    }
    if (!res) {
        return res;
    }
    if (ctx.flags().binary_file.empty()) {
        return res;
    }
    futils::file::View file;
    if (auto res = file.open(ctx.flags().binary_file); !res) {
        return unexpect_error("Failed to open binary file {}: {}", ctx.flags().binary_file, res.error().error<std::string>());
    }
    if (file.size() == 0) {
        return unexpect_error("Binary file is empty: {}", ctx.flags().binary_file);
    }
    MAYBE(fnt, ctx.module().get_statement(entry_decode_fn));
    MAYBE(decl, fnt.body.func_decl());
    RuntimeEnv runtime;
    std::map<std::uint64_t, std::shared_ptr<Value>> params;
    for (auto& param : decl.params.container) {
        // dummy
        params[param.id.value()] = std::make_shared<Value>();
    }
    runtime.input = futils::view::rvec(file.data(), file.size());
    runtime.input_pos = 0;
    InitialContext initial_ctx{.visitor = ctx.visitor};
    MAYBE_VOID(rt, runtime.interpret(initial_ctx, entry_stmt.id, params));
    return res;
}
