config.cpp.namespace = "rebgn"
config.cpp.bytes_type = "std::string"
config.cpp.sys_include = "string"

format Varint:
    prefix :u2
    match prefix:
        0 => value :u6
        1 => value :u14
        2 => value :u30
        3 => value :u62


# from ast_enum.bgn
enum BinaryOp:
    :u8
    mul = "*"
    div = "/"
    mod = "%"
    left_arithmetic_shift = "<<<"
    right_arithmetic_shift = ">>>"
    left_logical_shift = "<<"
    right_logical_shift = ">>"
    bit_and = "&"
    add = "+"
    sub = "-"
    bit_or = "|"
    bit_xor = "^"
    equal = "=="
    not_equal = "!="
    less = "<"
    less_or_eq = "<="
    grater = ">"
    grater_or_eq = ">="

    logical_and = "&&"

    logical_or = "||"

    cond_op1 = "?"
    cond_op2 = ":"

    range_exclusive = ".."
    range_inclusive = "..="

    assign = "="
    define_assign = ":="
    const_assign = "::="
    add_assign = "+="
    sub_assign = "-="
    mul_assign = "*="
    div_assign = "/="
    mod_assign = "%="
    left_logical_shift_assign = "<<="
    right_logical_shift_assign = ">>="
    left_arithmetic_shift_assign = "<<<="
    right_arithmetic_shift_assign = ">>>="
    bit_and_assign = "&="
    bit_or_assign = "|="
    bit_xor_assign = "^="

    comma = ","
    in_assign = "in"

enum UnaryOp:
    :u8
    not_ = "!"
    minus_sign = "-"

enum Endian:
    :u8
    unspec
    big
    little

enum AbstractOp:
    :u8
    NOP

    
    METADATA
    IMPORT
    SPECIFY_ENDIAN
    SPECIFY_BIT_ORDER
    SPECIFY_ALIGNMENT
    SPECIFY_LENGTH
    SPECIFY_STORAGE_TYPE
    SPECIFY_FIXED_VALUE
    MAP_TYPE

    DEFINE_PROGRAM
    END_PROGRAM
    DECLARE_PROGRAM

    DEFINE_FORMAT
    END_FORMAT
    DECLARE_FORMAT

    DEFINE_FIELD
    END_FIELD
    DECLARE_FIELD
    CONDITIONAL_FIELD

    DEFINE_PARAMETER
    END_PARAMETER
    DECLARE_PARAMETER
    
    DEFINE_FUNCTION
    END_FUNCTION
    DECLARE_FUNCTION
    
    DEFINE_ENUM
    END_ENUM
    DECLARE_ENUM
    
    DEFINE_ENUM_MEMBER
    END_ENUM_MEMBER
    DECLARE_ENUM_MEMBER
    
    DEFINE_UNION
    END_UNION
    DECLARE_UNION

    DEFINE_UNION_MEMBER
    END_UNION_MEMBER
    DECLARE_UNION_MEMBER

    DEFINE_STATE
    END_STATE
    DECLARE_STATE

    DEFINE_BIT_FIELD
    END_BIT_FIELD
    DECLARE_BIT_FIELD

    DEFINE_PACKED_OPERATION
    END_PACKED_OPERATION
    DECLARE_PACKED_OPERATION
    
    DEFINE_ENCODER

    DEFINE_DECODER
    
    ENCODE_INT
    DECODE_INT
    CALL_ENCODE
    CALL_DECODE
    ENUM_TO_INT_CAST
    INT_TO_ENUM_CAST
    BIT_CAST

    LOOP_INFINITE
    LOOP_CONDITION
    CONTINUE
    BREAK
    END_LOOP

    IF
    ELIF
    ELSE
    END_IF

    MATCH
    EXHAUSTIVE_MATCH
    CASE
    END_CASE
    DEFAULT_CASE
    END_MATCH

    DEFINE_VARIABLE
    DEFINE_CONSTANT
    
    BINARY
    UNARY
    ASSIGN
    SHORT_CIRCUIT 
    ASSERT
    EXPLICIT_ERROR

    ACCESS

    INDEX
    APPEND
    INC
    DEC
    NEG
    CALL
    RET

    IMMEDIATE_TRUE
    IMMEDIATE_FALSE
    IMMEDIATE_INT
    IMMEDIATE_INT64
    IMMEDIATE_STRING
    IMMEDIATE_TYPE
    IDENT_REF

    NEW_OBJECT



    SWITCH_UNION

    ENCODER_PARAMETER
    DECODER_PARAMETER

    STATE_VARIABLE_PARAMETER



 

format String:
    length :Varint
    data :[length.value]u8

format StringRef:
    code :Varint
    string :String

format IdentIndex:
    ident :Varint
    index :Varint


enum StorageType:
    :u8
    # terminal
    INT   
    UINT 
    FLOAT 
    STRUCT_REF
    RECURSIVE_STRUCT_REF
    BYTE_VECTOR # special case of vector
    BOOL

    # qualifiers
    ENUM
    ARRAY
    VECTOR
    # for union
    VARIANT






# TODO: be recursive
format Storage:
    type :StorageType
    match type:
        StorageType.INT => size :Varint
        StorageType.UINT => size :Varint
        StorageType.FLOAT => size :Varint
        StorageType.STRUCT_REF => ref :Varint
        StorageType.RECURSIVE_STRUCT_REF => ref :Varint
        StorageType.BYTE_VECTOR => ..
        StorageType.ENUM:
            ref :Varint
        StorageType.ARRAY:
            size :Varint
        StorageType.VECTOR:
            ref :Varint
        StorageType.VARIANT:
            ref :Varint 
            size :Varint

format Storages:
    length :Varint
    storages :[length.value]Storage

format Metadata:
    name :Varint
    len_exprs :Varint
    expr_refs :[len_exprs.value]Varint

format Code:
    op :AbstractOp
    match op:
        AbstractOp.METADATA:
            metadata :Metadata
        AbstractOp.DEFINE_PROGRAM:
            ident :Varint
        AbstractOp.IMPORT:
            ident :Varint
            ref :Varint # ref to program
        AbstractOp.IMMEDIATE_INT:
            ident :Varint
            int_value :Varint
        AbstractOp.SPECIFY_FIXED_VALUE:
            ref :Varint
        AbstractOp.IMMEDIATE_INT64:
            ident :Varint
            int_value64 :u64
        AbstractOp.IMMEDIATE_STRING:
            ident :Varint
        AbstractOp.IMMEDIATE_TRUE:
            ident :Varint
        AbstractOp.IMMEDIATE_FALSE:
            ident :Varint
        AbstractOp.IMMEDIATE_TYPE:
            ident :Varint
            storage :Storages
        AbstractOp.IDENT_REF:
            ref :Varint
        AbstractOp.DEFINE_FORMAT:
            ident :Varint
        AbstractOp.DEFINE_STATE:
            ident :Varint
        AbstractOp.DEFINE_FIELD:
            ident :Varint
            belong :Varint # belong to format or state or union or null
        AbstractOp.DEFINE_ENUM:
            ident :Varint
        AbstractOp.DEFINE_ENUM_MEMBER:
            ident :Varint
        AbstractOp.DEFINE_FUNCTION:
            ident :Varint
            belong :Varint # belong to format or null
        AbstractOp.DEFINE_ENCODER:
            left_ref :Varint # ref to format
            right_ref :Varint # ref to encoder
        AbstractOp.DEFINE_DECODER:
            left_ref :Varint # ref to format
            right_ref :Varint # ref to decoder
        AbstractOp.DEFINE_UNION:
            ident :Varint
            belong :Varint # ref to field
        AbstractOp.DEFINE_VARIABLE:
            ident :Varint
            ref :Varint # ref to initial expr
        AbstractOp.DEFINE_PARAMETER:
            ident: Varint
            belong :Varint # belong to function
        AbstractOp.DEFINE_UNION_MEMBER:
            ident :Varint
            belong :Varint # belong to union
        AbstractOp.SPECIFY_STORAGE_TYPE:
            storage :Storages
        AbstractOp.BINARY:
            ident :Varint
            bop :BinaryOp
            left_ref :Varint
            right_ref :Varint
        AbstractOp.UNARY:
            ident :Varint
            uop :UnaryOp
            ref :Varint
        AbstractOp.LOOP_CONDITION:
            ref :Varint
        AbstractOp.ACCESS:
            ident :Varint
            left_ref :Varint
            right_ref :Varint
        AbstractOp.INDEX:
            ident :Varint
            left_ref :Varint
            right_ref :Varint
        AbstractOp.ASSIGN:
            left_ref :Varint
            right_ref :Varint
        AbstractOp.ENCODE_INT:
            ref :Varint
            endian :Endian
            bit_size :Varint
        AbstractOp.DECODE_INT:
            ref :Varint
            endian :Endian
            bit_size :Varint
        AbstractOp.BIT_CAST:
            ident: Varint
            storage :Storages
            ref :Varint # ref to object
        AbstractOp.CALL_ENCODE:
            left_ref :Varint # ref to encoder
            right_ref :Varint # ref to object
        AbstractOp.CALL_DECODE:
            left_ref :Varint # ref to decoder
            right_ref :Varint # ref to object
        AbstractOp.LOOP_INFINITE:
            ref :Varint
        AbstractOp.INC:
            ref :Varint
        AbstractOp.DEC:
            ref :Varint
        AbstractOp.ENUM_TO_INT_CAST:
            ident :Varint
            left_ref :Varint # ref to enum
            right_ref :Varint # ref to object
        AbstractOp.INT_TO_ENUM_CAST:
            ident :Varint
            left_ref :Varint # ref to enum
            right_ref :Varint # ref to object
        AbstractOp.NEW_OBJECT:
            ident :Varint
            storage :Storages
        AbstractOp.ASSERT:
            ref :Varint
        AbstractOp.IF:
            ident :Varint
            ref :Varint
        AbstractOp.ELIF:
            ref :Varint
        AbstractOp.DECLARE_FORMAT:
            ref :Varint
        AbstractOp.DECLARE_FIELD:
            ref :Varint
        AbstractOp.DECLARE_ENUM:
            ref :Varint
        AbstractOp.DECLARE_ENUM_MEMBER:
            ref :Varint
        AbstractOp.DECLARE_FUNCTION:
            ref :Varint
        AbstractOp.DECLARE_UNION:
            ref :Varint
        AbstractOp.DECLARE_UNION_MEMBER:
            ref :Varint
        AbstractOp.CONDITIONAL_FIELD:
            left_ref :Varint # ref to expr
            right_ref :Varint # ref to field
        AbstractOp.CASE:
            ref :Varint
        AbstractOp.DECLARE_PROGRAM:
            ref :Varint
        AbstractOp.DEFINE_BIT_FIELD:
            ident :Varint
        AbstractOp.APPEND:
            left_ref :Varint # ref to vector
            right_ref :Varint # ref to object
        AbstractOp.DEFINE_PACKED_OPERATION:
            ident :Varint
        AbstractOp.SWITCH_UNION:
            ref :Varint # ref to union_member
        AbstractOp.RET:
            ref :Varint # maybe null
        AbstractOp.MATCH:
            ref :Varint # ref to expr
        AbstractOp.EXHAUSTIVE_MATCH:
            ref :Varint # ref to expr
        AbstractOp.ENCODER_PARAMETER:
            left_ref :Varint # ref to format
            right_ref :Varint # ref to encoder function
        AbstractOp.DECODER_PARAMETER:
            left_ref :Varint # ref to format
            right_ref :Varint # ref to decoder function
        AbstractOp.STATE_VARIABLE_PARAMETER:
            ref :Varint # ref to state


format StringRefs:
    refs_length :Varint
    refs :[refs_length.value]StringRef

format IdentIndexs:
    refs_length :Varint
    refs :[refs_length.value]IdentIndex

format Range:
    start :u64
    end :u64

format RangePacked:
    start :Varint
    end :Varint

format Ranges:
    length :Varint
    ranges :[length.value]RangePacked

format IdentRange:
    ident :Varint
    range :RangePacked

format IdentRanges:
    length :Varint
    ranges :[length.value]IdentRange

format BinaryModule:
    magic: "RBGM"
    strings :StringRefs
    identifiers :StringRefs
    ident_indexes :IdentIndexs
    programs :Ranges # root ranges
    ident_ranges :IdentRanges
    code_length :Varint
    code :[code_length.value]Code
