/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_FUNCTION_DECL_class
  Available Variables:
    ctx: Context_Statement_FUNCTION_DECL
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        module_: ebmgen::MappingTable
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
      item_id: ebm::StatementRef
      kind: const ebm::StatementKind&
      func_decl: const ebm::FunctionDecl&
        name: IdentifierRef
        return_type: TypeRef
        params: Block
          len: Varint
          container: std::vector<StatementRef>
        parent_format: WeakStatementRef
        kind: FunctionKind
        property: *WeakStatementRef
        body: StatementRef
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include "../codegen.hpp"
#include "ebm/extended_binary_module.hpp"
DEFINE_VISITOR(Statement_FUNCTION_DECL) {
    using namespace CODEGEN_NAMESPACE;
    /*here to write the hook*/
    CodeWriter w;
    if (ctx.func_decl.kind == ebm::FunctionKind::DECODE) {
        auto belong_name = ctx.identifier(ctx.func_decl.parent_format);
        w.write("parser ", belong_name, "_decode(");
        bool first = true;
        for (const auto& param : ctx.func_decl.params.container) {
            MAYBE(param_code, ctx.visit(param));
            if (!first) {
                w.write(", ");
            }
            w.write(param_code.to_writer());
            first = false;
        }
        w.writeln(") {");
        {
            auto scope = w.indent_scope();
            MAYBE(body_code, ctx.visit(ctx.func_decl.body));
            w.write(body_code.to_writer());
        }
        w.writeln("}");
        return w;
    }
    return "";
}
