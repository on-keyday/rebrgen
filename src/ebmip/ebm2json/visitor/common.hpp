/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: post_includes
  Available variables:
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

/*here to write the hook*/
#pragma once
#include "../codegen.hpp"
namespace ebm2json {
    struct ExprStringer {
        TRAVERSAL_VISITOR_BASE_WITHOUT_FUNC(ExprStringer, BaseVisitor);

        expected<std::string> visit(Context_Expression_LITERAL_INT& ctx) {
            return std::format("{}", ctx.int_value.value());
        }
        expected<std::string> visit(Context_Expression_LITERAL_INT64& ctx) {
            return std::format("{}", ctx.int64_value);
        }
        expected<std::string> visit(Context_Expression_BINARY_OP& ctx) {
            MAYBE(left, ctx.visit<std::string>(*this, ctx.left));
            MAYBE(right, ctx.visit<std::string>(*this, ctx.right));
            return std::format("{} {} {}", left, to_string(ctx.bop), right);
        }
        expected<std::string> visit(Context_Expression_UNARY_OP& ctx) {
            MAYBE(right, ctx.visit<std::string>(*this, ctx.operand));
            return std::format("{}{}", to_string(ctx.uop), right);
        }

        template <typename Ctx>
        expected<std::string> visit(Ctx&& ctx) {
            if (ctx.is_before_or_after()) {
                return pass;
            }
            if (ctx.context_name.contains("Statement") ||
                ctx.context_name.contains("Type")) {
                return {};
            }
            return traverse_children<std::string>(*this, std::forward<Ctx>(ctx));
        }
    };

    struct TypeStringer {
        TRAVERSAL_VISITOR_BASE_WITHOUT_FUNC(TypeStringer, BaseVisitor);
        expected<std::string> visit(Context_Type_INT& ctx) {
            return std::format("i{}", ctx.size.value());
        }
        expected<std::string> visit(Context_Type_UINT& ctx) {
            return std::format("u{}", ctx.size.value());
        }
        expected<std::string> visit(Context_Type_FLOAT& ctx) {
            return std::format("f{}", ctx.size.value());
        }
        expected<std::string> visit(Context_Type_ENUM& ctx) {
            return ctx.identifier(ctx.id);
        }
        expected<std::string> visit(Context_Type_STRUCT& ctx) {
            return ctx.identifier(ctx.id);
        }
        expected<std::string> visit(Context_Type_ARRAY& ctx) {
            MAYBE(elem_type, ctx.visit<std::string>(*this, ctx.element_type));
            return std::format("[{}]{}", ctx.length.value(), elem_type);
        }
        expected<std::string> visit(Context_Type_VECTOR& ctx) {
            MAYBE(elem_type, ctx.visit<std::string>(*this, ctx.element_type));
            return std::format("[]{}", elem_type);
        }

        template <typename Ctx>
        expected<std::string> visit(Ctx&& ctx) {
            if (ctx.is_before_or_after()) {
                return pass;
            }
            if (ctx.context_name.contains("Statement") ||
                ctx.context_name.contains("Expression")) {
                return {};
            }
            return traverse_children<std::string>(*this, std::forward<Ctx>(ctx));
        }
    };
}  // namespace ebm2json
