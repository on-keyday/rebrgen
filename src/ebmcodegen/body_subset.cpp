/*license*/
// Code generated by ebmcodegen at https://github.com/on-keyday/rebrgen
#include <ebm/extended_binary_module.hpp>
#include <set>
#include <map>
namespace ebmcodegen {
    std::map<ebm::StatementKind,std::pair<std::set<std::string_view>,std::vector<std::string_view>>> body_subset_StatementBody() {
        std::map<ebm::StatementKind,std::pair<std::set<std::string_view>,std::vector<std::string_view>>> subset_map;
        for(size_t i = 0;to_string(ebm::StatementKind(i))[0];i++) {
            ebm::StatementBody body;
            body.kind = ebm::StatementKind(i);
            body.alias({});
            body.assert_desc({});
            body.block({});
            body.break_({});
            body.continue_({});
            body.enum_decl({});
            body.enum_member_decl({});
            body.error_report({});
            body.expression({});
            body.field_decl({});
            body.func_decl({});
            body.if_statement({});
            body.loop({});
            body.lowered_statements({});
            body.match_branch({});
            body.match_statement({});
            body.metadata({});
            body.module_name({});
            body.offset({});
            body.param_decl({});
            body.previous_assignment({});
            body.property_decl({});
            body.property_member_decl({});
            body.read_data({});
            body.stream_type({});
            body.struct_decl({});
            body.sub_byte_range({});
            body.target({});
            body.value({});
            body.var_decl({});
            body.write_data({});
            std::set<std::string_view> subset;
            std::vector<std::string_view> ordered;
            body.visit([&](auto&& visitor,const char* name,auto&& value) {
                using T = std::decay_t<decltype(value)>;
                if constexpr (std::is_pointer_v<T>) {
                    if (value) { subset.insert(name); ordered.push_back(name); }
                }
                else {
                    subset.insert(name); ordered.push_back(name);
                }
            });
            subset_map[ebm::StatementKind(i)] = std::make_pair(std::move(subset), std::move(ordered));
        }
        return subset_map;
    }
    std::map<ebm::ExpressionKind,std::pair<std::set<std::string_view>,std::vector<std::string_view>>> body_subset_ExpressionBody() {
        std::map<ebm::ExpressionKind,std::pair<std::set<std::string_view>,std::vector<std::string_view>>> subset_map;
        for(size_t i = 0;to_string(ebm::ExpressionKind(i))[0];i++) {
            ebm::ExpressionBody body;
            body.kind = ebm::ExpressionKind(i);
            body.array_expr({});
            body.base({});
            body.bool_value({});
            body.bop({});
            body.call_desc({});
            body.cast_kind({});
            body.char_value({});
            body.condition({});
            body.conditional_stmt({});
            body.else_({});
            body.end({});
            body.endian_expr({});
            body.from_type({});
            body.id({});
            body.index({});
            body.int64_value({});
            body.int_value({});
            body.io_ref({});
            body.io_statement({});
            body.left({});
            body.lowered_expr({});
            body.member({});
            body.num_bytes({});
            body.operand({});
            body.or_cond({});
            body.right({});
            body.setter_status({});
            body.source_expr({});
            body.start({});
            body.stream_type({});
            body.string_value({});
            body.sub_range({});
            body.target_expr({});
            body.target_stmt({});
            body.then({});
            body.type_ref({});
            body.unit({});
            body.uop({});
            std::set<std::string_view> subset;
            std::vector<std::string_view> ordered;
            body.visit([&](auto&& visitor,const char* name,auto&& value) {
                using T = std::decay_t<decltype(value)>;
                if constexpr (std::is_pointer_v<T>) {
                    if (value) { subset.insert(name); ordered.push_back(name); }
                }
                else {
                    subset.insert(name); ordered.push_back(name);
                }
            });
            subset_map[ebm::ExpressionKind(i)] = std::make_pair(std::move(subset), std::move(ordered));
        }
        return subset_map;
    }
    std::map<ebm::TypeKind,std::pair<std::set<std::string_view>,std::vector<std::string_view>>> body_subset_TypeBody() {
        std::map<ebm::TypeKind,std::pair<std::set<std::string_view>,std::vector<std::string_view>>> subset_map;
        for(size_t i = 0;to_string(ebm::TypeKind(i))[0];i++) {
            ebm::TypeBody body;
            body.kind = ebm::TypeKind(i);
            body.base_type({});
            body.common_type({});
            body.element_type({});
            body.id({});
            body.inner_type({});
            body.length({});
            body.members({});
            body.params({});
            body.pointee_type({});
            body.related_field({});
            body.return_type({});
            body.size({});
            std::set<std::string_view> subset;
            std::vector<std::string_view> ordered;
            body.visit([&](auto&& visitor,const char* name,auto&& value) {
                using T = std::decay_t<decltype(value)>;
                if constexpr (std::is_pointer_v<T>) {
                    if (value) { subset.insert(name); ordered.push_back(name); }
                }
                else {
                    subset.insert(name); ordered.push_back(name);
                }
            });
            subset_map[ebm::TypeKind(i)] = std::make_pair(std::move(subset), std::move(ordered));
        }
        return subset_map;
    }
} // namespace ebmcodegen
