/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_SUB_BYTE_RANGE_class
  Available Variables:
    ctx: Context_Statement_SUB_BYTE_RANGE
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
        module_: ebmgen::MappingTable
      item_id: ebm::StatementRef
      kind: const ebm::StatementKind&
      sub_byte_range: const ebm::SubByteRange&
        stream_type: StreamType
        range_type: SubByteRangeType
        expression: *ExpressionRef
        length: *ExpressionRef
        offset: *ExpressionRef
        io_ref: StatementRef
        parent_io_ref: WeakStatementRef
        io_statement: StatementRef
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include "../codegen.hpp"
#include "ebmcg/ebm2go/codegen.hpp"
DEFINE_VISITOR(Statement_SUB_BYTE_RANGE) {
    using namespace CODEGEN_NAMESPACE;
    auto io_ = ctx.identifier(ctx.sub_byte_range.io_ref);
    auto io_base_ = io_ + "_base";
    auto parent_io_ = ctx.identifier(ctx.sub_byte_range.parent_io_ref);

    CodeWriter w;

    if (ctx.sub_byte_range.range_type == ebm::SubByteRangeType::bytes) {
        MAYBE(length, ctx.sub_byte_range.length());
        MAYBE(length_str, ctx.visit(length));

        if (ctx.config().use_io_reader_writer) {
            if (ctx.sub_byte_range.stream_type == ebm::StreamType::INPUT) {
                // Decode: read length bytes from reader, wrap in bytes.Reader for child
                w.writeln(io_, " := io.LimitReader(", io_base_, ",int64(", length_str.to_writer(), "))");
            }
            else {
                // Encode: create bytes.Buffer for child to write to
                ctx.config().imports.insert("bytes");
                w.writeln(io_, " := &bytes.Buffer{}");
            }

            MAYBE(do_io, ctx.visit(ctx.sub_byte_range.io_statement));
            w.write(do_io.to_writer());

            if (ctx.sub_byte_range.stream_type == ebm::StreamType::INPUT) {
                // After encoding: verify length and write to parent
                ctx.config().imports.insert("fmt");
                w.writeln("if ", io_, ".(*io.LimitedReader).N != 0 {");
                w.indent_writeln("return fmt.Errorf(\"subrange length mismatch: expected %d, but remains %d\", int(", length_str.to_writer(), "), ", io_, ".(*io.LimitedReader).N)");
                w.writeln("}");
            }
            else {
                // After encoding: verify length and write to parent
                ctx.config().imports.insert("fmt");
                w.writeln("if ", io_, ".Len() != int(", length_str.to_writer(), ") {");
                w.indent_writeln("return fmt.Errorf(\"subrange length mismatch: expected %d, got %d\", int(", length_str.to_writer(), "), ", io_, ".Len())");
                w.writeln("}");
                w.writeln("if _, err := ", parent_io_, ".Write(", io_, ".Bytes()); err != nil {");
                w.indent_writeln("return err");
                w.writeln("}");
            }
            return w;
        }

        if (ctx.sub_byte_range.stream_type == ebm::StreamType::INPUT) {
            // Decode: slice length bytes from parent, create *[]byte for child IO
            ctx.config().imports.insert("errors");
            w.writeln("if len(", parent_io_, ") - ", offset_ref(parent_io_), " < int(", length_str.to_writer(), ") {");
            w.indent_writeln("return errors.New(\"not enough data for subrange\")");
            w.writeln("}");
            w.writeln(io_base_, " := ", parent_io_, "[", offset_ref(parent_io_), ":int(", offset_ref(parent_io_), " + ", length_str.to_writer(), ")]");
            w.writeln(io_, " := &", io_base_);
            w.writeln(offset_var(io_), " := 0");
            w.writeln(offset_ref(parent_io_), " += int(", length_str.to_writer(), ")");
        }
        else if (ctx.config().append_io) {
            w.writeln(io_, " := ", parent_io_);
        }
        else {
            // Encode: allocate buffer from parent io
            w.writeln("if len(", parent_io_, ") - ", offset_ref(parent_io_), " < int(", length_str.to_writer(), ") {");
            {
                auto scope = w.indent_scope();
                w.indent_writeln("return errors.New(\"not enough space for subrange\")");
            }
            w.writeln("}");
            w.writeln(io_, " := ", parent_io_, "[", offset_ref(parent_io_), ":", offset_ref(parent_io_), "+ int(", length_str.to_writer(), ")]");
            w.writeln(offset_var(io_), "Base := 0");
            w.writeln(offset_var(io_), " := &", offset_var(io_), "Base");
        }

        MAYBE(do_io, ctx.visit(ctx.sub_byte_range.io_statement));
        w.write(do_io.to_writer());

        if (ctx.sub_byte_range.stream_type == ebm::StreamType::OUTPUT) {
            if (ctx.config().append_io) {
                w.writeln("if len(", io_, ") - len(", parent_io_, ") != int(", length_str.to_writer(), ") {");
                ctx.config().imports.insert("fmt");
                w.indent_writeln("return nil, fmt.Errorf(\"subrange length mismatch: expected %d, got %d\", int(", length_str.to_writer(), ") , len(", io_, ") - len(", parent_io_, "))");
                w.writeln("}");
                w.writeln(parent_io_, " = ", io_);
            }
            else {
                // After encoding: verify length and copy to parent
                ctx.config().imports.insert("fmt");
                w.writeln("if ", offset_ref(io_), " - ", offset_var(io_), "Base != int(", length_str.to_writer(), ") {");
                w.indent_writeln("return fmt.Errorf(\"subrange length mismatch: expected %d, got %d\", int(", length_str.to_writer(), "), len(*", io_, "))");
                w.writeln("}");
                w.writeln(offset_ref(parent_io_), "+= int(", length_str.to_writer(), ")");
            }
        }
    }
    else if (ctx.sub_byte_range.range_type == ebm::SubByteRangeType::seek_bytes) {
        MAYBE(length, ctx.sub_byte_range.length());
        MAYBE(length_str, ctx.visit(length));
        MAYBE(offset, ctx.sub_byte_range.offset());
        MAYBE(offset_str, ctx.visit(offset));

        if (ctx.sub_byte_range.stream_type == ebm::StreamType::INPUT) {
            // Decode: slice from offset with length, no parent advancement
            w.writeln(io_base_, " := ", parent_io_, "[int(", offset_str.to_writer(), "):int(", offset_str.to_writer(), " + ", length_str.to_writer(), ")]");
            w.writeln(io_, " := &", io_base_);
        }
        else {
            // Encode: slice from offset with length for writing
            w.writeln(io_base_, " := ", parent_io_, "[int(", offset_str.to_writer(), "):int(", offset_str.to_writer(), " + ", length_str.to_writer(), ")]");
            w.writeln(io_, " := &", io_base_);
        }

        MAYBE(do_io, ctx.visit(ctx.sub_byte_range.io_statement));
        w.write(do_io.to_writer());
    }

    return w;
}
