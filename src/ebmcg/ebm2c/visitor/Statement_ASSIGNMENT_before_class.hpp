/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_ASSIGNMENT_before_class
  Available Variables:
    ctx: Context_Statement_ASSIGNMENT_before<Result>
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
        module_: ebmgen::MappingTable
      item_id: ebm::StatementRef
      kind: const ebm::StatementKind&
      previous_assignment: const ebm::WeakStatementRef&
        id: StatementRef
      target: const ebm::ExpressionRef&
      value: const ebm::ExpressionRef&
      main_logic: ebmcodegen::util::MainLogicWrapper<Result>
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include "../codegen.hpp"
#include "ebm/extended_binary_module.hpp"
#include "includes.hpp"
DEFINE_VISITOR(Statement_ASSIGNMENT_before) {
    using namespace CODEGEN_NAMESPACE;
    auto member = ctx.get_field<"member">(ctx.target);
    if (auto comp = get_composite_field(ctx, member)) {
        auto setter = comp->composite_setter();
        if (!setter) {
            return pass;
        }
        MAYBE(base, ctx.get_field<"base">(ctx.target));
        MAYBE(base_str, ctx.visit(base));
        MAYBE(value, ctx.visit(ctx.value));
        CodeWriter w;
        auto parent_ident = ctx.identifier(comp->parent_struct);
        MAYBE(member_ident, ctx.identifier(*member));
        auto base_ = base_str.to_writer();
        if (ctx.get_field<"struct_decl.related_variant">(comp->parent_struct)) {
            base_ = CODE(std::move(base_), ".", parent_ident);
        }
        auto setter_func_name = std::format(
            "{}_set_{}",
            parent_ident,
            member_ident);
        w.writeln(setter_func_name, "(&", base_, ", ", value.to_writer(), ");");
        return w;
    }
    // array assignment to memcpy
    if (auto target_type = ctx.get_field<"type.instance">(ctx.target);
        target_type && target_type->body.kind == ebm::TypeKind::ARRAY) {
        auto annot = target_type->body.array_annotation();
        if (annot && *annot != ebm::ArrayAnnotation::none) {
            return pass;
        }
        // use memcpy for array assignment
        MAYBE(target_str, ctx.visit(ctx.target));
        MAYBE(value_str, ctx.visit(ctx.value));
        CodeWriter w;
        w.writeln("MEMCPY(", target_str.to_writer(), ", ", value_str.to_writer(), ", sizeof(", target_str.to_writer(), "));");
        return w;
    }
    /*here to write the hook*/
    return pass;
}
