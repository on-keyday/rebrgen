/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: entry_before_class
  Available Variables:
    ctx: Context_entry_before<Result>
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
        module_: ebmgen::MappingTable
      main_logic: ebmcodegen::util::MainLogicWrapper<Result>
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include <cctype>
#include <string>
#include "../codegen.hpp"
#include "ebm/extended_binary_module.hpp"
#include "ebmcodegen/stub/make_visitor.hpp"
#include "ebmcodegen/stub/util.hpp"
#include "ebmgen/common.hpp"
#include "escape/escape.h"
#include "json/stringer.h"
#include "number/parse.h"

namespace CODEGEN_NAMESPACE {

    inline expected<std::pair<CodeWriter, CodeWriter>> get_additional_parameters(Context_Statement_STRUCT_DECL& ctx, ebm::StatementRef func) {
        MAYBE(decl, ctx.get_field<"func_decl">(func));
        if (decl.params.container.size() > 1) {
            CodeWriter def, use;
            for (size_t i = 1; i < decl.params.container.size(); i++) {
                auto current = decl.params.container[i];
                MAYBE(param, ctx.visit(current));
                def.write(",", param.to_writer());
                use.write(",", ctx.identifier(current));
            }
            return std::make_pair(def, use);
        }
        return {};
    }

}  // namespace CODEGEN_NAMESPACE

DEFINE_VISITOR(entry_before) {
    using namespace CODEGEN_NAMESPACE;
    ctx.config().io_mode.slice_io = !ctx.flags().no_slice_io;
    ctx.config().io_mode.std_io = !ctx.flags().no_std_io;
    ctx.config().io_mode.bytes_io = ctx.flags().bytes_io;
    ctx.config().array_type_wrapper = [&](Result r, size_t size, ebm::ArrayAnnotation anno) -> expected<Result> {
        if (!ctx.config().use_io_reader_writer && anno != ebm::ArrayAnnotation::none) {
            // In *[]byte mode, annotated arrays are slices (they borrow from the IO buffer)
            return CODE("[]", r.to_writer());
        }
        // In io.Writer mode, all arrays are fixed-size (including annotated ones for lowered IO)
        return CODE("[", std::to_string(size), "]", r.to_writer());
    };
    ctx.config().vector_type_wrapper = [](Result r) -> expected<Result> {
        return CODE("[]", r.to_writer());
    };
    ctx.config().field_name_prior_to_type = true;
    ctx.config().int_prefix = "int";
    ctx.config().uint_prefix = "uint";
    ctx.config().float_prefix = "float";
    ctx.config().struct_definition_start_wrapper = [&](Context_Statement_STRUCT_DECL& sctx) -> expected<Result> {
        CodeWriter w;
        auto name = sctx.identifier();
        w.writeln_with_loc(to_any_ref(sctx.item_id), "type ", name, " struct ", ctx.config().begin_block);
        ctx.config().no_heap_mode.push_back(false);
        if (auto enc = sctx.struct_decl.encode_fn()) {
            MetadataSet meta;
            bool has_byte_write = false;
            auto detector =
                make_visitor<void>(ctx.visitor)
                    .name("MetaDataDetector")
                    .not_context("Type")
                    .not_context("Expression")
                    .not_before_or_after()
                    .on([&](auto&& self, Context_Statement_METADATA& ctx) {
                        return meta.try_add_metadata(self, &ctx.metadata);
                    })
                    .on([&](auto&& self, Context_Statement_WRITE_DATA& ctx) {
                        if (ctx.write_data.size.unit == ebm::SizeUnit::BYTE_FIXED &&
                            ctx.write_data.size.size()->value() == 1) {
                            has_byte_write = true;
                        }
                        return expected<void>{};
                    })
                    .on_default_traverse_children()
                    .build();
            MAYBE_VOID(detected, ctx.visit<void>(detector, *enc));
            if (auto conf = meta.get_first("config.go.union")) {
                if (conf->get_string(ctx, 0) == "noheap") {
                    ctx.config().no_heap_mode.back() = true;
                }
            }
            ctx.config().has_byte_io = has_byte_write;
        }
        if (!is_nil(sctx.struct_decl.name)) {
            ctx.output().struct_names.push_back(name);
        }
        return w;
    };
    ctx.config().struct_definition_end_wrapper = [](Context_Statement_STRUCT_DECL& ctx, CodeWriter& result) {
        ctx.config().no_heap_mode.pop_back();
        return result;
    };
    ctx.config().function_define_keyword = "func";
    ctx.config().function_return_type_separator = "";
    ctx.config().encoder_return_type = "error";
    ctx.config().decoder_return_type = "error";
    ctx.config().param_type_wrapper = [](Result type, bool is_state_variable) -> expected<Result> {
        if (is_state_variable) {
            return CODE("*", type.to_writer());
        }
        return type;
    };
    ctx.config().param_visitor = [](Context_Statement_PARAMETER_DECL& ctx, Result type) -> expected<Result> {
        auto kind = ctx.get_kind(ctx.param_decl.param_type);
        if (!ctx.config().use_io_reader_writer &&
            !ctx.config().append_io &&
            (kind == ebm::TypeKind::ENCODER_INPUT ||
             kind == ebm::TypeKind::DECODER_INPUT)) {
            return CODE(ctx.identifier(), " ", type.to_writer(), ", ", offset_var(ctx.identifier()), " *int");
        }
        return CODE(ctx.identifier(), " ", type.to_writer());
    };
    ctx.config().as_arg_visitor = [](Context_Expression_AS_ARG& ctx) -> expected<Result> {
        MAYBE(target, ctx.visit(ctx.target_expr));
        auto kind = ctx.get_kind(ctx.type);
        if (!ctx.config().use_io_reader_writer &&
            !ctx.config().append_io &&
            (kind == ebm::TypeKind::ENCODER_INPUT ||
             kind == ebm::TypeKind::DECODER_INPUT)) {
            return CODE(target.to_writer(), ", ", offset_var(target.to_string()));
        }
        return target;
    };
    ctx.config().struct_encode_start_wrapper = [](Context_Statement_STRUCT_DECL& sctx, ebm::StatementRef encode_fn) -> expected<Result> {
        CodeWriter w;
        MAYBE(def_use, get_additional_parameters(sctx, encode_fn));
        auto& def = def_use.first;
        auto& use = def_use.second;
        if (sctx.config().io_mode.bytes_io) {
            sctx.config().encoder_input_type = "*bytes.Buffer";
            sctx.config().imports.insert("bytes");
            sctx.config().encode_fn_name = "WriteBuffer";
            sctx.config().use_io_reader_writer = true;
            MAYBE(enc, sctx.visit(encode_fn));
            w.write(std::move(enc.to_writer()));
            auto name = sctx.identifier();
            w.writeln("func (s *", name, ") EncodeBuffer(reserved []byte", def, ") ([]byte,error) {");
            {
                auto scope = w.indent_scope();
                sctx.config().imports.insert("bytes");
                w.writeln("buf := bytes.NewBuffer(reserved)");
                w.writeln("err := s.WriteBuffer(buf", use, ")");
                w.writeln("if err != nil {");
                w.indent_writeln("return nil,err");
                w.writeln("}");
                w.writeln("return buf.Bytes(), nil");
            }
            w.writeln("}");
            w.writeln("func (s *", name, ") MustEncodeBuffer(reserved []byte", def, ") []byte {");
            {
                auto scope = w.indent_scope();
                w.writeln("buf,err := s.EncodeBuffer(reserved", use, ")");
                w.writeln("if err != nil {");
                w.indent_writeln("panic(err)");
                w.writeln("}");
                w.writeln("return buf");
            }
            w.writeln("}");
        }
        if (sctx.config().io_mode.std_io) {
            sctx.config().encoder_input_type = "io.Writer";
            sctx.config().imports.insert("io");
            sctx.config().encode_fn_name = "Write";
            sctx.config().use_io_reader_writer = true;
            MAYBE(enc, sctx.visit(encode_fn));
            w.write(std::move(enc.to_writer()));
            auto name = sctx.identifier();
            w.writeln("func (s *", name, ") EncodeCopy(reserved []byte", def, ") ([]byte,error) {");
            {
                auto scope = w.indent_scope();
                sctx.config().imports.insert("bytes");
                w.writeln("buf := bytes.NewBuffer(reserved)");
                w.writeln("err := s.Write(buf", use, ")");
                w.writeln("if err != nil {");
                w.indent_writeln("return nil,err");
                w.writeln("}");
                w.writeln("return buf.Bytes(), nil");
            }
            w.writeln("}");
            w.writeln("func (s *", name, ") MustEncodeCopy(reserved []byte", def, ") []byte {");
            {
                auto scope = w.indent_scope();
                w.writeln("buf,err := s.EncodeCopy(reserved", use, ")");
                w.writeln("if err != nil {");
                w.indent_writeln("panic(err)");
                w.writeln("}");
                w.writeln("return buf");
            }
            w.writeln("}");
        }
        if (sctx.config().io_mode.slice_io) {
            sctx.config().encoder_input_type = "[]byte";
            sctx.config().encode_fn_name = "EncodeSlice";
            sctx.config().use_io_reader_writer = false;
            sctx.config().append_io = false;
            MAYBE(enc, sctx.visit(encode_fn));
            w.write(std::move(enc.to_writer()));
            auto name = sctx.identifier();
            w.writeln("func (s *", name, ") Encode(buf []byte", def, ") ([]byte,error) {");
            {
                auto scope = w.indent_scope();
                w.writeln("var offset int");
                w.writeln("err := s.EncodeSlice(buf,&offset", use, ")");
                w.writeln("if err != nil {");
                w.indent_writeln("return nil,err");
                w.writeln("}");
                w.writeln("return buf[:offset], nil");
            }
            w.writeln("}");
            w.writeln("func (s *", name, ") MustEncode(reserved []byte", def, ") []byte {");
            {
                auto scope = w.indent_scope();
                w.writeln("buf,err := s.Encode(reserved", use, ")");
                w.writeln("if err != nil {");
                w.indent_writeln("panic(err)");
                w.writeln("}");
                w.writeln("return buf");
            }
            w.writeln("}");
            sctx.config().encoder_input_type = "[]byte";
            sctx.config().encoder_return_type = "([]byte,error)";
            sctx.config().encode_fn_name = "Append";
            sctx.config().use_io_reader_writer = false;
            sctx.config().append_io = true;
            MAYBE(enc2, sctx.visit(encode_fn));
            w.write(std::move(enc2.to_writer()));
            sctx.config().encoder_return_type = "error";
            sctx.config().append_io = false;
            w.writeln("func (s *", name, ") MustAppend(buf []byte", def, ") []byte {");
            {
                auto scope = w.indent_scope();
                w.writeln("var err error");
                w.writeln("buf,err = s.Append(buf", use, ")");
                w.writeln("if err != nil {");
                w.indent_writeln("panic(err)");
                w.writeln("}");
                w.writeln("return buf");
            }
            w.writeln("}");
        }
        return w;
    };

    ctx.config().struct_decode_start_wrapper = [](Context_Statement_STRUCT_DECL& sctx, ebm::StatementRef decode_fn) -> expected<Result> {
        CodeWriter w;
        MAYBE(func, sctx.get_field<"func_decl.params">(decode_fn));
        MAYBE(def_use, get_additional_parameters(sctx, decode_fn));
        auto& def = def_use.first;
        auto& use = def_use.second;

        if (sctx.config().io_mode.bytes_io) {
            sctx.config().decoder_input_type = "*bytes.Reader";
            sctx.config().imports.insert("bytes");
            sctx.config().decode_fn_name = "ReadBuffer";
            sctx.config().use_io_reader_writer = true;
            MAYBE(enc, sctx.visit(decode_fn));
            w.write(std::move(enc.to_writer()));
            auto name = sctx.identifier();
            w.writeln("func (s *", name, ") DecodeBuffer(buf []byte", def, ") ([]byte,error) {");
            {
                auto scope = w.indent_scope();
                sctx.config().imports.insert("bytes");
                w.writeln("r := bytes.NewReader(buf)");
                w.writeln("err := s.ReadBuffer(r", use, ")");
                w.writeln("if err != nil {");
                w.indent_writeln("return nil,err");
                w.writeln("}");
                w.writeln("return buf[int(r.Size()) - r.Len():], nil");
            }
            w.writeln("}");
            w.writeln("func (s *", name, ") DecodeExactBuffer(buf []byte", def, ") error {");
            {
                auto scope = w.indent_scope();
                w.writeln("remain,err := s.DecodeBuffer(buf", use, ")");
                w.writeln("if err != nil {");
                w.indent_writeln("return err");
                w.writeln("}");
                w.writeln("if len(remain) != 0 {");
                sctx.config().imports.insert("fmt");
                w.indent_writeln("return fmt.Errorf(\"expect no remaining bytes but got %d bytes\",len(remain))");
                w.writeln("}");
                w.writeln("return nil");
            }
            w.writeln("}");
        }
        if (sctx.config().io_mode.std_io) {
            sctx.config().decoder_input_type = "io.Reader";
            sctx.config().imports.insert("io");
            sctx.config().decode_fn_name = "Read";
            sctx.config().use_io_reader_writer = true;
            MAYBE(enc, sctx.visit(decode_fn));
            w.write(std::move(enc.to_writer()));
            auto name = sctx.identifier();
            w.writeln("func (s *", name, ") DecodeCopy(buf []byte", def, ") ([]byte,error) {");
            {
                auto scope = w.indent_scope();
                sctx.config().imports.insert("bytes");
                w.writeln("r := bytes.NewReader(buf)");
                w.writeln("err := s.Read(r", use, ")");
                w.writeln("if err != nil {");
                w.indent_writeln("return nil,err");
                w.writeln("}");
                w.writeln("return buf[int(r.Size()) - r.Len():], nil");
            }
            w.writeln("}");
            w.writeln("func (s *", name, ") DecodeExactCopy(buf []byte", def, ") error {");
            {
                auto scope = w.indent_scope();
                w.writeln("remain,err := s.DecodeCopy(buf", use, ")");
                w.writeln("if err != nil {");
                w.indent_writeln("return err");
                w.writeln("}");
                w.writeln("if len(remain) != 0 {");
                sctx.config().imports.insert("fmt");
                w.indent_writeln("return fmt.Errorf(\"expect no remaining bytes but got %d bytes\",len(remain))");
                w.writeln("}");
                w.writeln("return nil");
            }
            w.writeln("}");
        }
        if (sctx.config().io_mode.slice_io) {
            sctx.config().decoder_input_type = "[]byte";
            sctx.config().decode_fn_name = "DecodeSlice";
            sctx.config().use_io_reader_writer = false;
            MAYBE(enc, sctx.visit(decode_fn));
            w.write(std::move(enc.to_writer()));
            auto name = sctx.identifier();
            w.writeln("func (s *", name, ") Decode(buf []byte", def, ") ([]byte,error) {");
            {
                auto scope = w.indent_scope();
                w.writeln("var offset int");
                w.writeln("err := s.DecodeSlice(buf,&offset", use, ")");
                w.writeln("if err != nil {");
                w.indent_writeln("return nil,err");
                w.writeln("}");
                w.writeln("return buf[offset:], nil");
            }
            w.writeln("}");
            w.writeln("func (s *", name, ") DecodeExact(buf []byte", def, ") error {");
            {
                auto scope = w.indent_scope();
                w.writeln("remain,err := s.Decode(buf", use, ")");
                w.writeln("if err != nil {");
                w.indent_writeln("return err");
                w.writeln("}");
                w.writeln("if len(remain) != 0 {");
                sctx.config().imports.insert("fmt");
                w.indent_writeln("return fmt.Errorf(\"expect no remaining bytes but got %d bytes\",len(remain))");
                w.writeln("}");
                w.writeln("return nil");
            }
            w.writeln("}");
        }
        return w;
    };

    ctx.config().function_definition_start_wrapper = [&](Result return_type, std::string_view name, CodeWriter params, Context_Statement_FUNCTION_DECL& fctx) -> expected<Result> {
        CodeWriter w;
        std::string_view name_prefix;
        if (is_setter_func(fctx.func_decl.kind)) {
            name_prefix = "Set";
            if (is_nil(fctx.func_decl.name)) {
                name_prefix = "set";  // unexported
            }
            // first parameter is u1, change to value type
            MAYBE(param_type, fctx.get_field<"param_decl.param_type.instance">(fctx.func_decl.params.container[0]));
            if (auto size = param_type.body.size()) {
                if (size->value() == 1) {
                    if (name_prefix == "Set") {
                        name_prefix = "set";
                        ctx.config().bool_mapped_func.insert(get_id(fctx.item_id));
                        w.writeln("func (", ctx.config().self_value, " *", ctx.identifier(fctx.func_decl.parent_format), ") Set", name, "(value bool) ", ctx.config().function_return_type_separator, " ", return_type.to_writer(), " ", ctx.config().begin_block);
                        {
                            auto scope = w.indent_scope();
                            w.writeln("var intVal uint8");
                            w.writeln("if value {");
                            w.indent_writeln("intVal = 1");
                            w.writeln("} else {");
                            w.indent_writeln("intVal = 0");
                            w.writeln("}");
                            w.writeln("return ", ctx.config().self_value, ".", name_prefix, name, "(intVal)");
                        }
                        w.writeln("}");
                    }
                }
            }
        }
        std::string tmp_buffer;
        if (is_getter_func(fctx.func_decl.kind)) {
            // if return type is u1, change to bool
            MAYBE(ret_type, fctx.get_field<"func_decl.return_type.instance">(fctx.item_id));
            if (auto size = ret_type.body.size()) {
                if (size->value() == 1) {
                    tmp_buffer = std::string(name);
                    tmp_buffer[0] = std::tolower(tmp_buffer[0]);
                    w.writeln("func (", ctx.config().self_value, " *", ctx.identifier(fctx.func_decl.parent_format), ") ", name, "() ", ctx.config().function_return_type_separator, " bool ", ctx.config().begin_block);
                    {
                        auto scope = w.indent_scope();
                        w.writeln("intVal := ", ctx.config().self_value, ".", tmp_buffer, "()");
                        w.writeln("return intVal != 0");
                    }
                    w.writeln("}");
                    ctx.config().bool_mapped_func.insert(get_id(fctx.item_id));
                    name = tmp_buffer;
                }
            }
        }
        if (is_composite_func(fctx.func_decl.kind)) {
            // may change return type or params
            if (fctx.func_decl.kind == ebm::FunctionKind::COMPOSITE_GETTER) {
                auto got = ctx.get_field<"variant_desc">(fctx.func_decl.return_type);
                if (got && !is_nil(got->common_type)) {
                    MAYBE(typ, ctx.visit(got->common_type));
                    return_type = typ;
                }
            }
            else {
                auto got = ctx.get_field<"param_decl.param_type.variant_desc">(fctx.func_decl.params.container[0]);
                if (got && !is_nil(got->common_type)) {
                    MAYBE(typ, ctx.visit(got->common_type));
                    auto param_name = ctx.identifier(fctx.func_decl.params.container[0]);
                    params = CODE(param_name, " ", typ.to_writer());
                }
            }
        }
        if (fctx.func_decl.kind == ebm::FunctionKind::ENCODE) {
            name = fctx.config().encode_fn_name;
        }
        else if (fctx.func_decl.kind == ebm::FunctionKind::DECODE) {
            name = fctx.config().decode_fn_name;
        }
        if (!is_nil(fctx.func_decl.parent_format)) {
            auto struct_name = ctx.identifier(fctx.func_decl.parent_format);
            ctx.config().self_value = std::string(1, std::tolower(struct_name[0]));
            w.writeln(ctx.config().function_define_keyword, " (", ctx.config().self_value, " *", struct_name, ") ", name_prefix, name, "(", params, ") ", ctx.config().function_return_type_separator, " ", return_type.to_writer(), " ", ctx.config().begin_block);
        }
        else {
            w.writeln(ctx.config().function_define_keyword, " ", name_prefix, name, "(", params, ") ", ctx.config().function_return_type_separator, return_type.to_writer(), " ", ctx.config().begin_block);
        }
        if (fctx.func_decl.kind == ebm::FunctionKind::DECODE && ctx.config().has_byte_io && ctx.config().decoder_input_type == "io.Reader") {
            auto scope = w.indent_scope();
            fctx.config().imports.insert("io");
            MAYBE(param0, ctx.get_field<"container.0">(&fctx.func_decl.params));
            auto original = ctx.identifier(param0);
            auto ident = byte_io_ref(original);
            w.writeln(ident, ", _ := ", original, ".(io.ByteReader)");
        }
        if (fctx.func_decl.kind == ebm::FunctionKind::ENCODE && ctx.config().has_byte_io && ctx.config().encoder_input_type == "io.Writer") {
            auto scope = w.indent_scope();
            fctx.config().imports.insert("io");
            MAYBE(param0, ctx.get_field<"container.0">(&fctx.func_decl.params));
            auto original = ctx.identifier(param0);
            auto ident = byte_io_ref(original);
            w.writeln(ident, ", _ := ", original, ".(io.ByteWriter)");
        }
        return w;
    };
    ctx.config().composite_field_decl_visitor = [&](Context_Statement_COMPOSITE_FIELD_DECL& cctx) -> expected<Result> {
        if (cctx.composite_field_decl.kind == ebm::CompositeFieldKind::BULK_PRIMITIVE ||
            cctx.composite_field_decl.kind == ebm::CompositeFieldKind::PREFIXED_UNION_PRIMITIVE) {
            auto ident = cctx.identifier();
            MAYBE(typ, ctx.visit(cctx.composite_field_decl.composite_type));
            auto res = CODELINE(ident, " ", typ.to_writer());
            // for each field, generate getter and setter
            for (auto& field : cctx.composite_field_decl.fields.container) {
                MAYBE(field_decl, cctx.get_field<"field_decl">(field));
                auto getter = field_decl.composite_getter();
                auto setter = field_decl.composite_setter();
                if (getter) {
                    MAYBE(getter, ctx.visit(getter->id));
                    ctx.config().decl_toplevel.push_back(getter.to_writer());
                }
                if (setter) {
                    MAYBE(setter, ctx.visit(setter->id));
                    ctx.config().decl_toplevel.push_back(setter.to_writer());
                }
            }
            return res;
        }
        return cctx.visit(cctx.composite_field_decl.fields);
    };
    ctx.config().reserve_data_visitor = [&](Context_Statement_RESERVE_DATA& rctx) -> expected<Result> {
        MAYBE(write_data, ctx.get_field<"write_data">(rctx.reserve_data.write_data));
        MAYBE(size_str, get_size_str(ctx, rctx.reserve_data.size));
        auto io_ref = ctx.identifier(write_data.io_ref);
        MAYBE(target, ctx.visit(write_data.target));
        MAYBE(field_name, get_identifier_layer_str(ctx, from_weak(write_data.field)));
        field_name = "\\\"" + field_name + "\\\"";
        CodeWriter w;
        if (ctx.config().use_io_reader_writer) {
            // In io.Writer mode: no-op. The fixed array declaration provides storage.
            return "";
        }
        else if (ctx.config().append_io) {
            w.writeln(rctx.identifier(), " := len(", io_ref, ")");
            w.writeln(io_ref, " = append(", io_ref, ", make([]byte,", size_str, ")...)");
            w.writeln(target.to_writer(), " = ", io_ref, "[", rctx.identifier(), ":]");
        }
        else {
            rctx.config().imports.insert("errors");
            w.writeln("if len(", io_ref, ") - ", offset_ref(io_ref), " < int(", size_str, ") {");
            {
                auto scope = w.indent_scope();
                w.indent_writeln("return errors.New(\"not enough space to reserve data for field ", field_name, "\")");
            }
            w.writeln("}");
            w.writeln(target.to_writer(), " = ", io_ref, "[", offset_ref(io_ref), ":", offset_ref(io_ref), "+ int(", size_str, ")]");
        }
        return w;
    };
    ctx.config().is_error_visitor = [&](Context_Expression_IS_ERROR& ectx) -> expected<Result> {
        MAYBE(err, ctx.visit(ectx.target_expr));
        return CODE(err.to_writer(), " != nil");
    };
    ctx.config().error_return_visitor = [&](Context_Statement_ERROR_RETURN& rctx) -> expected<Result> {
        MAYBE(err_expr, ctx.visit(rctx.value));
        CodeWriter w;
        if (rctx.config().use_io_reader_writer && rctx.config().on_until_eof_loop) {
            w.writeln("if ", err_expr.to_writer(), " == io.EOF {");
            w.writeln("break");
            w.writeln("}");
        }
        if (ctx.config().append_io) {
            w.writeln("return nil,", err_expr.to_writer());
        }
        else {
            w.writeln("return ", err_expr.to_writer());
        }
        return w;
    };
    ctx.config().error_report_visitor = [&](Context_Statement_ERROR_REPORT& rptctx) -> expected<Result> {
        MAYBE(err_expr, ctx.get(rptctx.error_report.message));
        auto escaped_msg = futils::escape::escape_str<std::string>(err_expr.body.data);
        CodeWriter w;
        rptctx.config().imports.insert("errors");
        if (ctx.config().append_io) {
            w.writeln("return nil, errors.New(\"", escaped_msg, "\")");
        }
        else {
            w.writeln("return errors.New(\"", escaped_msg, "\")");
        }
        return w;
    };
    ctx.config().variable_type_separator = "";
    ctx.config().variable_with_type = false;
    ctx.config().variable_initializer = ":=";
    ctx.config().constant_define_keyword = "const";
    ctx.config().constant_initializer = "=";
    ctx.config().enum_decl_visitor = [&](Context_Statement_ENUM_DECL& ectx) -> expected<Result> {
        CodeWriter w;
        auto name = ectx.identifier();
        if (is_nil(ectx.enum_decl.base_type)) {
            w.writeln("type ", name, " int");
        }
        else {
            MAYBE(type, ctx.visit(ectx.enum_decl.base_type));
            w.writeln("type ", name, " ", type.to_writer());
        }
        w.writeln("");
        w.writeln("const (");
        {
            auto scope = w.indent_scope();
            for (auto& member_ref : ectx.enum_decl.members.container) {
                MAYBE(member, ectx.visit(member_ref));
                w.write(member.to_writer());
            }
        }
        w.writeln(")");
        w.writeln("func (e ", name, ") String() string {");
        {
            auto scope = w.indent_scope();
            w.writeln("switch e {");
            {
                auto scope = w.indent_scope();
                for (auto& member_ref : ectx.enum_decl.members.container) {
                    MAYBE(member, ectx.get_field<"enum_member_decl">(member_ref));
                    w.writeln("case ", name, "_", ectx.identifier(member_ref), ":");
                    if (!is_nil(member.string_repr)) {
                        MAYBE(lit, ctx.get(member.string_repr));
                        w.indent_writeln("return \"", futils::escape::escape_str<std::string>(lit.body.data), "\"");
                    }
                    else {
                        w.indent_writeln("return \"", ectx.identifier(member_ref), "\"");
                    }
                }
                ectx.config().imports.insert("fmt");
                w.writeln("default:");
                w.indent_writeln("return fmt.Sprintf(\"", name, "(%d)\",e)");
            }
            w.writeln("}");
        }
        w.writeln("}");
        return w;
    };
    ctx.config().enum_member_decl_visitor = [&](Context_Statement_ENUM_MEMBER_DECL& mctx) -> expected<Result> {
        auto enum_name = ctx.identifier(mctx.enum_member_decl.enum_decl);
        auto member_name = mctx.identifier();
        MAYBE(value_expr, ctx.visit(mctx.enum_member_decl.value));
        return CODELINE(enum_name, "_", member_name, " ", enum_name, " = ", value_expr.to_writer());
    };
    ctx.config().enum_member_accessor = "_";
    ctx.config().init_check_visitor = [&](Context_Statement_INIT_CHECK& ictx) -> expected<Result> {
        if (ictx.init_check.init_check_type == ebm::InitCheckType::union_init_encode ||
            ictx.init_check.init_check_type == ebm::InitCheckType::union_init_decode ||
            ictx.init_check.init_check_type == ebm::InitCheckType::union_get ||
            ictx.init_check.init_check_type == ebm::InitCheckType::union_set) {
            MAYBE(type, ictx.get_field<"type">(ictx.init_check.expect_value));
            if (get_composite_field(ctx, ctx.get_field<"member">(ictx.init_check.target_field))) {
                ctx.config().bulk_primitive.insert(get_id(type));
                return "";
            }
            if (ctx.config().no_heap_mode.back()) {
                return "";
            }
            MAYBE(field_txt, ictx.visit(ictx.init_check.target_field));
            auto tmpname = std::format("tmp{}", get_id(type));
            MAYBE(type_txt, ictx.visit(type));
            // tmp,ok := field_txt.(*type_txt)
            CodeWriter w;
            w.writeln(tmpname, ", ok := ", field_txt.to_writer(), ".(*", type_txt.to_writer(), ")");
            w.writeln("if !ok {");
            {
                auto scope = w.indent_scope();
                std::string nil = ictx.config().append_io ? "nil," : "";
                if (ictx.init_check.init_check_type == ebm::InitCheckType::union_init_encode) {
                    ictx.config().imports.insert("errors");
                    w.writeln("return ", nil, "errors.New(\"invalid union type for encoding\")");
                }
                else if (ictx.init_check.init_check_type == ebm::InitCheckType::union_get) {
                    MAYBE(func_decl, ictx.get_field<"id.func_decl">(ictx.init_check.related_function));
                    MAYBE(default_, as_DEFAULT_VALUE(ctx, func_decl.return_type));
                    w.writeln("return ", default_.to_writer());
                }
                else {
                    w.writeln(tmpname, " = &", type_txt.to_writer(), "{}");
                    w.writeln(field_txt.to_writer(), " = ", tmpname);
                }
            }
            w.writeln("}");
            w.writeln("_ = ", tmpname, " // to prevent unused warnings");
            return w;
        }
        return "";
    };
    ctx.config().variant_type_custom = [&](Context_Type_VARIANT& vctx) -> expected<Result> {
        if (is_nil(vctx.variant_desc.related_field) &&
            is_nil(vctx.variant_desc.common_type)) {
            ctx.config().any_variant.insert(get_id(vctx.item_id));
            return CODE("any");
        }
        return pass;
    };
    ctx.config().default_value_custom = [&](Context_Expression_DEFAULT_VALUE& dctx) -> expected<Result> {
        MAYBE(type, dctx.get(dctx.type));
        if (type.body.kind == ebm::TypeKind::ARRAY || type.body.kind == ebm::TypeKind::VECTOR ||
            type.body.kind == ebm::TypeKind::STRUCT || type.body.kind == ebm::TypeKind::RECURSIVE_STRUCT) {
            MAYBE(typ_txt, dctx.visit(dctx.type));
            return CODE(typ_txt.to_string(), "{}");
        }
        // integers and floats default to 0 with type
        if (type.body.kind == ebm::TypeKind::INT || type.body.kind == ebm::TypeKind::UINT ||
            type.body.kind == ebm::TypeKind::FLOAT || type.body.kind == ebm::TypeKind::ENUM) {
            MAYBE(typ_txt, dctx.visit(dctx.type));
            return CODE(typ_txt.to_string(), "(0)");
        }
        if (type.body.kind == ebm::TypeKind::VARIANT) {
            if (auto memb = type.body.variant_desc(); memb && !is_nil(memb->common_type)) {
                return as_DEFAULT_VALUE(dctx, memb->common_type);
            }
            return CODE("nil");
        }
        // currently, optional uses inner type default
        if (type.body.kind == ebm::TypeKind::OPTIONAL) {
            MAYBE(inner_type, type.body.inner_type());
            return as_DEFAULT_VALUE(dctx, inner_type);
        }

        return pass;
    };
    ctx.config().append_visitor = [&](Context_Statement_APPEND& actx) -> expected<Result> {
        MAYBE(target, actx.visit(actx.target));
        MAYBE(value, actx.visit(actx.value));
        return CODELINE(target.to_writer(), " = append(", target.to_writer(), ", ", value.to_writer(), ")");
    };
    ctx.config().can_read_stream_visitor = [&](Context_Expression_CAN_READ_STREAM& cctx) -> expected<Result> {
        auto stream = cctx.identifier(cctx.io_ref);
        MAYBE(size_str, get_size_str(cctx, cctx.num_bytes));
        if (ctx.config().use_io_reader_writer) {
            if (size_str.to_string() == "1") {
                // In io.Reader mode, we cannot check remaining bytes without consuming.
                // For now, always return true and let io.ReadFull fail with io.ErrUnexpectedEOF.
                return CODE("true");
            }
            return CODE("true");
        }
        return CODE("len(", stream, ") >= ", size_str);
    };
    ctx.config().pointer_type_wrapper = [](Result r) -> expected<Result> {
        return CODE("*", r.to_writer());
    };
    ctx.config().make_pointer_wrapper = [](Result r) -> expected<Result> {
        return CODE("&", r.to_writer());
    };
    ctx.config().default_value_option.pointer_init = "nil";
    ctx.config().default_value_option.decoder_return_init = "nil";
    ctx.config().default_value_option.encoder_return_init = "nil";
    ctx.config().conditional_loop_keyword = "for";
    ctx.config().infinity_loop_keyword = "for";

    ctx.config().append_function = "append";
    ctx.config().usize_type_name = "int";
    ctx.config().surrounded_array_size = true;
    ctx.config().use_brace_for_condition = false;

    ctx.config().alt_unary_op[ebm::UnaryOp::bit_not] = "^";

    ctx.config().conditional_visitor = [&](Context_Expression_CONDITIONAL& cctx) -> expected<Result> {
        MAYBE(cond_str, ctx.visit(cctx.condition));
        MAYBE(then_str, ctx.visit(cctx.then));
        MAYBE(else_str, ctx.visit(cctx.else_));
        MAYBE(type_str, ctx.visit(cctx.type));
        return CODE("func() ", type_str.to_writer(), " { if ", tidy_condition_brace(cond_str.to_string()),
                    " { return ", tidy_condition_brace(then_str.to_string()),
                    " } else { return ", tidy_condition_brace(else_str.to_string()), " } }()");
    };
    ctx.config().expression_memoization_config.enable = true;
    ctx.config().expression_memoization_config.target_kinds = {
        ebm::ExpressionKind::BINARY_OP,
        ebm::ExpressionKind::UNARY_OP,
        ebm::ExpressionKind::LITERAL_INT,
        ebm::ExpressionKind::LITERAL_INT64,
    };
    ctx.config().type_memoization_config.enable = true;
    ctx.config().type_memoization_config.target_kind_as_exclusive = true;
    ctx.config().type_memoization_config.target_kinds = {
        ebm::TypeKind::ARRAY,
        ebm::TypeKind::ENCODER_INPUT,
        ebm::TypeKind::DECODER_INPUT,
        ebm::TypeKind::ENCODER_RETURN,
    };
    ctx.config().int_to_array_custom = [&](Context_Statement_INT_TO_ARRAY& i2a_ctx) -> expected<Result> {
        MAYBE(target_type, i2a_ctx.get_field<"type.instance">(i2a_ctx.endian_convert.target));
        MAYBE(size, target_type.body.length());
        auto byte_size = size.value();
        switch (byte_size) {
            case 2:
            case 4:
            case 8: {
                auto endian = i2a_ctx.endian_convert.endian() == ebm::Endian::big ? "BigEndian" : "LittleEndian";
                MAYBE(target, i2a_ctx.visit(i2a_ctx.endian_convert.target));
                MAYBE(value_str, i2a_ctx.visit(i2a_ctx.endian_convert.source));
                ctx.config().imports.insert("encoding/binary");
                auto size_str = std::to_string(byte_size * 8);
                return CODELINE("binary.", endian, ".PutUint", size_str, "(", target.to_writer(), "[:], uint", size_str, "(", value_str.to_writer(), "))");
            }
        }
        return pass;
    };
    ctx.config().array_to_int_custom = [&](Context_Statement_ARRAY_TO_INT& i2a_ctx) -> expected<Result> {
        MAYBE(source_type, i2a_ctx.get_field<"type.instance">(i2a_ctx.endian_convert.source));
        MAYBE(size, source_type.body.length());
        auto byte_size = size.value();
        switch (byte_size) {
            case 2:
            case 4:
            case 8: {
                auto endian = i2a_ctx.endian_convert.endian() == ebm::Endian::big ? "BigEndian" : "LittleEndian";
                MAYBE(target, i2a_ctx.visit(i2a_ctx.endian_convert.target));
                MAYBE(value_str, i2a_ctx.visit(i2a_ctx.endian_convert.source));
                MAYBE(target_type, ctx.get_field<"type">(i2a_ctx.endian_convert.target));
                MAYBE(target_type_str, ctx.visit(target_type));
                ctx.config().imports.insert("encoding/binary");
                auto size_str = std::to_string(byte_size * 8);
                auto to = CODE("binary.", endian, ".Uint", size_str, "(", value_str.to_writer(), "[:])");
                auto cast_str = target_type_str.to_string();
                if (cast_str != "uint" + size_str) {
                    if (cast_str.starts_with("float") && cast_str.substr(5) == size_str) {
                        // for float, we need to convert from uint to float
                        std::string float_cast_str = "math.Float" + size_str + "frombits";
                        ctx.config().imports.insert("math");
                        to = CODE(float_cast_str, "(", to, ")");
                    }
                    else {
                        // for other int types, just cast
                        to = CODE(target_type_str.to_writer(), "(", to, ")");
                    }
                }
                return CODELINE(target.to_writer(), " = ", to);
            }
        }
        return pass;
    };
    return pass;
}
