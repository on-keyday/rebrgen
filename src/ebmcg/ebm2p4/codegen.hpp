/*license*/
// Code generated by ebmcodegen at https://github.com/on-keyday/rebrgen
#pragma once
// DO NOT EDIT THIS FILE MANUALLY. you should edit visitor implementation files instead.
#include <ebmcodegen/stub/entry.hpp>
#include <ebmcodegen/stub/util.hpp>
#include <ebmgen/common.hpp>
#include <ebmgen/convert/helper.hpp>
#include <ebmgen/mapping.hpp>
#include <code/code_writer.h>
#include <code/loc_writer.h>
#include <ebmcodegen/stub/writer_manager.hpp>
#include <concepts>
#include <strutil/append.h>
// This is a measure to prevent any impact on compilation even if a user mistakenly changes something like #include "lang/codegen.hpp" to #include "other_lang/codegen.hpp".
#ifndef EBM_CODEGEN_COMMON_INCLUDE_GUARD
#define EBM_CODEGEN_COMMON_INCLUDE_GUARD 1
#if __has_include("visitor/includes_before.hpp")
#include "visitor/includes_before.hpp"
#elif __has_include("visitor/dsl/includes_before_dsl.hpp")
#include "visitor/dsl/includes_before_dsl.hpp"
#elif __has_include("ebmcodegen/default_codegen_visitor/visitor/includes_before.hpp")
#include "ebmcodegen/default_codegen_visitor/visitor/includes_before.hpp"
#endif
#if __has_include("visitor/includes.hpp")
#include "visitor/includes.hpp"
#elif __has_include("visitor/dsl/includes_dsl.hpp")
#include "visitor/dsl/includes_dsl.hpp"
#elif __has_include("ebmcodegen/default_codegen_visitor/visitor/includes.hpp")
#include "ebmcodegen/default_codegen_visitor/visitor/includes.hpp"
#endif
#if __has_include("visitor/includes_after.hpp")
#include "visitor/includes_after.hpp"
#elif __has_include("visitor/dsl/includes_after_dsl.hpp")
#include "visitor/dsl/includes_after_dsl.hpp"
#elif __has_include("ebmcodegen/default_codegen_visitor/visitor/includes_after.hpp")
#include "ebmcodegen/default_codegen_visitor/visitor/includes_after.hpp"
#endif
namespace ebm2p4 {
    struct MergedVisitor;
    using namespace ebmgen;
    using namespace ebmcodegen::util;
    using CodeWriter = futils::code::LocWriter<std::string,std::vector,ebm::AnyRef>;
    
    struct Result {
        private: CodeWriter value;
        public: Result(std::string v) { value.write(v); }
        Result(const char* v) { value.write(v); }
        Result(CodeWriter&& v) : value(std::move(v)) {}
        Result() = default;
        constexpr std::string to_string() const {
            return value.to_string();
        }
        constexpr const CodeWriter& to_writer() const {
            return value;
        }
        constexpr CodeWriter& to_writer() {
            return value;
        }
        #if __has_include("visitor/Result_before.hpp")
        #include "visitor/Result_before.hpp"
        #elif __has_include("visitor/dsl/Result_before_dsl.hpp")
        #include "visitor/dsl/Result_before_dsl.hpp"
        #elif __has_include("ebmcodegen/default_codegen_visitor/visitor/Result_before.hpp")
        #include "ebmcodegen/default_codegen_visitor/visitor/Result_before.hpp"
        #endif
        #if __has_include("visitor/Result.hpp")
        #include "visitor/Result.hpp"
        #elif __has_include("visitor/dsl/Result_dsl.hpp")
        #include "visitor/dsl/Result_dsl.hpp"
        #elif __has_include("ebmcodegen/default_codegen_visitor/visitor/Result.hpp")
        #include "ebmcodegen/default_codegen_visitor/visitor/Result.hpp"
        #endif
        #if __has_include("visitor/Result_after.hpp")
        #include "visitor/Result_after.hpp"
        #elif __has_include("visitor/dsl/Result_after_dsl.hpp")
        #include "visitor/dsl/Result_after_dsl.hpp"
        #elif __has_include("ebmcodegen/default_codegen_visitor/visitor/Result_after.hpp")
        #include "ebmcodegen/default_codegen_visitor/visitor/Result_after.hpp"
        #endif
    };
    struct Flags : ebmcodegen::Flags {
        #define DEFINE_FLAG(type,name,default_,flag_name,flag_func,...) \
            static_assert(ebmcodegen::util::internal::is_c_ident(#name),"name must be a valid C identifier");type name = default_
        #define WEB_FILTERED(...) 
        #define WEB_UI_NAME(name) 
        #define WEB_LSP_NAME(name) 
        #define WEB_WORKER_NAME(name) 
        #define FILE_EXTENSIONS(...) 
        #define DEFINE_BOOL_FLAG(name,default_,flag_name,desc) DEFINE_FLAG(bool,name,default_,flag_name,VarBool,desc)
        #define DEFINE_STRING_FLAG(name,default_,flag_name,desc,arg_desc) DEFINE_FLAG(std::string_view,name,default_,flag_name,VarString<true>,desc,arg_desc)
        #define DEFINE_INT_FLAG(name,type,default_,flag_name,desc,arg_desc) DEFINE_FLAG(type,name,default_,flag_name,VarInt,desc,arg_desc)
        #define BEGIN_MAP_FLAG(name,MappedType,default_,flag_name,desc)static_assert(ebmcodegen::util::internal::is_c_ident(#name),"name must be a valid C identifier");MappedType name = default_;
        #define MAP_FLAG_ITEM(key,value) 
        #define END_MAP_FLAG() 
        #if __has_include("visitor/Flags_before.hpp")
        #include "visitor/Flags_before.hpp"
        #elif __has_include("visitor/dsl/Flags_before_dsl.hpp")
        #include "visitor/dsl/Flags_before_dsl.hpp"
        #elif __has_include("ebmcodegen/default_codegen_visitor/visitor/Flags_before.hpp")
        #include "ebmcodegen/default_codegen_visitor/visitor/Flags_before.hpp"
        #endif
        #if __has_include("visitor/Flags.hpp")
        #include "visitor/Flags.hpp"
        #elif __has_include("visitor/dsl/Flags_dsl.hpp")
        #include "visitor/dsl/Flags_dsl.hpp"
        #elif __has_include("ebmcodegen/default_codegen_visitor/visitor/Flags.hpp")
        #include "ebmcodegen/default_codegen_visitor/visitor/Flags.hpp"
        #endif
        #if __has_include("visitor/Flags_after.hpp")
        #include "visitor/Flags_after.hpp"
        #elif __has_include("visitor/dsl/Flags_after_dsl.hpp")
        #include "visitor/dsl/Flags_after_dsl.hpp"
        #elif __has_include("ebmcodegen/default_codegen_visitor/visitor/Flags_after.hpp")
        #include "ebmcodegen/default_codegen_visitor/visitor/Flags_after.hpp"
        #endif
        #undef DEFINE_FLAG
        #undef WEB_FILTERED
        #undef DEFINE_BOOL_FLAG
        #undef DEFINE_STRING_FLAG
        #undef DEFINE_INT_FLAG
        #undef BEGIN_MAP_FLAG
        #undef MAP_FLAG_ITEM
        #undef END_MAP_FLAG
        #undef WEB_UI_NAME
        #undef WEB_LSP_NAME
        #undef WEB_WORKER_NAME
        #undef FILE_EXTENSIONS
        #if __has_include("visitor/Flags_struct_before.hpp")
        #include "visitor/Flags_struct_before.hpp"
        #elif __has_include("visitor/dsl/Flags_struct_before_dsl.hpp")
        #include "visitor/dsl/Flags_struct_before_dsl.hpp"
        #elif __has_include("ebmcodegen/default_codegen_visitor/visitor/Flags_struct_before.hpp")
        #include "ebmcodegen/default_codegen_visitor/visitor/Flags_struct_before.hpp"
        #endif
        #if __has_include("visitor/Flags_struct.hpp")
        #include "visitor/Flags_struct.hpp"
        #elif __has_include("visitor/dsl/Flags_struct_dsl.hpp")
        #include "visitor/dsl/Flags_struct_dsl.hpp"
        #elif __has_include("ebmcodegen/default_codegen_visitor/visitor/Flags_struct.hpp")
        #include "ebmcodegen/default_codegen_visitor/visitor/Flags_struct.hpp"
        #endif
        #if __has_include("visitor/Flags_struct_after.hpp")
        #include "visitor/Flags_struct_after.hpp"
        #elif __has_include("visitor/dsl/Flags_struct_after_dsl.hpp")
        #include "visitor/dsl/Flags_struct_after_dsl.hpp"
        #elif __has_include("ebmcodegen/default_codegen_visitor/visitor/Flags_struct_after.hpp")
        #include "ebmcodegen/default_codegen_visitor/visitor/Flags_struct_after.hpp"
        #endif
        void bind(futils::cmdline::option::Context& ctx) {
            lang_name = "p4";
            ui_lang_name = lang_name;
            lsp_name = lang_name;
            webworker_name = "ebm2p4";
            file_extensions = {".p4"};
            ebmcodegen::Flags::bind(ctx); // bind basis
            #define DEFINE_FLAG(type,name,default_,flag_name,flag_func,...) \
                ctx.flag_func(&name,flag_name,__VA_ARGS__)
            #define WEB_FILTERED(...) web_filtered.insert_range(std::set{__VA_ARGS__})
            #define WEB_UI_NAME(name) ui_lang_name = name
            #define WEB_LSP_NAME(name) lsp_name = name
            #define WEB_WORKER_NAME(name) webworker_name = name
            #define FILE_EXTENSIONS(...) file_extensions = std::vector<std::string_view>{__VA_ARGS__}
            #define DEFINE_BOOL_FLAG(name,default_,flag_name,desc) DEFINE_FLAG(bool,name,default_,flag_name,VarBool,desc)
            #define DEFINE_STRING_FLAG(name,default_,flag_name,desc,arg_desc) DEFINE_FLAG(std::string_view,name,default_,flag_name,VarString<true>,desc,arg_desc)
            #define DEFINE_INT_FLAG(name,type,default_,flag_name,desc,arg_desc) DEFINE_FLAG(type,name,default_,flag_name,VarInt,desc,arg_desc)
            #define BEGIN_MAP_FLAG(name,MappedType,default_,flag_name,desc){ std::map<std::string,MappedType> map__; auto& target__ = name; auto flag_name__ = flag_name; auto desc__ = desc; std::string arg_desc__ = "{"; 
            #define MAP_FLAG_ITEM(key,value) map__[key] = value;if (!arg_desc__.empty() && arg_desc__.back() != '{') { arg_desc__ += ","; }arg_desc__ += key;
            #define END_MAP_FLAG() ctx.VarMap(&target__,flag_name__,desc__,arg_desc__ + "}",std::move(map__)); }
            #if __has_include("visitor/Flags_before.hpp")
            #include "visitor/Flags_before.hpp"
            #elif __has_include("visitor/dsl/Flags_before_dsl.hpp")
            #include "visitor/dsl/Flags_before_dsl.hpp"
            #elif __has_include("ebmcodegen/default_codegen_visitor/visitor/Flags_before.hpp")
            #include "ebmcodegen/default_codegen_visitor/visitor/Flags_before.hpp"
            #endif
            #if __has_include("visitor/Flags.hpp")
            #include "visitor/Flags.hpp"
            #elif __has_include("visitor/dsl/Flags_dsl.hpp")
            #include "visitor/dsl/Flags_dsl.hpp"
            #elif __has_include("ebmcodegen/default_codegen_visitor/visitor/Flags.hpp")
            #include "ebmcodegen/default_codegen_visitor/visitor/Flags.hpp"
            #endif
            #if __has_include("visitor/Flags_after.hpp")
            #include "visitor/Flags_after.hpp"
            #elif __has_include("visitor/dsl/Flags_after_dsl.hpp")
            #include "visitor/dsl/Flags_after_dsl.hpp"
            #elif __has_include("ebmcodegen/default_codegen_visitor/visitor/Flags_after.hpp")
            #include "ebmcodegen/default_codegen_visitor/visitor/Flags_after.hpp"
            #endif
            #undef DEFINE_FLAG
            #undef WEB_FILTERED
            #undef DEFINE_BOOL_FLAG
            #undef DEFINE_STRING_FLAG
            #undef DEFINE_INT_FLAG
            #undef BEGIN_MAP_FLAG
            #undef MAP_FLAG_ITEM
            #undef END_MAP_FLAG
            #undef WEB_UI_NAME
            #undef WEB_LSP_NAME
            #undef WEB_WORKER_NAME
            #undef FILE_EXTENSIONS
            #if __has_include("visitor/Flags_bind_before.hpp")
            #include "visitor/Flags_bind_before.hpp"
            #elif __has_include("visitor/dsl/Flags_bind_before_dsl.hpp")
            #include "visitor/dsl/Flags_bind_before_dsl.hpp"
            #elif __has_include("ebmcodegen/default_codegen_visitor/visitor/Flags_bind_before.hpp")
            #include "ebmcodegen/default_codegen_visitor/visitor/Flags_bind_before.hpp"
            #endif
            #if __has_include("visitor/Flags_bind.hpp")
            #include "visitor/Flags_bind.hpp"
            #elif __has_include("visitor/dsl/Flags_bind_dsl.hpp")
            #include "visitor/dsl/Flags_bind_dsl.hpp"
            #elif __has_include("ebmcodegen/default_codegen_visitor/visitor/Flags_bind.hpp")
            #include "ebmcodegen/default_codegen_visitor/visitor/Flags_bind.hpp"
            #endif
            #if __has_include("visitor/Flags_bind_after.hpp")
            #include "visitor/Flags_bind_after.hpp"
            #elif __has_include("visitor/dsl/Flags_bind_after_dsl.hpp")
            #include "visitor/dsl/Flags_bind_after_dsl.hpp"
            #elif __has_include("ebmcodegen/default_codegen_visitor/visitor/Flags_bind_after.hpp")
            #include "ebmcodegen/default_codegen_visitor/visitor/Flags_bind_after.hpp"
            #endif
        }
    };
    struct Output : ebmcodegen::Output {
    #if __has_include("visitor/Output_before.hpp")
    #include "visitor/Output_before.hpp"
    #elif __has_include("visitor/dsl/Output_before_dsl.hpp")
    #include "visitor/dsl/Output_before_dsl.hpp"
    #elif __has_include("ebmcodegen/default_codegen_visitor/visitor/Output_before.hpp")
    #include "ebmcodegen/default_codegen_visitor/visitor/Output_before.hpp"
    #endif
    #if __has_include("visitor/Output.hpp")
    #include "visitor/Output.hpp"
    #elif __has_include("visitor/dsl/Output_dsl.hpp")
    #include "visitor/dsl/Output_dsl.hpp"
    #elif __has_include("ebmcodegen/default_codegen_visitor/visitor/Output.hpp")
    #include "ebmcodegen/default_codegen_visitor/visitor/Output.hpp"
    #endif
    #if __has_include("visitor/Output_after.hpp")
    #include "visitor/Output_after.hpp"
    #elif __has_include("visitor/dsl/Output_after_dsl.hpp")
    #include "visitor/dsl/Output_after_dsl.hpp"
    #elif __has_include("ebmcodegen/default_codegen_visitor/visitor/Output_after.hpp")
    #include "ebmcodegen/default_codegen_visitor/visitor/Output_after.hpp"
    #endif
    };
    template <typename Tag>
    struct UserHook {}; // Hook tag
    template <typename Tag>
    struct UserInlinedHook {}; // Hook tag
    template <typename Tag>
    struct UserDSLHook {}; // Hook tag
    template <typename Tag>
    struct UserInlinedDSLHook {}; // Hook tag
    template <typename Tag>
    struct DefaultCodegenVisitorHook {}; // Hook tag
    template <typename Tag>
    struct DefaultCodegenVisitorInlinedHook {}; // Hook tag
    template<typename T>
    constexpr bool dependent_false = false;
    template<typename Context>
    concept HasVisitorInContext = requires(const Context& ctx) { ctx.visitor; };
    template<typename Context>
    concept HasLegacyVisitorInContext = requires(const Context& ctx) { *ctx.__legacy_compat_ptr; };
    template<typename Result,typename VisitorImpl,typename Context>
    concept HasVisitor = !std::is_base_of_v<ContextBase<std::decay_t<VisitorImpl>>,std::decay_t<VisitorImpl>> && requires(VisitorImpl v,Context c) {
         { v.visit(c) } -> std::convertible_to<expected<Result>>;
    };
    template<typename Context>
    decltype(auto) get_visitor_arg_from_context(Context&& ctx) {
        if constexpr (HasVisitorInContext<Context>) {
            return *ctx.visitor.__legacy_compat_ptr;
        }
        else if constexpr (HasLegacyVisitorInContext<Context>) {
            return *ctx.__legacy_compat_ptr;
        }
        else {
            static_assert(dependent_false<Context>, "No visitor found in context");
        }
    }
    template<typename Result,typename UserContext,typename TypeContext>
    auto& get_visitor_from_context(UserContext&& uctx,TypeContext&& ctx) {
        if constexpr (HasVisitor<Result,UserContext,TypeContext>) {
            return uctx;
        }
        else {
            return get_visitor_arg_from_context(uctx);
        }
    }
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_entry(Context&& ctx);
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_entry(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_pre_visitor(Context&& ctx,ebm::ExtendedBinaryModule& ebm);
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_pre_visitor(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_post_entry(Context&& ctx,expected<Result>& entry_result);
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_post_entry(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_BLOCK(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_BLOCK(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_ASSIGNMENT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ASSIGNMENT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_YIELD(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_YIELD(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_APPEND(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_APPEND(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_RETURN(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_RETURN(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_ERROR_RETURN(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ERROR_RETURN(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_ASSERT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ASSERT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_READ_DATA(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_READ_DATA(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_WRITE_DATA(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_WRITE_DATA(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_RESERVE_DATA(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_RESERVE_DATA(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_IF_STATEMENT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_IF_STATEMENT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_LOOP_STATEMENT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_LOOP_STATEMENT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_MATCH_STATEMENT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_MATCH_STATEMENT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_MATCH_BRANCH(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_MATCH_BRANCH(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_BREAK(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_BREAK(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_CONTINUE(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_CONTINUE(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_FUNCTION_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_FUNCTION_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_VARIABLE_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_VARIABLE_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_PARAMETER_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_PARAMETER_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_FIELD_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_FIELD_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_COMPOSITE_FIELD_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_COMPOSITE_FIELD_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_ENUM_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ENUM_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_ENUM_MEMBER_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ENUM_MEMBER_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_STRUCT_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_STRUCT_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_UNION_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_UNION_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_UNION_MEMBER_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_UNION_MEMBER_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_PROGRAM_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_PROGRAM_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_PROPERTY_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_PROPERTY_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_PROPERTY_MEMBER_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_PROPERTY_MEMBER_DECL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_METADATA(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_METADATA(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_IMPORT_MODULE(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_IMPORT_MODULE(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_EXPRESSION(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_EXPRESSION(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_ERROR_REPORT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ERROR_REPORT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_LOWERED_IO_STATEMENTS(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_LOWERED_IO_STATEMENTS(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_SUB_BYTE_RANGE(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_SUB_BYTE_RANGE(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_INIT_CHECK(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_INIT_CHECK(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement_ENDIAN_VARIABLE(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ENDIAN_VARIABLE(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Statement(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Result = Result, typename Context>
    expected<Result> dispatch_Statement_default(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {}) {
        switch(in.body.kind) {
            case ebm::StatementKind::BLOCK: {
                return dispatch_Statement_BLOCK<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::ASSIGNMENT: {
                return dispatch_Statement_ASSIGNMENT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::YIELD: {
                return dispatch_Statement_YIELD<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::APPEND: {
                return dispatch_Statement_APPEND<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::RETURN: {
                return dispatch_Statement_RETURN<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::ERROR_RETURN: {
                return dispatch_Statement_ERROR_RETURN<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::ASSERT: {
                return dispatch_Statement_ASSERT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::READ_DATA: {
                return dispatch_Statement_READ_DATA<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::WRITE_DATA: {
                return dispatch_Statement_WRITE_DATA<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::RESERVE_DATA: {
                return dispatch_Statement_RESERVE_DATA<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::IF_STATEMENT: {
                return dispatch_Statement_IF_STATEMENT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::LOOP_STATEMENT: {
                return dispatch_Statement_LOOP_STATEMENT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::MATCH_STATEMENT: {
                return dispatch_Statement_MATCH_STATEMENT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::MATCH_BRANCH: {
                return dispatch_Statement_MATCH_BRANCH<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::BREAK: {
                return dispatch_Statement_BREAK<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::CONTINUE: {
                return dispatch_Statement_CONTINUE<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::FUNCTION_DECL: {
                return dispatch_Statement_FUNCTION_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::VARIABLE_DECL: {
                return dispatch_Statement_VARIABLE_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::PARAMETER_DECL: {
                return dispatch_Statement_PARAMETER_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::FIELD_DECL: {
                return dispatch_Statement_FIELD_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::COMPOSITE_FIELD_DECL: {
                return dispatch_Statement_COMPOSITE_FIELD_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::ENUM_DECL: {
                return dispatch_Statement_ENUM_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::ENUM_MEMBER_DECL: {
                return dispatch_Statement_ENUM_MEMBER_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::STRUCT_DECL: {
                return dispatch_Statement_STRUCT_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::UNION_DECL: {
                return dispatch_Statement_UNION_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::UNION_MEMBER_DECL: {
                return dispatch_Statement_UNION_MEMBER_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::PROGRAM_DECL: {
                return dispatch_Statement_PROGRAM_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::PROPERTY_DECL: {
                return dispatch_Statement_PROPERTY_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::PROPERTY_MEMBER_DECL: {
                return dispatch_Statement_PROPERTY_MEMBER_DECL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::METADATA: {
                return dispatch_Statement_METADATA<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::IMPORT_MODULE: {
                return dispatch_Statement_IMPORT_MODULE<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::EXPRESSION: {
                return dispatch_Statement_EXPRESSION<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::ERROR_REPORT: {
                return dispatch_Statement_ERROR_REPORT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::LOWERED_IO_STATEMENTS: {
                return dispatch_Statement_LOWERED_IO_STATEMENTS<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::SUB_BYTE_RANGE: {
                return dispatch_Statement_SUB_BYTE_RANGE<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::INIT_CHECK: {
                return dispatch_Statement_INIT_CHECK<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::ENDIAN_VARIABLE: {
                return dispatch_Statement_ENDIAN_VARIABLE<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            default: {
                return unexpect_error("Unknown Statement kind: {}", to_string(in.body.kind));
            }
        }
    }
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Block(Context&& ctx,const ebm::Block& in);
    template<typename Result>
    struct ListDispatcher_Block {
        template<typename Context>
        expected<void> on_dispatch(Context&& ctx,const ebm::Block& in,expected<Result>&& result) {
            if (!result) {
                return unexpect_error(std::move(result.error()));
            }
            return {}; // Default no-op implementation
        }
        template<typename Context>
        expected<Result> finalize(Context&& ctx, const ebm::Block& in) {
            return {}; // Default no-op implementation
        }
    };
    
    template<>
    struct ListDispatcher_Block<Result> {
        CodeWriter result;
        template<typename Context>
        expected<void> on_dispatch(Context&& ctx,const ebm::Block& in,expected<Result>&& result) {
            if (!result) {
                return unexpect_error(std::move(result.error()));
            }
            this->result.write(std::move(result->to_writer()));
            return {};
        }
        template<typename Context>
        expected<Result> finalize(Context&& ctx, const ebm::Block& in) {
            return std::move(result);
        }
    };
    template<typename Result = Result, typename Context>
    expected<Result> dispatch_Block_default(Context&& ctx,const ebm::Block& in) {
        ListDispatcher_Block<Result> dispatcher;
        for(auto& elem:in.container) {
            auto result = visit_Statement<Result>(ctx,elem);
            MAYBE_VOID(dispatch,dispatcher.on_dispatch(std::forward<Context>(ctx),in,std::move(result)));
        }
        return dispatcher.finalize(std::forward<Context>(ctx),in);
    }
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Block(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_LITERAL_INT(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_LITERAL_INT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_LITERAL_INT64(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_LITERAL_INT64(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_LITERAL_BOOL(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_LITERAL_BOOL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_LITERAL_STRING(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_LITERAL_STRING(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_LITERAL_TYPE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_LITERAL_TYPE(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_LITERAL_CHAR(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_LITERAL_CHAR(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_IDENTIFIER(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_IDENTIFIER(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_BINARY_OP(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_BINARY_OP(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_UNARY_OP(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_UNARY_OP(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_CALL(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_CALL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_INDEX_ACCESS(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_INDEX_ACCESS(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_MEMBER_ACCESS(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_MEMBER_ACCESS(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_ENUM_MEMBER(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_ENUM_MEMBER(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_TYPE_CAST(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_TYPE_CAST(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_RANGE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_RANGE(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_DEFAULT_VALUE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_DEFAULT_VALUE(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_IS_LITTLE_ENDIAN(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_IS_LITTLE_ENDIAN(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_GET_STREAM_OFFSET(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_GET_STREAM_OFFSET(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_GET_REMAINING_BYTES(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_GET_REMAINING_BYTES(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_CAN_READ_STREAM(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_CAN_READ_STREAM(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_ARRAY_SIZE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_ARRAY_SIZE(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_ENUM_IS_DEFINED(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_ENUM_IS_DEFINED(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_IS_ERROR(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_IS_ERROR(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_MAX_VALUE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_MAX_VALUE(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_READ_DATA(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_READ_DATA(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_WRITE_DATA(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_WRITE_DATA(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_CONDITIONAL_STATEMENT(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_CONDITIONAL_STATEMENT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_CONDITIONAL(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_CONDITIONAL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_AVAILABLE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_AVAILABLE(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_SIZEOF(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_SIZEOF(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_SUB_RANGE_INIT(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_SUB_RANGE_INIT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_OR_COND(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_OR_COND(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_ADDRESS_OF(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_ADDRESS_OF(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_OPTIONAL_OF(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_OPTIONAL_OF(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_SETTER_STATUS(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_SETTER_STATUS(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_SELF(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_SELF(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression_AS_ARG(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_AS_ARG(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expression(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Result = Result, typename Context>
    expected<Result> dispatch_Expression_default(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {}) {
        switch(in.body.kind) {
            case ebm::ExpressionKind::LITERAL_INT: {
                return dispatch_Expression_LITERAL_INT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::LITERAL_INT64: {
                return dispatch_Expression_LITERAL_INT64<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::LITERAL_BOOL: {
                return dispatch_Expression_LITERAL_BOOL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::LITERAL_STRING: {
                return dispatch_Expression_LITERAL_STRING<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::LITERAL_TYPE: {
                return dispatch_Expression_LITERAL_TYPE<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::LITERAL_CHAR: {
                return dispatch_Expression_LITERAL_CHAR<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::IDENTIFIER: {
                return dispatch_Expression_IDENTIFIER<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::BINARY_OP: {
                return dispatch_Expression_BINARY_OP<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::UNARY_OP: {
                return dispatch_Expression_UNARY_OP<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::CALL: {
                return dispatch_Expression_CALL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::INDEX_ACCESS: {
                return dispatch_Expression_INDEX_ACCESS<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::MEMBER_ACCESS: {
                return dispatch_Expression_MEMBER_ACCESS<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::ENUM_MEMBER: {
                return dispatch_Expression_ENUM_MEMBER<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::TYPE_CAST: {
                return dispatch_Expression_TYPE_CAST<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::RANGE: {
                return dispatch_Expression_RANGE<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::DEFAULT_VALUE: {
                return dispatch_Expression_DEFAULT_VALUE<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::IS_LITTLE_ENDIAN: {
                return dispatch_Expression_IS_LITTLE_ENDIAN<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::GET_STREAM_OFFSET: {
                return dispatch_Expression_GET_STREAM_OFFSET<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::GET_REMAINING_BYTES: {
                return dispatch_Expression_GET_REMAINING_BYTES<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::CAN_READ_STREAM: {
                return dispatch_Expression_CAN_READ_STREAM<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::ARRAY_SIZE: {
                return dispatch_Expression_ARRAY_SIZE<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::ENUM_IS_DEFINED: {
                return dispatch_Expression_ENUM_IS_DEFINED<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::IS_ERROR: {
                return dispatch_Expression_IS_ERROR<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::MAX_VALUE: {
                return dispatch_Expression_MAX_VALUE<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::READ_DATA: {
                return dispatch_Expression_READ_DATA<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::WRITE_DATA: {
                return dispatch_Expression_WRITE_DATA<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::CONDITIONAL_STATEMENT: {
                return dispatch_Expression_CONDITIONAL_STATEMENT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::CONDITIONAL: {
                return dispatch_Expression_CONDITIONAL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::AVAILABLE: {
                return dispatch_Expression_AVAILABLE<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::SIZEOF: {
                return dispatch_Expression_SIZEOF<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::SUB_RANGE_INIT: {
                return dispatch_Expression_SUB_RANGE_INIT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::OR_COND: {
                return dispatch_Expression_OR_COND<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::ADDRESS_OF: {
                return dispatch_Expression_ADDRESS_OF<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::OPTIONAL_OF: {
                return dispatch_Expression_OPTIONAL_OF<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::SETTER_STATUS: {
                return dispatch_Expression_SETTER_STATUS<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::SELF: {
                return dispatch_Expression_SELF<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::AS_ARG: {
                return dispatch_Expression_AS_ARG<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            default: {
                return unexpect_error("Unknown Expression kind: {}", to_string(in.body.kind));
            }
        }
    }
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Expressions(Context&& ctx,const ebm::Expressions& in);
    template<typename Result>
    struct ListDispatcher_Expressions {
        template<typename Context>
        expected<void> on_dispatch(Context&& ctx,const ebm::Expressions& in,expected<Result>&& result) {
            if (!result) {
                return unexpect_error(std::move(result.error()));
            }
            return {}; // Default no-op implementation
        }
        template<typename Context>
        expected<Result> finalize(Context&& ctx, const ebm::Expressions& in) {
            return {}; // Default no-op implementation
        }
    };
    
    template<>
    struct ListDispatcher_Expressions<Result> {
        CodeWriter result;
        template<typename Context>
        expected<void> on_dispatch(Context&& ctx,const ebm::Expressions& in,expected<Result>&& result) {
            if (!result) {
                return unexpect_error(std::move(result.error()));
            }
            this->result.write(std::move(result->to_writer()));
            return {};
        }
        template<typename Context>
        expected<Result> finalize(Context&& ctx, const ebm::Expressions& in) {
            return std::move(result);
        }
    };
    template<typename Result = Result, typename Context>
    expected<Result> dispatch_Expressions_default(Context&& ctx,const ebm::Expressions& in) {
        ListDispatcher_Expressions<Result> dispatcher;
        for(auto& elem:in.container) {
            auto result = visit_Expression<Result>(ctx,elem);
            MAYBE_VOID(dispatch,dispatcher.on_dispatch(std::forward<Context>(ctx),in,std::move(result)));
        }
        return dispatcher.finalize(std::forward<Context>(ctx),in);
    }
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expressions(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_INT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_INT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_UINT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_UINT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_USIZE(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_USIZE(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_FLOAT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_FLOAT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_STRUCT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_STRUCT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_RECURSIVE_STRUCT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_RECURSIVE_STRUCT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_BOOL(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_BOOL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_VOID(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_VOID(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_META(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_META(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_ENUM(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_ENUM(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_ARRAY(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_ARRAY(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_VECTOR(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_VECTOR(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_VARIANT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_VARIANT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_RANGE(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_RANGE(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_ENCODER_RETURN(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_ENCODER_RETURN(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_DECODER_RETURN(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_DECODER_RETURN(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_ENCODER_INPUT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_ENCODER_INPUT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_DECODER_INPUT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_DECODER_INPUT(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_PROPERTY_SETTER_RETURN(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_PROPERTY_SETTER_RETURN(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_OPTIONAL(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_OPTIONAL(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_PTR(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_PTR(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type_FUNCTION(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_FUNCTION(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Type(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Result = Result, typename Context>
    expected<Result> dispatch_Type_default(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {}) {
        switch(in.body.kind) {
            case ebm::TypeKind::INT: {
                return dispatch_Type_INT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::UINT: {
                return dispatch_Type_UINT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::USIZE: {
                return dispatch_Type_USIZE<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::FLOAT: {
                return dispatch_Type_FLOAT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::STRUCT: {
                return dispatch_Type_STRUCT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::RECURSIVE_STRUCT: {
                return dispatch_Type_RECURSIVE_STRUCT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::BOOL: {
                return dispatch_Type_BOOL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::VOID: {
                return dispatch_Type_VOID<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::META: {
                return dispatch_Type_META<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::ENUM: {
                return dispatch_Type_ENUM<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::ARRAY: {
                return dispatch_Type_ARRAY<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::VECTOR: {
                return dispatch_Type_VECTOR<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::VARIANT: {
                return dispatch_Type_VARIANT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::RANGE: {
                return dispatch_Type_RANGE<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::ENCODER_RETURN: {
                return dispatch_Type_ENCODER_RETURN<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::DECODER_RETURN: {
                return dispatch_Type_DECODER_RETURN<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::ENCODER_INPUT: {
                return dispatch_Type_ENCODER_INPUT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::DECODER_INPUT: {
                return dispatch_Type_DECODER_INPUT<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::PROPERTY_SETTER_RETURN: {
                return dispatch_Type_PROPERTY_SETTER_RETURN<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::OPTIONAL: {
                return dispatch_Type_OPTIONAL<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::PTR: {
                return dispatch_Type_PTR<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::FUNCTION: {
                return dispatch_Type_FUNCTION<Result>(std::forward<Context>(ctx),in,alias_ref);
            }
            default: {
                return unexpect_error("Unknown Type kind: {}", to_string(in.body.kind));
            }
        }
    }
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result,typename Context>
    expected<Result> dispatch_Types(Context&& ctx,const ebm::Types& in);
    template<typename Result>
    struct ListDispatcher_Types {
        template<typename Context>
        expected<void> on_dispatch(Context&& ctx,const ebm::Types& in,expected<Result>&& result) {
            if (!result) {
                return unexpect_error(std::move(result.error()));
            }
            return {}; // Default no-op implementation
        }
        template<typename Context>
        expected<Result> finalize(Context&& ctx, const ebm::Types& in) {
            return {}; // Default no-op implementation
        }
    };
    
    template<>
    struct ListDispatcher_Types<Result> {
        CodeWriter result;
        template<typename Context>
        expected<void> on_dispatch(Context&& ctx,const ebm::Types& in,expected<Result>&& result) {
            if (!result) {
                return unexpect_error(std::move(result.error()));
            }
            this->result.write(std::move(result->to_writer()));
            return {};
        }
        template<typename Context>
        expected<Result> finalize(Context&& ctx, const ebm::Types& in) {
            return std::move(result);
        }
    };
    template<typename Result = Result, typename Context>
    expected<Result> dispatch_Types_default(Context&& ctx,const ebm::Types& in) {
        ListDispatcher_Types<Result> dispatcher;
        for(auto& elem:in.container) {
            auto result = visit_Type<Result>(ctx,elem);
            MAYBE_VOID(dispatch,dispatcher.on_dispatch(std::forward<Context>(ctx),in,std::move(result)));
        }
        return dispatcher.finalize(std::forward<Context>(ctx),in);
    }
    template<typename Result = Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Types(UserContext&& ctx,TypeContext&& type_ctx);
    template<typename Result = Result, typename UserContext, typename TypeContext>
    expected<Result> traverse_children(UserContext&& uctx, TypeContext&& type_ctx);
    // for backward compatibility
    
    // generic visitor for Statement
    template<typename Result = Result, typename Context>
    expected<Result> visit_Statement(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {}) {
        return dispatch_Statement<Result>(std::forward<Context>(ctx),in,alias_ref);
    }
    // short-hand visitor for Statement
    template<typename Result = Result, typename Context>
    expected<Result> visit_Statement(Context&& ctx,const ebm::StatementRef& ref) {
        MAYBE(elem, get_visitor_arg_from_context(ctx).module_.get_statement(ref));
        return dispatch_Statement<Result>(std::forward<Context>(ctx),elem,ref);
    }
    // for DSL convenience
    template<typename Result = Result, typename Context>
    expected<Result> visit_Object(Context&& ctx,const ebm::Statement& in, ebm::StatementRef alias_ref = {})  {
        return visit_Statement<Result>(std::forward<Context>(ctx),in,alias_ref);
    }
    // for DSL convenience
    template<typename Result = Result, typename Context>
    expected<Result> visit_Object(Context&& ctx, ebm::StatementRef ref)  {
        return visit_Statement<Result>(std::forward<Context>(ctx),ref);
    }
    // list visitor for Block
    template<typename Result = Result, typename Context>
    expected<Result> visit_Block(Context&& ctx,const ebm::Block& in) {
        return dispatch_Block<Result>(std::forward<Context>(ctx),in);
    }
    // for DSL convenience
    template<typename Result = Result, typename Context>
    expected<Result> visit_Object(Context&& ctx,const ebm::Block& in)  {
        return visit_Block<Result>(std::forward<Context>(ctx),in);
    }
    // generic visitor for Expression
    template<typename Result = Result, typename Context>
    expected<Result> visit_Expression(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {}) {
        return dispatch_Expression<Result>(std::forward<Context>(ctx),in,alias_ref);
    }
    // short-hand visitor for Expression
    template<typename Result = Result, typename Context>
    expected<Result> visit_Expression(Context&& ctx,const ebm::ExpressionRef& ref) {
        MAYBE(elem, get_visitor_arg_from_context(ctx).module_.get_expression(ref));
        return dispatch_Expression<Result>(std::forward<Context>(ctx),elem,ref);
    }
    // for DSL convenience
    template<typename Result = Result, typename Context>
    expected<Result> visit_Object(Context&& ctx,const ebm::Expression& in, ebm::ExpressionRef alias_ref = {})  {
        return visit_Expression<Result>(std::forward<Context>(ctx),in,alias_ref);
    }
    // for DSL convenience
    template<typename Result = Result, typename Context>
    expected<Result> visit_Object(Context&& ctx, ebm::ExpressionRef ref)  {
        return visit_Expression<Result>(std::forward<Context>(ctx),ref);
    }
    // list visitor for Expressions
    template<typename Result = Result, typename Context>
    expected<Result> visit_Expressions(Context&& ctx,const ebm::Expressions& in) {
        return dispatch_Expressions<Result>(std::forward<Context>(ctx),in);
    }
    // for DSL convenience
    template<typename Result = Result, typename Context>
    expected<Result> visit_Object(Context&& ctx,const ebm::Expressions& in)  {
        return visit_Expressions<Result>(std::forward<Context>(ctx),in);
    }
    // generic visitor for Type
    template<typename Result = Result, typename Context>
    expected<Result> visit_Type(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {}) {
        return dispatch_Type<Result>(std::forward<Context>(ctx),in,alias_ref);
    }
    // short-hand visitor for Type
    template<typename Result = Result, typename Context>
    expected<Result> visit_Type(Context&& ctx,const ebm::TypeRef& ref) {
        MAYBE(elem, get_visitor_arg_from_context(ctx).module_.get_type(ref));
        return dispatch_Type<Result>(std::forward<Context>(ctx),elem,ref);
    }
    // for DSL convenience
    template<typename Result = Result, typename Context>
    expected<Result> visit_Object(Context&& ctx,const ebm::Type& in, ebm::TypeRef alias_ref = {})  {
        return visit_Type<Result>(std::forward<Context>(ctx),in,alias_ref);
    }
    // for DSL convenience
    template<typename Result = Result, typename Context>
    expected<Result> visit_Object(Context&& ctx, ebm::TypeRef ref)  {
        return visit_Type<Result>(std::forward<Context>(ctx),ref);
    }
    // list visitor for Types
    template<typename Result = Result, typename Context>
    expected<Result> visit_Types(Context&& ctx,const ebm::Types& in) {
        return dispatch_Types<Result>(std::forward<Context>(ctx),in);
    }
    // for DSL convenience
    template<typename Result = Result, typename Context>
    expected<Result> visit_Object(Context&& ctx,const ebm::Types& in)  {
        return visit_Types<Result>(std::forward<Context>(ctx),in);
    }
    template<class R = void, typename Context,typename Callback>
    R get_visitor_impl(Context&& ctx,Callback&& cb);
    struct BaseVisitor {
        BaseVisitor(MergedVisitor* __legacy_compat_ptr,ebmgen::EBMProxy module_,Flags& flags,Output& output,futils::binary::writer& wm) :__legacy_compat_ptr(__legacy_compat_ptr),module_(module_, ebmgen::lazy_init),flags(flags),output(output),wm(wm){}
        static constexpr const char* program_name = "ebm2p4";
        MergedVisitor* const __legacy_compat_ptr;
        ebmgen::MappingTable module_;
        Flags& flags;
        Output& output;
        ebmcodegen::WriterManager<CodeWriter> wm;
        #if __has_include("visitor/Visitor_before.hpp")
        #include "visitor/Visitor_before.hpp"
        #elif __has_include("visitor/dsl/Visitor_before_dsl.hpp")
        #include "visitor/dsl/Visitor_before_dsl.hpp"
        #elif __has_include("ebmcodegen/default_codegen_visitor/visitor/Visitor_before.hpp")
        #include "ebmcodegen/default_codegen_visitor/visitor/Visitor_before.hpp"
        #endif
        #if __has_include("visitor/Visitor.hpp")
        #include "visitor/Visitor.hpp"
        #elif __has_include("visitor/dsl/Visitor_dsl.hpp")
        #include "visitor/dsl/Visitor_dsl.hpp"
        #elif __has_include("ebmcodegen/default_codegen_visitor/visitor/Visitor.hpp")
        #include "ebmcodegen/default_codegen_visitor/visitor/Visitor.hpp"
        #endif
        #if __has_include("visitor/Visitor_after.hpp")
        #include "visitor/Visitor_after.hpp"
        #elif __has_include("visitor/dsl/Visitor_after_dsl.hpp")
        #include "visitor/dsl/Visitor_after_dsl.hpp"
        #elif __has_include("ebmcodegen/default_codegen_visitor/visitor/Visitor_after.hpp")
        #include "ebmcodegen/default_codegen_visitor/visitor/Visitor_after.hpp"
        #endif
    };
    template<typename V>
    concept BaseVisitorLike = std::derived_from<V,BaseVisitor>;
    struct InitialContext : ebmcodegen::util::ContextBase<InitialContext> {
        BaseVisitor& visitor;
    };
    template<typename Tag>
    struct Visitor; // Customization point struct
    struct Context_entry : ebmcodegen::util::ContextBase<Context_entry> {
        constexpr static std::string_view context_name = "entry";
        BaseVisitor& visitor;
    };
    struct VisitorTag_entry {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_ENTRY(instance_name) \
    auto& visitor = instance_name.visitor;
    template <typename Result>
    struct Context_entry_before : ebmcodegen::util::ContextBase<Context_entry_before<Result>> {
        constexpr static std::string_view context_name = "entry_before";
        BaseVisitor& visitor;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_entry_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_ENTRY_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_entry_after : ebmcodegen::util::ContextBase<Context_entry_after<Result>> {
        constexpr static std::string_view context_name = "entry_after";
        BaseVisitor& visitor;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_entry_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_ENTRY_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_pre_visitor : ebmcodegen::util::ContextBase<Context_pre_visitor> {
        constexpr static std::string_view context_name = "pre_visitor";
        BaseVisitor& visitor;
        ebm::ExtendedBinaryModule& ebm;
    };
    struct VisitorTag_pre_visitor {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_PRE_VISITOR(instance_name) \
    auto& visitor = instance_name.visitor;auto& ebm = instance_name.ebm;
    template <typename Result>
    struct Context_pre_visitor_before : ebmcodegen::util::ContextBase<Context_pre_visitor_before<Result>> {
        constexpr static std::string_view context_name = "pre_visitor_before";
        BaseVisitor& visitor;
        ebm::ExtendedBinaryModule& ebm;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_pre_visitor_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_PRE_VISITOR_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& ebm = instance_name.ebm;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_pre_visitor_after : ebmcodegen::util::ContextBase<Context_pre_visitor_after<Result>> {
        constexpr static std::string_view context_name = "pre_visitor_after";
        BaseVisitor& visitor;
        ebm::ExtendedBinaryModule& ebm;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_pre_visitor_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_PRE_VISITOR_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& ebm = instance_name.ebm;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    template <typename Result>
    struct Context_post_entry : ebmcodegen::util::ContextBase<Context_post_entry<Result>> {
        constexpr static std::string_view context_name = "post_entry";
        BaseVisitor& visitor;
        expected<Result>& entry_result;
    };
    struct VisitorTag_post_entry {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_POST_ENTRY(instance_name) \
    auto& visitor = instance_name.visitor;auto& entry_result = instance_name.entry_result;
    template <typename Result>
    struct Context_post_entry_before : ebmcodegen::util::ContextBase<Context_post_entry_before<Result>> {
        constexpr static std::string_view context_name = "post_entry_before";
        BaseVisitor& visitor;
        expected<Result>& entry_result;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_post_entry_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_POST_ENTRY_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& entry_result = instance_name.entry_result;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_post_entry_after : ebmcodegen::util::ContextBase<Context_post_entry_after<Result>> {
        constexpr static std::string_view context_name = "post_entry_after";
        BaseVisitor& visitor;
        expected<Result>& entry_result;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_post_entry_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_POST_ENTRY_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& entry_result = instance_name.entry_result;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_BLOCK : ebmcodegen::util::ContextBase<Context_Statement_BLOCK> {
        constexpr static std::string_view context_name = "Statement_BLOCK";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Block& block;
    };
    struct VisitorTag_Statement_BLOCK {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_BLOCK(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& block = instance_name.block;
    template <typename Result>
    struct Context_Statement_BLOCK_before : ebmcodegen::util::ContextBase<Context_Statement_BLOCK_before<Result>> {
        constexpr static std::string_view context_name = "Statement_BLOCK_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Block& block;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_BLOCK_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_BLOCK_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& block = instance_name.block;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_BLOCK_after : ebmcodegen::util::ContextBase<Context_Statement_BLOCK_after<Result>> {
        constexpr static std::string_view context_name = "Statement_BLOCK_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Block& block;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_BLOCK_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_BLOCK_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& block = instance_name.block;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_ASSIGNMENT : ebmcodegen::util::ContextBase<Context_Statement_ASSIGNMENT> {
        constexpr static std::string_view context_name = "Statement_ASSIGNMENT";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::WeakStatementRef& previous_assignment;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
    };
    struct VisitorTag_Statement_ASSIGNMENT {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_ASSIGNMENT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& previous_assignment = instance_name.previous_assignment;auto& target = instance_name.target;auto& value = instance_name.value;
    template <typename Result>
    struct Context_Statement_ASSIGNMENT_before : ebmcodegen::util::ContextBase<Context_Statement_ASSIGNMENT_before<Result>> {
        constexpr static std::string_view context_name = "Statement_ASSIGNMENT_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::WeakStatementRef& previous_assignment;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_ASSIGNMENT_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_ASSIGNMENT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& previous_assignment = instance_name.previous_assignment;auto& target = instance_name.target;auto& value = instance_name.value;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_ASSIGNMENT_after : ebmcodegen::util::ContextBase<Context_Statement_ASSIGNMENT_after<Result>> {
        constexpr static std::string_view context_name = "Statement_ASSIGNMENT_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::WeakStatementRef& previous_assignment;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_ASSIGNMENT_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_ASSIGNMENT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& previous_assignment = instance_name.previous_assignment;auto& target = instance_name.target;auto& value = instance_name.value;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_YIELD : ebmcodegen::util::ContextBase<Context_Statement_YIELD> {
        constexpr static std::string_view context_name = "Statement_YIELD";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::WeakStatementRef& previous_assignment;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
    };
    struct VisitorTag_Statement_YIELD {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_YIELD(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& previous_assignment = instance_name.previous_assignment;auto& target = instance_name.target;auto& value = instance_name.value;
    template <typename Result>
    struct Context_Statement_YIELD_before : ebmcodegen::util::ContextBase<Context_Statement_YIELD_before<Result>> {
        constexpr static std::string_view context_name = "Statement_YIELD_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::WeakStatementRef& previous_assignment;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_YIELD_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_YIELD_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& previous_assignment = instance_name.previous_assignment;auto& target = instance_name.target;auto& value = instance_name.value;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_YIELD_after : ebmcodegen::util::ContextBase<Context_Statement_YIELD_after<Result>> {
        constexpr static std::string_view context_name = "Statement_YIELD_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::WeakStatementRef& previous_assignment;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_YIELD_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_YIELD_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& previous_assignment = instance_name.previous_assignment;auto& target = instance_name.target;auto& value = instance_name.value;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_APPEND : ebmcodegen::util::ContextBase<Context_Statement_APPEND> {
        constexpr static std::string_view context_name = "Statement_APPEND";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
    };
    struct VisitorTag_Statement_APPEND {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_APPEND(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& target = instance_name.target;auto& value = instance_name.value;
    template <typename Result>
    struct Context_Statement_APPEND_before : ebmcodegen::util::ContextBase<Context_Statement_APPEND_before<Result>> {
        constexpr static std::string_view context_name = "Statement_APPEND_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_APPEND_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_APPEND_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& target = instance_name.target;auto& value = instance_name.value;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_APPEND_after : ebmcodegen::util::ContextBase<Context_Statement_APPEND_after<Result>> {
        constexpr static std::string_view context_name = "Statement_APPEND_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_APPEND_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_APPEND_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& target = instance_name.target;auto& value = instance_name.value;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_RETURN : ebmcodegen::util::ContextBase<Context_Statement_RETURN> {
        constexpr static std::string_view context_name = "Statement_RETURN";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::WeakStatementRef& related_function;
        const ebm::ExpressionRef& value;
    };
    struct VisitorTag_Statement_RETURN {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_RETURN(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& related_function = instance_name.related_function;auto& value = instance_name.value;
    template <typename Result>
    struct Context_Statement_RETURN_before : ebmcodegen::util::ContextBase<Context_Statement_RETURN_before<Result>> {
        constexpr static std::string_view context_name = "Statement_RETURN_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::WeakStatementRef& related_function;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_RETURN_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_RETURN_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& related_function = instance_name.related_function;auto& value = instance_name.value;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_RETURN_after : ebmcodegen::util::ContextBase<Context_Statement_RETURN_after<Result>> {
        constexpr static std::string_view context_name = "Statement_RETURN_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::WeakStatementRef& related_function;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_RETURN_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_RETURN_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& related_function = instance_name.related_function;auto& value = instance_name.value;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_ERROR_RETURN : ebmcodegen::util::ContextBase<Context_Statement_ERROR_RETURN> {
        constexpr static std::string_view context_name = "Statement_ERROR_RETURN";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::WeakStatementRef& related_field;
        const ebm::WeakStatementRef& related_function;
        const ebm::ExpressionRef& value;
    };
    struct VisitorTag_Statement_ERROR_RETURN {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_ERROR_RETURN(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& related_field = instance_name.related_field;auto& related_function = instance_name.related_function;auto& value = instance_name.value;
    template <typename Result>
    struct Context_Statement_ERROR_RETURN_before : ebmcodegen::util::ContextBase<Context_Statement_ERROR_RETURN_before<Result>> {
        constexpr static std::string_view context_name = "Statement_ERROR_RETURN_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::WeakStatementRef& related_field;
        const ebm::WeakStatementRef& related_function;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_ERROR_RETURN_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_ERROR_RETURN_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& related_field = instance_name.related_field;auto& related_function = instance_name.related_function;auto& value = instance_name.value;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_ERROR_RETURN_after : ebmcodegen::util::ContextBase<Context_Statement_ERROR_RETURN_after<Result>> {
        constexpr static std::string_view context_name = "Statement_ERROR_RETURN_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::WeakStatementRef& related_field;
        const ebm::WeakStatementRef& related_function;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_ERROR_RETURN_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_ERROR_RETURN_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& related_field = instance_name.related_field;auto& related_function = instance_name.related_function;auto& value = instance_name.value;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_ASSERT : ebmcodegen::util::ContextBase<Context_Statement_ASSERT> {
        constexpr static std::string_view context_name = "Statement_ASSERT";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::AssertDesc& assert_desc;
    };
    struct VisitorTag_Statement_ASSERT {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_ASSERT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& assert_desc = instance_name.assert_desc;
    template <typename Result>
    struct Context_Statement_ASSERT_before : ebmcodegen::util::ContextBase<Context_Statement_ASSERT_before<Result>> {
        constexpr static std::string_view context_name = "Statement_ASSERT_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::AssertDesc& assert_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_ASSERT_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_ASSERT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& assert_desc = instance_name.assert_desc;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_ASSERT_after : ebmcodegen::util::ContextBase<Context_Statement_ASSERT_after<Result>> {
        constexpr static std::string_view context_name = "Statement_ASSERT_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::AssertDesc& assert_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_ASSERT_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_ASSERT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& assert_desc = instance_name.assert_desc;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_READ_DATA : ebmcodegen::util::ContextBase<Context_Statement_READ_DATA> {
        constexpr static std::string_view context_name = "Statement_READ_DATA";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IOData& read_data;
    };
    struct VisitorTag_Statement_READ_DATA {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_READ_DATA(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& read_data = instance_name.read_data;
    template <typename Result>
    struct Context_Statement_READ_DATA_before : ebmcodegen::util::ContextBase<Context_Statement_READ_DATA_before<Result>> {
        constexpr static std::string_view context_name = "Statement_READ_DATA_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IOData& read_data;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_READ_DATA_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_READ_DATA_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& read_data = instance_name.read_data;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_READ_DATA_after : ebmcodegen::util::ContextBase<Context_Statement_READ_DATA_after<Result>> {
        constexpr static std::string_view context_name = "Statement_READ_DATA_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IOData& read_data;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_READ_DATA_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_READ_DATA_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& read_data = instance_name.read_data;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_WRITE_DATA : ebmcodegen::util::ContextBase<Context_Statement_WRITE_DATA> {
        constexpr static std::string_view context_name = "Statement_WRITE_DATA";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IOData& write_data;
    };
    struct VisitorTag_Statement_WRITE_DATA {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_WRITE_DATA(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& write_data = instance_name.write_data;
    template <typename Result>
    struct Context_Statement_WRITE_DATA_before : ebmcodegen::util::ContextBase<Context_Statement_WRITE_DATA_before<Result>> {
        constexpr static std::string_view context_name = "Statement_WRITE_DATA_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IOData& write_data;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_WRITE_DATA_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_WRITE_DATA_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& write_data = instance_name.write_data;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_WRITE_DATA_after : ebmcodegen::util::ContextBase<Context_Statement_WRITE_DATA_after<Result>> {
        constexpr static std::string_view context_name = "Statement_WRITE_DATA_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IOData& write_data;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_WRITE_DATA_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_WRITE_DATA_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& write_data = instance_name.write_data;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_RESERVE_DATA : ebmcodegen::util::ContextBase<Context_Statement_RESERVE_DATA> {
        constexpr static std::string_view context_name = "Statement_RESERVE_DATA";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ReserveData& reserve_data;
    };
    struct VisitorTag_Statement_RESERVE_DATA {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_RESERVE_DATA(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& reserve_data = instance_name.reserve_data;
    template <typename Result>
    struct Context_Statement_RESERVE_DATA_before : ebmcodegen::util::ContextBase<Context_Statement_RESERVE_DATA_before<Result>> {
        constexpr static std::string_view context_name = "Statement_RESERVE_DATA_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ReserveData& reserve_data;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_RESERVE_DATA_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_RESERVE_DATA_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& reserve_data = instance_name.reserve_data;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_RESERVE_DATA_after : ebmcodegen::util::ContextBase<Context_Statement_RESERVE_DATA_after<Result>> {
        constexpr static std::string_view context_name = "Statement_RESERVE_DATA_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ReserveData& reserve_data;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_RESERVE_DATA_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_RESERVE_DATA_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& reserve_data = instance_name.reserve_data;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_IF_STATEMENT : ebmcodegen::util::ContextBase<Context_Statement_IF_STATEMENT> {
        constexpr static std::string_view context_name = "Statement_IF_STATEMENT";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IfStatement& if_statement;
    };
    struct VisitorTag_Statement_IF_STATEMENT {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_IF_STATEMENT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& if_statement = instance_name.if_statement;
    template <typename Result>
    struct Context_Statement_IF_STATEMENT_before : ebmcodegen::util::ContextBase<Context_Statement_IF_STATEMENT_before<Result>> {
        constexpr static std::string_view context_name = "Statement_IF_STATEMENT_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IfStatement& if_statement;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_IF_STATEMENT_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_IF_STATEMENT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& if_statement = instance_name.if_statement;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_IF_STATEMENT_after : ebmcodegen::util::ContextBase<Context_Statement_IF_STATEMENT_after<Result>> {
        constexpr static std::string_view context_name = "Statement_IF_STATEMENT_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IfStatement& if_statement;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_IF_STATEMENT_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_IF_STATEMENT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& if_statement = instance_name.if_statement;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_LOOP_STATEMENT : ebmcodegen::util::ContextBase<Context_Statement_LOOP_STATEMENT> {
        constexpr static std::string_view context_name = "Statement_LOOP_STATEMENT";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopStatement& loop;
    };
    struct VisitorTag_Statement_LOOP_STATEMENT {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_LOOP_STATEMENT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& loop = instance_name.loop;
    template <typename Result>
    struct Context_Statement_LOOP_STATEMENT_before : ebmcodegen::util::ContextBase<Context_Statement_LOOP_STATEMENT_before<Result>> {
        constexpr static std::string_view context_name = "Statement_LOOP_STATEMENT_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopStatement& loop;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_LOOP_STATEMENT_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_LOOP_STATEMENT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& loop = instance_name.loop;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_LOOP_STATEMENT_after : ebmcodegen::util::ContextBase<Context_Statement_LOOP_STATEMENT_after<Result>> {
        constexpr static std::string_view context_name = "Statement_LOOP_STATEMENT_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopStatement& loop;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_LOOP_STATEMENT_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_LOOP_STATEMENT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& loop = instance_name.loop;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_MATCH_STATEMENT : ebmcodegen::util::ContextBase<Context_Statement_MATCH_STATEMENT> {
        constexpr static std::string_view context_name = "Statement_MATCH_STATEMENT";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::MatchStatement& match_statement;
    };
    struct VisitorTag_Statement_MATCH_STATEMENT {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_MATCH_STATEMENT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& match_statement = instance_name.match_statement;
    template <typename Result>
    struct Context_Statement_MATCH_STATEMENT_before : ebmcodegen::util::ContextBase<Context_Statement_MATCH_STATEMENT_before<Result>> {
        constexpr static std::string_view context_name = "Statement_MATCH_STATEMENT_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::MatchStatement& match_statement;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_MATCH_STATEMENT_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_MATCH_STATEMENT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& match_statement = instance_name.match_statement;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_MATCH_STATEMENT_after : ebmcodegen::util::ContextBase<Context_Statement_MATCH_STATEMENT_after<Result>> {
        constexpr static std::string_view context_name = "Statement_MATCH_STATEMENT_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::MatchStatement& match_statement;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_MATCH_STATEMENT_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_MATCH_STATEMENT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& match_statement = instance_name.match_statement;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_MATCH_BRANCH : ebmcodegen::util::ContextBase<Context_Statement_MATCH_BRANCH> {
        constexpr static std::string_view context_name = "Statement_MATCH_BRANCH";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::MatchBranch& match_branch;
    };
    struct VisitorTag_Statement_MATCH_BRANCH {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_MATCH_BRANCH(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& match_branch = instance_name.match_branch;
    template <typename Result>
    struct Context_Statement_MATCH_BRANCH_before : ebmcodegen::util::ContextBase<Context_Statement_MATCH_BRANCH_before<Result>> {
        constexpr static std::string_view context_name = "Statement_MATCH_BRANCH_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::MatchBranch& match_branch;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_MATCH_BRANCH_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_MATCH_BRANCH_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& match_branch = instance_name.match_branch;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_MATCH_BRANCH_after : ebmcodegen::util::ContextBase<Context_Statement_MATCH_BRANCH_after<Result>> {
        constexpr static std::string_view context_name = "Statement_MATCH_BRANCH_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::MatchBranch& match_branch;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_MATCH_BRANCH_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_MATCH_BRANCH_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& match_branch = instance_name.match_branch;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_BREAK : ebmcodegen::util::ContextBase<Context_Statement_BREAK> {
        constexpr static std::string_view context_name = "Statement_BREAK";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopFlowControl& break_;
    };
    struct VisitorTag_Statement_BREAK {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_BREAK(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& break_ = instance_name.break_;
    template <typename Result>
    struct Context_Statement_BREAK_before : ebmcodegen::util::ContextBase<Context_Statement_BREAK_before<Result>> {
        constexpr static std::string_view context_name = "Statement_BREAK_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopFlowControl& break_;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_BREAK_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_BREAK_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& break_ = instance_name.break_;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_BREAK_after : ebmcodegen::util::ContextBase<Context_Statement_BREAK_after<Result>> {
        constexpr static std::string_view context_name = "Statement_BREAK_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopFlowControl& break_;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_BREAK_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_BREAK_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& break_ = instance_name.break_;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_CONTINUE : ebmcodegen::util::ContextBase<Context_Statement_CONTINUE> {
        constexpr static std::string_view context_name = "Statement_CONTINUE";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopFlowControl& continue_;
    };
    struct VisitorTag_Statement_CONTINUE {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_CONTINUE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& continue_ = instance_name.continue_;
    template <typename Result>
    struct Context_Statement_CONTINUE_before : ebmcodegen::util::ContextBase<Context_Statement_CONTINUE_before<Result>> {
        constexpr static std::string_view context_name = "Statement_CONTINUE_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopFlowControl& continue_;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_CONTINUE_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_CONTINUE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& continue_ = instance_name.continue_;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_CONTINUE_after : ebmcodegen::util::ContextBase<Context_Statement_CONTINUE_after<Result>> {
        constexpr static std::string_view context_name = "Statement_CONTINUE_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopFlowControl& continue_;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_CONTINUE_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_CONTINUE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& continue_ = instance_name.continue_;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_FUNCTION_DECL : ebmcodegen::util::ContextBase<Context_Statement_FUNCTION_DECL> {
        constexpr static std::string_view context_name = "Statement_FUNCTION_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::FunctionDecl& func_decl;
    };
    struct VisitorTag_Statement_FUNCTION_DECL {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_FUNCTION_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& func_decl = instance_name.func_decl;
    template <typename Result>
    struct Context_Statement_FUNCTION_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_FUNCTION_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_FUNCTION_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::FunctionDecl& func_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_FUNCTION_DECL_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_FUNCTION_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& func_decl = instance_name.func_decl;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_FUNCTION_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_FUNCTION_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_FUNCTION_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::FunctionDecl& func_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_FUNCTION_DECL_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_FUNCTION_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& func_decl = instance_name.func_decl;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_VARIABLE_DECL : ebmcodegen::util::ContextBase<Context_Statement_VARIABLE_DECL> {
        constexpr static std::string_view context_name = "Statement_VARIABLE_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::VariableDecl& var_decl;
    };
    struct VisitorTag_Statement_VARIABLE_DECL {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_VARIABLE_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& var_decl = instance_name.var_decl;
    template <typename Result>
    struct Context_Statement_VARIABLE_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_VARIABLE_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_VARIABLE_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::VariableDecl& var_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_VARIABLE_DECL_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_VARIABLE_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& var_decl = instance_name.var_decl;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_VARIABLE_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_VARIABLE_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_VARIABLE_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::VariableDecl& var_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_VARIABLE_DECL_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_VARIABLE_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& var_decl = instance_name.var_decl;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_PARAMETER_DECL : ebmcodegen::util::ContextBase<Context_Statement_PARAMETER_DECL> {
        constexpr static std::string_view context_name = "Statement_PARAMETER_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ParameterDecl& param_decl;
    };
    struct VisitorTag_Statement_PARAMETER_DECL {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_PARAMETER_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& param_decl = instance_name.param_decl;
    template <typename Result>
    struct Context_Statement_PARAMETER_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_PARAMETER_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_PARAMETER_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ParameterDecl& param_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_PARAMETER_DECL_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_PARAMETER_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& param_decl = instance_name.param_decl;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_PARAMETER_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_PARAMETER_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_PARAMETER_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ParameterDecl& param_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_PARAMETER_DECL_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_PARAMETER_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& param_decl = instance_name.param_decl;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_FIELD_DECL : ebmcodegen::util::ContextBase<Context_Statement_FIELD_DECL> {
        constexpr static std::string_view context_name = "Statement_FIELD_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::FieldDecl& field_decl;
    };
    struct VisitorTag_Statement_FIELD_DECL {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_FIELD_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& field_decl = instance_name.field_decl;
    template <typename Result>
    struct Context_Statement_FIELD_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_FIELD_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_FIELD_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::FieldDecl& field_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_FIELD_DECL_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_FIELD_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& field_decl = instance_name.field_decl;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_FIELD_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_FIELD_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_FIELD_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::FieldDecl& field_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_FIELD_DECL_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_FIELD_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& field_decl = instance_name.field_decl;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_COMPOSITE_FIELD_DECL : ebmcodegen::util::ContextBase<Context_Statement_COMPOSITE_FIELD_DECL> {
        constexpr static std::string_view context_name = "Statement_COMPOSITE_FIELD_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::CompositeFieldDecl& composite_field_decl;
    };
    struct VisitorTag_Statement_COMPOSITE_FIELD_DECL {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_COMPOSITE_FIELD_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& composite_field_decl = instance_name.composite_field_decl;
    template <typename Result>
    struct Context_Statement_COMPOSITE_FIELD_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_COMPOSITE_FIELD_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_COMPOSITE_FIELD_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::CompositeFieldDecl& composite_field_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_COMPOSITE_FIELD_DECL_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& composite_field_decl = instance_name.composite_field_decl;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_COMPOSITE_FIELD_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_COMPOSITE_FIELD_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_COMPOSITE_FIELD_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::CompositeFieldDecl& composite_field_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_COMPOSITE_FIELD_DECL_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_COMPOSITE_FIELD_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& composite_field_decl = instance_name.composite_field_decl;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_ENUM_DECL : ebmcodegen::util::ContextBase<Context_Statement_ENUM_DECL> {
        constexpr static std::string_view context_name = "Statement_ENUM_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EnumDecl& enum_decl;
    };
    struct VisitorTag_Statement_ENUM_DECL {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_ENUM_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& enum_decl = instance_name.enum_decl;
    template <typename Result>
    struct Context_Statement_ENUM_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_ENUM_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_ENUM_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EnumDecl& enum_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_ENUM_DECL_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_ENUM_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& enum_decl = instance_name.enum_decl;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_ENUM_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_ENUM_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_ENUM_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EnumDecl& enum_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_ENUM_DECL_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_ENUM_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& enum_decl = instance_name.enum_decl;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_ENUM_MEMBER_DECL : ebmcodegen::util::ContextBase<Context_Statement_ENUM_MEMBER_DECL> {
        constexpr static std::string_view context_name = "Statement_ENUM_MEMBER_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EnumMemberDecl& enum_member_decl;
    };
    struct VisitorTag_Statement_ENUM_MEMBER_DECL {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_ENUM_MEMBER_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& enum_member_decl = instance_name.enum_member_decl;
    template <typename Result>
    struct Context_Statement_ENUM_MEMBER_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_ENUM_MEMBER_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_ENUM_MEMBER_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EnumMemberDecl& enum_member_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_ENUM_MEMBER_DECL_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_ENUM_MEMBER_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& enum_member_decl = instance_name.enum_member_decl;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_ENUM_MEMBER_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_ENUM_MEMBER_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_ENUM_MEMBER_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EnumMemberDecl& enum_member_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_ENUM_MEMBER_DECL_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_ENUM_MEMBER_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& enum_member_decl = instance_name.enum_member_decl;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_STRUCT_DECL : ebmcodegen::util::ContextBase<Context_Statement_STRUCT_DECL> {
        constexpr static std::string_view context_name = "Statement_STRUCT_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::StructDecl& struct_decl;
    };
    struct VisitorTag_Statement_STRUCT_DECL {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_STRUCT_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& struct_decl = instance_name.struct_decl;
    template <typename Result>
    struct Context_Statement_STRUCT_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_STRUCT_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_STRUCT_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::StructDecl& struct_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_STRUCT_DECL_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_STRUCT_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& struct_decl = instance_name.struct_decl;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_STRUCT_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_STRUCT_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_STRUCT_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::StructDecl& struct_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_STRUCT_DECL_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_STRUCT_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& struct_decl = instance_name.struct_decl;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_UNION_DECL : ebmcodegen::util::ContextBase<Context_Statement_UNION_DECL> {
        constexpr static std::string_view context_name = "Statement_UNION_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
    };
    struct VisitorTag_Statement_UNION_DECL {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_UNION_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;
    template <typename Result>
    struct Context_Statement_UNION_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_UNION_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_UNION_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_UNION_DECL_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_UNION_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_UNION_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_UNION_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_UNION_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_UNION_DECL_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_UNION_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_UNION_MEMBER_DECL : ebmcodegen::util::ContextBase<Context_Statement_UNION_MEMBER_DECL> {
        constexpr static std::string_view context_name = "Statement_UNION_MEMBER_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
    };
    struct VisitorTag_Statement_UNION_MEMBER_DECL {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_UNION_MEMBER_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;
    template <typename Result>
    struct Context_Statement_UNION_MEMBER_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_UNION_MEMBER_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_UNION_MEMBER_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_UNION_MEMBER_DECL_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_UNION_MEMBER_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_UNION_MEMBER_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_UNION_MEMBER_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_UNION_MEMBER_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_UNION_MEMBER_DECL_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_UNION_MEMBER_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_PROGRAM_DECL : ebmcodegen::util::ContextBase<Context_Statement_PROGRAM_DECL> {
        constexpr static std::string_view context_name = "Statement_PROGRAM_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Block& block;
    };
    struct VisitorTag_Statement_PROGRAM_DECL {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_PROGRAM_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& block = instance_name.block;
    template <typename Result>
    struct Context_Statement_PROGRAM_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_PROGRAM_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_PROGRAM_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Block& block;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_PROGRAM_DECL_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_PROGRAM_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& block = instance_name.block;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_PROGRAM_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_PROGRAM_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_PROGRAM_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Block& block;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_PROGRAM_DECL_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_PROGRAM_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& block = instance_name.block;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_PROPERTY_DECL : ebmcodegen::util::ContextBase<Context_Statement_PROPERTY_DECL> {
        constexpr static std::string_view context_name = "Statement_PROPERTY_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::PropertyDecl& property_decl;
    };
    struct VisitorTag_Statement_PROPERTY_DECL {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_PROPERTY_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& property_decl = instance_name.property_decl;
    template <typename Result>
    struct Context_Statement_PROPERTY_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_PROPERTY_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_PROPERTY_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::PropertyDecl& property_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_PROPERTY_DECL_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_PROPERTY_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& property_decl = instance_name.property_decl;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_PROPERTY_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_PROPERTY_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_PROPERTY_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::PropertyDecl& property_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_PROPERTY_DECL_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_PROPERTY_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& property_decl = instance_name.property_decl;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_PROPERTY_MEMBER_DECL : ebmcodegen::util::ContextBase<Context_Statement_PROPERTY_MEMBER_DECL> {
        constexpr static std::string_view context_name = "Statement_PROPERTY_MEMBER_DECL";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::PropertyMemberDecl& property_member_decl;
    };
    struct VisitorTag_Statement_PROPERTY_MEMBER_DECL {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_PROPERTY_MEMBER_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& property_member_decl = instance_name.property_member_decl;
    template <typename Result>
    struct Context_Statement_PROPERTY_MEMBER_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_PROPERTY_MEMBER_DECL_before<Result>> {
        constexpr static std::string_view context_name = "Statement_PROPERTY_MEMBER_DECL_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::PropertyMemberDecl& property_member_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_PROPERTY_MEMBER_DECL_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& property_member_decl = instance_name.property_member_decl;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_PROPERTY_MEMBER_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_PROPERTY_MEMBER_DECL_after<Result>> {
        constexpr static std::string_view context_name = "Statement_PROPERTY_MEMBER_DECL_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::PropertyMemberDecl& property_member_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_PROPERTY_MEMBER_DECL_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_PROPERTY_MEMBER_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& property_member_decl = instance_name.property_member_decl;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_METADATA : ebmcodegen::util::ContextBase<Context_Statement_METADATA> {
        constexpr static std::string_view context_name = "Statement_METADATA";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Metadata& metadata;
    };
    struct VisitorTag_Statement_METADATA {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_METADATA(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& metadata = instance_name.metadata;
    template <typename Result>
    struct Context_Statement_METADATA_before : ebmcodegen::util::ContextBase<Context_Statement_METADATA_before<Result>> {
        constexpr static std::string_view context_name = "Statement_METADATA_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Metadata& metadata;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_METADATA_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_METADATA_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& metadata = instance_name.metadata;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_METADATA_after : ebmcodegen::util::ContextBase<Context_Statement_METADATA_after<Result>> {
        constexpr static std::string_view context_name = "Statement_METADATA_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Metadata& metadata;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_METADATA_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_METADATA_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& metadata = instance_name.metadata;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_IMPORT_MODULE : ebmcodegen::util::ContextBase<Context_Statement_IMPORT_MODULE> {
        constexpr static std::string_view context_name = "Statement_IMPORT_MODULE";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ImportDecl& import_decl;
    };
    struct VisitorTag_Statement_IMPORT_MODULE {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_IMPORT_MODULE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& import_decl = instance_name.import_decl;
    template <typename Result>
    struct Context_Statement_IMPORT_MODULE_before : ebmcodegen::util::ContextBase<Context_Statement_IMPORT_MODULE_before<Result>> {
        constexpr static std::string_view context_name = "Statement_IMPORT_MODULE_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ImportDecl& import_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_IMPORT_MODULE_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_IMPORT_MODULE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& import_decl = instance_name.import_decl;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_IMPORT_MODULE_after : ebmcodegen::util::ContextBase<Context_Statement_IMPORT_MODULE_after<Result>> {
        constexpr static std::string_view context_name = "Statement_IMPORT_MODULE_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ImportDecl& import_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_IMPORT_MODULE_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_IMPORT_MODULE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& import_decl = instance_name.import_decl;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_EXPRESSION : ebmcodegen::util::ContextBase<Context_Statement_EXPRESSION> {
        constexpr static std::string_view context_name = "Statement_EXPRESSION";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ExpressionRef& expression;
    };
    struct VisitorTag_Statement_EXPRESSION {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_EXPRESSION(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& expression = instance_name.expression;
    template <typename Result>
    struct Context_Statement_EXPRESSION_before : ebmcodegen::util::ContextBase<Context_Statement_EXPRESSION_before<Result>> {
        constexpr static std::string_view context_name = "Statement_EXPRESSION_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ExpressionRef& expression;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_EXPRESSION_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_EXPRESSION_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& expression = instance_name.expression;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_EXPRESSION_after : ebmcodegen::util::ContextBase<Context_Statement_EXPRESSION_after<Result>> {
        constexpr static std::string_view context_name = "Statement_EXPRESSION_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ExpressionRef& expression;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_EXPRESSION_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_EXPRESSION_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& expression = instance_name.expression;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_ERROR_REPORT : ebmcodegen::util::ContextBase<Context_Statement_ERROR_REPORT> {
        constexpr static std::string_view context_name = "Statement_ERROR_REPORT";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ErrorReport& error_report;
    };
    struct VisitorTag_Statement_ERROR_REPORT {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_ERROR_REPORT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& error_report = instance_name.error_report;
    template <typename Result>
    struct Context_Statement_ERROR_REPORT_before : ebmcodegen::util::ContextBase<Context_Statement_ERROR_REPORT_before<Result>> {
        constexpr static std::string_view context_name = "Statement_ERROR_REPORT_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ErrorReport& error_report;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_ERROR_REPORT_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_ERROR_REPORT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& error_report = instance_name.error_report;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_ERROR_REPORT_after : ebmcodegen::util::ContextBase<Context_Statement_ERROR_REPORT_after<Result>> {
        constexpr static std::string_view context_name = "Statement_ERROR_REPORT_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ErrorReport& error_report;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_ERROR_REPORT_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_ERROR_REPORT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& error_report = instance_name.error_report;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_LOWERED_IO_STATEMENTS : ebmcodegen::util::ContextBase<Context_Statement_LOWERED_IO_STATEMENTS> {
        constexpr static std::string_view context_name = "Statement_LOWERED_IO_STATEMENTS";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoweredIOStatements& lowered_io_statements;
    };
    struct VisitorTag_Statement_LOWERED_IO_STATEMENTS {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_LOWERED_IO_STATEMENTS(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& lowered_io_statements = instance_name.lowered_io_statements;
    template <typename Result>
    struct Context_Statement_LOWERED_IO_STATEMENTS_before : ebmcodegen::util::ContextBase<Context_Statement_LOWERED_IO_STATEMENTS_before<Result>> {
        constexpr static std::string_view context_name = "Statement_LOWERED_IO_STATEMENTS_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoweredIOStatements& lowered_io_statements;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_LOWERED_IO_STATEMENTS_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& lowered_io_statements = instance_name.lowered_io_statements;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_LOWERED_IO_STATEMENTS_after : ebmcodegen::util::ContextBase<Context_Statement_LOWERED_IO_STATEMENTS_after<Result>> {
        constexpr static std::string_view context_name = "Statement_LOWERED_IO_STATEMENTS_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoweredIOStatements& lowered_io_statements;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_LOWERED_IO_STATEMENTS_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_LOWERED_IO_STATEMENTS_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& lowered_io_statements = instance_name.lowered_io_statements;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_SUB_BYTE_RANGE : ebmcodegen::util::ContextBase<Context_Statement_SUB_BYTE_RANGE> {
        constexpr static std::string_view context_name = "Statement_SUB_BYTE_RANGE";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::SubByteRange& sub_byte_range;
    };
    struct VisitorTag_Statement_SUB_BYTE_RANGE {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_SUB_BYTE_RANGE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& sub_byte_range = instance_name.sub_byte_range;
    template <typename Result>
    struct Context_Statement_SUB_BYTE_RANGE_before : ebmcodegen::util::ContextBase<Context_Statement_SUB_BYTE_RANGE_before<Result>> {
        constexpr static std::string_view context_name = "Statement_SUB_BYTE_RANGE_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::SubByteRange& sub_byte_range;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_SUB_BYTE_RANGE_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_SUB_BYTE_RANGE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& sub_byte_range = instance_name.sub_byte_range;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_SUB_BYTE_RANGE_after : ebmcodegen::util::ContextBase<Context_Statement_SUB_BYTE_RANGE_after<Result>> {
        constexpr static std::string_view context_name = "Statement_SUB_BYTE_RANGE_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::SubByteRange& sub_byte_range;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_SUB_BYTE_RANGE_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_SUB_BYTE_RANGE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& sub_byte_range = instance_name.sub_byte_range;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_INIT_CHECK : ebmcodegen::util::ContextBase<Context_Statement_INIT_CHECK> {
        constexpr static std::string_view context_name = "Statement_INIT_CHECK";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::InitCheck& init_check;
    };
    struct VisitorTag_Statement_INIT_CHECK {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_INIT_CHECK(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& init_check = instance_name.init_check;
    template <typename Result>
    struct Context_Statement_INIT_CHECK_before : ebmcodegen::util::ContextBase<Context_Statement_INIT_CHECK_before<Result>> {
        constexpr static std::string_view context_name = "Statement_INIT_CHECK_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::InitCheck& init_check;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_INIT_CHECK_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_INIT_CHECK_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& init_check = instance_name.init_check;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_INIT_CHECK_after : ebmcodegen::util::ContextBase<Context_Statement_INIT_CHECK_after<Result>> {
        constexpr static std::string_view context_name = "Statement_INIT_CHECK_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::InitCheck& init_check;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_INIT_CHECK_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_INIT_CHECK_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& init_check = instance_name.init_check;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_ENDIAN_VARIABLE : ebmcodegen::util::ContextBase<Context_Statement_ENDIAN_VARIABLE> {
        constexpr static std::string_view context_name = "Statement_ENDIAN_VARIABLE";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EndianVariable& endian_variable;
    };
    struct VisitorTag_Statement_ENDIAN_VARIABLE {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_ENDIAN_VARIABLE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& endian_variable = instance_name.endian_variable;
    template <typename Result>
    struct Context_Statement_ENDIAN_VARIABLE_before : ebmcodegen::util::ContextBase<Context_Statement_ENDIAN_VARIABLE_before<Result>> {
        constexpr static std::string_view context_name = "Statement_ENDIAN_VARIABLE_before";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EndianVariable& endian_variable;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_ENDIAN_VARIABLE_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_ENDIAN_VARIABLE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& endian_variable = instance_name.endian_variable;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_ENDIAN_VARIABLE_after : ebmcodegen::util::ContextBase<Context_Statement_ENDIAN_VARIABLE_after<Result>> {
        constexpr static std::string_view context_name = "Statement_ENDIAN_VARIABLE_after";
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EndianVariable& endian_variable;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_ENDIAN_VARIABLE_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_ENDIAN_VARIABLE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& endian_variable = instance_name.endian_variable;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement : ebmcodegen::util::ContextBase<Context_Statement> {
        constexpr static std::string_view context_name = "Statement";
        BaseVisitor& visitor;
        const ebm::Statement& in;
        ebm::StatementRef alias_ref;
    };
    struct VisitorTag_Statement {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& alias_ref = instance_name.alias_ref;
    template <typename Result>
    struct Context_Statement_before : ebmcodegen::util::ContextBase<Context_Statement_before<Result>> {
        constexpr static std::string_view context_name = "Statement_before";
        BaseVisitor& visitor;
        const ebm::Statement& in;
        ebm::StatementRef alias_ref;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& alias_ref = instance_name.alias_ref;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Statement_after : ebmcodegen::util::ContextBase<Context_Statement_after<Result>> {
        constexpr static std::string_view context_name = "Statement_after";
        BaseVisitor& visitor;
        const ebm::Statement& in;
        ebm::StatementRef alias_ref;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_STATEMENT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& alias_ref = instance_name.alias_ref;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Block : ebmcodegen::util::ContextBase<Context_Block> {
        constexpr static std::string_view context_name = "Block";
        BaseVisitor& visitor;
        const ebm::Block& in;
    };
    struct VisitorTag_Block {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_BLOCK(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;
    template <typename Result>
    struct Context_Block_before : ebmcodegen::util::ContextBase<Context_Block_before<Result>> {
        constexpr static std::string_view context_name = "Block_before";
        BaseVisitor& visitor;
        const ebm::Block& in;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Block_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_BLOCK_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Block_after : ebmcodegen::util::ContextBase<Context_Block_after<Result>> {
        constexpr static std::string_view context_name = "Block_after";
        BaseVisitor& visitor;
        const ebm::Block& in;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Block_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_BLOCK_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_LITERAL_INT : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_INT> {
        constexpr static std::string_view context_name = "Expression_LITERAL_INT";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Varint& int_value;
    };
    struct VisitorTag_Expression_LITERAL_INT {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_LITERAL_INT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& int_value = instance_name.int_value;
    template <typename Result>
    struct Context_Expression_LITERAL_INT_before : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_INT_before<Result>> {
        constexpr static std::string_view context_name = "Expression_LITERAL_INT_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Varint& int_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_LITERAL_INT_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_LITERAL_INT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& int_value = instance_name.int_value;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_LITERAL_INT_after : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_INT_after<Result>> {
        constexpr static std::string_view context_name = "Expression_LITERAL_INT_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Varint& int_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_LITERAL_INT_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_LITERAL_INT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& int_value = instance_name.int_value;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_LITERAL_INT64 : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_INT64> {
        constexpr static std::string_view context_name = "Expression_LITERAL_INT64";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const std::uint64_t& int64_value;
    };
    struct VisitorTag_Expression_LITERAL_INT64 {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_LITERAL_INT64(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& int64_value = instance_name.int64_value;
    template <typename Result>
    struct Context_Expression_LITERAL_INT64_before : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_INT64_before<Result>> {
        constexpr static std::string_view context_name = "Expression_LITERAL_INT64_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const std::uint64_t& int64_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_LITERAL_INT64_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_LITERAL_INT64_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& int64_value = instance_name.int64_value;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_LITERAL_INT64_after : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_INT64_after<Result>> {
        constexpr static std::string_view context_name = "Expression_LITERAL_INT64_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const std::uint64_t& int64_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_LITERAL_INT64_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_LITERAL_INT64_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& int64_value = instance_name.int64_value;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_LITERAL_BOOL : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_BOOL> {
        constexpr static std::string_view context_name = "Expression_LITERAL_BOOL";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const std::uint8_t& bool_value;
    };
    struct VisitorTag_Expression_LITERAL_BOOL {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_LITERAL_BOOL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& bool_value = instance_name.bool_value;
    template <typename Result>
    struct Context_Expression_LITERAL_BOOL_before : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_BOOL_before<Result>> {
        constexpr static std::string_view context_name = "Expression_LITERAL_BOOL_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const std::uint8_t& bool_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_LITERAL_BOOL_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_LITERAL_BOOL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& bool_value = instance_name.bool_value;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_LITERAL_BOOL_after : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_BOOL_after<Result>> {
        constexpr static std::string_view context_name = "Expression_LITERAL_BOOL_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const std::uint8_t& bool_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_LITERAL_BOOL_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_LITERAL_BOOL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& bool_value = instance_name.bool_value;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_LITERAL_STRING : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_STRING> {
        constexpr static std::string_view context_name = "Expression_LITERAL_STRING";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StringRef& string_value;
    };
    struct VisitorTag_Expression_LITERAL_STRING {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_LITERAL_STRING(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& string_value = instance_name.string_value;
    template <typename Result>
    struct Context_Expression_LITERAL_STRING_before : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_STRING_before<Result>> {
        constexpr static std::string_view context_name = "Expression_LITERAL_STRING_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StringRef& string_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_LITERAL_STRING_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_LITERAL_STRING_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& string_value = instance_name.string_value;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_LITERAL_STRING_after : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_STRING_after<Result>> {
        constexpr static std::string_view context_name = "Expression_LITERAL_STRING_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StringRef& string_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_LITERAL_STRING_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_LITERAL_STRING_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& string_value = instance_name.string_value;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_LITERAL_TYPE : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_TYPE> {
        constexpr static std::string_view context_name = "Expression_LITERAL_TYPE";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::TypeRef& type_ref;
    };
    struct VisitorTag_Expression_LITERAL_TYPE {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_LITERAL_TYPE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& type_ref = instance_name.type_ref;
    template <typename Result>
    struct Context_Expression_LITERAL_TYPE_before : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_TYPE_before<Result>> {
        constexpr static std::string_view context_name = "Expression_LITERAL_TYPE_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::TypeRef& type_ref;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_LITERAL_TYPE_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_LITERAL_TYPE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& type_ref = instance_name.type_ref;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_LITERAL_TYPE_after : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_TYPE_after<Result>> {
        constexpr static std::string_view context_name = "Expression_LITERAL_TYPE_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::TypeRef& type_ref;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_LITERAL_TYPE_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_LITERAL_TYPE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& type_ref = instance_name.type_ref;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_LITERAL_CHAR : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_CHAR> {
        constexpr static std::string_view context_name = "Expression_LITERAL_CHAR";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Varint& char_value;
    };
    struct VisitorTag_Expression_LITERAL_CHAR {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_LITERAL_CHAR(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& char_value = instance_name.char_value;
    template <typename Result>
    struct Context_Expression_LITERAL_CHAR_before : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_CHAR_before<Result>> {
        constexpr static std::string_view context_name = "Expression_LITERAL_CHAR_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Varint& char_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_LITERAL_CHAR_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_LITERAL_CHAR_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& char_value = instance_name.char_value;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_LITERAL_CHAR_after : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_CHAR_after<Result>> {
        constexpr static std::string_view context_name = "Expression_LITERAL_CHAR_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Varint& char_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_LITERAL_CHAR_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_LITERAL_CHAR_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& char_value = instance_name.char_value;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_IDENTIFIER : ebmcodegen::util::ContextBase<Context_Expression_IDENTIFIER> {
        constexpr static std::string_view context_name = "Expression_IDENTIFIER";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::WeakStatementRef& id;
    };
    struct VisitorTag_Expression_IDENTIFIER {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_IDENTIFIER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& id = instance_name.id;
    template <typename Result>
    struct Context_Expression_IDENTIFIER_before : ebmcodegen::util::ContextBase<Context_Expression_IDENTIFIER_before<Result>> {
        constexpr static std::string_view context_name = "Expression_IDENTIFIER_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::WeakStatementRef& id;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_IDENTIFIER_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_IDENTIFIER_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& id = instance_name.id;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_IDENTIFIER_after : ebmcodegen::util::ContextBase<Context_Expression_IDENTIFIER_after<Result>> {
        constexpr static std::string_view context_name = "Expression_IDENTIFIER_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::WeakStatementRef& id;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_IDENTIFIER_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_IDENTIFIER_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& id = instance_name.id;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_BINARY_OP : ebmcodegen::util::ContextBase<Context_Expression_BINARY_OP> {
        constexpr static std::string_view context_name = "Expression_BINARY_OP";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::BinaryOp& bop;
        const ebm::ExpressionRef& left;
        const ebm::ExpressionRef& right;
    };
    struct VisitorTag_Expression_BINARY_OP {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_BINARY_OP(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& bop = instance_name.bop;auto& left = instance_name.left;auto& right = instance_name.right;
    template <typename Result>
    struct Context_Expression_BINARY_OP_before : ebmcodegen::util::ContextBase<Context_Expression_BINARY_OP_before<Result>> {
        constexpr static std::string_view context_name = "Expression_BINARY_OP_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::BinaryOp& bop;
        const ebm::ExpressionRef& left;
        const ebm::ExpressionRef& right;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_BINARY_OP_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_BINARY_OP_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& bop = instance_name.bop;auto& left = instance_name.left;auto& right = instance_name.right;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_BINARY_OP_after : ebmcodegen::util::ContextBase<Context_Expression_BINARY_OP_after<Result>> {
        constexpr static std::string_view context_name = "Expression_BINARY_OP_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::BinaryOp& bop;
        const ebm::ExpressionRef& left;
        const ebm::ExpressionRef& right;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_BINARY_OP_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_BINARY_OP_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& bop = instance_name.bop;auto& left = instance_name.left;auto& right = instance_name.right;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_UNARY_OP : ebmcodegen::util::ContextBase<Context_Expression_UNARY_OP> {
        constexpr static std::string_view context_name = "Expression_UNARY_OP";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& operand;
        const ebm::UnaryOp& uop;
    };
    struct VisitorTag_Expression_UNARY_OP {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_UNARY_OP(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& operand = instance_name.operand;auto& uop = instance_name.uop;
    template <typename Result>
    struct Context_Expression_UNARY_OP_before : ebmcodegen::util::ContextBase<Context_Expression_UNARY_OP_before<Result>> {
        constexpr static std::string_view context_name = "Expression_UNARY_OP_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& operand;
        const ebm::UnaryOp& uop;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_UNARY_OP_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_UNARY_OP_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& operand = instance_name.operand;auto& uop = instance_name.uop;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_UNARY_OP_after : ebmcodegen::util::ContextBase<Context_Expression_UNARY_OP_after<Result>> {
        constexpr static std::string_view context_name = "Expression_UNARY_OP_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& operand;
        const ebm::UnaryOp& uop;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_UNARY_OP_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_UNARY_OP_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& operand = instance_name.operand;auto& uop = instance_name.uop;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_CALL : ebmcodegen::util::ContextBase<Context_Expression_CALL> {
        constexpr static std::string_view context_name = "Expression_CALL";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::CallDesc& call_desc;
    };
    struct VisitorTag_Expression_CALL {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_CALL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& call_desc = instance_name.call_desc;
    template <typename Result>
    struct Context_Expression_CALL_before : ebmcodegen::util::ContextBase<Context_Expression_CALL_before<Result>> {
        constexpr static std::string_view context_name = "Expression_CALL_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::CallDesc& call_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_CALL_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_CALL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& call_desc = instance_name.call_desc;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_CALL_after : ebmcodegen::util::ContextBase<Context_Expression_CALL_after<Result>> {
        constexpr static std::string_view context_name = "Expression_CALL_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::CallDesc& call_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_CALL_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_CALL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& call_desc = instance_name.call_desc;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_INDEX_ACCESS : ebmcodegen::util::ContextBase<Context_Expression_INDEX_ACCESS> {
        constexpr static std::string_view context_name = "Expression_INDEX_ACCESS";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& base;
        const ebm::ExpressionRef& index;
    };
    struct VisitorTag_Expression_INDEX_ACCESS {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_INDEX_ACCESS(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& base = instance_name.base;auto& index = instance_name.index;
    template <typename Result>
    struct Context_Expression_INDEX_ACCESS_before : ebmcodegen::util::ContextBase<Context_Expression_INDEX_ACCESS_before<Result>> {
        constexpr static std::string_view context_name = "Expression_INDEX_ACCESS_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& base;
        const ebm::ExpressionRef& index;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_INDEX_ACCESS_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_INDEX_ACCESS_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& base = instance_name.base;auto& index = instance_name.index;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_INDEX_ACCESS_after : ebmcodegen::util::ContextBase<Context_Expression_INDEX_ACCESS_after<Result>> {
        constexpr static std::string_view context_name = "Expression_INDEX_ACCESS_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& base;
        const ebm::ExpressionRef& index;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_INDEX_ACCESS_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_INDEX_ACCESS_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& base = instance_name.base;auto& index = instance_name.index;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_MEMBER_ACCESS : ebmcodegen::util::ContextBase<Context_Expression_MEMBER_ACCESS> {
        constexpr static std::string_view context_name = "Expression_MEMBER_ACCESS";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& base;
        const ebm::ExpressionRef& member;
    };
    struct VisitorTag_Expression_MEMBER_ACCESS {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_MEMBER_ACCESS(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& base = instance_name.base;auto& member = instance_name.member;
    template <typename Result>
    struct Context_Expression_MEMBER_ACCESS_before : ebmcodegen::util::ContextBase<Context_Expression_MEMBER_ACCESS_before<Result>> {
        constexpr static std::string_view context_name = "Expression_MEMBER_ACCESS_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& base;
        const ebm::ExpressionRef& member;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_MEMBER_ACCESS_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_MEMBER_ACCESS_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& base = instance_name.base;auto& member = instance_name.member;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_MEMBER_ACCESS_after : ebmcodegen::util::ContextBase<Context_Expression_MEMBER_ACCESS_after<Result>> {
        constexpr static std::string_view context_name = "Expression_MEMBER_ACCESS_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& base;
        const ebm::ExpressionRef& member;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_MEMBER_ACCESS_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_MEMBER_ACCESS_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& base = instance_name.base;auto& member = instance_name.member;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_ENUM_MEMBER : ebmcodegen::util::ContextBase<Context_Expression_ENUM_MEMBER> {
        constexpr static std::string_view context_name = "Expression_ENUM_MEMBER";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& enum_decl;
        const ebm::ExpressionRef& member;
    };
    struct VisitorTag_Expression_ENUM_MEMBER {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_ENUM_MEMBER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& enum_decl = instance_name.enum_decl;auto& member = instance_name.member;
    template <typename Result>
    struct Context_Expression_ENUM_MEMBER_before : ebmcodegen::util::ContextBase<Context_Expression_ENUM_MEMBER_before<Result>> {
        constexpr static std::string_view context_name = "Expression_ENUM_MEMBER_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& enum_decl;
        const ebm::ExpressionRef& member;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_ENUM_MEMBER_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_ENUM_MEMBER_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& enum_decl = instance_name.enum_decl;auto& member = instance_name.member;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_ENUM_MEMBER_after : ebmcodegen::util::ContextBase<Context_Expression_ENUM_MEMBER_after<Result>> {
        constexpr static std::string_view context_name = "Expression_ENUM_MEMBER_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& enum_decl;
        const ebm::ExpressionRef& member;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_ENUM_MEMBER_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_ENUM_MEMBER_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& enum_decl = instance_name.enum_decl;auto& member = instance_name.member;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_TYPE_CAST : ebmcodegen::util::ContextBase<Context_Expression_TYPE_CAST> {
        constexpr static std::string_view context_name = "Expression_TYPE_CAST";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::TypeCastDesc& type_cast_desc;
    };
    struct VisitorTag_Expression_TYPE_CAST {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_TYPE_CAST(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& type_cast_desc = instance_name.type_cast_desc;
    template <typename Result>
    struct Context_Expression_TYPE_CAST_before : ebmcodegen::util::ContextBase<Context_Expression_TYPE_CAST_before<Result>> {
        constexpr static std::string_view context_name = "Expression_TYPE_CAST_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::TypeCastDesc& type_cast_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_TYPE_CAST_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_TYPE_CAST_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& type_cast_desc = instance_name.type_cast_desc;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_TYPE_CAST_after : ebmcodegen::util::ContextBase<Context_Expression_TYPE_CAST_after<Result>> {
        constexpr static std::string_view context_name = "Expression_TYPE_CAST_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::TypeCastDesc& type_cast_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_TYPE_CAST_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_TYPE_CAST_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& type_cast_desc = instance_name.type_cast_desc;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_RANGE : ebmcodegen::util::ContextBase<Context_Expression_RANGE> {
        constexpr static std::string_view context_name = "Expression_RANGE";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& end;
        const ebm::ExpressionRef& start;
    };
    struct VisitorTag_Expression_RANGE {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_RANGE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& end = instance_name.end;auto& start = instance_name.start;
    template <typename Result>
    struct Context_Expression_RANGE_before : ebmcodegen::util::ContextBase<Context_Expression_RANGE_before<Result>> {
        constexpr static std::string_view context_name = "Expression_RANGE_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& end;
        const ebm::ExpressionRef& start;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_RANGE_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_RANGE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& end = instance_name.end;auto& start = instance_name.start;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_RANGE_after : ebmcodegen::util::ContextBase<Context_Expression_RANGE_after<Result>> {
        constexpr static std::string_view context_name = "Expression_RANGE_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& end;
        const ebm::ExpressionRef& start;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_RANGE_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_RANGE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& end = instance_name.end;auto& start = instance_name.start;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_DEFAULT_VALUE : ebmcodegen::util::ContextBase<Context_Expression_DEFAULT_VALUE> {
        constexpr static std::string_view context_name = "Expression_DEFAULT_VALUE";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
    };
    struct VisitorTag_Expression_DEFAULT_VALUE {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_DEFAULT_VALUE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;
    template <typename Result>
    struct Context_Expression_DEFAULT_VALUE_before : ebmcodegen::util::ContextBase<Context_Expression_DEFAULT_VALUE_before<Result>> {
        constexpr static std::string_view context_name = "Expression_DEFAULT_VALUE_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_DEFAULT_VALUE_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_DEFAULT_VALUE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_DEFAULT_VALUE_after : ebmcodegen::util::ContextBase<Context_Expression_DEFAULT_VALUE_after<Result>> {
        constexpr static std::string_view context_name = "Expression_DEFAULT_VALUE_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_DEFAULT_VALUE_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_DEFAULT_VALUE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_IS_LITTLE_ENDIAN : ebmcodegen::util::ContextBase<Context_Expression_IS_LITTLE_ENDIAN> {
        constexpr static std::string_view context_name = "Expression_IS_LITTLE_ENDIAN";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& endian_expr;
    };
    struct VisitorTag_Expression_IS_LITTLE_ENDIAN {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_IS_LITTLE_ENDIAN(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& endian_expr = instance_name.endian_expr;
    template <typename Result>
    struct Context_Expression_IS_LITTLE_ENDIAN_before : ebmcodegen::util::ContextBase<Context_Expression_IS_LITTLE_ENDIAN_before<Result>> {
        constexpr static std::string_view context_name = "Expression_IS_LITTLE_ENDIAN_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& endian_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_IS_LITTLE_ENDIAN_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& endian_expr = instance_name.endian_expr;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_IS_LITTLE_ENDIAN_after : ebmcodegen::util::ContextBase<Context_Expression_IS_LITTLE_ENDIAN_after<Result>> {
        constexpr static std::string_view context_name = "Expression_IS_LITTLE_ENDIAN_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& endian_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_IS_LITTLE_ENDIAN_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_IS_LITTLE_ENDIAN_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& endian_expr = instance_name.endian_expr;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_GET_STREAM_OFFSET : ebmcodegen::util::ContextBase<Context_Expression_GET_STREAM_OFFSET> {
        constexpr static std::string_view context_name = "Expression_GET_STREAM_OFFSET";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_ref;
        const ebm::StreamType& stream_type;
        const ebm::SizeUnit& unit;
    };
    struct VisitorTag_Expression_GET_STREAM_OFFSET {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_GET_STREAM_OFFSET(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& io_ref = instance_name.io_ref;auto& stream_type = instance_name.stream_type;auto& unit = instance_name.unit;
    template <typename Result>
    struct Context_Expression_GET_STREAM_OFFSET_before : ebmcodegen::util::ContextBase<Context_Expression_GET_STREAM_OFFSET_before<Result>> {
        constexpr static std::string_view context_name = "Expression_GET_STREAM_OFFSET_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_ref;
        const ebm::StreamType& stream_type;
        const ebm::SizeUnit& unit;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_GET_STREAM_OFFSET_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_GET_STREAM_OFFSET_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& io_ref = instance_name.io_ref;auto& stream_type = instance_name.stream_type;auto& unit = instance_name.unit;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_GET_STREAM_OFFSET_after : ebmcodegen::util::ContextBase<Context_Expression_GET_STREAM_OFFSET_after<Result>> {
        constexpr static std::string_view context_name = "Expression_GET_STREAM_OFFSET_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_ref;
        const ebm::StreamType& stream_type;
        const ebm::SizeUnit& unit;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_GET_STREAM_OFFSET_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_GET_STREAM_OFFSET_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& io_ref = instance_name.io_ref;auto& stream_type = instance_name.stream_type;auto& unit = instance_name.unit;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_GET_REMAINING_BYTES : ebmcodegen::util::ContextBase<Context_Expression_GET_REMAINING_BYTES> {
        constexpr static std::string_view context_name = "Expression_GET_REMAINING_BYTES";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_ref;
        const ebm::StreamType& stream_type;
    };
    struct VisitorTag_Expression_GET_REMAINING_BYTES {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_GET_REMAINING_BYTES(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& io_ref = instance_name.io_ref;auto& stream_type = instance_name.stream_type;
    template <typename Result>
    struct Context_Expression_GET_REMAINING_BYTES_before : ebmcodegen::util::ContextBase<Context_Expression_GET_REMAINING_BYTES_before<Result>> {
        constexpr static std::string_view context_name = "Expression_GET_REMAINING_BYTES_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_ref;
        const ebm::StreamType& stream_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_GET_REMAINING_BYTES_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_GET_REMAINING_BYTES_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& io_ref = instance_name.io_ref;auto& stream_type = instance_name.stream_type;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_GET_REMAINING_BYTES_after : ebmcodegen::util::ContextBase<Context_Expression_GET_REMAINING_BYTES_after<Result>> {
        constexpr static std::string_view context_name = "Expression_GET_REMAINING_BYTES_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_ref;
        const ebm::StreamType& stream_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_GET_REMAINING_BYTES_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_GET_REMAINING_BYTES_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& io_ref = instance_name.io_ref;auto& stream_type = instance_name.stream_type;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_CAN_READ_STREAM : ebmcodegen::util::ContextBase<Context_Expression_CAN_READ_STREAM> {
        constexpr static std::string_view context_name = "Expression_CAN_READ_STREAM";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_ref;
        const ebm::Size& num_bytes;
        const ebm::StreamType& stream_type;
    };
    struct VisitorTag_Expression_CAN_READ_STREAM {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_CAN_READ_STREAM(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& io_ref = instance_name.io_ref;auto& num_bytes = instance_name.num_bytes;auto& stream_type = instance_name.stream_type;
    template <typename Result>
    struct Context_Expression_CAN_READ_STREAM_before : ebmcodegen::util::ContextBase<Context_Expression_CAN_READ_STREAM_before<Result>> {
        constexpr static std::string_view context_name = "Expression_CAN_READ_STREAM_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_ref;
        const ebm::Size& num_bytes;
        const ebm::StreamType& stream_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_CAN_READ_STREAM_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_CAN_READ_STREAM_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& io_ref = instance_name.io_ref;auto& num_bytes = instance_name.num_bytes;auto& stream_type = instance_name.stream_type;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_CAN_READ_STREAM_after : ebmcodegen::util::ContextBase<Context_Expression_CAN_READ_STREAM_after<Result>> {
        constexpr static std::string_view context_name = "Expression_CAN_READ_STREAM_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_ref;
        const ebm::Size& num_bytes;
        const ebm::StreamType& stream_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_CAN_READ_STREAM_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_CAN_READ_STREAM_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& io_ref = instance_name.io_ref;auto& num_bytes = instance_name.num_bytes;auto& stream_type = instance_name.stream_type;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_ARRAY_SIZE : ebmcodegen::util::ContextBase<Context_Expression_ARRAY_SIZE> {
        constexpr static std::string_view context_name = "Expression_ARRAY_SIZE";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& array_expr;
    };
    struct VisitorTag_Expression_ARRAY_SIZE {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_ARRAY_SIZE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& array_expr = instance_name.array_expr;
    template <typename Result>
    struct Context_Expression_ARRAY_SIZE_before : ebmcodegen::util::ContextBase<Context_Expression_ARRAY_SIZE_before<Result>> {
        constexpr static std::string_view context_name = "Expression_ARRAY_SIZE_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& array_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_ARRAY_SIZE_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_ARRAY_SIZE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& array_expr = instance_name.array_expr;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_ARRAY_SIZE_after : ebmcodegen::util::ContextBase<Context_Expression_ARRAY_SIZE_after<Result>> {
        constexpr static std::string_view context_name = "Expression_ARRAY_SIZE_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& array_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_ARRAY_SIZE_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_ARRAY_SIZE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& array_expr = instance_name.array_expr;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_ENUM_IS_DEFINED : ebmcodegen::util::ContextBase<Context_Expression_ENUM_IS_DEFINED> {
        constexpr static std::string_view context_name = "Expression_ENUM_IS_DEFINED";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
    };
    struct VisitorTag_Expression_ENUM_IS_DEFINED {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_ENUM_IS_DEFINED(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& lowered_expr = instance_name.lowered_expr;auto& target_expr = instance_name.target_expr;
    template <typename Result>
    struct Context_Expression_ENUM_IS_DEFINED_before : ebmcodegen::util::ContextBase<Context_Expression_ENUM_IS_DEFINED_before<Result>> {
        constexpr static std::string_view context_name = "Expression_ENUM_IS_DEFINED_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_ENUM_IS_DEFINED_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_ENUM_IS_DEFINED_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& lowered_expr = instance_name.lowered_expr;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_ENUM_IS_DEFINED_after : ebmcodegen::util::ContextBase<Context_Expression_ENUM_IS_DEFINED_after<Result>> {
        constexpr static std::string_view context_name = "Expression_ENUM_IS_DEFINED_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_ENUM_IS_DEFINED_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_ENUM_IS_DEFINED_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& lowered_expr = instance_name.lowered_expr;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_IS_ERROR : ebmcodegen::util::ContextBase<Context_Expression_IS_ERROR> {
        constexpr static std::string_view context_name = "Expression_IS_ERROR";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
    };
    struct VisitorTag_Expression_IS_ERROR {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_IS_ERROR(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& target_expr = instance_name.target_expr;
    template <typename Result>
    struct Context_Expression_IS_ERROR_before : ebmcodegen::util::ContextBase<Context_Expression_IS_ERROR_before<Result>> {
        constexpr static std::string_view context_name = "Expression_IS_ERROR_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_IS_ERROR_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_IS_ERROR_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_IS_ERROR_after : ebmcodegen::util::ContextBase<Context_Expression_IS_ERROR_after<Result>> {
        constexpr static std::string_view context_name = "Expression_IS_ERROR_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_IS_ERROR_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_IS_ERROR_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_MAX_VALUE : ebmcodegen::util::ContextBase<Context_Expression_MAX_VALUE> {
        constexpr static std::string_view context_name = "Expression_MAX_VALUE";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
    };
    struct VisitorTag_Expression_MAX_VALUE {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_MAX_VALUE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& lowered_expr = instance_name.lowered_expr;
    template <typename Result>
    struct Context_Expression_MAX_VALUE_before : ebmcodegen::util::ContextBase<Context_Expression_MAX_VALUE_before<Result>> {
        constexpr static std::string_view context_name = "Expression_MAX_VALUE_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_MAX_VALUE_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_MAX_VALUE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& lowered_expr = instance_name.lowered_expr;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_MAX_VALUE_after : ebmcodegen::util::ContextBase<Context_Expression_MAX_VALUE_after<Result>> {
        constexpr static std::string_view context_name = "Expression_MAX_VALUE_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_MAX_VALUE_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_MAX_VALUE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& lowered_expr = instance_name.lowered_expr;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_READ_DATA : ebmcodegen::util::ContextBase<Context_Expression_READ_DATA> {
        constexpr static std::string_view context_name = "Expression_READ_DATA";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_statement;
        const ebm::StatementRef& target_stmt;
    };
    struct VisitorTag_Expression_READ_DATA {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_READ_DATA(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& io_statement = instance_name.io_statement;auto& target_stmt = instance_name.target_stmt;
    template <typename Result>
    struct Context_Expression_READ_DATA_before : ebmcodegen::util::ContextBase<Context_Expression_READ_DATA_before<Result>> {
        constexpr static std::string_view context_name = "Expression_READ_DATA_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_statement;
        const ebm::StatementRef& target_stmt;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_READ_DATA_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_READ_DATA_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& io_statement = instance_name.io_statement;auto& target_stmt = instance_name.target_stmt;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_READ_DATA_after : ebmcodegen::util::ContextBase<Context_Expression_READ_DATA_after<Result>> {
        constexpr static std::string_view context_name = "Expression_READ_DATA_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_statement;
        const ebm::StatementRef& target_stmt;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_READ_DATA_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_READ_DATA_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& io_statement = instance_name.io_statement;auto& target_stmt = instance_name.target_stmt;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_WRITE_DATA : ebmcodegen::util::ContextBase<Context_Expression_WRITE_DATA> {
        constexpr static std::string_view context_name = "Expression_WRITE_DATA";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_statement;
        const ebm::ExpressionRef& target_expr;
    };
    struct VisitorTag_Expression_WRITE_DATA {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_WRITE_DATA(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& io_statement = instance_name.io_statement;auto& target_expr = instance_name.target_expr;
    template <typename Result>
    struct Context_Expression_WRITE_DATA_before : ebmcodegen::util::ContextBase<Context_Expression_WRITE_DATA_before<Result>> {
        constexpr static std::string_view context_name = "Expression_WRITE_DATA_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_statement;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_WRITE_DATA_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_WRITE_DATA_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& io_statement = instance_name.io_statement;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_WRITE_DATA_after : ebmcodegen::util::ContextBase<Context_Expression_WRITE_DATA_after<Result>> {
        constexpr static std::string_view context_name = "Expression_WRITE_DATA_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_statement;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_WRITE_DATA_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_WRITE_DATA_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& io_statement = instance_name.io_statement;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_CONDITIONAL_STATEMENT : ebmcodegen::util::ContextBase<Context_Expression_CONDITIONAL_STATEMENT> {
        constexpr static std::string_view context_name = "Expression_CONDITIONAL_STATEMENT";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& conditional_stmt;
        const ebm::StatementRef& target_stmt;
    };
    struct VisitorTag_Expression_CONDITIONAL_STATEMENT {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_CONDITIONAL_STATEMENT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& conditional_stmt = instance_name.conditional_stmt;auto& target_stmt = instance_name.target_stmt;
    template <typename Result>
    struct Context_Expression_CONDITIONAL_STATEMENT_before : ebmcodegen::util::ContextBase<Context_Expression_CONDITIONAL_STATEMENT_before<Result>> {
        constexpr static std::string_view context_name = "Expression_CONDITIONAL_STATEMENT_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& conditional_stmt;
        const ebm::StatementRef& target_stmt;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_CONDITIONAL_STATEMENT_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& conditional_stmt = instance_name.conditional_stmt;auto& target_stmt = instance_name.target_stmt;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_CONDITIONAL_STATEMENT_after : ebmcodegen::util::ContextBase<Context_Expression_CONDITIONAL_STATEMENT_after<Result>> {
        constexpr static std::string_view context_name = "Expression_CONDITIONAL_STATEMENT_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& conditional_stmt;
        const ebm::StatementRef& target_stmt;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_CONDITIONAL_STATEMENT_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_CONDITIONAL_STATEMENT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& conditional_stmt = instance_name.conditional_stmt;auto& target_stmt = instance_name.target_stmt;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_CONDITIONAL : ebmcodegen::util::ContextBase<Context_Expression_CONDITIONAL> {
        constexpr static std::string_view context_name = "Expression_CONDITIONAL";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& condition;
        const ebm::ExpressionRef& else_;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& then;
    };
    struct VisitorTag_Expression_CONDITIONAL {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_CONDITIONAL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& condition = instance_name.condition;auto& else_ = instance_name.else_;auto& lowered_expr = instance_name.lowered_expr;auto& then = instance_name.then;
    template <typename Result>
    struct Context_Expression_CONDITIONAL_before : ebmcodegen::util::ContextBase<Context_Expression_CONDITIONAL_before<Result>> {
        constexpr static std::string_view context_name = "Expression_CONDITIONAL_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& condition;
        const ebm::ExpressionRef& else_;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& then;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_CONDITIONAL_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_CONDITIONAL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& condition = instance_name.condition;auto& else_ = instance_name.else_;auto& lowered_expr = instance_name.lowered_expr;auto& then = instance_name.then;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_CONDITIONAL_after : ebmcodegen::util::ContextBase<Context_Expression_CONDITIONAL_after<Result>> {
        constexpr static std::string_view context_name = "Expression_CONDITIONAL_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& condition;
        const ebm::ExpressionRef& else_;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& then;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_CONDITIONAL_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_CONDITIONAL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& condition = instance_name.condition;auto& else_ = instance_name.else_;auto& lowered_expr = instance_name.lowered_expr;auto& then = instance_name.then;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_AVAILABLE : ebmcodegen::util::ContextBase<Context_Expression_AVAILABLE> {
        constexpr static std::string_view context_name = "Expression_AVAILABLE";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
    };
    struct VisitorTag_Expression_AVAILABLE {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_AVAILABLE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& lowered_expr = instance_name.lowered_expr;auto& target_expr = instance_name.target_expr;
    template <typename Result>
    struct Context_Expression_AVAILABLE_before : ebmcodegen::util::ContextBase<Context_Expression_AVAILABLE_before<Result>> {
        constexpr static std::string_view context_name = "Expression_AVAILABLE_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_AVAILABLE_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_AVAILABLE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& lowered_expr = instance_name.lowered_expr;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_AVAILABLE_after : ebmcodegen::util::ContextBase<Context_Expression_AVAILABLE_after<Result>> {
        constexpr static std::string_view context_name = "Expression_AVAILABLE_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_AVAILABLE_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_AVAILABLE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& lowered_expr = instance_name.lowered_expr;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_SIZEOF : ebmcodegen::util::ContextBase<Context_Expression_SIZEOF> {
        constexpr static std::string_view context_name = "Expression_SIZEOF";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
    };
    struct VisitorTag_Expression_SIZEOF {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_SIZEOF(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& lowered_expr = instance_name.lowered_expr;auto& target_expr = instance_name.target_expr;
    template <typename Result>
    struct Context_Expression_SIZEOF_before : ebmcodegen::util::ContextBase<Context_Expression_SIZEOF_before<Result>> {
        constexpr static std::string_view context_name = "Expression_SIZEOF_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_SIZEOF_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_SIZEOF_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& lowered_expr = instance_name.lowered_expr;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_SIZEOF_after : ebmcodegen::util::ContextBase<Context_Expression_SIZEOF_after<Result>> {
        constexpr static std::string_view context_name = "Expression_SIZEOF_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_SIZEOF_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_SIZEOF_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& lowered_expr = instance_name.lowered_expr;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_SUB_RANGE_INIT : ebmcodegen::util::ContextBase<Context_Expression_SUB_RANGE_INIT> {
        constexpr static std::string_view context_name = "Expression_SUB_RANGE_INIT";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& sub_range;
    };
    struct VisitorTag_Expression_SUB_RANGE_INIT {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_SUB_RANGE_INIT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& sub_range = instance_name.sub_range;
    template <typename Result>
    struct Context_Expression_SUB_RANGE_INIT_before : ebmcodegen::util::ContextBase<Context_Expression_SUB_RANGE_INIT_before<Result>> {
        constexpr static std::string_view context_name = "Expression_SUB_RANGE_INIT_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& sub_range;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_SUB_RANGE_INIT_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_SUB_RANGE_INIT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& sub_range = instance_name.sub_range;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_SUB_RANGE_INIT_after : ebmcodegen::util::ContextBase<Context_Expression_SUB_RANGE_INIT_after<Result>> {
        constexpr static std::string_view context_name = "Expression_SUB_RANGE_INIT_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& sub_range;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_SUB_RANGE_INIT_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_SUB_RANGE_INIT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& sub_range = instance_name.sub_range;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_OR_COND : ebmcodegen::util::ContextBase<Context_Expression_OR_COND> {
        constexpr static std::string_view context_name = "Expression_OR_COND";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Expressions& or_cond;
    };
    struct VisitorTag_Expression_OR_COND {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_OR_COND(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& or_cond = instance_name.or_cond;
    template <typename Result>
    struct Context_Expression_OR_COND_before : ebmcodegen::util::ContextBase<Context_Expression_OR_COND_before<Result>> {
        constexpr static std::string_view context_name = "Expression_OR_COND_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Expressions& or_cond;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_OR_COND_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_OR_COND_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& or_cond = instance_name.or_cond;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_OR_COND_after : ebmcodegen::util::ContextBase<Context_Expression_OR_COND_after<Result>> {
        constexpr static std::string_view context_name = "Expression_OR_COND_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Expressions& or_cond;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_OR_COND_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_OR_COND_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& or_cond = instance_name.or_cond;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_ADDRESS_OF : ebmcodegen::util::ContextBase<Context_Expression_ADDRESS_OF> {
        constexpr static std::string_view context_name = "Expression_ADDRESS_OF";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
    };
    struct VisitorTag_Expression_ADDRESS_OF {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_ADDRESS_OF(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& target_expr = instance_name.target_expr;
    template <typename Result>
    struct Context_Expression_ADDRESS_OF_before : ebmcodegen::util::ContextBase<Context_Expression_ADDRESS_OF_before<Result>> {
        constexpr static std::string_view context_name = "Expression_ADDRESS_OF_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_ADDRESS_OF_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_ADDRESS_OF_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_ADDRESS_OF_after : ebmcodegen::util::ContextBase<Context_Expression_ADDRESS_OF_after<Result>> {
        constexpr static std::string_view context_name = "Expression_ADDRESS_OF_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_ADDRESS_OF_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_ADDRESS_OF_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_OPTIONAL_OF : ebmcodegen::util::ContextBase<Context_Expression_OPTIONAL_OF> {
        constexpr static std::string_view context_name = "Expression_OPTIONAL_OF";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
    };
    struct VisitorTag_Expression_OPTIONAL_OF {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_OPTIONAL_OF(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& target_expr = instance_name.target_expr;
    template <typename Result>
    struct Context_Expression_OPTIONAL_OF_before : ebmcodegen::util::ContextBase<Context_Expression_OPTIONAL_OF_before<Result>> {
        constexpr static std::string_view context_name = "Expression_OPTIONAL_OF_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_OPTIONAL_OF_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_OPTIONAL_OF_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_OPTIONAL_OF_after : ebmcodegen::util::ContextBase<Context_Expression_OPTIONAL_OF_after<Result>> {
        constexpr static std::string_view context_name = "Expression_OPTIONAL_OF_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_OPTIONAL_OF_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_OPTIONAL_OF_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_SETTER_STATUS : ebmcodegen::util::ContextBase<Context_Expression_SETTER_STATUS> {
        constexpr static std::string_view context_name = "Expression_SETTER_STATUS";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::SetterStatus& setter_status;
    };
    struct VisitorTag_Expression_SETTER_STATUS {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_SETTER_STATUS(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& setter_status = instance_name.setter_status;
    template <typename Result>
    struct Context_Expression_SETTER_STATUS_before : ebmcodegen::util::ContextBase<Context_Expression_SETTER_STATUS_before<Result>> {
        constexpr static std::string_view context_name = "Expression_SETTER_STATUS_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::SetterStatus& setter_status;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_SETTER_STATUS_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_SETTER_STATUS_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& setter_status = instance_name.setter_status;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_SETTER_STATUS_after : ebmcodegen::util::ContextBase<Context_Expression_SETTER_STATUS_after<Result>> {
        constexpr static std::string_view context_name = "Expression_SETTER_STATUS_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::SetterStatus& setter_status;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_SETTER_STATUS_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_SETTER_STATUS_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& setter_status = instance_name.setter_status;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_SELF : ebmcodegen::util::ContextBase<Context_Expression_SELF> {
        constexpr static std::string_view context_name = "Expression_SELF";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
    };
    struct VisitorTag_Expression_SELF {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_SELF(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;
    template <typename Result>
    struct Context_Expression_SELF_before : ebmcodegen::util::ContextBase<Context_Expression_SELF_before<Result>> {
        constexpr static std::string_view context_name = "Expression_SELF_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_SELF_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_SELF_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_SELF_after : ebmcodegen::util::ContextBase<Context_Expression_SELF_after<Result>> {
        constexpr static std::string_view context_name = "Expression_SELF_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_SELF_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_SELF_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_AS_ARG : ebmcodegen::util::ContextBase<Context_Expression_AS_ARG> {
        constexpr static std::string_view context_name = "Expression_AS_ARG";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
    };
    struct VisitorTag_Expression_AS_ARG {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_AS_ARG(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& target_expr = instance_name.target_expr;
    template <typename Result>
    struct Context_Expression_AS_ARG_before : ebmcodegen::util::ContextBase<Context_Expression_AS_ARG_before<Result>> {
        constexpr static std::string_view context_name = "Expression_AS_ARG_before";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_AS_ARG_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_AS_ARG_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_AS_ARG_after : ebmcodegen::util::ContextBase<Context_Expression_AS_ARG_after<Result>> {
        constexpr static std::string_view context_name = "Expression_AS_ARG_after";
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_AS_ARG_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_AS_ARG_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression : ebmcodegen::util::ContextBase<Context_Expression> {
        constexpr static std::string_view context_name = "Expression";
        BaseVisitor& visitor;
        const ebm::Expression& in;
        ebm::ExpressionRef alias_ref;
    };
    struct VisitorTag_Expression {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& alias_ref = instance_name.alias_ref;
    template <typename Result>
    struct Context_Expression_before : ebmcodegen::util::ContextBase<Context_Expression_before<Result>> {
        constexpr static std::string_view context_name = "Expression_before";
        BaseVisitor& visitor;
        const ebm::Expression& in;
        ebm::ExpressionRef alias_ref;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& alias_ref = instance_name.alias_ref;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expression_after : ebmcodegen::util::ContextBase<Context_Expression_after<Result>> {
        constexpr static std::string_view context_name = "Expression_after";
        BaseVisitor& visitor;
        const ebm::Expression& in;
        ebm::ExpressionRef alias_ref;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSION_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& alias_ref = instance_name.alias_ref;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expressions : ebmcodegen::util::ContextBase<Context_Expressions> {
        constexpr static std::string_view context_name = "Expressions";
        BaseVisitor& visitor;
        const ebm::Expressions& in;
    };
    struct VisitorTag_Expressions {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSIONS(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;
    template <typename Result>
    struct Context_Expressions_before : ebmcodegen::util::ContextBase<Context_Expressions_before<Result>> {
        constexpr static std::string_view context_name = "Expressions_before";
        BaseVisitor& visitor;
        const ebm::Expressions& in;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expressions_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSIONS_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Expressions_after : ebmcodegen::util::ContextBase<Context_Expressions_after<Result>> {
        constexpr static std::string_view context_name = "Expressions_after";
        BaseVisitor& visitor;
        const ebm::Expressions& in;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expressions_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_EXPRESSIONS_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_INT : ebmcodegen::util::ContextBase<Context_Type_INT> {
        constexpr static std::string_view context_name = "Type_INT";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
    };
    struct VisitorTag_Type_INT {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_INT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& size = instance_name.size;
    template <typename Result>
    struct Context_Type_INT_before : ebmcodegen::util::ContextBase<Context_Type_INT_before<Result>> {
        constexpr static std::string_view context_name = "Type_INT_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_INT_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_INT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& size = instance_name.size;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Type_INT_after : ebmcodegen::util::ContextBase<Context_Type_INT_after<Result>> {
        constexpr static std::string_view context_name = "Type_INT_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_INT_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_INT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& size = instance_name.size;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_UINT : ebmcodegen::util::ContextBase<Context_Type_UINT> {
        constexpr static std::string_view context_name = "Type_UINT";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
    };
    struct VisitorTag_Type_UINT {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_UINT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& size = instance_name.size;
    template <typename Result>
    struct Context_Type_UINT_before : ebmcodegen::util::ContextBase<Context_Type_UINT_before<Result>> {
        constexpr static std::string_view context_name = "Type_UINT_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_UINT_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_UINT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& size = instance_name.size;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Type_UINT_after : ebmcodegen::util::ContextBase<Context_Type_UINT_after<Result>> {
        constexpr static std::string_view context_name = "Type_UINT_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_UINT_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_UINT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& size = instance_name.size;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_USIZE : ebmcodegen::util::ContextBase<Context_Type_USIZE> {
        constexpr static std::string_view context_name = "Type_USIZE";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    struct VisitorTag_Type_USIZE {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_USIZE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;
    template <typename Result>
    struct Context_Type_USIZE_before : ebmcodegen::util::ContextBase<Context_Type_USIZE_before<Result>> {
        constexpr static std::string_view context_name = "Type_USIZE_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_USIZE_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_USIZE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Type_USIZE_after : ebmcodegen::util::ContextBase<Context_Type_USIZE_after<Result>> {
        constexpr static std::string_view context_name = "Type_USIZE_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_USIZE_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_USIZE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_FLOAT : ebmcodegen::util::ContextBase<Context_Type_FLOAT> {
        constexpr static std::string_view context_name = "Type_FLOAT";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
    };
    struct VisitorTag_Type_FLOAT {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_FLOAT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& size = instance_name.size;
    template <typename Result>
    struct Context_Type_FLOAT_before : ebmcodegen::util::ContextBase<Context_Type_FLOAT_before<Result>> {
        constexpr static std::string_view context_name = "Type_FLOAT_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_FLOAT_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_FLOAT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& size = instance_name.size;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Type_FLOAT_after : ebmcodegen::util::ContextBase<Context_Type_FLOAT_after<Result>> {
        constexpr static std::string_view context_name = "Type_FLOAT_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_FLOAT_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_FLOAT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& size = instance_name.size;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_STRUCT : ebmcodegen::util::ContextBase<Context_Type_STRUCT> {
        constexpr static std::string_view context_name = "Type_STRUCT";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::WeakStatementRef& id;
    };
    struct VisitorTag_Type_STRUCT {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_STRUCT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& id = instance_name.id;
    template <typename Result>
    struct Context_Type_STRUCT_before : ebmcodegen::util::ContextBase<Context_Type_STRUCT_before<Result>> {
        constexpr static std::string_view context_name = "Type_STRUCT_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::WeakStatementRef& id;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_STRUCT_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_STRUCT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& id = instance_name.id;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Type_STRUCT_after : ebmcodegen::util::ContextBase<Context_Type_STRUCT_after<Result>> {
        constexpr static std::string_view context_name = "Type_STRUCT_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::WeakStatementRef& id;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_STRUCT_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_STRUCT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& id = instance_name.id;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_RECURSIVE_STRUCT : ebmcodegen::util::ContextBase<Context_Type_RECURSIVE_STRUCT> {
        constexpr static std::string_view context_name = "Type_RECURSIVE_STRUCT";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::WeakStatementRef& id;
    };
    struct VisitorTag_Type_RECURSIVE_STRUCT {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_RECURSIVE_STRUCT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& id = instance_name.id;
    template <typename Result>
    struct Context_Type_RECURSIVE_STRUCT_before : ebmcodegen::util::ContextBase<Context_Type_RECURSIVE_STRUCT_before<Result>> {
        constexpr static std::string_view context_name = "Type_RECURSIVE_STRUCT_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::WeakStatementRef& id;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_RECURSIVE_STRUCT_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_RECURSIVE_STRUCT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& id = instance_name.id;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Type_RECURSIVE_STRUCT_after : ebmcodegen::util::ContextBase<Context_Type_RECURSIVE_STRUCT_after<Result>> {
        constexpr static std::string_view context_name = "Type_RECURSIVE_STRUCT_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::WeakStatementRef& id;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_RECURSIVE_STRUCT_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_RECURSIVE_STRUCT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& id = instance_name.id;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_BOOL : ebmcodegen::util::ContextBase<Context_Type_BOOL> {
        constexpr static std::string_view context_name = "Type_BOOL";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    struct VisitorTag_Type_BOOL {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_BOOL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;
    template <typename Result>
    struct Context_Type_BOOL_before : ebmcodegen::util::ContextBase<Context_Type_BOOL_before<Result>> {
        constexpr static std::string_view context_name = "Type_BOOL_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_BOOL_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_BOOL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Type_BOOL_after : ebmcodegen::util::ContextBase<Context_Type_BOOL_after<Result>> {
        constexpr static std::string_view context_name = "Type_BOOL_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_BOOL_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_BOOL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_VOID : ebmcodegen::util::ContextBase<Context_Type_VOID> {
        constexpr static std::string_view context_name = "Type_VOID";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    struct VisitorTag_Type_VOID {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_VOID(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;
    template <typename Result>
    struct Context_Type_VOID_before : ebmcodegen::util::ContextBase<Context_Type_VOID_before<Result>> {
        constexpr static std::string_view context_name = "Type_VOID_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_VOID_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_VOID_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Type_VOID_after : ebmcodegen::util::ContextBase<Context_Type_VOID_after<Result>> {
        constexpr static std::string_view context_name = "Type_VOID_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_VOID_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_VOID_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_META : ebmcodegen::util::ContextBase<Context_Type_META> {
        constexpr static std::string_view context_name = "Type_META";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    struct VisitorTag_Type_META {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_META(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;
    template <typename Result>
    struct Context_Type_META_before : ebmcodegen::util::ContextBase<Context_Type_META_before<Result>> {
        constexpr static std::string_view context_name = "Type_META_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_META_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_META_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Type_META_after : ebmcodegen::util::ContextBase<Context_Type_META_after<Result>> {
        constexpr static std::string_view context_name = "Type_META_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_META_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_META_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_ENUM : ebmcodegen::util::ContextBase<Context_Type_ENUM> {
        constexpr static std::string_view context_name = "Type_ENUM";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& base_type;
        const ebm::WeakStatementRef& id;
    };
    struct VisitorTag_Type_ENUM {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_ENUM(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& base_type = instance_name.base_type;auto& id = instance_name.id;
    template <typename Result>
    struct Context_Type_ENUM_before : ebmcodegen::util::ContextBase<Context_Type_ENUM_before<Result>> {
        constexpr static std::string_view context_name = "Type_ENUM_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& base_type;
        const ebm::WeakStatementRef& id;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_ENUM_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_ENUM_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& base_type = instance_name.base_type;auto& id = instance_name.id;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Type_ENUM_after : ebmcodegen::util::ContextBase<Context_Type_ENUM_after<Result>> {
        constexpr static std::string_view context_name = "Type_ENUM_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& base_type;
        const ebm::WeakStatementRef& id;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_ENUM_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_ENUM_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& base_type = instance_name.base_type;auto& id = instance_name.id;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_ARRAY : ebmcodegen::util::ContextBase<Context_Type_ARRAY> {
        constexpr static std::string_view context_name = "Type_ARRAY";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::ArrayAnnotation& array_annotation;
        const ebm::TypeRef& element_type;
        const ebm::Varint& length;
    };
    struct VisitorTag_Type_ARRAY {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_ARRAY(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& array_annotation = instance_name.array_annotation;auto& element_type = instance_name.element_type;auto& length = instance_name.length;
    template <typename Result>
    struct Context_Type_ARRAY_before : ebmcodegen::util::ContextBase<Context_Type_ARRAY_before<Result>> {
        constexpr static std::string_view context_name = "Type_ARRAY_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::ArrayAnnotation& array_annotation;
        const ebm::TypeRef& element_type;
        const ebm::Varint& length;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_ARRAY_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_ARRAY_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& array_annotation = instance_name.array_annotation;auto& element_type = instance_name.element_type;auto& length = instance_name.length;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Type_ARRAY_after : ebmcodegen::util::ContextBase<Context_Type_ARRAY_after<Result>> {
        constexpr static std::string_view context_name = "Type_ARRAY_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::ArrayAnnotation& array_annotation;
        const ebm::TypeRef& element_type;
        const ebm::Varint& length;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_ARRAY_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_ARRAY_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& array_annotation = instance_name.array_annotation;auto& element_type = instance_name.element_type;auto& length = instance_name.length;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_VECTOR : ebmcodegen::util::ContextBase<Context_Type_VECTOR> {
        constexpr static std::string_view context_name = "Type_VECTOR";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& element_type;
    };
    struct VisitorTag_Type_VECTOR {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_VECTOR(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& element_type = instance_name.element_type;
    template <typename Result>
    struct Context_Type_VECTOR_before : ebmcodegen::util::ContextBase<Context_Type_VECTOR_before<Result>> {
        constexpr static std::string_view context_name = "Type_VECTOR_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& element_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_VECTOR_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_VECTOR_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& element_type = instance_name.element_type;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Type_VECTOR_after : ebmcodegen::util::ContextBase<Context_Type_VECTOR_after<Result>> {
        constexpr static std::string_view context_name = "Type_VECTOR_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& element_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_VECTOR_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_VECTOR_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& element_type = instance_name.element_type;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_VARIANT : ebmcodegen::util::ContextBase<Context_Type_VARIANT> {
        constexpr static std::string_view context_name = "Type_VARIANT";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::VariantDesc& variant_desc;
    };
    struct VisitorTag_Type_VARIANT {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_VARIANT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& variant_desc = instance_name.variant_desc;
    template <typename Result>
    struct Context_Type_VARIANT_before : ebmcodegen::util::ContextBase<Context_Type_VARIANT_before<Result>> {
        constexpr static std::string_view context_name = "Type_VARIANT_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::VariantDesc& variant_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_VARIANT_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_VARIANT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& variant_desc = instance_name.variant_desc;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Type_VARIANT_after : ebmcodegen::util::ContextBase<Context_Type_VARIANT_after<Result>> {
        constexpr static std::string_view context_name = "Type_VARIANT_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::VariantDesc& variant_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_VARIANT_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_VARIANT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& variant_desc = instance_name.variant_desc;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_RANGE : ebmcodegen::util::ContextBase<Context_Type_RANGE> {
        constexpr static std::string_view context_name = "Type_RANGE";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& base_type;
    };
    struct VisitorTag_Type_RANGE {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_RANGE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& base_type = instance_name.base_type;
    template <typename Result>
    struct Context_Type_RANGE_before : ebmcodegen::util::ContextBase<Context_Type_RANGE_before<Result>> {
        constexpr static std::string_view context_name = "Type_RANGE_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& base_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_RANGE_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_RANGE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& base_type = instance_name.base_type;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Type_RANGE_after : ebmcodegen::util::ContextBase<Context_Type_RANGE_after<Result>> {
        constexpr static std::string_view context_name = "Type_RANGE_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& base_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_RANGE_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_RANGE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& base_type = instance_name.base_type;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_ENCODER_RETURN : ebmcodegen::util::ContextBase<Context_Type_ENCODER_RETURN> {
        constexpr static std::string_view context_name = "Type_ENCODER_RETURN";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    struct VisitorTag_Type_ENCODER_RETURN {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_ENCODER_RETURN(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;
    template <typename Result>
    struct Context_Type_ENCODER_RETURN_before : ebmcodegen::util::ContextBase<Context_Type_ENCODER_RETURN_before<Result>> {
        constexpr static std::string_view context_name = "Type_ENCODER_RETURN_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_ENCODER_RETURN_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_ENCODER_RETURN_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Type_ENCODER_RETURN_after : ebmcodegen::util::ContextBase<Context_Type_ENCODER_RETURN_after<Result>> {
        constexpr static std::string_view context_name = "Type_ENCODER_RETURN_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_ENCODER_RETURN_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_ENCODER_RETURN_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_DECODER_RETURN : ebmcodegen::util::ContextBase<Context_Type_DECODER_RETURN> {
        constexpr static std::string_view context_name = "Type_DECODER_RETURN";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    struct VisitorTag_Type_DECODER_RETURN {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_DECODER_RETURN(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;
    template <typename Result>
    struct Context_Type_DECODER_RETURN_before : ebmcodegen::util::ContextBase<Context_Type_DECODER_RETURN_before<Result>> {
        constexpr static std::string_view context_name = "Type_DECODER_RETURN_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_DECODER_RETURN_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_DECODER_RETURN_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Type_DECODER_RETURN_after : ebmcodegen::util::ContextBase<Context_Type_DECODER_RETURN_after<Result>> {
        constexpr static std::string_view context_name = "Type_DECODER_RETURN_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_DECODER_RETURN_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_DECODER_RETURN_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_ENCODER_INPUT : ebmcodegen::util::ContextBase<Context_Type_ENCODER_INPUT> {
        constexpr static std::string_view context_name = "Type_ENCODER_INPUT";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    struct VisitorTag_Type_ENCODER_INPUT {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_ENCODER_INPUT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;
    template <typename Result>
    struct Context_Type_ENCODER_INPUT_before : ebmcodegen::util::ContextBase<Context_Type_ENCODER_INPUT_before<Result>> {
        constexpr static std::string_view context_name = "Type_ENCODER_INPUT_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_ENCODER_INPUT_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_ENCODER_INPUT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Type_ENCODER_INPUT_after : ebmcodegen::util::ContextBase<Context_Type_ENCODER_INPUT_after<Result>> {
        constexpr static std::string_view context_name = "Type_ENCODER_INPUT_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_ENCODER_INPUT_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_ENCODER_INPUT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_DECODER_INPUT : ebmcodegen::util::ContextBase<Context_Type_DECODER_INPUT> {
        constexpr static std::string_view context_name = "Type_DECODER_INPUT";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    struct VisitorTag_Type_DECODER_INPUT {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_DECODER_INPUT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;
    template <typename Result>
    struct Context_Type_DECODER_INPUT_before : ebmcodegen::util::ContextBase<Context_Type_DECODER_INPUT_before<Result>> {
        constexpr static std::string_view context_name = "Type_DECODER_INPUT_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_DECODER_INPUT_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_DECODER_INPUT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Type_DECODER_INPUT_after : ebmcodegen::util::ContextBase<Context_Type_DECODER_INPUT_after<Result>> {
        constexpr static std::string_view context_name = "Type_DECODER_INPUT_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_DECODER_INPUT_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_DECODER_INPUT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_PROPERTY_SETTER_RETURN : ebmcodegen::util::ContextBase<Context_Type_PROPERTY_SETTER_RETURN> {
        constexpr static std::string_view context_name = "Type_PROPERTY_SETTER_RETURN";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    struct VisitorTag_Type_PROPERTY_SETTER_RETURN {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_PROPERTY_SETTER_RETURN(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;
    template <typename Result>
    struct Context_Type_PROPERTY_SETTER_RETURN_before : ebmcodegen::util::ContextBase<Context_Type_PROPERTY_SETTER_RETURN_before<Result>> {
        constexpr static std::string_view context_name = "Type_PROPERTY_SETTER_RETURN_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_PROPERTY_SETTER_RETURN_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_PROPERTY_SETTER_RETURN_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Type_PROPERTY_SETTER_RETURN_after : ebmcodegen::util::ContextBase<Context_Type_PROPERTY_SETTER_RETURN_after<Result>> {
        constexpr static std::string_view context_name = "Type_PROPERTY_SETTER_RETURN_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_PROPERTY_SETTER_RETURN_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_PROPERTY_SETTER_RETURN_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_OPTIONAL : ebmcodegen::util::ContextBase<Context_Type_OPTIONAL> {
        constexpr static std::string_view context_name = "Type_OPTIONAL";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& inner_type;
    };
    struct VisitorTag_Type_OPTIONAL {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_OPTIONAL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& inner_type = instance_name.inner_type;
    template <typename Result>
    struct Context_Type_OPTIONAL_before : ebmcodegen::util::ContextBase<Context_Type_OPTIONAL_before<Result>> {
        constexpr static std::string_view context_name = "Type_OPTIONAL_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& inner_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_OPTIONAL_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_OPTIONAL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& inner_type = instance_name.inner_type;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Type_OPTIONAL_after : ebmcodegen::util::ContextBase<Context_Type_OPTIONAL_after<Result>> {
        constexpr static std::string_view context_name = "Type_OPTIONAL_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& inner_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_OPTIONAL_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_OPTIONAL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& inner_type = instance_name.inner_type;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_PTR : ebmcodegen::util::ContextBase<Context_Type_PTR> {
        constexpr static std::string_view context_name = "Type_PTR";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& pointee_type;
    };
    struct VisitorTag_Type_PTR {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_PTR(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& pointee_type = instance_name.pointee_type;
    template <typename Result>
    struct Context_Type_PTR_before : ebmcodegen::util::ContextBase<Context_Type_PTR_before<Result>> {
        constexpr static std::string_view context_name = "Type_PTR_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& pointee_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_PTR_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_PTR_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& pointee_type = instance_name.pointee_type;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Type_PTR_after : ebmcodegen::util::ContextBase<Context_Type_PTR_after<Result>> {
        constexpr static std::string_view context_name = "Type_PTR_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& pointee_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_PTR_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_PTR_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& pointee_type = instance_name.pointee_type;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_FUNCTION : ebmcodegen::util::ContextBase<Context_Type_FUNCTION> {
        constexpr static std::string_view context_name = "Type_FUNCTION";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::FuncTypeDesc& func_desc;
    };
    struct VisitorTag_Type_FUNCTION {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_FUNCTION(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& func_desc = instance_name.func_desc;
    template <typename Result>
    struct Context_Type_FUNCTION_before : ebmcodegen::util::ContextBase<Context_Type_FUNCTION_before<Result>> {
        constexpr static std::string_view context_name = "Type_FUNCTION_before";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::FuncTypeDesc& func_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_FUNCTION_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_FUNCTION_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& func_desc = instance_name.func_desc;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Type_FUNCTION_after : ebmcodegen::util::ContextBase<Context_Type_FUNCTION_after<Result>> {
        constexpr static std::string_view context_name = "Type_FUNCTION_after";
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::FuncTypeDesc& func_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_FUNCTION_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_FUNCTION_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& func_desc = instance_name.func_desc;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type : ebmcodegen::util::ContextBase<Context_Type> {
        constexpr static std::string_view context_name = "Type";
        BaseVisitor& visitor;
        const ebm::Type& in;
        ebm::TypeRef alias_ref;
    };
    struct VisitorTag_Type {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& alias_ref = instance_name.alias_ref;
    template <typename Result>
    struct Context_Type_before : ebmcodegen::util::ContextBase<Context_Type_before<Result>> {
        constexpr static std::string_view context_name = "Type_before";
        BaseVisitor& visitor;
        const ebm::Type& in;
        ebm::TypeRef alias_ref;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& alias_ref = instance_name.alias_ref;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Type_after : ebmcodegen::util::ContextBase<Context_Type_after<Result>> {
        constexpr static std::string_view context_name = "Type_after";
        BaseVisitor& visitor;
        const ebm::Type& in;
        ebm::TypeRef alias_ref;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& alias_ref = instance_name.alias_ref;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Types : ebmcodegen::util::ContextBase<Context_Types> {
        constexpr static std::string_view context_name = "Types";
        BaseVisitor& visitor;
        const ebm::Types& in;
    };
    struct VisitorTag_Types {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPES(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;
    template <typename Result>
    struct Context_Types_before : ebmcodegen::util::ContextBase<Context_Types_before<Result>> {
        constexpr static std::string_view context_name = "Types_before";
        BaseVisitor& visitor;
        const ebm::Types& in;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Types_before {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPES_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& main_logic = instance_name.main_logic;
    template <typename Result>
    struct Context_Types_after : ebmcodegen::util::ContextBase<Context_Types_after<Result>> {
        constexpr static std::string_view context_name = "Types_after";
        BaseVisitor& visitor;
        const ebm::Types& in;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Types_after {};
    // Deconstruct context fields
    #define EBM2P4_DECONSTRUCT_TYPES_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    #define EBM2P4_CODEGEN_VISITOR_entry ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_entry>>
    #define EBM2P4_CODEGEN_CONTEXT_entry ebm2p4::Context_entry
    #define EBM2P4_CODEGEN_VISITOR_entry_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_entry_before>>
    #define EBM2P4_CODEGEN_CONTEXT_entry_before ebm2p4::Context_entry_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_entry_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_entry_after>>
    #define EBM2P4_CODEGEN_CONTEXT_entry_after ebm2p4::Context_entry_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_pre_visitor ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_pre_visitor>>
    #define EBM2P4_CODEGEN_CONTEXT_pre_visitor ebm2p4::Context_pre_visitor
    #define EBM2P4_CODEGEN_VISITOR_pre_visitor_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_pre_visitor_before>>
    #define EBM2P4_CODEGEN_CONTEXT_pre_visitor_before ebm2p4::Context_pre_visitor_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_pre_visitor_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_pre_visitor_after>>
    #define EBM2P4_CODEGEN_CONTEXT_pre_visitor_after ebm2p4::Context_pre_visitor_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_post_entry ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_post_entry>>
    #define EBM2P4_CODEGEN_CONTEXT_post_entry ebm2p4::Context_post_entry<Result>
    #define EBM2P4_CODEGEN_VISITOR_post_entry_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_post_entry_before>>
    #define EBM2P4_CODEGEN_CONTEXT_post_entry_before ebm2p4::Context_post_entry_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_post_entry_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_post_entry_after>>
    #define EBM2P4_CODEGEN_CONTEXT_post_entry_after ebm2p4::Context_post_entry_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_BLOCK ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_BLOCK>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_BLOCK ebm2p4::Context_Statement_BLOCK
    #define EBM2P4_CODEGEN_VISITOR_Statement_BLOCK_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_BLOCK_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_BLOCK_before ebm2p4::Context_Statement_BLOCK_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_BLOCK_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_BLOCK_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_BLOCK_after ebm2p4::Context_Statement_BLOCK_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_ASSIGNMENT ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_ASSIGNMENT>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_ASSIGNMENT ebm2p4::Context_Statement_ASSIGNMENT
    #define EBM2P4_CODEGEN_VISITOR_Statement_ASSIGNMENT_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_ASSIGNMENT_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_ASSIGNMENT_before ebm2p4::Context_Statement_ASSIGNMENT_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_ASSIGNMENT_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_ASSIGNMENT_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_ASSIGNMENT_after ebm2p4::Context_Statement_ASSIGNMENT_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_YIELD ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_YIELD>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_YIELD ebm2p4::Context_Statement_YIELD
    #define EBM2P4_CODEGEN_VISITOR_Statement_YIELD_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_YIELD_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_YIELD_before ebm2p4::Context_Statement_YIELD_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_YIELD_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_YIELD_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_YIELD_after ebm2p4::Context_Statement_YIELD_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_APPEND ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_APPEND>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_APPEND ebm2p4::Context_Statement_APPEND
    #define EBM2P4_CODEGEN_VISITOR_Statement_APPEND_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_APPEND_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_APPEND_before ebm2p4::Context_Statement_APPEND_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_APPEND_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_APPEND_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_APPEND_after ebm2p4::Context_Statement_APPEND_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_RETURN ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_RETURN>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_RETURN ebm2p4::Context_Statement_RETURN
    #define EBM2P4_CODEGEN_VISITOR_Statement_RETURN_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_RETURN_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_RETURN_before ebm2p4::Context_Statement_RETURN_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_RETURN_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_RETURN_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_RETURN_after ebm2p4::Context_Statement_RETURN_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_ERROR_RETURN ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_ERROR_RETURN>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_ERROR_RETURN ebm2p4::Context_Statement_ERROR_RETURN
    #define EBM2P4_CODEGEN_VISITOR_Statement_ERROR_RETURN_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_ERROR_RETURN_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_ERROR_RETURN_before ebm2p4::Context_Statement_ERROR_RETURN_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_ERROR_RETURN_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_ERROR_RETURN_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_ERROR_RETURN_after ebm2p4::Context_Statement_ERROR_RETURN_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_ASSERT ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_ASSERT>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_ASSERT ebm2p4::Context_Statement_ASSERT
    #define EBM2P4_CODEGEN_VISITOR_Statement_ASSERT_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_ASSERT_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_ASSERT_before ebm2p4::Context_Statement_ASSERT_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_ASSERT_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_ASSERT_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_ASSERT_after ebm2p4::Context_Statement_ASSERT_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_READ_DATA ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_READ_DATA>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_READ_DATA ebm2p4::Context_Statement_READ_DATA
    #define EBM2P4_CODEGEN_VISITOR_Statement_READ_DATA_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_READ_DATA_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_READ_DATA_before ebm2p4::Context_Statement_READ_DATA_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_READ_DATA_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_READ_DATA_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_READ_DATA_after ebm2p4::Context_Statement_READ_DATA_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_WRITE_DATA ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_WRITE_DATA>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_WRITE_DATA ebm2p4::Context_Statement_WRITE_DATA
    #define EBM2P4_CODEGEN_VISITOR_Statement_WRITE_DATA_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_WRITE_DATA_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_WRITE_DATA_before ebm2p4::Context_Statement_WRITE_DATA_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_WRITE_DATA_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_WRITE_DATA_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_WRITE_DATA_after ebm2p4::Context_Statement_WRITE_DATA_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_RESERVE_DATA ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_RESERVE_DATA>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_RESERVE_DATA ebm2p4::Context_Statement_RESERVE_DATA
    #define EBM2P4_CODEGEN_VISITOR_Statement_RESERVE_DATA_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_RESERVE_DATA_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_RESERVE_DATA_before ebm2p4::Context_Statement_RESERVE_DATA_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_RESERVE_DATA_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_RESERVE_DATA_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_RESERVE_DATA_after ebm2p4::Context_Statement_RESERVE_DATA_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_IF_STATEMENT ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_IF_STATEMENT>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_IF_STATEMENT ebm2p4::Context_Statement_IF_STATEMENT
    #define EBM2P4_CODEGEN_VISITOR_Statement_IF_STATEMENT_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_IF_STATEMENT_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_IF_STATEMENT_before ebm2p4::Context_Statement_IF_STATEMENT_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_IF_STATEMENT_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_IF_STATEMENT_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_IF_STATEMENT_after ebm2p4::Context_Statement_IF_STATEMENT_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_LOOP_STATEMENT ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_LOOP_STATEMENT>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_LOOP_STATEMENT ebm2p4::Context_Statement_LOOP_STATEMENT
    #define EBM2P4_CODEGEN_VISITOR_Statement_LOOP_STATEMENT_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_LOOP_STATEMENT_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_LOOP_STATEMENT_before ebm2p4::Context_Statement_LOOP_STATEMENT_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_LOOP_STATEMENT_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_LOOP_STATEMENT_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_LOOP_STATEMENT_after ebm2p4::Context_Statement_LOOP_STATEMENT_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_MATCH_STATEMENT ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_MATCH_STATEMENT>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_MATCH_STATEMENT ebm2p4::Context_Statement_MATCH_STATEMENT
    #define EBM2P4_CODEGEN_VISITOR_Statement_MATCH_STATEMENT_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_MATCH_STATEMENT_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_MATCH_STATEMENT_before ebm2p4::Context_Statement_MATCH_STATEMENT_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_MATCH_STATEMENT_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_MATCH_STATEMENT_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_MATCH_STATEMENT_after ebm2p4::Context_Statement_MATCH_STATEMENT_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_MATCH_BRANCH ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_MATCH_BRANCH>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_MATCH_BRANCH ebm2p4::Context_Statement_MATCH_BRANCH
    #define EBM2P4_CODEGEN_VISITOR_Statement_MATCH_BRANCH_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_MATCH_BRANCH_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_MATCH_BRANCH_before ebm2p4::Context_Statement_MATCH_BRANCH_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_MATCH_BRANCH_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_MATCH_BRANCH_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_MATCH_BRANCH_after ebm2p4::Context_Statement_MATCH_BRANCH_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_BREAK ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_BREAK>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_BREAK ebm2p4::Context_Statement_BREAK
    #define EBM2P4_CODEGEN_VISITOR_Statement_BREAK_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_BREAK_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_BREAK_before ebm2p4::Context_Statement_BREAK_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_BREAK_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_BREAK_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_BREAK_after ebm2p4::Context_Statement_BREAK_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_CONTINUE ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_CONTINUE>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_CONTINUE ebm2p4::Context_Statement_CONTINUE
    #define EBM2P4_CODEGEN_VISITOR_Statement_CONTINUE_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_CONTINUE_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_CONTINUE_before ebm2p4::Context_Statement_CONTINUE_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_CONTINUE_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_CONTINUE_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_CONTINUE_after ebm2p4::Context_Statement_CONTINUE_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_FUNCTION_DECL ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_FUNCTION_DECL>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_FUNCTION_DECL ebm2p4::Context_Statement_FUNCTION_DECL
    #define EBM2P4_CODEGEN_VISITOR_Statement_FUNCTION_DECL_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_FUNCTION_DECL_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_FUNCTION_DECL_before ebm2p4::Context_Statement_FUNCTION_DECL_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_FUNCTION_DECL_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_FUNCTION_DECL_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_FUNCTION_DECL_after ebm2p4::Context_Statement_FUNCTION_DECL_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_VARIABLE_DECL ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_VARIABLE_DECL>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_VARIABLE_DECL ebm2p4::Context_Statement_VARIABLE_DECL
    #define EBM2P4_CODEGEN_VISITOR_Statement_VARIABLE_DECL_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_VARIABLE_DECL_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_VARIABLE_DECL_before ebm2p4::Context_Statement_VARIABLE_DECL_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_VARIABLE_DECL_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_VARIABLE_DECL_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_VARIABLE_DECL_after ebm2p4::Context_Statement_VARIABLE_DECL_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_PARAMETER_DECL ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_PARAMETER_DECL>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_PARAMETER_DECL ebm2p4::Context_Statement_PARAMETER_DECL
    #define EBM2P4_CODEGEN_VISITOR_Statement_PARAMETER_DECL_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_PARAMETER_DECL_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_PARAMETER_DECL_before ebm2p4::Context_Statement_PARAMETER_DECL_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_PARAMETER_DECL_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_PARAMETER_DECL_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_PARAMETER_DECL_after ebm2p4::Context_Statement_PARAMETER_DECL_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_FIELD_DECL ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_FIELD_DECL>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_FIELD_DECL ebm2p4::Context_Statement_FIELD_DECL
    #define EBM2P4_CODEGEN_VISITOR_Statement_FIELD_DECL_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_FIELD_DECL_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_FIELD_DECL_before ebm2p4::Context_Statement_FIELD_DECL_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_FIELD_DECL_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_FIELD_DECL_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_FIELD_DECL_after ebm2p4::Context_Statement_FIELD_DECL_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_COMPOSITE_FIELD_DECL ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_COMPOSITE_FIELD_DECL>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_COMPOSITE_FIELD_DECL ebm2p4::Context_Statement_COMPOSITE_FIELD_DECL
    #define EBM2P4_CODEGEN_VISITOR_Statement_COMPOSITE_FIELD_DECL_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_COMPOSITE_FIELD_DECL_before ebm2p4::Context_Statement_COMPOSITE_FIELD_DECL_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_COMPOSITE_FIELD_DECL_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_COMPOSITE_FIELD_DECL_after ebm2p4::Context_Statement_COMPOSITE_FIELD_DECL_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_ENUM_DECL ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_ENUM_DECL>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_ENUM_DECL ebm2p4::Context_Statement_ENUM_DECL
    #define EBM2P4_CODEGEN_VISITOR_Statement_ENUM_DECL_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_ENUM_DECL_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_ENUM_DECL_before ebm2p4::Context_Statement_ENUM_DECL_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_ENUM_DECL_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_ENUM_DECL_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_ENUM_DECL_after ebm2p4::Context_Statement_ENUM_DECL_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_ENUM_MEMBER_DECL ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_ENUM_MEMBER_DECL>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_ENUM_MEMBER_DECL ebm2p4::Context_Statement_ENUM_MEMBER_DECL
    #define EBM2P4_CODEGEN_VISITOR_Statement_ENUM_MEMBER_DECL_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_ENUM_MEMBER_DECL_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_ENUM_MEMBER_DECL_before ebm2p4::Context_Statement_ENUM_MEMBER_DECL_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_ENUM_MEMBER_DECL_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_ENUM_MEMBER_DECL_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_ENUM_MEMBER_DECL_after ebm2p4::Context_Statement_ENUM_MEMBER_DECL_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_STRUCT_DECL ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_STRUCT_DECL>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_STRUCT_DECL ebm2p4::Context_Statement_STRUCT_DECL
    #define EBM2P4_CODEGEN_VISITOR_Statement_STRUCT_DECL_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_STRUCT_DECL_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_STRUCT_DECL_before ebm2p4::Context_Statement_STRUCT_DECL_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_STRUCT_DECL_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_STRUCT_DECL_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_STRUCT_DECL_after ebm2p4::Context_Statement_STRUCT_DECL_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_UNION_DECL ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_UNION_DECL>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_UNION_DECL ebm2p4::Context_Statement_UNION_DECL
    #define EBM2P4_CODEGEN_VISITOR_Statement_UNION_DECL_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_UNION_DECL_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_UNION_DECL_before ebm2p4::Context_Statement_UNION_DECL_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_UNION_DECL_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_UNION_DECL_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_UNION_DECL_after ebm2p4::Context_Statement_UNION_DECL_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_UNION_MEMBER_DECL ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_UNION_MEMBER_DECL>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_UNION_MEMBER_DECL ebm2p4::Context_Statement_UNION_MEMBER_DECL
    #define EBM2P4_CODEGEN_VISITOR_Statement_UNION_MEMBER_DECL_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_UNION_MEMBER_DECL_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_UNION_MEMBER_DECL_before ebm2p4::Context_Statement_UNION_MEMBER_DECL_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_UNION_MEMBER_DECL_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_UNION_MEMBER_DECL_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_UNION_MEMBER_DECL_after ebm2p4::Context_Statement_UNION_MEMBER_DECL_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_PROGRAM_DECL ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_PROGRAM_DECL>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_PROGRAM_DECL ebm2p4::Context_Statement_PROGRAM_DECL
    #define EBM2P4_CODEGEN_VISITOR_Statement_PROGRAM_DECL_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_PROGRAM_DECL_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_PROGRAM_DECL_before ebm2p4::Context_Statement_PROGRAM_DECL_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_PROGRAM_DECL_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_PROGRAM_DECL_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_PROGRAM_DECL_after ebm2p4::Context_Statement_PROGRAM_DECL_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_PROPERTY_DECL ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_PROPERTY_DECL>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_PROPERTY_DECL ebm2p4::Context_Statement_PROPERTY_DECL
    #define EBM2P4_CODEGEN_VISITOR_Statement_PROPERTY_DECL_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_PROPERTY_DECL_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_PROPERTY_DECL_before ebm2p4::Context_Statement_PROPERTY_DECL_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_PROPERTY_DECL_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_PROPERTY_DECL_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_PROPERTY_DECL_after ebm2p4::Context_Statement_PROPERTY_DECL_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_PROPERTY_MEMBER_DECL ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_PROPERTY_MEMBER_DECL>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_PROPERTY_MEMBER_DECL ebm2p4::Context_Statement_PROPERTY_MEMBER_DECL
    #define EBM2P4_CODEGEN_VISITOR_Statement_PROPERTY_MEMBER_DECL_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_PROPERTY_MEMBER_DECL_before ebm2p4::Context_Statement_PROPERTY_MEMBER_DECL_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_PROPERTY_MEMBER_DECL_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_PROPERTY_MEMBER_DECL_after ebm2p4::Context_Statement_PROPERTY_MEMBER_DECL_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_METADATA ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_METADATA>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_METADATA ebm2p4::Context_Statement_METADATA
    #define EBM2P4_CODEGEN_VISITOR_Statement_METADATA_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_METADATA_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_METADATA_before ebm2p4::Context_Statement_METADATA_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_METADATA_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_METADATA_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_METADATA_after ebm2p4::Context_Statement_METADATA_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_IMPORT_MODULE ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_IMPORT_MODULE>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_IMPORT_MODULE ebm2p4::Context_Statement_IMPORT_MODULE
    #define EBM2P4_CODEGEN_VISITOR_Statement_IMPORT_MODULE_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_IMPORT_MODULE_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_IMPORT_MODULE_before ebm2p4::Context_Statement_IMPORT_MODULE_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_IMPORT_MODULE_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_IMPORT_MODULE_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_IMPORT_MODULE_after ebm2p4::Context_Statement_IMPORT_MODULE_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_EXPRESSION ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_EXPRESSION>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_EXPRESSION ebm2p4::Context_Statement_EXPRESSION
    #define EBM2P4_CODEGEN_VISITOR_Statement_EXPRESSION_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_EXPRESSION_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_EXPRESSION_before ebm2p4::Context_Statement_EXPRESSION_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_EXPRESSION_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_EXPRESSION_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_EXPRESSION_after ebm2p4::Context_Statement_EXPRESSION_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_ERROR_REPORT ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_ERROR_REPORT>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_ERROR_REPORT ebm2p4::Context_Statement_ERROR_REPORT
    #define EBM2P4_CODEGEN_VISITOR_Statement_ERROR_REPORT_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_ERROR_REPORT_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_ERROR_REPORT_before ebm2p4::Context_Statement_ERROR_REPORT_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_ERROR_REPORT_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_ERROR_REPORT_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_ERROR_REPORT_after ebm2p4::Context_Statement_ERROR_REPORT_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_LOWERED_IO_STATEMENTS ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_LOWERED_IO_STATEMENTS>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_LOWERED_IO_STATEMENTS ebm2p4::Context_Statement_LOWERED_IO_STATEMENTS
    #define EBM2P4_CODEGEN_VISITOR_Statement_LOWERED_IO_STATEMENTS_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_LOWERED_IO_STATEMENTS_before ebm2p4::Context_Statement_LOWERED_IO_STATEMENTS_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_LOWERED_IO_STATEMENTS_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_LOWERED_IO_STATEMENTS_after ebm2p4::Context_Statement_LOWERED_IO_STATEMENTS_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_SUB_BYTE_RANGE ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_SUB_BYTE_RANGE>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_SUB_BYTE_RANGE ebm2p4::Context_Statement_SUB_BYTE_RANGE
    #define EBM2P4_CODEGEN_VISITOR_Statement_SUB_BYTE_RANGE_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_SUB_BYTE_RANGE_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_SUB_BYTE_RANGE_before ebm2p4::Context_Statement_SUB_BYTE_RANGE_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_SUB_BYTE_RANGE_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_SUB_BYTE_RANGE_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_SUB_BYTE_RANGE_after ebm2p4::Context_Statement_SUB_BYTE_RANGE_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_INIT_CHECK ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_INIT_CHECK>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_INIT_CHECK ebm2p4::Context_Statement_INIT_CHECK
    #define EBM2P4_CODEGEN_VISITOR_Statement_INIT_CHECK_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_INIT_CHECK_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_INIT_CHECK_before ebm2p4::Context_Statement_INIT_CHECK_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_INIT_CHECK_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_INIT_CHECK_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_INIT_CHECK_after ebm2p4::Context_Statement_INIT_CHECK_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_ENDIAN_VARIABLE ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_ENDIAN_VARIABLE>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_ENDIAN_VARIABLE ebm2p4::Context_Statement_ENDIAN_VARIABLE
    #define EBM2P4_CODEGEN_VISITOR_Statement_ENDIAN_VARIABLE_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_ENDIAN_VARIABLE_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_ENDIAN_VARIABLE_before ebm2p4::Context_Statement_ENDIAN_VARIABLE_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_ENDIAN_VARIABLE_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_ENDIAN_VARIABLE_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_ENDIAN_VARIABLE_after ebm2p4::Context_Statement_ENDIAN_VARIABLE_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_dispatch ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_dispatch ebm2p4::Context_Statement
    #define EBM2P4_CODEGEN_VISITOR_Statement_before_dispatch ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_before_dispatch ebm2p4::Context_Statement_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Statement_after_dispatch ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Statement_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Statement_after_dispatch ebm2p4::Context_Statement_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Block ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Block>>
    #define EBM2P4_CODEGEN_CONTEXT_Block ebm2p4::Context_Block
    #define EBM2P4_CODEGEN_VISITOR_Block_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Block_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Block_before ebm2p4::Context_Block_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Block_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Block_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Block_after ebm2p4::Context_Block_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_LITERAL_INT ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_LITERAL_INT>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_LITERAL_INT ebm2p4::Context_Expression_LITERAL_INT
    #define EBM2P4_CODEGEN_VISITOR_Expression_LITERAL_INT_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_LITERAL_INT_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_LITERAL_INT_before ebm2p4::Context_Expression_LITERAL_INT_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_LITERAL_INT_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_LITERAL_INT_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_LITERAL_INT_after ebm2p4::Context_Expression_LITERAL_INT_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_LITERAL_INT64 ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_LITERAL_INT64>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_LITERAL_INT64 ebm2p4::Context_Expression_LITERAL_INT64
    #define EBM2P4_CODEGEN_VISITOR_Expression_LITERAL_INT64_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_LITERAL_INT64_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_LITERAL_INT64_before ebm2p4::Context_Expression_LITERAL_INT64_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_LITERAL_INT64_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_LITERAL_INT64_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_LITERAL_INT64_after ebm2p4::Context_Expression_LITERAL_INT64_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_LITERAL_BOOL ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_LITERAL_BOOL>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_LITERAL_BOOL ebm2p4::Context_Expression_LITERAL_BOOL
    #define EBM2P4_CODEGEN_VISITOR_Expression_LITERAL_BOOL_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_LITERAL_BOOL_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_LITERAL_BOOL_before ebm2p4::Context_Expression_LITERAL_BOOL_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_LITERAL_BOOL_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_LITERAL_BOOL_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_LITERAL_BOOL_after ebm2p4::Context_Expression_LITERAL_BOOL_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_LITERAL_STRING ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_LITERAL_STRING>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_LITERAL_STRING ebm2p4::Context_Expression_LITERAL_STRING
    #define EBM2P4_CODEGEN_VISITOR_Expression_LITERAL_STRING_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_LITERAL_STRING_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_LITERAL_STRING_before ebm2p4::Context_Expression_LITERAL_STRING_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_LITERAL_STRING_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_LITERAL_STRING_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_LITERAL_STRING_after ebm2p4::Context_Expression_LITERAL_STRING_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_LITERAL_TYPE ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_LITERAL_TYPE>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_LITERAL_TYPE ebm2p4::Context_Expression_LITERAL_TYPE
    #define EBM2P4_CODEGEN_VISITOR_Expression_LITERAL_TYPE_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_LITERAL_TYPE_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_LITERAL_TYPE_before ebm2p4::Context_Expression_LITERAL_TYPE_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_LITERAL_TYPE_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_LITERAL_TYPE_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_LITERAL_TYPE_after ebm2p4::Context_Expression_LITERAL_TYPE_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_LITERAL_CHAR ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_LITERAL_CHAR>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_LITERAL_CHAR ebm2p4::Context_Expression_LITERAL_CHAR
    #define EBM2P4_CODEGEN_VISITOR_Expression_LITERAL_CHAR_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_LITERAL_CHAR_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_LITERAL_CHAR_before ebm2p4::Context_Expression_LITERAL_CHAR_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_LITERAL_CHAR_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_LITERAL_CHAR_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_LITERAL_CHAR_after ebm2p4::Context_Expression_LITERAL_CHAR_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_IDENTIFIER ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_IDENTIFIER>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_IDENTIFIER ebm2p4::Context_Expression_IDENTIFIER
    #define EBM2P4_CODEGEN_VISITOR_Expression_IDENTIFIER_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_IDENTIFIER_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_IDENTIFIER_before ebm2p4::Context_Expression_IDENTIFIER_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_IDENTIFIER_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_IDENTIFIER_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_IDENTIFIER_after ebm2p4::Context_Expression_IDENTIFIER_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_BINARY_OP ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_BINARY_OP>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_BINARY_OP ebm2p4::Context_Expression_BINARY_OP
    #define EBM2P4_CODEGEN_VISITOR_Expression_BINARY_OP_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_BINARY_OP_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_BINARY_OP_before ebm2p4::Context_Expression_BINARY_OP_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_BINARY_OP_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_BINARY_OP_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_BINARY_OP_after ebm2p4::Context_Expression_BINARY_OP_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_UNARY_OP ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_UNARY_OP>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_UNARY_OP ebm2p4::Context_Expression_UNARY_OP
    #define EBM2P4_CODEGEN_VISITOR_Expression_UNARY_OP_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_UNARY_OP_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_UNARY_OP_before ebm2p4::Context_Expression_UNARY_OP_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_UNARY_OP_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_UNARY_OP_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_UNARY_OP_after ebm2p4::Context_Expression_UNARY_OP_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_CALL ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_CALL>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_CALL ebm2p4::Context_Expression_CALL
    #define EBM2P4_CODEGEN_VISITOR_Expression_CALL_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_CALL_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_CALL_before ebm2p4::Context_Expression_CALL_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_CALL_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_CALL_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_CALL_after ebm2p4::Context_Expression_CALL_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_INDEX_ACCESS ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_INDEX_ACCESS>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_INDEX_ACCESS ebm2p4::Context_Expression_INDEX_ACCESS
    #define EBM2P4_CODEGEN_VISITOR_Expression_INDEX_ACCESS_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_INDEX_ACCESS_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_INDEX_ACCESS_before ebm2p4::Context_Expression_INDEX_ACCESS_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_INDEX_ACCESS_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_INDEX_ACCESS_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_INDEX_ACCESS_after ebm2p4::Context_Expression_INDEX_ACCESS_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_MEMBER_ACCESS ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_MEMBER_ACCESS>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_MEMBER_ACCESS ebm2p4::Context_Expression_MEMBER_ACCESS
    #define EBM2P4_CODEGEN_VISITOR_Expression_MEMBER_ACCESS_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_MEMBER_ACCESS_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_MEMBER_ACCESS_before ebm2p4::Context_Expression_MEMBER_ACCESS_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_MEMBER_ACCESS_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_MEMBER_ACCESS_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_MEMBER_ACCESS_after ebm2p4::Context_Expression_MEMBER_ACCESS_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_ENUM_MEMBER ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_ENUM_MEMBER>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_ENUM_MEMBER ebm2p4::Context_Expression_ENUM_MEMBER
    #define EBM2P4_CODEGEN_VISITOR_Expression_ENUM_MEMBER_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_ENUM_MEMBER_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_ENUM_MEMBER_before ebm2p4::Context_Expression_ENUM_MEMBER_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_ENUM_MEMBER_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_ENUM_MEMBER_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_ENUM_MEMBER_after ebm2p4::Context_Expression_ENUM_MEMBER_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_TYPE_CAST ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_TYPE_CAST>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_TYPE_CAST ebm2p4::Context_Expression_TYPE_CAST
    #define EBM2P4_CODEGEN_VISITOR_Expression_TYPE_CAST_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_TYPE_CAST_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_TYPE_CAST_before ebm2p4::Context_Expression_TYPE_CAST_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_TYPE_CAST_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_TYPE_CAST_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_TYPE_CAST_after ebm2p4::Context_Expression_TYPE_CAST_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_RANGE ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_RANGE>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_RANGE ebm2p4::Context_Expression_RANGE
    #define EBM2P4_CODEGEN_VISITOR_Expression_RANGE_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_RANGE_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_RANGE_before ebm2p4::Context_Expression_RANGE_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_RANGE_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_RANGE_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_RANGE_after ebm2p4::Context_Expression_RANGE_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_DEFAULT_VALUE ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_DEFAULT_VALUE>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_DEFAULT_VALUE ebm2p4::Context_Expression_DEFAULT_VALUE
    #define EBM2P4_CODEGEN_VISITOR_Expression_DEFAULT_VALUE_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_DEFAULT_VALUE_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_DEFAULT_VALUE_before ebm2p4::Context_Expression_DEFAULT_VALUE_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_DEFAULT_VALUE_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_DEFAULT_VALUE_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_DEFAULT_VALUE_after ebm2p4::Context_Expression_DEFAULT_VALUE_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_IS_LITTLE_ENDIAN ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_IS_LITTLE_ENDIAN>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_IS_LITTLE_ENDIAN ebm2p4::Context_Expression_IS_LITTLE_ENDIAN
    #define EBM2P4_CODEGEN_VISITOR_Expression_IS_LITTLE_ENDIAN_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_IS_LITTLE_ENDIAN_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_IS_LITTLE_ENDIAN_before ebm2p4::Context_Expression_IS_LITTLE_ENDIAN_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_IS_LITTLE_ENDIAN_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_IS_LITTLE_ENDIAN_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_IS_LITTLE_ENDIAN_after ebm2p4::Context_Expression_IS_LITTLE_ENDIAN_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_GET_STREAM_OFFSET ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_GET_STREAM_OFFSET>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_GET_STREAM_OFFSET ebm2p4::Context_Expression_GET_STREAM_OFFSET
    #define EBM2P4_CODEGEN_VISITOR_Expression_GET_STREAM_OFFSET_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_GET_STREAM_OFFSET_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_GET_STREAM_OFFSET_before ebm2p4::Context_Expression_GET_STREAM_OFFSET_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_GET_STREAM_OFFSET_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_GET_STREAM_OFFSET_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_GET_STREAM_OFFSET_after ebm2p4::Context_Expression_GET_STREAM_OFFSET_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_GET_REMAINING_BYTES ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_GET_REMAINING_BYTES>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_GET_REMAINING_BYTES ebm2p4::Context_Expression_GET_REMAINING_BYTES
    #define EBM2P4_CODEGEN_VISITOR_Expression_GET_REMAINING_BYTES_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_GET_REMAINING_BYTES_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_GET_REMAINING_BYTES_before ebm2p4::Context_Expression_GET_REMAINING_BYTES_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_GET_REMAINING_BYTES_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_GET_REMAINING_BYTES_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_GET_REMAINING_BYTES_after ebm2p4::Context_Expression_GET_REMAINING_BYTES_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_CAN_READ_STREAM ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_CAN_READ_STREAM>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_CAN_READ_STREAM ebm2p4::Context_Expression_CAN_READ_STREAM
    #define EBM2P4_CODEGEN_VISITOR_Expression_CAN_READ_STREAM_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_CAN_READ_STREAM_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_CAN_READ_STREAM_before ebm2p4::Context_Expression_CAN_READ_STREAM_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_CAN_READ_STREAM_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_CAN_READ_STREAM_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_CAN_READ_STREAM_after ebm2p4::Context_Expression_CAN_READ_STREAM_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_ARRAY_SIZE ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_ARRAY_SIZE>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_ARRAY_SIZE ebm2p4::Context_Expression_ARRAY_SIZE
    #define EBM2P4_CODEGEN_VISITOR_Expression_ARRAY_SIZE_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_ARRAY_SIZE_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_ARRAY_SIZE_before ebm2p4::Context_Expression_ARRAY_SIZE_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_ARRAY_SIZE_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_ARRAY_SIZE_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_ARRAY_SIZE_after ebm2p4::Context_Expression_ARRAY_SIZE_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_ENUM_IS_DEFINED ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_ENUM_IS_DEFINED>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_ENUM_IS_DEFINED ebm2p4::Context_Expression_ENUM_IS_DEFINED
    #define EBM2P4_CODEGEN_VISITOR_Expression_ENUM_IS_DEFINED_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_ENUM_IS_DEFINED_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_ENUM_IS_DEFINED_before ebm2p4::Context_Expression_ENUM_IS_DEFINED_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_ENUM_IS_DEFINED_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_ENUM_IS_DEFINED_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_ENUM_IS_DEFINED_after ebm2p4::Context_Expression_ENUM_IS_DEFINED_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_IS_ERROR ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_IS_ERROR>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_IS_ERROR ebm2p4::Context_Expression_IS_ERROR
    #define EBM2P4_CODEGEN_VISITOR_Expression_IS_ERROR_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_IS_ERROR_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_IS_ERROR_before ebm2p4::Context_Expression_IS_ERROR_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_IS_ERROR_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_IS_ERROR_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_IS_ERROR_after ebm2p4::Context_Expression_IS_ERROR_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_MAX_VALUE ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_MAX_VALUE>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_MAX_VALUE ebm2p4::Context_Expression_MAX_VALUE
    #define EBM2P4_CODEGEN_VISITOR_Expression_MAX_VALUE_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_MAX_VALUE_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_MAX_VALUE_before ebm2p4::Context_Expression_MAX_VALUE_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_MAX_VALUE_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_MAX_VALUE_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_MAX_VALUE_after ebm2p4::Context_Expression_MAX_VALUE_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_READ_DATA ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_READ_DATA>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_READ_DATA ebm2p4::Context_Expression_READ_DATA
    #define EBM2P4_CODEGEN_VISITOR_Expression_READ_DATA_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_READ_DATA_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_READ_DATA_before ebm2p4::Context_Expression_READ_DATA_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_READ_DATA_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_READ_DATA_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_READ_DATA_after ebm2p4::Context_Expression_READ_DATA_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_WRITE_DATA ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_WRITE_DATA>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_WRITE_DATA ebm2p4::Context_Expression_WRITE_DATA
    #define EBM2P4_CODEGEN_VISITOR_Expression_WRITE_DATA_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_WRITE_DATA_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_WRITE_DATA_before ebm2p4::Context_Expression_WRITE_DATA_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_WRITE_DATA_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_WRITE_DATA_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_WRITE_DATA_after ebm2p4::Context_Expression_WRITE_DATA_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_CONDITIONAL_STATEMENT ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_CONDITIONAL_STATEMENT>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_CONDITIONAL_STATEMENT ebm2p4::Context_Expression_CONDITIONAL_STATEMENT
    #define EBM2P4_CODEGEN_VISITOR_Expression_CONDITIONAL_STATEMENT_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_CONDITIONAL_STATEMENT_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_CONDITIONAL_STATEMENT_before ebm2p4::Context_Expression_CONDITIONAL_STATEMENT_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_CONDITIONAL_STATEMENT_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_CONDITIONAL_STATEMENT_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_CONDITIONAL_STATEMENT_after ebm2p4::Context_Expression_CONDITIONAL_STATEMENT_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_CONDITIONAL ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_CONDITIONAL>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_CONDITIONAL ebm2p4::Context_Expression_CONDITIONAL
    #define EBM2P4_CODEGEN_VISITOR_Expression_CONDITIONAL_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_CONDITIONAL_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_CONDITIONAL_before ebm2p4::Context_Expression_CONDITIONAL_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_CONDITIONAL_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_CONDITIONAL_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_CONDITIONAL_after ebm2p4::Context_Expression_CONDITIONAL_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_AVAILABLE ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_AVAILABLE>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_AVAILABLE ebm2p4::Context_Expression_AVAILABLE
    #define EBM2P4_CODEGEN_VISITOR_Expression_AVAILABLE_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_AVAILABLE_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_AVAILABLE_before ebm2p4::Context_Expression_AVAILABLE_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_AVAILABLE_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_AVAILABLE_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_AVAILABLE_after ebm2p4::Context_Expression_AVAILABLE_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_SIZEOF ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_SIZEOF>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_SIZEOF ebm2p4::Context_Expression_SIZEOF
    #define EBM2P4_CODEGEN_VISITOR_Expression_SIZEOF_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_SIZEOF_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_SIZEOF_before ebm2p4::Context_Expression_SIZEOF_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_SIZEOF_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_SIZEOF_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_SIZEOF_after ebm2p4::Context_Expression_SIZEOF_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_SUB_RANGE_INIT ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_SUB_RANGE_INIT>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_SUB_RANGE_INIT ebm2p4::Context_Expression_SUB_RANGE_INIT
    #define EBM2P4_CODEGEN_VISITOR_Expression_SUB_RANGE_INIT_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_SUB_RANGE_INIT_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_SUB_RANGE_INIT_before ebm2p4::Context_Expression_SUB_RANGE_INIT_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_SUB_RANGE_INIT_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_SUB_RANGE_INIT_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_SUB_RANGE_INIT_after ebm2p4::Context_Expression_SUB_RANGE_INIT_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_OR_COND ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_OR_COND>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_OR_COND ebm2p4::Context_Expression_OR_COND
    #define EBM2P4_CODEGEN_VISITOR_Expression_OR_COND_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_OR_COND_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_OR_COND_before ebm2p4::Context_Expression_OR_COND_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_OR_COND_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_OR_COND_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_OR_COND_after ebm2p4::Context_Expression_OR_COND_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_ADDRESS_OF ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_ADDRESS_OF>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_ADDRESS_OF ebm2p4::Context_Expression_ADDRESS_OF
    #define EBM2P4_CODEGEN_VISITOR_Expression_ADDRESS_OF_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_ADDRESS_OF_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_ADDRESS_OF_before ebm2p4::Context_Expression_ADDRESS_OF_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_ADDRESS_OF_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_ADDRESS_OF_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_ADDRESS_OF_after ebm2p4::Context_Expression_ADDRESS_OF_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_OPTIONAL_OF ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_OPTIONAL_OF>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_OPTIONAL_OF ebm2p4::Context_Expression_OPTIONAL_OF
    #define EBM2P4_CODEGEN_VISITOR_Expression_OPTIONAL_OF_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_OPTIONAL_OF_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_OPTIONAL_OF_before ebm2p4::Context_Expression_OPTIONAL_OF_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_OPTIONAL_OF_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_OPTIONAL_OF_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_OPTIONAL_OF_after ebm2p4::Context_Expression_OPTIONAL_OF_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_SETTER_STATUS ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_SETTER_STATUS>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_SETTER_STATUS ebm2p4::Context_Expression_SETTER_STATUS
    #define EBM2P4_CODEGEN_VISITOR_Expression_SETTER_STATUS_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_SETTER_STATUS_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_SETTER_STATUS_before ebm2p4::Context_Expression_SETTER_STATUS_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_SETTER_STATUS_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_SETTER_STATUS_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_SETTER_STATUS_after ebm2p4::Context_Expression_SETTER_STATUS_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_SELF ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_SELF>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_SELF ebm2p4::Context_Expression_SELF
    #define EBM2P4_CODEGEN_VISITOR_Expression_SELF_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_SELF_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_SELF_before ebm2p4::Context_Expression_SELF_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_SELF_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_SELF_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_SELF_after ebm2p4::Context_Expression_SELF_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_AS_ARG ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_AS_ARG>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_AS_ARG ebm2p4::Context_Expression_AS_ARG
    #define EBM2P4_CODEGEN_VISITOR_Expression_AS_ARG_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_AS_ARG_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_AS_ARG_before ebm2p4::Context_Expression_AS_ARG_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_AS_ARG_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_AS_ARG_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_AS_ARG_after ebm2p4::Context_Expression_AS_ARG_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_dispatch ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_dispatch ebm2p4::Context_Expression
    #define EBM2P4_CODEGEN_VISITOR_Expression_before_dispatch ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_before_dispatch ebm2p4::Context_Expression_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expression_after_dispatch ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expression_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expression_after_dispatch ebm2p4::Context_Expression_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expressions ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expressions>>
    #define EBM2P4_CODEGEN_CONTEXT_Expressions ebm2p4::Context_Expressions
    #define EBM2P4_CODEGEN_VISITOR_Expressions_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expressions_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Expressions_before ebm2p4::Context_Expressions_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Expressions_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Expressions_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Expressions_after ebm2p4::Context_Expressions_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_INT ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_INT>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_INT ebm2p4::Context_Type_INT
    #define EBM2P4_CODEGEN_VISITOR_Type_INT_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_INT_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_INT_before ebm2p4::Context_Type_INT_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_INT_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_INT_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_INT_after ebm2p4::Context_Type_INT_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_UINT ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_UINT>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_UINT ebm2p4::Context_Type_UINT
    #define EBM2P4_CODEGEN_VISITOR_Type_UINT_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_UINT_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_UINT_before ebm2p4::Context_Type_UINT_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_UINT_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_UINT_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_UINT_after ebm2p4::Context_Type_UINT_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_USIZE ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_USIZE>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_USIZE ebm2p4::Context_Type_USIZE
    #define EBM2P4_CODEGEN_VISITOR_Type_USIZE_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_USIZE_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_USIZE_before ebm2p4::Context_Type_USIZE_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_USIZE_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_USIZE_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_USIZE_after ebm2p4::Context_Type_USIZE_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_FLOAT ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_FLOAT>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_FLOAT ebm2p4::Context_Type_FLOAT
    #define EBM2P4_CODEGEN_VISITOR_Type_FLOAT_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_FLOAT_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_FLOAT_before ebm2p4::Context_Type_FLOAT_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_FLOAT_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_FLOAT_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_FLOAT_after ebm2p4::Context_Type_FLOAT_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_STRUCT ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_STRUCT>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_STRUCT ebm2p4::Context_Type_STRUCT
    #define EBM2P4_CODEGEN_VISITOR_Type_STRUCT_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_STRUCT_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_STRUCT_before ebm2p4::Context_Type_STRUCT_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_STRUCT_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_STRUCT_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_STRUCT_after ebm2p4::Context_Type_STRUCT_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_RECURSIVE_STRUCT ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_RECURSIVE_STRUCT>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_RECURSIVE_STRUCT ebm2p4::Context_Type_RECURSIVE_STRUCT
    #define EBM2P4_CODEGEN_VISITOR_Type_RECURSIVE_STRUCT_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_RECURSIVE_STRUCT_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_RECURSIVE_STRUCT_before ebm2p4::Context_Type_RECURSIVE_STRUCT_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_RECURSIVE_STRUCT_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_RECURSIVE_STRUCT_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_RECURSIVE_STRUCT_after ebm2p4::Context_Type_RECURSIVE_STRUCT_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_BOOL ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_BOOL>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_BOOL ebm2p4::Context_Type_BOOL
    #define EBM2P4_CODEGEN_VISITOR_Type_BOOL_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_BOOL_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_BOOL_before ebm2p4::Context_Type_BOOL_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_BOOL_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_BOOL_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_BOOL_after ebm2p4::Context_Type_BOOL_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_VOID ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_VOID>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_VOID ebm2p4::Context_Type_VOID
    #define EBM2P4_CODEGEN_VISITOR_Type_VOID_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_VOID_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_VOID_before ebm2p4::Context_Type_VOID_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_VOID_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_VOID_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_VOID_after ebm2p4::Context_Type_VOID_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_META ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_META>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_META ebm2p4::Context_Type_META
    #define EBM2P4_CODEGEN_VISITOR_Type_META_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_META_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_META_before ebm2p4::Context_Type_META_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_META_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_META_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_META_after ebm2p4::Context_Type_META_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_ENUM ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_ENUM>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_ENUM ebm2p4::Context_Type_ENUM
    #define EBM2P4_CODEGEN_VISITOR_Type_ENUM_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_ENUM_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_ENUM_before ebm2p4::Context_Type_ENUM_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_ENUM_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_ENUM_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_ENUM_after ebm2p4::Context_Type_ENUM_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_ARRAY ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_ARRAY>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_ARRAY ebm2p4::Context_Type_ARRAY
    #define EBM2P4_CODEGEN_VISITOR_Type_ARRAY_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_ARRAY_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_ARRAY_before ebm2p4::Context_Type_ARRAY_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_ARRAY_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_ARRAY_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_ARRAY_after ebm2p4::Context_Type_ARRAY_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_VECTOR ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_VECTOR>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_VECTOR ebm2p4::Context_Type_VECTOR
    #define EBM2P4_CODEGEN_VISITOR_Type_VECTOR_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_VECTOR_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_VECTOR_before ebm2p4::Context_Type_VECTOR_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_VECTOR_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_VECTOR_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_VECTOR_after ebm2p4::Context_Type_VECTOR_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_VARIANT ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_VARIANT>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_VARIANT ebm2p4::Context_Type_VARIANT
    #define EBM2P4_CODEGEN_VISITOR_Type_VARIANT_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_VARIANT_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_VARIANT_before ebm2p4::Context_Type_VARIANT_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_VARIANT_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_VARIANT_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_VARIANT_after ebm2p4::Context_Type_VARIANT_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_RANGE ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_RANGE>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_RANGE ebm2p4::Context_Type_RANGE
    #define EBM2P4_CODEGEN_VISITOR_Type_RANGE_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_RANGE_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_RANGE_before ebm2p4::Context_Type_RANGE_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_RANGE_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_RANGE_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_RANGE_after ebm2p4::Context_Type_RANGE_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_ENCODER_RETURN ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_ENCODER_RETURN>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_ENCODER_RETURN ebm2p4::Context_Type_ENCODER_RETURN
    #define EBM2P4_CODEGEN_VISITOR_Type_ENCODER_RETURN_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_ENCODER_RETURN_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_ENCODER_RETURN_before ebm2p4::Context_Type_ENCODER_RETURN_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_ENCODER_RETURN_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_ENCODER_RETURN_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_ENCODER_RETURN_after ebm2p4::Context_Type_ENCODER_RETURN_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_DECODER_RETURN ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_DECODER_RETURN>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_DECODER_RETURN ebm2p4::Context_Type_DECODER_RETURN
    #define EBM2P4_CODEGEN_VISITOR_Type_DECODER_RETURN_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_DECODER_RETURN_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_DECODER_RETURN_before ebm2p4::Context_Type_DECODER_RETURN_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_DECODER_RETURN_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_DECODER_RETURN_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_DECODER_RETURN_after ebm2p4::Context_Type_DECODER_RETURN_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_ENCODER_INPUT ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_ENCODER_INPUT>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_ENCODER_INPUT ebm2p4::Context_Type_ENCODER_INPUT
    #define EBM2P4_CODEGEN_VISITOR_Type_ENCODER_INPUT_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_ENCODER_INPUT_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_ENCODER_INPUT_before ebm2p4::Context_Type_ENCODER_INPUT_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_ENCODER_INPUT_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_ENCODER_INPUT_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_ENCODER_INPUT_after ebm2p4::Context_Type_ENCODER_INPUT_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_DECODER_INPUT ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_DECODER_INPUT>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_DECODER_INPUT ebm2p4::Context_Type_DECODER_INPUT
    #define EBM2P4_CODEGEN_VISITOR_Type_DECODER_INPUT_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_DECODER_INPUT_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_DECODER_INPUT_before ebm2p4::Context_Type_DECODER_INPUT_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_DECODER_INPUT_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_DECODER_INPUT_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_DECODER_INPUT_after ebm2p4::Context_Type_DECODER_INPUT_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_PROPERTY_SETTER_RETURN ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_PROPERTY_SETTER_RETURN>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_PROPERTY_SETTER_RETURN ebm2p4::Context_Type_PROPERTY_SETTER_RETURN
    #define EBM2P4_CODEGEN_VISITOR_Type_PROPERTY_SETTER_RETURN_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_PROPERTY_SETTER_RETURN_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_PROPERTY_SETTER_RETURN_before ebm2p4::Context_Type_PROPERTY_SETTER_RETURN_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_PROPERTY_SETTER_RETURN_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_PROPERTY_SETTER_RETURN_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_PROPERTY_SETTER_RETURN_after ebm2p4::Context_Type_PROPERTY_SETTER_RETURN_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_OPTIONAL ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_OPTIONAL>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_OPTIONAL ebm2p4::Context_Type_OPTIONAL
    #define EBM2P4_CODEGEN_VISITOR_Type_OPTIONAL_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_OPTIONAL_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_OPTIONAL_before ebm2p4::Context_Type_OPTIONAL_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_OPTIONAL_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_OPTIONAL_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_OPTIONAL_after ebm2p4::Context_Type_OPTIONAL_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_PTR ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_PTR>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_PTR ebm2p4::Context_Type_PTR
    #define EBM2P4_CODEGEN_VISITOR_Type_PTR_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_PTR_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_PTR_before ebm2p4::Context_Type_PTR_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_PTR_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_PTR_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_PTR_after ebm2p4::Context_Type_PTR_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_FUNCTION ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_FUNCTION>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_FUNCTION ebm2p4::Context_Type_FUNCTION
    #define EBM2P4_CODEGEN_VISITOR_Type_FUNCTION_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_FUNCTION_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_FUNCTION_before ebm2p4::Context_Type_FUNCTION_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_FUNCTION_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_FUNCTION_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_FUNCTION_after ebm2p4::Context_Type_FUNCTION_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_dispatch ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_dispatch ebm2p4::Context_Type
    #define EBM2P4_CODEGEN_VISITOR_Type_before_dispatch ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_before_dispatch ebm2p4::Context_Type_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Type_after_dispatch ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Type_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Type_after_dispatch ebm2p4::Context_Type_after<Result>
    #define EBM2P4_CODEGEN_VISITOR_Types ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Types>>
    #define EBM2P4_CODEGEN_CONTEXT_Types ebm2p4::Context_Types
    #define EBM2P4_CODEGEN_VISITOR_Types_before ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Types_before>>
    #define EBM2P4_CODEGEN_CONTEXT_Types_before ebm2p4::Context_Types_before<Result>
    #define EBM2P4_CODEGEN_VISITOR_Types_after ebm2p4::Visitor<ebm2p4::UserHook<ebm2p4::VisitorTag_Types_after>>
    #define EBM2P4_CODEGEN_CONTEXT_Types_after ebm2p4::Context_Types_after<Result>
    #define CODEGEN_NAMESPACE ebm2p4
    #define CODEGEN_VISITOR(name) EBM2P4_CODEGEN_VISITOR_##name
    #define CODEGEN_CONTEXT_PARAMETERS(name) EBM2P4_CODEGEN_CONTEXT_PARAMETERS_##name
    #define CODEGEN_CONTEXT(name) EBM2P4_CODEGEN_CONTEXT_##name
}  // namespace ebm2p4
#if __has_include("visitor/post_includes_before.hpp")
#include "visitor/post_includes_before.hpp"
#elif __has_include("visitor/dsl/post_includes_before_dsl.hpp")
#include "visitor/dsl/post_includes_before_dsl.hpp"
#elif __has_include("ebmcodegen/default_codegen_visitor/visitor/post_includes_before.hpp")
#include "ebmcodegen/default_codegen_visitor/visitor/post_includes_before.hpp"
#endif
#if __has_include("visitor/post_includes.hpp")
#include "visitor/post_includes.hpp"
#elif __has_include("visitor/dsl/post_includes_dsl.hpp")
#include "visitor/dsl/post_includes_dsl.hpp"
#elif __has_include("ebmcodegen/default_codegen_visitor/visitor/post_includes.hpp")
#include "ebmcodegen/default_codegen_visitor/visitor/post_includes.hpp"
#endif
#if __has_include("visitor/post_includes_after.hpp")
#include "visitor/post_includes_after.hpp"
#elif __has_include("visitor/dsl/post_includes_after_dsl.hpp")
#include "visitor/dsl/post_includes_after_dsl.hpp"
#elif __has_include("ebmcodegen/default_codegen_visitor/visitor/post_includes_after.hpp")
#include "ebmcodegen/default_codegen_visitor/visitor/post_includes_after.hpp"
#endif
#endif // EBM_CODEGEN_COMMON_INCLUDE_GUARD
