/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_FUNCTION_DECL
  Available variables:
    *this: Visitor
    module_: MappingTable
    item_id: StatementRef
    generator_default_logic: std::function<expected<Result>()>
    default_logic: std::function<expected<Result>()>
    kind: StatementKind
    func_decl: FunctionDecl
      name: IdentifierRef
      return_type: TypeRef
      params: Block
        len: Varint
        container: std::vector<StatementRef>
      parent_format: StatementRef
      kind: FunctionKind
      body: StatementRef
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/
// This code is included within the visit_Statement_FUNCTION_DECL function.
// We can use variables like `visitor` and `func_decl` directly.
CodeWriter w;
auto func_name = module_.get_associated_identifier(item_id);
MAYBE(return_type_str, visit_Type(*this, func_decl.return_type));

std::string params_str = "";
if (!is_nil(func_decl.parent_format)) {
    params_str += "self";
}
for (auto& param_stmt_ref : func_decl.params.container) {
    MAYBE(param_stmt, module_.get_statement(param_stmt_ref));
    MAYBE(param_decl, param_stmt.body.param_decl());
    auto param_name = module_.get_associated_identifier(param_stmt_ref);
    MAYBE(param_type_str, visit_Type(*this, param_decl.param_type));  // Correctly extract the string value
    if (!params_str.empty()) {
        params_str += ", ";
    }
    params_str += param_name + ": \"" + param_type_str.to_string() + "\"";
}

if (func_decl.kind == ebm::FunctionKind::PROPERTY_GETTER) {
    w.writeln("@property");
}
else if (func_decl.kind == ebm::FunctionKind::PROPERTY_SETTER) {
    w.writeln("@", func_name, ".setter");
}
w.writeln("def ", func_name, "(", params_str, ") -> \"", return_type_str.to_writer(), "\":");
auto scope = w.indent_scope();
MAYBE(res, visit_Statement(*this, func_decl.body));
if (res.to_writer().empty()) {
    w.writeln("pass");  // If the body is empty, we just pass
}
else {
    merge_result(*this, w, res);
}

return w;
