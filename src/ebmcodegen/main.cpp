/*license*/
#include <cmdline/template/help_option.h>
#include <cmdline/template/parse_and_err.h>
#include <wrap/cout.h>
#include "../ebm/extended_binary_module.hpp"
#include <file/file_stream.h>  // Required for futils::file::FileStream
#include <binary/writer.h>     // Required for futils::binary::writer
#include <file/file_view.h>
#include <code/code_writer.h>
#include <ebmgen/common.hpp>
#include <ebmgen/mapping.hpp>

struct Flags : futils::cmdline::templ::HelpOption {
    std::string_view input;
    std::string_view output;
    std::string_view debug_output;  // New flag for debug output

    void bind(futils::cmdline::option::Context& ctx) {
        bind_help(ctx);
        ctx.VarString<true>(&input, "i,input", "input file", "FILE", futils::cmdline::option::CustomFlag::required);
        ctx.VarString<true>(&output, "o,output", "output file (if -, write to stdout)", "FILE");
        ctx.VarString<true>(&debug_output, "d,debug-print", "debug output file", "FILE");  // Bind new flag
    }
};

auto& cout = futils::wrap::cout_wrap();
auto& cerr = futils::wrap::cerr_wrap();

int Main(Flags& flags, futils::cmdline::option::Context& ctx) {
    ebm::ExtendedBinaryModule ebm;
    futils::file::View view;
    if (auto res = view.open(flags.input); !res) {
        cerr << "Failed to open input file: " << flags.input << ": " << res.error().error<std::string>() << '\n';
    }
    futils::binary::reader reader{view};
    auto err = ebm.decode(reader);
    if (err) {
        cerr << "Failed to decode EBM: " << err.error<std::string>() << '\n';
        return 1;
    }
    ebmgen::MappingTable mod{ebm};
    auto entry_point = mod.get_statement(ebm::StatementRef{ebm.max_id.id});
    if (!entry_point) {
        cerr << "No entry point found\n";
        return 1;
    }
    futils::code::CodeWriter<std::string> w;
    w.writeln("// Code generated by ebmcodegen at https://github.com/on-keyday/rebrgen");
    w.writeln("#include <ebmcodegen/stub/entry.hpp>");
    w.writeln();
    w.writeln("struct Flags : ebmcodegen::Flags {};");
    w.writeln("struct Output : ebmcodegen::Output {};");
    w.writeln("DEFINE_ENTRY(Flags,Output) {}");
    cout << w.out();
    entry_point->body.block();
    return 0;
}

int main(int argc, char** argv) {
    Flags flags;
    return futils::cmdline::templ::parse_or_err<std::string>(
        argc, argv, flags,
        [](auto&& str, bool err) {
            if (err)
                cerr << str;
            else
                cout << str;
        },
        [](Flags& flags, futils::cmdline::option::Context& ctx) {
            return Main(flags, ctx);
        });
}