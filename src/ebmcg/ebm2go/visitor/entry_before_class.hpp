/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: entry_before_class
  Available Variables:
    ctx: Context_entry_before<Result>
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        module_: ebmgen::MappingTable
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
      main_logic: ebmcodegen::util::MainLogicWrapper<Result>
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include <cctype>
#include <string>
#include "../codegen.hpp"
#include "ebm/extended_binary_module.hpp"
#include "ebmcodegen/stub/util.hpp"
#include "escape/escape.h"
DEFINE_VISITOR(entry_before) {
    using namespace CODEGEN_NAMESPACE;
    ctx.config().array_type_wrapper = [](Result r, size_t size, ebm::ArrayAnnotation) -> expected<Result> {
        return CODE("[", std::to_string(size), "]", r.to_writer());
    };
    ctx.config().vector_type_wrapper = [](Result r) -> expected<Result> {
        return CODE("[]", r.to_writer());
    };
    ctx.config().field_name_prior_to_type = true;
    ctx.config().int_prefix = "int";
    ctx.config().uint_prefix = "uint";
    ctx.config().float_prefix = "float";
    ctx.config().struct_definition_start_wrapper = [&](Context_Statement_STRUCT_DECL& sctx) -> expected<Result> {
        CodeWriter w;
        auto name = sctx.identifier();
        w.writeln("type ", name, " struct ", ctx.config().begin_block);
        return w;
    };
    ctx.config().function_define_keyword = "func";
    ctx.config().function_return_type_separator = "";
    ctx.config().encoder_return_type = "error";
    ctx.config().decoder_return_type = "error";
    ctx.config().encoder_input_type = "[]byte";
    ctx.config().decoder_input_type = "[]byte";
    ctx.config().function_definition_start_wrapper = [&](Result return_type, std::string_view name, CodeWriter params, Context_Statement_FUNCTION_DECL& fctx) -> expected<Result> {
        CodeWriter w;
        std::string_view name_prefix;
        if (is_setter_func(fctx.func_decl.kind)) {
            name_prefix = "Set";
            if (is_nil(fctx.func_decl.name)) {
                name_prefix = "set";  // unexported
            }
        }
        if (is_composite_func(fctx.func_decl.kind)) {
            // may change return type or params

            if (fctx.func_decl.kind == ebm::FunctionKind::COMPOSITE_GETTER) {
                auto got = ctx.get_field<"variant_desc">(fctx.func_decl.return_type);
                if (got && !is_nil(got->common_type)) {
                    MAYBE(typ, ctx.visit(got->common_type));
                    return_type = typ;
                }
            }
            else {
                auto got = ctx.get_field<"param_decl.param_type.variant_desc">(fctx.func_decl.params.container[0]);
                if (got && !is_nil(got->common_type)) {
                    MAYBE(typ, ctx.visit(got->common_type));
                    auto param_name = ctx.identifier(fctx.func_decl.params.container[0]);
                    params = CODE(param_name, " ", typ.to_writer());
                }
            }
        }
        if (!is_nil(fctx.func_decl.parent_format)) {
            auto struct_name = ctx.identifier(fctx.func_decl.parent_format);
            ctx.config().self_value = std::string(1, std::tolower(struct_name[0]));
            w.writeln(ctx.config().function_define_keyword, " (", ctx.config().self_value, " *", struct_name, ") ", name_prefix, name, "(", params, ") ", ctx.config().function_return_type_separator, " ", return_type.to_writer(), " ", ctx.config().begin_block);
        }
        else {
            w.writeln(ctx.config().function_define_keyword, " ", name_prefix, name, "(", params, ") ", ctx.config().function_return_type_separator, return_type.to_writer(), " ", ctx.config().begin_block);
        }
        return w;
    };
    ctx.config().composite_field_decl_visitor = [&](Context_Statement_COMPOSITE_FIELD_DECL& cctx) -> expected<Result> {
        if (cctx.composite_field_decl.kind == ebm::CompositeFieldKind::BULK_PRIMITIVE ||
            cctx.composite_field_decl.kind == ebm::CompositeFieldKind::PREFIXED_UNION_PRIMITIVE) {
            auto ident = cctx.identifier();
            MAYBE(typ, ctx.visit(cctx.composite_field_decl.composite_type));
            auto res = CODELINE(ident, " ", typ.to_writer());
            // for each field, generate getter and setter
            for (auto& field : cctx.composite_field_decl.fields.container) {
                MAYBE(field_decl, cctx.get_field<"field_decl">(field));
                auto getter = field_decl.composite_getter();
                auto setter = field_decl.composite_setter();
                if (getter) {
                    MAYBE(getter, ctx.visit(getter->id));
                    ctx.config().decl_toplevel.push_back(getter.to_writer());
                }
                if (setter) {
                    MAYBE(setter, ctx.visit(setter->id));
                    ctx.config().decl_toplevel.push_back(setter.to_writer());
                }
            }
            return res;
        }
        return cctx.visit(cctx.composite_field_decl.fields);
    };
    ctx.config().read_data_visitor = [&](Context_Statement_READ_DATA& rctx) -> expected<Result> {
        if (auto low = rctx.read_data.lowered_statement()) {
            if (low->lowering_type == ebm::LoweringIOType::VECTORIZED_IO) {
                return rctx.visit(low->io_statement.id);
            }
        }
        if (auto cand = is_bytes_type(rctx, rctx.read_data.data_type)) {
            MAYBE(target, rctx.visit(rctx.read_data.target));
            MAYBE(size_str, get_size_str(rctx, rctx.read_data.size));
            auto io_ = rctx.identifier(rctx.read_data.io_ref);
            auto offset_val = CODE("0");
            if (auto offset = rctx.read_data.offset()) {
                MAYBE(offset_str, rctx.visit(*offset));
                offset_val = offset_str.to_writer();
            }
            MAYBE(layer_str, get_identifier_layer_str(rctx, from_weak(rctx.read_data.field)));
            layer_str = "\"" + layer_str + "\"";
            if (cand == BytesType::vector) {
                return CODELINE("/* read from buffer*/");
            }
            else if (cand == BytesType::array) {
                return CODELINE("/* read from buffer */");
            }
        }
        if (auto lw = rctx.read_data.lowered_statement()) {
            return rctx.visit(lw->io_statement.id);
        }
        return "/* not implemented read data */";
    };
    ctx.config().write_data_visitor = [&](Context_Statement_WRITE_DATA& wctx) -> expected<Result> {
        if (auto low = wctx.write_data.lowered_statement()) {
            if (low->lowering_type == ebm::LoweringIOType::VECTORIZED_IO) {
                return wctx.visit(low->io_statement.id);
            }
        }
        if (auto cand = is_bytes_type(wctx, wctx.write_data.data_type)) {
            MAYBE(target, wctx.visit(wctx.write_data.target));
            MAYBE(size_str, get_size_str(wctx, wctx.write_data.size));
            auto io_ = wctx.identifier(wctx.write_data.io_ref);
            auto offset_val = CODE("0");
            if (auto offset = wctx.write_data.offset()) {
                MAYBE(offset_str, wctx.visit(*offset));
                offset_val = offset_str.to_writer();
            }
            MAYBE(layer_str, get_identifier_layer_str(wctx, from_weak(wctx.write_data.field)));
            layer_str = "\"" + layer_str + "\"";
            if (cand == BytesType::vector) {
                return CODELINE("/* write to buffer*/");
            }
            else if (cand == BytesType::array) {
                return CODELINE("/* write to buffer */");
            }
        }
        if (auto lw = wctx.write_data.lowered_statement()) {
            return wctx.visit(lw->io_statement.id);
        }
        return "/* not implemented write data */";
    };
    ctx.config().is_error_visitor = [&](Context_Expression_IS_ERROR& ectx) -> expected<Result> {
        MAYBE(err, ctx.visit(ectx.target_expr));
        return CODE(err.to_writer(), " != nil");
    };
    ctx.config().error_return_visitor = [&](Context_Statement_ERROR_RETURN& rctx) -> expected<Result> {
        MAYBE(err_expr, ctx.visit(rctx.value));
        return CODELINE("return ", err_expr.to_writer());
    };
    ctx.config().error_report_visitor = [&](Context_Statement_ERROR_REPORT& rptctx) -> expected<Result> {
        MAYBE(err_expr, ctx.get(rptctx.error_report.message));
        auto escaped_msg = futils::escape::escape_str<std::string>(err_expr.body.data);
        CodeWriter w;
        rptctx.config().imports.insert("errors");
        w.writeln("return errors.New(\"", escaped_msg, "\")");
        return w;
    };
    ctx.config().variable_type_separator = "";
    ctx.config().variable_with_type = false;
    ctx.config().variable_initializer = ":=";
    ctx.config().enum_decl_visitor = [&](Context_Statement_ENUM_DECL& ectx) -> expected<Result> {
        CodeWriter w;
        auto name = ectx.identifier();
        w.writeln("type ", name, " int");
        w.writeln("");
        w.writeln("const (");
        {
            auto scope = w.indent_scope();
            for (auto& member_ref : ectx.enum_decl.members.container) {
                MAYBE(member, ectx.visit(member_ref));
                w.write(member.to_writer());
            }
        }
        w.writeln(")");
        return w;
    };
    ctx.config().enum_member_decl_visitor = [&](Context_Statement_ENUM_MEMBER_DECL& mctx) -> expected<Result> {
        auto enum_name = ctx.identifier(mctx.enum_member_decl.enum_decl);
        auto member_name = mctx.identifier();
        MAYBE(value_expr, ctx.visit(mctx.enum_member_decl.value));
        return CODELINE(enum_name, "_", member_name, " ", enum_name, " = ", value_expr.to_writer());
    };
    ctx.config().enum_member_accessor = "_";
    ctx.config().init_check_visitor = [&](Context_Statement_INIT_CHECK& ictx) -> expected<Result> {
        if (ictx.init_check.init_check_type == ebm::InitCheckType::union_init_encode ||
            ictx.init_check.init_check_type == ebm::InitCheckType::union_init_decode ||
            ictx.init_check.init_check_type == ebm::InitCheckType::union_get ||
            ictx.init_check.init_check_type == ebm::InitCheckType::union_set) {
            MAYBE(type, ictx.get_field<"type">(ictx.init_check.expect_value));
            if (get_composite_field(ctx, ctx.get_field<"member">(ictx.init_check.target_field))) {
                ctx.config().bulk_primitive.insert(get_id(type));
                return "";
            }
            MAYBE(field_txt, ictx.visit(ictx.init_check.target_field));
            auto tmpname = std::format("tmp{}", get_id(type));
            MAYBE(type_txt, ictx.visit(type));
            // tmp,ok := field_txt.(*type_txt)
            CodeWriter w;
            w.writeln(tmpname, ", ok := ", field_txt.to_writer(), ".(*", type_txt.to_writer(), ")");
            w.writeln("if !ok {");
            {
                auto scope = w.indent_scope();
                if (ictx.init_check.init_check_type == ebm::InitCheckType::union_init_encode) {
                    w.writeln("return errors.New(\"invalid union type for encoding\")");
                }
                else if (ictx.init_check.init_check_type == ebm::InitCheckType::union_get) {
                    MAYBE(func_decl, ictx.get_field<"id.func_decl">(ictx.init_check.related_function));
                    MAYBE(default_, as_DEFAULT_VALUE(ctx, func_decl.return_type));
                    w.writeln("return ", default_.to_writer());
                }
                else {
                    w.writeln(tmpname, " = &", type_txt.to_writer(), "{}");
                    w.writeln(field_txt.to_writer(), " = ", tmpname);
                }
            }
            w.writeln("}");
            return w;
        }
        return "";
    };
    ctx.config().variant_type_custom = [&](Context_Type_VARIANT& vctx) -> expected<Result> {
        if (is_nil(vctx.variant_desc.related_field) &&
            is_nil(vctx.variant_desc.common_type)) {
            ctx.config().any_variant.insert(get_id(vctx.item_id));
            return CODE("any");
        }
        return pass;
    };
    ctx.config().default_value_custom = [&](Context_Expression_DEFAULT_VALUE& dctx) -> expected<Result> {
        MAYBE(type, dctx.get(dctx.type));
        if (type.body.kind == ebm::TypeKind::ARRAY || type.body.kind == ebm::TypeKind::VECTOR ||
            type.body.kind == ebm::TypeKind::STRUCT || type.body.kind == ebm::TypeKind::RECURSIVE_STRUCT) {
            MAYBE(typ_txt, dctx.visit(dctx.type));
            return CODE(typ_txt.to_string(), "{}");
        }
        // integers and floats default to 0 with type
        if (type.body.kind == ebm::TypeKind::INT || type.body.kind == ebm::TypeKind::UINT ||
            type.body.kind == ebm::TypeKind::FLOAT || type.body.kind == ebm::TypeKind::ENUM) {
            MAYBE(typ_txt, dctx.visit(dctx.type));
            return CODE(typ_txt.to_string(), "(0)");
        }
        if (type.body.kind == ebm::TypeKind::VARIANT) {
            if (auto memb = type.body.variant_desc(); memb && !is_nil(memb->common_type)) {
                return as_DEFAULT_VALUE(dctx, memb->common_type);
            }
            return CODE("nil");
        }
        // currently, optional uses inner type default
        if (type.body.kind == ebm::TypeKind::OPTIONAL) {
            MAYBE(inner_type, type.body.inner_type());
            return as_DEFAULT_VALUE(dctx, inner_type);
        }
        return pass;
    };
    ctx.config().append_visitor = [&](Context_Statement_APPEND& actx) -> expected<Result> {
        MAYBE(target, actx.visit(actx.target));
        MAYBE(value, actx.visit(actx.value));
        return CODELINE(target.to_writer(), " = append(", target.to_writer(), ", ", value.to_writer(), ")");
    };
    ctx.config().can_read_stream_visitor = [&](Context_Expression_CAN_READ_STREAM& cctx) -> expected<Result> {
        auto stream = cctx.identifier(cctx.io_ref);
        MAYBE(size_str, get_size_str(cctx, cctx.num_bytes));
        return CODE("len(", stream, ") >= ", size_str);
    };
    ctx.config().pointer_type_wrapper = [](Result r) -> expected<Result> {
        return CODE("*", r.to_writer());
    };
    ctx.config().make_pointer_wrapper = [](Result r) -> expected<Result> {
        return CODE("&", r.to_writer());
    };
    ctx.config().default_value_option.pointer_init = "nil";
    ctx.config().default_value_option.decoder_return_init = "nil";
    ctx.config().default_value_option.encoder_return_init = "nil";
    ctx.config().conditional_loop_keyword = "for";
    ctx.config().infinity_loop_keyword = "for";

    ctx.config().append_function = "append";
    ctx.config().usize_type_name = "int";
    ctx.config().surrounded_array_size = true;
    ctx.config().use_brace_for_condition = false;

    ctx.config().alt_unary_op[ebm::UnaryOp::bit_not] = "^";

    return pass;
}
