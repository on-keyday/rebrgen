/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_ASSIGNMENT_before_class
  Available Variables:
    ctx: Context_Statement_ASSIGNMENT_before<Result>
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
        module_: ebmgen::MappingTable
      item_id: ebm::StatementRef
      kind: const ebm::StatementKind&
      previous_assignment: const ebm::WeakStatementRef&
        id: StatementRef
      target: const ebm::ExpressionRef&
      value: const ebm::ExpressionRef&
      main_logic: ebmcodegen::util::MainLogicWrapper<Result>
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include "../codegen.hpp"
DEFINE_VISITOR(Statement_ASSIGNMENT_before) {
    using namespace CODEGEN_NAMESPACE;
    auto member = ctx.get_field<"member">(ctx.target);
    if (!member) {
        return pass;
    }
    if (auto comp = get_composite_field(ctx, member)) {
        auto setter = comp->composite_setter();
        if (!setter) {
            return pass;
        }
        MAYBE(base, ctx.get_field<"base">(ctx.target));
        MAYBE(base_str, ctx.visit(base));
        MAYBE(value, ctx.visit(ctx.value));
        CodeWriter w;
        auto parent_ident = ctx.identifier(comp->parent_struct);
        MAYBE(member_ident, ctx.identifier(*member));
        auto base_ = base_str.to_writer();
        if (ctx.get_field<"struct_decl.related_variant">(comp->parent_struct)) {
            auto field_id = ctx.get_field<"body.id">(*member);
            if (field_id) {
                if (auto variant_type = get_variant_member_from_field(ctx, from_weak(*field_id))) {
                    // variant member composite field: use INIT_CHECK-asserted variable (tmp{type_id})
                    auto variant_hold = std::format("tmp{}", get_id(*variant_type));
                    base_ = CODE(variant_hold);
                }
            }
        }
        auto setter_prefix = "Set";
        if (ctx.config().bool_mapped_func.contains(get_id(setter->id))) {
            setter_prefix = "set";
        }
        auto setter_func_name = std::format(
            "{}{}",
            setter_prefix,
            member_ident);
        w.writeln(base_, ".", setter_func_name, "(", value.to_writer(), ")");
        return w;
    }
    auto may_variant = ctx.get_field<"body.id.id">(member);
    if (!may_variant) {
        return pass;
    }
    if (auto type_ref = get_variant_member_from_field(ctx, *may_variant)) {
        if (ctx.config().bulk_primitive.contains(get_id(*type_ref))) {
            // bulk primitive assignment
            MAYBE(base, ctx.get_field<"base.base">(ctx.target));
            MAYBE(base_str, ctx.visit(base));
            MAYBE(value, ctx.visit(ctx.value));
            MAYBE(comp_field, (ctx.get_field<physical_field>(*type_ref)));
            MAYBE(setter, comp_field.composite_setter());
            auto setter_func_name = std::format("set{}", ctx.identifier(setter.id));
            MAYBE(comp_field_type, ctx.get_field<"composite_field_decl">(comp_field.composite_field()));
            MAYBE(cast_str, ctx.visit(comp_field_type.composite_type));
            CodeWriter w;
            w.writeln(std::move(base_str.to_writer()), ".", setter_func_name, "(", std::move(cast_str.to_writer()), "(", std::move(value.to_writer()), "))");
            return w;
        }
    }
    return pass;
}
