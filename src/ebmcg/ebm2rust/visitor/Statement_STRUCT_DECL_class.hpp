/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_STRUCT_DECL_class
  Available Variables:
    ctx: Context_Statement_STRUCT_DECL
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
        module_: ebmgen::MappingTable
      item_id: ebm::StatementRef
      kind: const ebm::StatementKind&
      struct_decl: const ebm::StructDecl&
        name: IdentifierRef
        fields: Block
          len: Varint
          container: std::vector<StatementRef>
        is_recursive: bool
        is_fixed_size: bool
        has_related_variant: bool
        has_encode_decode: bool
        has_functions: bool
        has_properties: bool
        has_parent: bool
        has_nested_types: bool
        related_variant: *TypeRef
        size: *Size
          unit: SizeUnit
          ref: *ExpressionRef
          size: *Varint
        decode_fn: *StatementRef
        encode_fn: *StatementRef
        methods: *Block
          len: Varint
          container: std::vector<StatementRef>
        properties: *Block
          len: Varint
          container: std::vector<StatementRef>
        parent_struct: *WeakStatementRef
        nested_types: *Block
          len: Varint
          container: std::vector<StatementRef>
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

/*here to write the hook*/
#include "../codegen.hpp"
DEFINE_VISITOR(Statement_STRUCT_DECL) {
    auto name = ctx.identifier();
    CodeWriter w;
    w.writeln("#[derive(Debug, Clone, PartialEq, Eq, Default)]");  // Add common derives
    w.writeln("pub struct ", name, " {");
    {
        auto scope = w.indent_scope();
        for (auto& field : ctx.struct_decl.fields.container) {
            MAYBE(field_str, ctx.visit(field));
            w.write(field_str.to_writer());
        }
    }
    w.writeln("}");

    w.writeln();  // Add a newline for separation
    if (ctx.struct_decl.has_encode_decode() || ctx.struct_decl.has_functions() || ctx.struct_decl.has_properties()) {
        w.writeln("impl ", name, " {");
        {
            auto impl_scope = w.indent_scope();

            if (auto prop_block = ctx.struct_decl.properties()) {
                for (auto& prop_ref : prop_block->container) {
                    MAYBE(prop_stmt, ctx.get(prop_ref));
                    MAYBE(prop_str, ctx.visit(prop_ref));
                    w.write(prop_str.to_writer());
                }
            }

            if (auto fns = ctx.struct_decl.methods()) {
                for (auto& method_ref : fns->container) {
                    MAYBE(method_str, ctx.visit(method_ref));
                    w.write(method_str.to_writer());
                }
            }
            if (auto enc_fn = ctx.struct_decl.encode_fn()) {
                MAYBE(encode_fn_str, ctx.visit(*enc_fn));
                w.write(encode_fn_str.to_writer());
            }
            if (auto dec_fn = ctx.struct_decl.decode_fn()) {
                MAYBE(decode_fn_str, ctx.visit(*dec_fn));
                w.write(decode_fn_str.to_writer());
            }
        }
        w.writeln("}");
    }

    return w;
}