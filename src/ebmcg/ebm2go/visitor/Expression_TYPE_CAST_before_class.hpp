/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Expression_TYPE_CAST_before_class
  Available Variables:
    ctx: Context_Expression_TYPE_CAST_before<Result>
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        module_: ebmgen::MappingTable
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
      item_id: ebm::ExpressionRef
      type: const ebm::TypeRef&
      kind: const ebm::ExpressionKind&
      type_cast_desc: const ebm::TypeCastDesc&
        source_expr: ExpressionRef
        from_type: TypeRef
        cast_kind: CastType
        cast_function: *WeakStatementRef
      main_logic: ebmcodegen::util::MainLogicWrapper<Result>
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include "../codegen.hpp"
#include "ebm/extended_binary_module.hpp"
DEFINE_VISITOR(Expression_TYPE_CAST_before) {
    using namespace CODEGEN_NAMESPACE;
    auto target_type = ctx.module().get_type(ctx.type);
    if (!target_type) return pass;
    if (target_type->body.kind == ebm::TypeKind::VARIANT) {
        auto variant_desc = target_type->body.variant_desc();
        if (variant_desc) {
            if (!is_nil(variant_desc->common_type)) {
                ebm::Expression expr;
                expr.body.kind = ebm::ExpressionKind::TYPE_CAST;
                expr.body.type = variant_desc->common_type;
                expr.body.type_cast_desc(ebm::TypeCastDesc{
                    .source_expr = ctx.type_cast_desc.source_expr,
                    .from_type = ctx.type_cast_desc.from_type,
                    .cast_kind = ebm::CastType::OTHER,
                });
                MAYBE(expr_str, ctx.visit(expr));
                return CODE(expr_str.to_writer());
            }
            else {
                MAYBE(source_expr_str, ctx.visit(ctx.type_cast_desc.source_expr));
                return CODE(source_expr_str.to_writer());
            }
        }
    }
    auto source_type = ctx.module().get_type(ctx.type_cast_desc.from_type);
    if (!source_type) return pass;
    if (source_type->body.kind == ebm::TypeKind::VARIANT) {
        if (ctx.config().any_variant.contains(get_id(ctx.type_cast_desc.from_type))) {
            MAYBE(target_type_str, ctx.visit(ctx.type));
            MAYBE(source_expr_str, ctx.visit(ctx.type_cast_desc.source_expr));
            auto counter = ctx.config().any_cast_counter[get_id(ctx.type_cast_desc.from_type)]++;
            auto tmp_var = std::format("any_cast_tmp_{}_{}", get_id(ctx.item_id), counter);
            auto ok = tmp_var + "_ok";
            MAYBE(got, ctx.get_writer());
            auto w = CODELINE(tmp_var, ",", ok, " := ", source_expr_str.to_writer(), ".(", target_type_str.to_writer(), ")");
            w.writeln("if !", ok, " {");
            {
                auto scope = w.indent_scope();
                w.writeln("return false");
            }
            w.writeln("}");
            got.get().write(std::move(w));
            return CODE(tmp_var);
        }
    }

    if (ctx.type_cast_desc.cast_kind == ebm::CastType::FLOAT_TO_INT_BIT) {
        MAYBE(target_size, target_type->body.size());
        MAYBE(target_type_str, ctx.visit(ctx.type));
        if (target_size.value() == 32) {
            MAYBE(source_expr_str, ctx.visit(ctx.type_cast_desc.source_expr));
            ctx.config().imports.insert("math");
            return CODE("(", target_type_str.to_writer(), "(math.Float32bits(float32(", source_expr_str.to_writer(), "))))");
        }
        else if (target_size.value() == 64) {
            MAYBE(source_expr_str, ctx.visit(ctx.type_cast_desc.source_expr));
            ctx.config().imports.insert("math");
            return CODE("(", target_type_str.to_writer(), "(math.Float64bits(float64(", source_expr_str.to_writer(), "))))");
        }
    }
    if (ctx.type_cast_desc.cast_kind == ebm::CastType::INT_TO_FLOAT_BIT) {
        MAYBE(target_size, target_type->body.size());
        MAYBE(target_type_str, ctx.visit(ctx.type));
        if (target_size.value() == 32) {
            MAYBE(source_expr_str, ctx.visit(ctx.type_cast_desc.source_expr));
            ctx.config().imports.insert("math");
            return CODE("math.Float32frombits(", source_expr_str.to_writer(), ")");
        }
        else if (target_size.value() == 64) {
            MAYBE(source_expr_str, ctx.visit(ctx.type_cast_desc.source_expr));
            ctx.config().imports.insert("math");
            return CODE("math.Float64frombits(", source_expr_str.to_writer(), ")");
        }
    }
    /*here to write the hook*/
    return pass;
}
