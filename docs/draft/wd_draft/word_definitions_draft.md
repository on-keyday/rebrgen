## Core Concepts

- **brgen**: A project that converts binary format definitions from a custom DSL (.bgn files) into source code for various languages. The original brgen uses an AST-to-Code model.
- **rebrgen**: A generator construction project for `brgen`. It uses a more flexible AST-to-IR-to-Code model.
- **.bgn**: A custom Domain-Specific Language (DSL) used by `brgen` to define binary formats.

### EBM (Extended Binary Module)

- **EBM (ExtendedBinaryModule)**: An Intermediate Representation (IR) that replaces a previous, less flexible IR (known as bm or Binary Module). It is considered superior due to its graph-based structure with centralized data tables, structured control flow, and a higher-level of abstraction. The definition file is `src/ebm/extended_binary_module.bgn`.
- **IR (Intermediate Representation)**: A generic term for the data structure used to represent the source code between the parsing and code generation phases. In this project, the primary IR is EBM.
- **...Ref types (e.g., `StatementRef`, `TypeRef`)**: Reference types that act as wrappers around a unique ID. They are used throughout the EBM to link to objects (like Statements, Types, etc.) stored in centralized tables. This is a fundamental aspect of the EBM's graph-based design, avoiding data duplication and simplifying analysis.

### ebmgen (AST to EBM Converter)

- **ebmgen**: A subproject of `rebrgen` and the successor to `bmgen`. It converts the `brgen` Abstract Syntax Tree (AST) into the `ExtendedBinaryModule` (EBM) Intermediate Representation (IR).
- **ConverterContext**: The central object that orchestrates the AST-to-EBM conversion process within `ebmgen`. It holds the `ConverterState`, the `EBMRepository`, and provides access to the different specialized converters (e.g., `StatementConverter`).
- **EBMRepository**: A key component of `ebmgen` responsible for building the EBM. It manages the creation of all EBM objects (Identifiers, Types, Statements, Expressions), assigns unique IDs, and uses `ReferenceRepository` instances to store them. It ensures that identical objects are not duplicated.
- **ReferenceRepository**: A template class used by `EBMRepository` to manage a collection of a specific EBM object type (e.g., all `Statement` objects). It handles the logic for adding new objects, caching them to prevent duplicates, and assigning IDs.
- **ConverterState**: A struct that holds the transient state during the conversion process. This includes context like the current endianness, the AST node being processed, and a cache of already visited nodes to correctly handle cycles and shared structures.
- **MappingTable**: A class used after the EBM is constructed to provide convenient, high-performance access to its contents. It builds hashmaps to look up any object by its ID and provides crucial helper functions for code generators.
- **get_associated_identifier**: A key function within `MappingTable` that code generators should use to retrieve the string name for an identifier associated with a `StatementRef`, `ExpressionRef`, or `TypeRef`. It provides a robust way to get a name, even generating a temporary one if none is explicitly defined.

### ebmcodegen (Code Generator Generator)

- **ebmcodegen**: A code-generator-generator subproject. It scans the EBM using a reflection mechanism based on the visitor pattern and generates C++ code that forms the backbone of a language-specific code generator.
- **visitor hook**: A C++ code snippet provided as a `.hpp` file that implements language-specific code generation logic for a particular EBM node (e.g., a `Statement` or `Expression`). It is not a class definition, but rather the literal body of a function that is dynamically generated by `ebmcodegen`. Each hook must return an `expected<Result>` value, where the `Result` struct holds the generated code in a `CodeWriter` object. The lifecycle of these hooks (creation, updating) is managed by the `script/ebmtemplate.py` script.
- **DSL (for Visitor Hooks)**: A Domain-Specific Language supported by `ebmcodegen` to write visitor hooks in a more concise and readable way. It allows mixing C++ code, EBM node processing, and control flow structures using special markers (`{% ... %}`, `{{ ... }}`, `{* ... *}`, etc.).

## Utility Scripts and Tools

- **src2json**: A tool from the `brgen` repository that parses `.bgn` files and outputs the `brgen` AST in JSON format.
- **json2cpp2**: A tool from the `brgen` repository that generates C++ header and source files (`.hpp`/`.cpp`) from a JSON definition, specifically used for `extended_binary_module.bgn`.
- **ebmtemplate.py**: A helper script that wraps `ebmcodegen` to simplify the lifecycle of visitor hooks. It is used to create new hook files, update the variable information in existing hooks, and list available hooks.
- **unictest.py**: An automated testing script that orchestrates the entire development and verification workflow. It handles EBM generation, runs the target code generator, and executes language-specific tests. It can also report unimplemented visitor hooks.
- **update_ebm.py**: A script that automates the process of regenerating all EBM-related files when the core EBM structure (`extended_binary_module.bgn`) is modified. It updates C++ definitions, rebuilds tools, and regenerates metadata and conversion files to ensure project-wide consistency.

## C++ Internals

- **MAYBE macro**: A C++ macro used extensively for error handling. It's designed to work with `expected<T>` types and raw pointers, checking for an error state and performing an early return if an error is found, similar to Rust's `?` operator.
