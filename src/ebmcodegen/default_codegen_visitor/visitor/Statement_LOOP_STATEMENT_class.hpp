/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_LOOP_STATEMENT_class
  Available Variables:
    ctx: Context_Statement_LOOP_STATEMENT
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
        module_: ebmgen::MappingTable
      item_id: ebm::StatementRef
      kind: const ebm::StatementKind&
      loop: const ebm::LoopStatement&
        loop_type: LoopType
        collection: *ExpressionRef
        condition: *Condition
          cond: ExpressionRef
        increment: *StatementRef
        init: *StatementRef
        item_var: *StatementRef
        body: StatementRef
        lowered_statement: LoweredStatementRef
        next_lowered_loop: LoweredStatementRef
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/
/*license*/
#include "../codegen.hpp"
DEFINE_VISITOR(Statement_LOOP_STATEMENT) {
    if (ctx.config().loop_statement_custom) {
        return ctx.config().loop_statement_custom(ctx);
    }
    auto& loop = ctx.loop;
    if (!is_nil(loop.lowered_statement.id)) {
        return ctx.visit(loop.lowered_statement.id);
    }
    CodeWriter w;
    if (auto init = loop.init(); init && init->id.value() != 0) {
        MAYBE(init_s, ctx.visit(*init));
        w.write(init_s.to_writer());
    }
    std::optional<std::string> cond;
    CodeWriter condition_related;
    if (auto c = loop.condition()) {
        auto added = ctx.add_writer();
        MAYBE(expr, ctx.visit(c->cond));
        cond = std::move(expr.to_string());
        MAYBE(got, ctx.get_writer());
        condition_related = std::move(got.get());
        w.write(condition_related);
    }
    else {
        if (ctx.config().infinity_loop_keyword.empty()) {
            MAYBE(true_, get_bool_literal(ctx, true));
            cond = std::move(true_);
        }
    }

    if (ctx.config().before_loop_wrapper) {
        MAYBE(before, ctx.config().before_loop_wrapper(ctx));
        w.write(before.to_writer());
    }

    if (cond) {
        if (ctx.config().use_brace_for_condition) {
            w.writeln(ctx.config().conditional_loop_keyword, " (", tidy_condition_brace(std::move(*cond)), ") ", ctx.config().begin_block);
        }
        else {
            w.writeln(ctx.config().conditional_loop_keyword, " ", tidy_condition_brace(std::move(*cond)), " ", ctx.config().begin_block);
        }
    }
    else {
        w.writeln(ctx.config().infinity_loop_keyword, " ", ctx.config().begin_block);
    }
    {
        auto body_indent = w.indent_scope();
        if (ctx.config().before_loop_body_wrapper) {
            MAYBE(before, ctx.config().before_loop_body_wrapper(ctx));
            w.write(before.to_writer());
        }
        MAYBE(body, ctx.visit(loop.body));
        bool empty_body = body.to_writer().empty();
        w.write(body.to_writer());
        if (auto iter = loop.increment()) {
            MAYBE(step, ctx.visit(*iter));
            w.write(step.to_writer());
            empty_body = empty_body && step.to_writer().empty();
        }
        w.write(condition_related);
        if (ctx.config().after_loop_body_wrapper) {
            MAYBE(after, ctx.config().after_loop_body_wrapper(ctx));
            w.write(after.to_writer());
        }
        empty_body = empty_body && body.to_writer().empty();
        if (empty_body && ctx.config().empty_block_marker.size()) {
            w.writeln(ctx.config().empty_block_marker);
        }
    }
    w.writeln(ctx.config().end_block);

    return w;
}