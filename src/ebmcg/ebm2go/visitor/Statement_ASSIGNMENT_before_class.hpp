/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_ASSIGNMENT_before_class
  Available Variables:
    ctx: Context_Statement_ASSIGNMENT_before<Result>
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        module_: ebmgen::MappingTable
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
      item_id: ebm::StatementRef
      kind: const ebm::StatementKind&
      previous_assignment: const ebm::WeakStatementRef&
        id: StatementRef
      target: const ebm::ExpressionRef&
      value: const ebm::ExpressionRef&
      main_logic: ebmcodegen::util::MainLogicWrapper<Result>
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include "../codegen.hpp"
DEFINE_VISITOR(Statement_ASSIGNMENT_before) {
    using namespace CODEGEN_NAMESPACE;
    auto member = ctx.get_field<"member">(ctx.target);
    if (auto comp = get_composite_field(ctx, member)) {
        auto setter = comp->composite_setter();
        if (!setter) {
            return pass;
        }
        MAYBE(base, ctx.get_field<"base">(ctx.target));
        MAYBE(base_str, ctx.visit(base));
        MAYBE(value, ctx.visit(ctx.value));
        CodeWriter w;
        auto parent_ident = ctx.identifier(comp->parent_struct);
        MAYBE(member_ident, ctx.identifier(*member));
        auto base_ = base_str.to_writer();
        if (ctx.get_field<"struct_decl.related_variant">(comp->parent_struct)) {
            base_ = CODE(std::move(base_), ".", parent_ident);
        }
        auto setter_func_name = std::format(
            "Set{}",
            member_ident);
        w.writeln(base_, ".", setter_func_name, "(", value.to_writer(), ");");
        return w;
    }
    return pass;
}
