/*license*/
// Code generated by ebmcodegen at https://github.com/on-keyday/rebrgen
// DO NOT EDIT THIS FILE MANUALLY. you should edit visitor implementation files instead.
#include <ebmcodegen/stub/entry.hpp>
#include <ebmcodegen/stub/util.hpp>
#include <ebmgen/common.hpp>
#include <ebmgen/convert/helper.hpp>
#include <ebmgen/mapping.hpp>
#include <code/code_writer.h>
#include <code/loc_writer.h>
#include "codegen.hpp"
#undef CODEGEN_VISITOR
#undef CODEGEN_CONTEXT_PARAMETERS
#undef CODEGEN_CONTEXT
namespace ebm2python {
    expected<Result> visit_unimplemented(MergedVisitor& visitor,std::string_view kind,std::uint64_t item_id);
}
#if __has_include("visitor/entry_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_entry>>
#define CODEGEN_CONTEXT(dummy_name) Context_entry
#include "visitor/entry_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_entry"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_entry>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_entry>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_ENTRY)
#define CODEGEN_EXPECTED_PRIORITY_ENTRY 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_entry>> {}; // Unimplemented
#endif
#if __has_include("visitor/entry_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_entry_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_entry_before<Result>
#include "visitor/entry_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_entry_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_entry_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_entry_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_ENTRY_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_ENTRY_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_entry_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/entry_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_entry_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_entry_after<Result>
#include "visitor/entry_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_entry_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_entry_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_entry_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_ENTRY_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_ENTRY_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_entry_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/pre_visitor_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_pre_visitor>>
#define CODEGEN_CONTEXT(dummy_name) Context_pre_visitor
#include "visitor/pre_visitor_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_pre_visitor"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_pre_visitor>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_pre_visitor>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR)
#define CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_pre_visitor>> {}; // Unimplemented
#endif
#if __has_include("visitor/pre_visitor_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_pre_visitor_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_pre_visitor_before<Result>
#include "visitor/pre_visitor_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_pre_visitor_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_pre_visitor_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_pre_visitor_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_pre_visitor_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/pre_visitor_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_pre_visitor_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_pre_visitor_after<Result>
#include "visitor/pre_visitor_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_pre_visitor_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_pre_visitor_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_pre_visitor_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_pre_visitor_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/post_entry_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_post_entry>>
#define CODEGEN_CONTEXT(dummy_name) Context_post_entry<Result>
#include "visitor/post_entry_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_post_entry<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_post_entry>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_post_entry>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_POST_ENTRY)
#define CODEGEN_EXPECTED_PRIORITY_POST_ENTRY 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_post_entry>> {}; // Unimplemented
#endif
#if __has_include("visitor/post_entry_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_post_entry_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_post_entry_before<Result>
#include "visitor/post_entry_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_post_entry_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_post_entry_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_post_entry_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_post_entry_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/post_entry_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_post_entry_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_post_entry_after<Result>
#include "visitor/post_entry_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_post_entry_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_post_entry_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_post_entry_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_post_entry_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_BLOCK_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_BLOCK>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_BLOCK
#include "visitor/Statement_BLOCK_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_BLOCK"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_BLOCK>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_BLOCK>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_BLOCK>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_BLOCK_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_BLOCK_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_BLOCK_before<Result>
#include "visitor/Statement_BLOCK_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_BLOCK_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_BLOCK_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_BLOCK_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_BLOCK_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_BLOCK_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_BLOCK_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_BLOCK_after<Result>
#include "visitor/Statement_BLOCK_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_BLOCK_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_BLOCK_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_BLOCK_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_BLOCK_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ASSIGNMENT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ASSIGNMENT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ASSIGNMENT
#include "visitor/Statement_ASSIGNMENT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ASSIGNMENT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ASSIGNMENT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ASSIGNMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ASSIGNMENT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ASSIGNMENT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ASSIGNMENT_before<Result>
#include "visitor/Statement_ASSIGNMENT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ASSIGNMENT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ASSIGNMENT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ASSIGNMENT_after<Result>
#include "visitor/Statement_ASSIGNMENT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ASSIGNMENT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_YIELD_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_YIELD>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_YIELD
#include "visitor/Statement_YIELD_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_YIELD"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_YIELD>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_YIELD>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_YIELD>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_YIELD_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_YIELD_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_YIELD_before<Result>
#include "visitor/Statement_YIELD_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_YIELD_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_YIELD_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_YIELD_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_YIELD_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_YIELD_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_YIELD_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_YIELD_after<Result>
#include "visitor/Statement_YIELD_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_YIELD_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_YIELD_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_YIELD_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_YIELD_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_APPEND_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_APPEND>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_APPEND
#include "visitor/Statement_APPEND_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_APPEND"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_APPEND>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_APPEND>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_APPEND>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_APPEND_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_APPEND_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_APPEND_before<Result>
#include "visitor/Statement_APPEND_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_APPEND_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_APPEND_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_APPEND_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_APPEND_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_APPEND_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_APPEND_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_APPEND_after<Result>
#include "visitor/Statement_APPEND_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_APPEND_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_APPEND_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_APPEND_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_APPEND_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_RETURN_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_RETURN>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_RETURN
#include "visitor/Statement_RETURN_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_RETURN"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_RETURN>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_RETURN>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_RETURN_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_RETURN_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_RETURN_before<Result>
#include "visitor/Statement_RETURN_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_RETURN_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_RETURN_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_RETURN_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_RETURN_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_RETURN_after<Result>
#include "visitor/Statement_RETURN_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_RETURN_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_RETURN_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ERROR_RETURN_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ERROR_RETURN>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ERROR_RETURN
#include "visitor/Statement_ERROR_RETURN_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ERROR_RETURN"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ERROR_RETURN>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ERROR_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ERROR_RETURN>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ERROR_RETURN_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ERROR_RETURN_before<Result>
#include "visitor/Statement_ERROR_RETURN_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ERROR_RETURN_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ERROR_RETURN_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ERROR_RETURN_after<Result>
#include "visitor/Statement_ERROR_RETURN_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ERROR_RETURN_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ASSERT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ASSERT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ASSERT
#include "visitor/Statement_ASSERT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ASSERT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ASSERT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ASSERT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ASSERT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ASSERT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ASSERT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ASSERT_before<Result>
#include "visitor/Statement_ASSERT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ASSERT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ASSERT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ASSERT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ASSERT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ASSERT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ASSERT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ASSERT_after<Result>
#include "visitor/Statement_ASSERT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ASSERT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ASSERT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ASSERT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ASSERT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_READ_DATA_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_READ_DATA>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_READ_DATA
#include "visitor/Statement_READ_DATA_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_READ_DATA"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_READ_DATA>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_READ_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_READ_DATA>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_READ_DATA_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_READ_DATA_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_READ_DATA_before<Result>
#include "visitor/Statement_READ_DATA_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_READ_DATA_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_READ_DATA_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_READ_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_READ_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_READ_DATA_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_READ_DATA_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_READ_DATA_after<Result>
#include "visitor/Statement_READ_DATA_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_READ_DATA_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_READ_DATA_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_READ_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_READ_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_WRITE_DATA_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_WRITE_DATA>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_WRITE_DATA
#include "visitor/Statement_WRITE_DATA_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_WRITE_DATA"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_WRITE_DATA>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_WRITE_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_WRITE_DATA>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_WRITE_DATA_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_WRITE_DATA_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_WRITE_DATA_before<Result>
#include "visitor/Statement_WRITE_DATA_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_WRITE_DATA_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_WRITE_DATA_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_WRITE_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_WRITE_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_WRITE_DATA_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_WRITE_DATA_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_WRITE_DATA_after<Result>
#include "visitor/Statement_WRITE_DATA_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_WRITE_DATA_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_WRITE_DATA_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_WRITE_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_WRITE_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_RESERVE_DATA_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_RESERVE_DATA>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_RESERVE_DATA
#include "visitor/Statement_RESERVE_DATA_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_RESERVE_DATA"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_RESERVE_DATA>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_RESERVE_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_RESERVE_DATA>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_RESERVE_DATA_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_RESERVE_DATA_before<Result>
#include "visitor/Statement_RESERVE_DATA_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_RESERVE_DATA_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_RESERVE_DATA_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_RESERVE_DATA_after<Result>
#include "visitor/Statement_RESERVE_DATA_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_RESERVE_DATA_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_IF_STATEMENT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_IF_STATEMENT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_IF_STATEMENT
#include "visitor/Statement_IF_STATEMENT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_IF_STATEMENT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_IF_STATEMENT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_IF_STATEMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_IF_STATEMENT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_IF_STATEMENT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_IF_STATEMENT_before<Result>
#include "visitor/Statement_IF_STATEMENT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_IF_STATEMENT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_IF_STATEMENT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_IF_STATEMENT_after<Result>
#include "visitor/Statement_IF_STATEMENT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_IF_STATEMENT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_LOOP_STATEMENT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_LOOP_STATEMENT
#include "visitor/Statement_LOOP_STATEMENT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_LOOP_STATEMENT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_LOOP_STATEMENT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_LOOP_STATEMENT_before<Result>
#include "visitor/Statement_LOOP_STATEMENT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_LOOP_STATEMENT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_LOOP_STATEMENT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_LOOP_STATEMENT_after<Result>
#include "visitor/Statement_LOOP_STATEMENT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_LOOP_STATEMENT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_MATCH_STATEMENT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_MATCH_STATEMENT
#include "visitor/Statement_MATCH_STATEMENT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_MATCH_STATEMENT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_MATCH_STATEMENT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_MATCH_STATEMENT_before<Result>
#include "visitor/Statement_MATCH_STATEMENT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_MATCH_STATEMENT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_MATCH_STATEMENT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_MATCH_STATEMENT_after<Result>
#include "visitor/Statement_MATCH_STATEMENT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_MATCH_STATEMENT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_MATCH_BRANCH_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_MATCH_BRANCH
#include "visitor/Statement_MATCH_BRANCH_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_MATCH_BRANCH"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_MATCH_BRANCH_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_MATCH_BRANCH_before<Result>
#include "visitor/Statement_MATCH_BRANCH_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_MATCH_BRANCH_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_MATCH_BRANCH_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_MATCH_BRANCH_after<Result>
#include "visitor/Statement_MATCH_BRANCH_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_MATCH_BRANCH_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_BREAK_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_BREAK>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_BREAK
#include "visitor/Statement_BREAK_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_BREAK"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_BREAK>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_BREAK>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_BREAK>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_BREAK_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_BREAK_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_BREAK_before<Result>
#include "visitor/Statement_BREAK_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_BREAK_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_BREAK_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_BREAK_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_BREAK_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_BREAK_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_BREAK_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_BREAK_after<Result>
#include "visitor/Statement_BREAK_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_BREAK_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_BREAK_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_BREAK_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_BREAK_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_CONTINUE_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_CONTINUE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_CONTINUE
#include "visitor/Statement_CONTINUE_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_CONTINUE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_CONTINUE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_CONTINUE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_CONTINUE>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_CONTINUE_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_CONTINUE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_CONTINUE_before<Result>
#include "visitor/Statement_CONTINUE_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_CONTINUE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_CONTINUE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_CONTINUE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_CONTINUE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_CONTINUE_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_CONTINUE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_CONTINUE_after<Result>
#include "visitor/Statement_CONTINUE_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_CONTINUE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_CONTINUE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_CONTINUE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_CONTINUE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_FUNCTION_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_FUNCTION_DECL
#include "visitor/Statement_FUNCTION_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_FUNCTION_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_FUNCTION_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_FUNCTION_DECL_before<Result>
#include "visitor/Statement_FUNCTION_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_FUNCTION_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_FUNCTION_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_FUNCTION_DECL_after<Result>
#include "visitor/Statement_FUNCTION_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_FUNCTION_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_VARIABLE_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_VARIABLE_DECL
#include "visitor/Statement_VARIABLE_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_VARIABLE_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_VARIABLE_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_VARIABLE_DECL_before<Result>
#include "visitor/Statement_VARIABLE_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_VARIABLE_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_VARIABLE_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_VARIABLE_DECL_after<Result>
#include "visitor/Statement_VARIABLE_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_VARIABLE_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_PARAMETER_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PARAMETER_DECL
#include "visitor/Statement_PARAMETER_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PARAMETER_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_PARAMETER_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PARAMETER_DECL_before<Result>
#include "visitor/Statement_PARAMETER_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PARAMETER_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_PARAMETER_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PARAMETER_DECL_after<Result>
#include "visitor/Statement_PARAMETER_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PARAMETER_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_FIELD_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_FIELD_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_FIELD_DECL
#include "visitor/Statement_FIELD_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_FIELD_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_FIELD_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_FIELD_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_FIELD_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_FIELD_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_FIELD_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_FIELD_DECL_before<Result>
#include "visitor/Statement_FIELD_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_FIELD_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_FIELD_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_FIELD_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_FIELD_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_FIELD_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_FIELD_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_FIELD_DECL_after<Result>
#include "visitor/Statement_FIELD_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_FIELD_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_FIELD_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_FIELD_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_FIELD_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_COMPOSITE_FIELD_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_COMPOSITE_FIELD_DECL
#include "visitor/Statement_COMPOSITE_FIELD_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_COMPOSITE_FIELD_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_COMPOSITE_FIELD_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_COMPOSITE_FIELD_DECL_before<Result>
#include "visitor/Statement_COMPOSITE_FIELD_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_COMPOSITE_FIELD_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_COMPOSITE_FIELD_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_COMPOSITE_FIELD_DECL_after<Result>
#include "visitor/Statement_COMPOSITE_FIELD_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_COMPOSITE_FIELD_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ENUM_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENUM_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENUM_DECL
#include "visitor/Statement_ENUM_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENUM_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENUM_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENUM_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENUM_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ENUM_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENUM_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENUM_DECL_before<Result>
#include "visitor/Statement_ENUM_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENUM_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENUM_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENUM_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENUM_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ENUM_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENUM_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENUM_DECL_after<Result>
#include "visitor/Statement_ENUM_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENUM_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENUM_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENUM_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENUM_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ENUM_MEMBER_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENUM_MEMBER_DECL
#include "visitor/Statement_ENUM_MEMBER_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENUM_MEMBER_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ENUM_MEMBER_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENUM_MEMBER_DECL_before<Result>
#include "visitor/Statement_ENUM_MEMBER_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENUM_MEMBER_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ENUM_MEMBER_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENUM_MEMBER_DECL_after<Result>
#include "visitor/Statement_ENUM_MEMBER_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENUM_MEMBER_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_STRUCT_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_STRUCT_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_STRUCT_DECL
#include "visitor/Statement_STRUCT_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_STRUCT_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_STRUCT_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_STRUCT_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_STRUCT_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_STRUCT_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_STRUCT_DECL_before<Result>
#include "visitor/Statement_STRUCT_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_STRUCT_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_STRUCT_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_STRUCT_DECL_after<Result>
#include "visitor/Statement_STRUCT_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_STRUCT_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_UNION_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_UNION_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_UNION_DECL
#include "visitor/Statement_UNION_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_UNION_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_UNION_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_UNION_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_UNION_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_UNION_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_UNION_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_UNION_DECL_before<Result>
#include "visitor/Statement_UNION_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_UNION_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_UNION_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_UNION_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_UNION_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_UNION_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_UNION_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_UNION_DECL_after<Result>
#include "visitor/Statement_UNION_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_UNION_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_UNION_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_UNION_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_UNION_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_UNION_MEMBER_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_UNION_MEMBER_DECL
#include "visitor/Statement_UNION_MEMBER_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_UNION_MEMBER_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_UNION_MEMBER_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_UNION_MEMBER_DECL_before<Result>
#include "visitor/Statement_UNION_MEMBER_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_UNION_MEMBER_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_UNION_MEMBER_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_UNION_MEMBER_DECL_after<Result>
#include "visitor/Statement_UNION_MEMBER_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_UNION_MEMBER_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_PROGRAM_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROGRAM_DECL
#include "visitor/Statement_PROGRAM_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROGRAM_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_PROGRAM_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROGRAM_DECL_before<Result>
#include "visitor/Statement_PROGRAM_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROGRAM_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_PROGRAM_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROGRAM_DECL_after<Result>
#include "visitor/Statement_PROGRAM_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROGRAM_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_PROPERTY_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROPERTY_DECL
#include "visitor/Statement_PROPERTY_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROPERTY_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_PROPERTY_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROPERTY_DECL_before<Result>
#include "visitor/Statement_PROPERTY_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROPERTY_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_PROPERTY_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROPERTY_DECL_after<Result>
#include "visitor/Statement_PROPERTY_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROPERTY_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_PROPERTY_MEMBER_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROPERTY_MEMBER_DECL
#include "visitor/Statement_PROPERTY_MEMBER_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROPERTY_MEMBER_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_PROPERTY_MEMBER_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROPERTY_MEMBER_DECL_before<Result>
#include "visitor/Statement_PROPERTY_MEMBER_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROPERTY_MEMBER_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_PROPERTY_MEMBER_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROPERTY_MEMBER_DECL_after<Result>
#include "visitor/Statement_PROPERTY_MEMBER_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROPERTY_MEMBER_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_METADATA_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_METADATA>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_METADATA
#include "visitor/Statement_METADATA_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_METADATA"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_METADATA>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_METADATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_METADATA>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_METADATA_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_METADATA_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_METADATA_before<Result>
#include "visitor/Statement_METADATA_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_METADATA_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_METADATA_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_METADATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_METADATA_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_METADATA_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_METADATA_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_METADATA_after<Result>
#include "visitor/Statement_METADATA_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_METADATA_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_METADATA_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_METADATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_METADATA_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_IMPORT_MODULE_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_IMPORT_MODULE
#include "visitor/Statement_IMPORT_MODULE_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_IMPORT_MODULE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_IMPORT_MODULE_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_IMPORT_MODULE_before<Result>
#include "visitor/Statement_IMPORT_MODULE_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_IMPORT_MODULE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_IMPORT_MODULE_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_IMPORT_MODULE_after<Result>
#include "visitor/Statement_IMPORT_MODULE_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_IMPORT_MODULE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_EXPRESSION_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_EXPRESSION>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_EXPRESSION
#include "visitor/Statement_EXPRESSION_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_EXPRESSION"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_EXPRESSION>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_EXPRESSION>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_EXPRESSION>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_EXPRESSION_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_EXPRESSION_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_EXPRESSION_before<Result>
#include "visitor/Statement_EXPRESSION_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_EXPRESSION_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_EXPRESSION_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_EXPRESSION_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_EXPRESSION_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_EXPRESSION_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_EXPRESSION_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_EXPRESSION_after<Result>
#include "visitor/Statement_EXPRESSION_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_EXPRESSION_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_EXPRESSION_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_EXPRESSION_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_EXPRESSION_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ERROR_REPORT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ERROR_REPORT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ERROR_REPORT
#include "visitor/Statement_ERROR_REPORT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ERROR_REPORT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ERROR_REPORT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ERROR_REPORT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ERROR_REPORT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ERROR_REPORT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ERROR_REPORT_before<Result>
#include "visitor/Statement_ERROR_REPORT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ERROR_REPORT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ERROR_REPORT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ERROR_REPORT_after<Result>
#include "visitor/Statement_ERROR_REPORT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ERROR_REPORT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_LOWERED_IO_STATEMENTS_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_LOWERED_IO_STATEMENTS
#include "visitor/Statement_LOWERED_IO_STATEMENTS_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_LOWERED_IO_STATEMENTS"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_LOWERED_IO_STATEMENTS_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_LOWERED_IO_STATEMENTS_before<Result>
#include "visitor/Statement_LOWERED_IO_STATEMENTS_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_LOWERED_IO_STATEMENTS_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_LOWERED_IO_STATEMENTS_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_LOWERED_IO_STATEMENTS_after<Result>
#include "visitor/Statement_LOWERED_IO_STATEMENTS_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_LOWERED_IO_STATEMENTS_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_SUB_BYTE_RANGE_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_SUB_BYTE_RANGE
#include "visitor/Statement_SUB_BYTE_RANGE_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_SUB_BYTE_RANGE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_SUB_BYTE_RANGE_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_SUB_BYTE_RANGE_before<Result>
#include "visitor/Statement_SUB_BYTE_RANGE_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_SUB_BYTE_RANGE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_SUB_BYTE_RANGE_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_SUB_BYTE_RANGE_after<Result>
#include "visitor/Statement_SUB_BYTE_RANGE_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_SUB_BYTE_RANGE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_INIT_CHECK_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_INIT_CHECK>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_INIT_CHECK
#include "visitor/Statement_INIT_CHECK_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_INIT_CHECK"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_INIT_CHECK>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_INIT_CHECK>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_INIT_CHECK>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_INIT_CHECK_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_INIT_CHECK_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_INIT_CHECK_before<Result>
#include "visitor/Statement_INIT_CHECK_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_INIT_CHECK_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_INIT_CHECK_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_INIT_CHECK_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_INIT_CHECK_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_INIT_CHECK_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_INIT_CHECK_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_INIT_CHECK_after<Result>
#include "visitor/Statement_INIT_CHECK_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_INIT_CHECK_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_INIT_CHECK_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_INIT_CHECK_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_INIT_CHECK_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ENDIAN_VARIABLE_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENDIAN_VARIABLE
#include "visitor/Statement_ENDIAN_VARIABLE_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENDIAN_VARIABLE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ENDIAN_VARIABLE_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENDIAN_VARIABLE_before<Result>
#include "visitor/Statement_ENDIAN_VARIABLE_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENDIAN_VARIABLE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ENDIAN_VARIABLE_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENDIAN_VARIABLE_after<Result>
#include "visitor/Statement_ENDIAN_VARIABLE_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENDIAN_VARIABLE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_dispatch_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement
#include "visitor/Statement_dispatch_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_before_dispatch_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_before<Result>
#include "visitor/Statement_before_dispatch_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_after_dispatch_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_after<Result>
#include "visitor/Statement_after_dispatch_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Statement_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Block_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Block>>
#define CODEGEN_CONTEXT(dummy_name) Context_Block
#include "visitor/Block_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Block"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Block>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Block>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_BLOCK)
#define CODEGEN_EXPECTED_PRIORITY_BLOCK 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Block>> {}; // Unimplemented
#endif
#if __has_include("visitor/Block_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Block_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Block_before<Result>
#include "visitor/Block_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Block_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Block_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Block_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_BLOCK_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_BLOCK_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Block_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Block_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Block_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Block_after<Result>
#include "visitor/Block_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Block_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Block_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Block_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_BLOCK_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_BLOCK_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Block_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_INT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_INT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_INT
#include "visitor/Expression_LITERAL_INT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_INT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_INT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_INT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_INT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_INT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_INT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_INT_before<Result>
#include "visitor/Expression_LITERAL_INT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_INT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_INT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_INT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_INT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_INT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_INT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_INT_after<Result>
#include "visitor/Expression_LITERAL_INT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_INT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_INT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_INT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_INT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_INT64_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_INT64>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_INT64
#include "visitor/Expression_LITERAL_INT64_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_INT64"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_INT64>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_INT64>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_INT64>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_INT64_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_INT64_before<Result>
#include "visitor/Expression_LITERAL_INT64_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_INT64_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_INT64_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_INT64_after<Result>
#include "visitor/Expression_LITERAL_INT64_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_INT64_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_BOOL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_BOOL
#include "visitor/Expression_LITERAL_BOOL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_BOOL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_BOOL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_BOOL_before<Result>
#include "visitor/Expression_LITERAL_BOOL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_BOOL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_BOOL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_BOOL_after<Result>
#include "visitor/Expression_LITERAL_BOOL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_BOOL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_STRING_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_STRING>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_STRING
#include "visitor/Expression_LITERAL_STRING_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_STRING"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_STRING>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_STRING>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_STRING>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_STRING_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_STRING_before<Result>
#include "visitor/Expression_LITERAL_STRING_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_STRING_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_STRING_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_STRING_after<Result>
#include "visitor/Expression_LITERAL_STRING_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_STRING_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_TYPE_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_TYPE
#include "visitor/Expression_LITERAL_TYPE_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_TYPE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_TYPE_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_TYPE_before<Result>
#include "visitor/Expression_LITERAL_TYPE_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_TYPE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_TYPE_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_TYPE_after<Result>
#include "visitor/Expression_LITERAL_TYPE_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_TYPE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_CHAR_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_CHAR
#include "visitor/Expression_LITERAL_CHAR_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_CHAR"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_CHAR_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_CHAR_before<Result>
#include "visitor/Expression_LITERAL_CHAR_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_CHAR_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_CHAR_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_CHAR_after<Result>
#include "visitor/Expression_LITERAL_CHAR_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_CHAR_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_IDENTIFIER_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IDENTIFIER>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IDENTIFIER
#include "visitor/Expression_IDENTIFIER_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IDENTIFIER"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IDENTIFIER>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IDENTIFIER>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IDENTIFIER>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_IDENTIFIER_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IDENTIFIER_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IDENTIFIER_before<Result>
#include "visitor/Expression_IDENTIFIER_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IDENTIFIER_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IDENTIFIER_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IDENTIFIER_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IDENTIFIER_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_IDENTIFIER_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IDENTIFIER_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IDENTIFIER_after<Result>
#include "visitor/Expression_IDENTIFIER_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IDENTIFIER_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IDENTIFIER_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IDENTIFIER_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IDENTIFIER_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_BINARY_OP_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_BINARY_OP>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_BINARY_OP
#include "visitor/Expression_BINARY_OP_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_BINARY_OP"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_BINARY_OP>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_BINARY_OP>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_BINARY_OP>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_BINARY_OP_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_BINARY_OP_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_BINARY_OP_before<Result>
#include "visitor/Expression_BINARY_OP_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_BINARY_OP_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_BINARY_OP_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_BINARY_OP_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_BINARY_OP_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_BINARY_OP_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_BINARY_OP_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_BINARY_OP_after<Result>
#include "visitor/Expression_BINARY_OP_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_BINARY_OP_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_BINARY_OP_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_BINARY_OP_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_BINARY_OP_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_UNARY_OP_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_UNARY_OP>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_UNARY_OP
#include "visitor/Expression_UNARY_OP_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_UNARY_OP"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_UNARY_OP>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_UNARY_OP>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_UNARY_OP>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_UNARY_OP_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_UNARY_OP_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_UNARY_OP_before<Result>
#include "visitor/Expression_UNARY_OP_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_UNARY_OP_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_UNARY_OP_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_UNARY_OP_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_UNARY_OP_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_UNARY_OP_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_UNARY_OP_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_UNARY_OP_after<Result>
#include "visitor/Expression_UNARY_OP_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_UNARY_OP_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_UNARY_OP_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_UNARY_OP_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_UNARY_OP_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_CALL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CALL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CALL
#include "visitor/Expression_CALL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CALL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CALL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CALL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CALL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_CALL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CALL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CALL_before<Result>
#include "visitor/Expression_CALL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CALL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CALL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CALL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CALL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_CALL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CALL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CALL_after<Result>
#include "visitor/Expression_CALL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CALL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CALL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CALL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CALL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_INDEX_ACCESS_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_INDEX_ACCESS
#include "visitor/Expression_INDEX_ACCESS_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_INDEX_ACCESS"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_INDEX_ACCESS_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_INDEX_ACCESS_before<Result>
#include "visitor/Expression_INDEX_ACCESS_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_INDEX_ACCESS_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_INDEX_ACCESS_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_INDEX_ACCESS_after<Result>
#include "visitor/Expression_INDEX_ACCESS_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_INDEX_ACCESS_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_MEMBER_ACCESS_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_MEMBER_ACCESS
#include "visitor/Expression_MEMBER_ACCESS_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_MEMBER_ACCESS"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_MEMBER_ACCESS_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_MEMBER_ACCESS_before<Result>
#include "visitor/Expression_MEMBER_ACCESS_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_MEMBER_ACCESS_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_MEMBER_ACCESS_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_MEMBER_ACCESS_after<Result>
#include "visitor/Expression_MEMBER_ACCESS_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_MEMBER_ACCESS_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_ENUM_MEMBER_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ENUM_MEMBER
#include "visitor/Expression_ENUM_MEMBER_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ENUM_MEMBER"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_ENUM_MEMBER_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ENUM_MEMBER_before<Result>
#include "visitor/Expression_ENUM_MEMBER_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ENUM_MEMBER_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_ENUM_MEMBER_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ENUM_MEMBER_after<Result>
#include "visitor/Expression_ENUM_MEMBER_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ENUM_MEMBER_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_TYPE_CAST_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_TYPE_CAST>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_TYPE_CAST
#include "visitor/Expression_TYPE_CAST_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_TYPE_CAST"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_TYPE_CAST>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_TYPE_CAST>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_TYPE_CAST>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_TYPE_CAST_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_TYPE_CAST_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_TYPE_CAST_before<Result>
#include "visitor/Expression_TYPE_CAST_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_TYPE_CAST_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_TYPE_CAST_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_TYPE_CAST_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_TYPE_CAST_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_TYPE_CAST_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_TYPE_CAST_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_TYPE_CAST_after<Result>
#include "visitor/Expression_TYPE_CAST_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_TYPE_CAST_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_TYPE_CAST_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_TYPE_CAST_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_TYPE_CAST_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_RANGE_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_RANGE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_RANGE
#include "visitor/Expression_RANGE_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_RANGE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_RANGE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_RANGE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_RANGE>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_RANGE_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_RANGE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_RANGE_before<Result>
#include "visitor/Expression_RANGE_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_RANGE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_RANGE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_RANGE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_RANGE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_RANGE_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_RANGE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_RANGE_after<Result>
#include "visitor/Expression_RANGE_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_RANGE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_RANGE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_RANGE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_RANGE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_DEFAULT_VALUE_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_DEFAULT_VALUE
#include "visitor/Expression_DEFAULT_VALUE_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_DEFAULT_VALUE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_DEFAULT_VALUE_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_DEFAULT_VALUE_before<Result>
#include "visitor/Expression_DEFAULT_VALUE_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_DEFAULT_VALUE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_DEFAULT_VALUE_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_DEFAULT_VALUE_after<Result>
#include "visitor/Expression_DEFAULT_VALUE_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_DEFAULT_VALUE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_IS_LITTLE_ENDIAN_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IS_LITTLE_ENDIAN
#include "visitor/Expression_IS_LITTLE_ENDIAN_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IS_LITTLE_ENDIAN"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_IS_LITTLE_ENDIAN_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IS_LITTLE_ENDIAN_before<Result>
#include "visitor/Expression_IS_LITTLE_ENDIAN_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IS_LITTLE_ENDIAN_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_IS_LITTLE_ENDIAN_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IS_LITTLE_ENDIAN_after<Result>
#include "visitor/Expression_IS_LITTLE_ENDIAN_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IS_LITTLE_ENDIAN_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_GET_STREAM_OFFSET_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_GET_STREAM_OFFSET
#include "visitor/Expression_GET_STREAM_OFFSET_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_GET_STREAM_OFFSET"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_GET_STREAM_OFFSET_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_GET_STREAM_OFFSET_before<Result>
#include "visitor/Expression_GET_STREAM_OFFSET_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_GET_STREAM_OFFSET_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_GET_STREAM_OFFSET_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_GET_STREAM_OFFSET_after<Result>
#include "visitor/Expression_GET_STREAM_OFFSET_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_GET_STREAM_OFFSET_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_GET_REMAINING_BYTES_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_GET_REMAINING_BYTES
#include "visitor/Expression_GET_REMAINING_BYTES_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_GET_REMAINING_BYTES"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_GET_REMAINING_BYTES_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_GET_REMAINING_BYTES_before<Result>
#include "visitor/Expression_GET_REMAINING_BYTES_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_GET_REMAINING_BYTES_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_GET_REMAINING_BYTES_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_GET_REMAINING_BYTES_after<Result>
#include "visitor/Expression_GET_REMAINING_BYTES_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_GET_REMAINING_BYTES_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_CAN_READ_STREAM_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CAN_READ_STREAM
#include "visitor/Expression_CAN_READ_STREAM_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CAN_READ_STREAM"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_CAN_READ_STREAM_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CAN_READ_STREAM_before<Result>
#include "visitor/Expression_CAN_READ_STREAM_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CAN_READ_STREAM_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_CAN_READ_STREAM_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CAN_READ_STREAM_after<Result>
#include "visitor/Expression_CAN_READ_STREAM_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CAN_READ_STREAM_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_ARRAY_SIZE_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ARRAY_SIZE
#include "visitor/Expression_ARRAY_SIZE_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ARRAY_SIZE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_ARRAY_SIZE_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ARRAY_SIZE_before<Result>
#include "visitor/Expression_ARRAY_SIZE_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ARRAY_SIZE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_ARRAY_SIZE_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ARRAY_SIZE_after<Result>
#include "visitor/Expression_ARRAY_SIZE_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ARRAY_SIZE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_ENUM_IS_DEFINED_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ENUM_IS_DEFINED
#include "visitor/Expression_ENUM_IS_DEFINED_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ENUM_IS_DEFINED"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_ENUM_IS_DEFINED_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ENUM_IS_DEFINED_before<Result>
#include "visitor/Expression_ENUM_IS_DEFINED_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ENUM_IS_DEFINED_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_ENUM_IS_DEFINED_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ENUM_IS_DEFINED_after<Result>
#include "visitor/Expression_ENUM_IS_DEFINED_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ENUM_IS_DEFINED_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_IS_ERROR_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IS_ERROR>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IS_ERROR
#include "visitor/Expression_IS_ERROR_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IS_ERROR"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IS_ERROR>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IS_ERROR>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IS_ERROR>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_IS_ERROR_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IS_ERROR_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IS_ERROR_before<Result>
#include "visitor/Expression_IS_ERROR_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IS_ERROR_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IS_ERROR_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IS_ERROR_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IS_ERROR_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_IS_ERROR_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IS_ERROR_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IS_ERROR_after<Result>
#include "visitor/Expression_IS_ERROR_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IS_ERROR_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IS_ERROR_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IS_ERROR_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_IS_ERROR_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_MAX_VALUE_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_MAX_VALUE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_MAX_VALUE
#include "visitor/Expression_MAX_VALUE_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_MAX_VALUE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_MAX_VALUE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_MAX_VALUE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_MAX_VALUE>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_MAX_VALUE_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_MAX_VALUE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_MAX_VALUE_before<Result>
#include "visitor/Expression_MAX_VALUE_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_MAX_VALUE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_MAX_VALUE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_MAX_VALUE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_MAX_VALUE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_MAX_VALUE_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_MAX_VALUE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_MAX_VALUE_after<Result>
#include "visitor/Expression_MAX_VALUE_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_MAX_VALUE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_MAX_VALUE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_MAX_VALUE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_MAX_VALUE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_READ_DATA_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_READ_DATA>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_READ_DATA
#include "visitor/Expression_READ_DATA_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_READ_DATA"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_READ_DATA>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_READ_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_READ_DATA>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_READ_DATA_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_READ_DATA_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_READ_DATA_before<Result>
#include "visitor/Expression_READ_DATA_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_READ_DATA_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_READ_DATA_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_READ_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_READ_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_READ_DATA_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_READ_DATA_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_READ_DATA_after<Result>
#include "visitor/Expression_READ_DATA_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_READ_DATA_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_READ_DATA_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_READ_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_READ_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_WRITE_DATA_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_WRITE_DATA>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_WRITE_DATA
#include "visitor/Expression_WRITE_DATA_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_WRITE_DATA"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_WRITE_DATA>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_WRITE_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_WRITE_DATA>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_WRITE_DATA_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_WRITE_DATA_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_WRITE_DATA_before<Result>
#include "visitor/Expression_WRITE_DATA_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_WRITE_DATA_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_WRITE_DATA_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_WRITE_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_WRITE_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_WRITE_DATA_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_WRITE_DATA_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_WRITE_DATA_after<Result>
#include "visitor/Expression_WRITE_DATA_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_WRITE_DATA_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_WRITE_DATA_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_WRITE_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_WRITE_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_CONDITIONAL_STATEMENT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CONDITIONAL_STATEMENT
#include "visitor/Expression_CONDITIONAL_STATEMENT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CONDITIONAL_STATEMENT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_CONDITIONAL_STATEMENT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CONDITIONAL_STATEMENT_before<Result>
#include "visitor/Expression_CONDITIONAL_STATEMENT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CONDITIONAL_STATEMENT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_CONDITIONAL_STATEMENT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CONDITIONAL_STATEMENT_after<Result>
#include "visitor/Expression_CONDITIONAL_STATEMENT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CONDITIONAL_STATEMENT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_CONDITIONAL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CONDITIONAL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CONDITIONAL
#include "visitor/Expression_CONDITIONAL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CONDITIONAL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CONDITIONAL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CONDITIONAL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CONDITIONAL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_CONDITIONAL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CONDITIONAL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CONDITIONAL_before<Result>
#include "visitor/Expression_CONDITIONAL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CONDITIONAL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CONDITIONAL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CONDITIONAL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CONDITIONAL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_CONDITIONAL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CONDITIONAL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CONDITIONAL_after<Result>
#include "visitor/Expression_CONDITIONAL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CONDITIONAL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CONDITIONAL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CONDITIONAL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_CONDITIONAL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_AVAILABLE_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_AVAILABLE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_AVAILABLE
#include "visitor/Expression_AVAILABLE_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_AVAILABLE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_AVAILABLE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_AVAILABLE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_AVAILABLE>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_AVAILABLE_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_AVAILABLE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_AVAILABLE_before<Result>
#include "visitor/Expression_AVAILABLE_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_AVAILABLE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_AVAILABLE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_AVAILABLE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_AVAILABLE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_AVAILABLE_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_AVAILABLE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_AVAILABLE_after<Result>
#include "visitor/Expression_AVAILABLE_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_AVAILABLE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_AVAILABLE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_AVAILABLE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_AVAILABLE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_SIZEOF_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SIZEOF>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SIZEOF
#include "visitor/Expression_SIZEOF_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SIZEOF"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SIZEOF>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SIZEOF>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SIZEOF>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_SIZEOF_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SIZEOF_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SIZEOF_before<Result>
#include "visitor/Expression_SIZEOF_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SIZEOF_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SIZEOF_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SIZEOF_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SIZEOF_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_SIZEOF_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SIZEOF_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SIZEOF_after<Result>
#include "visitor/Expression_SIZEOF_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SIZEOF_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SIZEOF_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SIZEOF_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SIZEOF_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_SUB_RANGE_INIT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SUB_RANGE_INIT
#include "visitor/Expression_SUB_RANGE_INIT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SUB_RANGE_INIT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_SUB_RANGE_INIT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SUB_RANGE_INIT_before<Result>
#include "visitor/Expression_SUB_RANGE_INIT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SUB_RANGE_INIT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_SUB_RANGE_INIT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SUB_RANGE_INIT_after<Result>
#include "visitor/Expression_SUB_RANGE_INIT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SUB_RANGE_INIT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_OR_COND_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_OR_COND>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_OR_COND
#include "visitor/Expression_OR_COND_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_OR_COND"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_OR_COND>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_OR_COND>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_OR_COND>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_OR_COND_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_OR_COND_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_OR_COND_before<Result>
#include "visitor/Expression_OR_COND_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_OR_COND_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_OR_COND_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_OR_COND_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_OR_COND_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_OR_COND_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_OR_COND_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_OR_COND_after<Result>
#include "visitor/Expression_OR_COND_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_OR_COND_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_OR_COND_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_OR_COND_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_OR_COND_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_ADDRESS_OF_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ADDRESS_OF>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ADDRESS_OF
#include "visitor/Expression_ADDRESS_OF_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ADDRESS_OF"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ADDRESS_OF>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ADDRESS_OF>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ADDRESS_OF>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_ADDRESS_OF_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ADDRESS_OF_before<Result>
#include "visitor/Expression_ADDRESS_OF_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ADDRESS_OF_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_ADDRESS_OF_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ADDRESS_OF_after<Result>
#include "visitor/Expression_ADDRESS_OF_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ADDRESS_OF_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_OPTIONAL_OF_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_OPTIONAL_OF
#include "visitor/Expression_OPTIONAL_OF_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_OPTIONAL_OF"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_OPTIONAL_OF_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_OPTIONAL_OF_before<Result>
#include "visitor/Expression_OPTIONAL_OF_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_OPTIONAL_OF_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_OPTIONAL_OF_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_OPTIONAL_OF_after<Result>
#include "visitor/Expression_OPTIONAL_OF_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_OPTIONAL_OF_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_SETTER_STATUS_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SETTER_STATUS>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SETTER_STATUS
#include "visitor/Expression_SETTER_STATUS_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SETTER_STATUS"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SETTER_STATUS>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SETTER_STATUS>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SETTER_STATUS>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_SETTER_STATUS_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SETTER_STATUS_before<Result>
#include "visitor/Expression_SETTER_STATUS_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SETTER_STATUS_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_SETTER_STATUS_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SETTER_STATUS_after<Result>
#include "visitor/Expression_SETTER_STATUS_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SETTER_STATUS_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_SELF_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SELF>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SELF
#include "visitor/Expression_SELF_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SELF"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SELF>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SELF>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SELF>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_SELF_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SELF_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SELF_before<Result>
#include "visitor/Expression_SELF_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SELF_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SELF_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SELF_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SELF_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_SELF_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SELF_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SELF_after<Result>
#include "visitor/Expression_SELF_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SELF_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SELF_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SELF_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_SELF_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_AS_ARG_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_AS_ARG>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_AS_ARG
#include "visitor/Expression_AS_ARG_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_AS_ARG"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_AS_ARG>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_AS_ARG>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_AS_ARG>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_AS_ARG_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_AS_ARG_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_AS_ARG_before<Result>
#include "visitor/Expression_AS_ARG_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_AS_ARG_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_AS_ARG_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_AS_ARG_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_AS_ARG_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_AS_ARG_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_AS_ARG_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_AS_ARG_after<Result>
#include "visitor/Expression_AS_ARG_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_AS_ARG_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_AS_ARG_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_AS_ARG_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_AS_ARG_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_dispatch_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression
#include "visitor/Expression_dispatch_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_before_dispatch_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_before<Result>
#include "visitor/Expression_before_dispatch_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_after_dispatch_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_after<Result>
#include "visitor/Expression_after_dispatch_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expression_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expressions_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expressions>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expressions
#include "visitor/Expressions_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expressions"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expressions>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expressions>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expressions>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expressions_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expressions_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expressions_before<Result>
#include "visitor/Expressions_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expressions_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expressions_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expressions_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expressions_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expressions_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expressions_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expressions_after<Result>
#include "visitor/Expressions_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expressions_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expressions_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expressions_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Expressions_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_INT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_INT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_INT
#include "visitor/Type_INT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_INT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_INT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_INT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_INT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_INT 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_INT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_INT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_INT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_INT_before<Result>
#include "visitor/Type_INT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_INT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_INT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_INT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_INT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_INT_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_INT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_INT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_INT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_INT_after<Result>
#include "visitor/Type_INT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_INT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_INT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_INT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_INT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_INT_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_INT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_UINT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_UINT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_UINT
#include "visitor/Type_UINT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_UINT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_UINT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_UINT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_UINT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_UINT 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_UINT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_UINT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_UINT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_UINT_before<Result>
#include "visitor/Type_UINT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_UINT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_UINT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_UINT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_UINT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_UINT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_UINT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_UINT_after<Result>
#include "visitor/Type_UINT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_UINT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_UINT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_UINT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_UINT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_USIZE_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_USIZE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_USIZE
#include "visitor/Type_USIZE_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_USIZE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_USIZE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_USIZE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_USIZE>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_USIZE_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_USIZE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_USIZE_before<Result>
#include "visitor/Type_USIZE_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_USIZE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_USIZE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_USIZE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_USIZE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_USIZE_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_USIZE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_USIZE_after<Result>
#include "visitor/Type_USIZE_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_USIZE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_USIZE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_USIZE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_USIZE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_FLOAT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_FLOAT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_FLOAT
#include "visitor/Type_FLOAT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_FLOAT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_FLOAT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_FLOAT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_FLOAT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_FLOAT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_FLOAT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_FLOAT_before<Result>
#include "visitor/Type_FLOAT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_FLOAT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_FLOAT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_FLOAT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_FLOAT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_FLOAT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_FLOAT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_FLOAT_after<Result>
#include "visitor/Type_FLOAT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_FLOAT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_FLOAT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_FLOAT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_FLOAT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_STRUCT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_STRUCT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_STRUCT
#include "visitor/Type_STRUCT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_STRUCT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_STRUCT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_STRUCT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_STRUCT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_STRUCT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_STRUCT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_STRUCT_before<Result>
#include "visitor/Type_STRUCT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_STRUCT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_STRUCT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_STRUCT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_STRUCT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_STRUCT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_STRUCT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_STRUCT_after<Result>
#include "visitor/Type_STRUCT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_STRUCT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_STRUCT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_STRUCT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_STRUCT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_RECURSIVE_STRUCT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_RECURSIVE_STRUCT
#include "visitor/Type_RECURSIVE_STRUCT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_RECURSIVE_STRUCT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_RECURSIVE_STRUCT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_RECURSIVE_STRUCT_before<Result>
#include "visitor/Type_RECURSIVE_STRUCT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_RECURSIVE_STRUCT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_RECURSIVE_STRUCT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_RECURSIVE_STRUCT_after<Result>
#include "visitor/Type_RECURSIVE_STRUCT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_RECURSIVE_STRUCT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_BOOL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_BOOL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_BOOL
#include "visitor/Type_BOOL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_BOOL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_BOOL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_BOOL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_BOOL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_BOOL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_BOOL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_BOOL_before<Result>
#include "visitor/Type_BOOL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_BOOL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_BOOL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_BOOL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_BOOL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_BOOL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_BOOL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_BOOL_after<Result>
#include "visitor/Type_BOOL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_BOOL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_BOOL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_BOOL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_BOOL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_VOID_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VOID>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VOID
#include "visitor/Type_VOID_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VOID"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VOID>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VOID>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VOID)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VOID 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VOID>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_VOID_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VOID_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VOID_before<Result>
#include "visitor/Type_VOID_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VOID_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VOID_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VOID_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VOID_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_VOID_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VOID_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VOID_after<Result>
#include "visitor/Type_VOID_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VOID_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VOID_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VOID_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VOID_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_META_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_META>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_META
#include "visitor/Type_META_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_META"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_META>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_META>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_META)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_META 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_META>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_META_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_META_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_META_before<Result>
#include "visitor/Type_META_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_META_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_META_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_META_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_META_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_META_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_META_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_META_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_META_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_META_after<Result>
#include "visitor/Type_META_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_META_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_META_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_META_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_META_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_META_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_META_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_ENUM_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENUM>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENUM
#include "visitor/Type_ENUM_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENUM"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENUM>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENUM>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENUM>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_ENUM_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENUM_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENUM_before<Result>
#include "visitor/Type_ENUM_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENUM_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENUM_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENUM_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENUM_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_ENUM_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENUM_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENUM_after<Result>
#include "visitor/Type_ENUM_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENUM_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENUM_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENUM_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENUM_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_ARRAY_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ARRAY>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ARRAY
#include "visitor/Type_ARRAY_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ARRAY"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ARRAY>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ARRAY>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ARRAY>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_ARRAY_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ARRAY_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ARRAY_before<Result>
#include "visitor/Type_ARRAY_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ARRAY_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ARRAY_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ARRAY_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ARRAY_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_ARRAY_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ARRAY_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ARRAY_after<Result>
#include "visitor/Type_ARRAY_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ARRAY_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ARRAY_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ARRAY_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ARRAY_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_VECTOR_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VECTOR>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VECTOR
#include "visitor/Type_VECTOR_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VECTOR"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VECTOR>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VECTOR>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VECTOR>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_VECTOR_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VECTOR_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VECTOR_before<Result>
#include "visitor/Type_VECTOR_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VECTOR_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VECTOR_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VECTOR_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VECTOR_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_VECTOR_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VECTOR_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VECTOR_after<Result>
#include "visitor/Type_VECTOR_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VECTOR_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VECTOR_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VECTOR_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VECTOR_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_VARIANT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VARIANT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VARIANT
#include "visitor/Type_VARIANT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VARIANT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VARIANT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VARIANT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VARIANT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_VARIANT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VARIANT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VARIANT_before<Result>
#include "visitor/Type_VARIANT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VARIANT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VARIANT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VARIANT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VARIANT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_VARIANT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VARIANT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VARIANT_after<Result>
#include "visitor/Type_VARIANT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VARIANT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VARIANT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VARIANT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_VARIANT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_RANGE_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_RANGE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_RANGE
#include "visitor/Type_RANGE_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_RANGE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_RANGE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_RANGE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_RANGE>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_RANGE_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_RANGE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_RANGE_before<Result>
#include "visitor/Type_RANGE_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_RANGE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_RANGE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_RANGE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_RANGE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_RANGE_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_RANGE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_RANGE_after<Result>
#include "visitor/Type_RANGE_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_RANGE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_RANGE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_RANGE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_RANGE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_ENCODER_RETURN_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENCODER_RETURN>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENCODER_RETURN
#include "visitor/Type_ENCODER_RETURN_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENCODER_RETURN"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENCODER_RETURN>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENCODER_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENCODER_RETURN>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_ENCODER_RETURN_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENCODER_RETURN_before<Result>
#include "visitor/Type_ENCODER_RETURN_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENCODER_RETURN_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_ENCODER_RETURN_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENCODER_RETURN_after<Result>
#include "visitor/Type_ENCODER_RETURN_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENCODER_RETURN_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_DECODER_RETURN_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_DECODER_RETURN>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_DECODER_RETURN
#include "visitor/Type_DECODER_RETURN_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_DECODER_RETURN"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_DECODER_RETURN>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_DECODER_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_DECODER_RETURN>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_DECODER_RETURN_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_DECODER_RETURN_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_DECODER_RETURN_before<Result>
#include "visitor/Type_DECODER_RETURN_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_DECODER_RETURN_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_DECODER_RETURN_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_DECODER_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_DECODER_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_DECODER_RETURN_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_DECODER_RETURN_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_DECODER_RETURN_after<Result>
#include "visitor/Type_DECODER_RETURN_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_DECODER_RETURN_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_DECODER_RETURN_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_DECODER_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_DECODER_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_ENCODER_INPUT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENCODER_INPUT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENCODER_INPUT
#include "visitor/Type_ENCODER_INPUT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENCODER_INPUT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENCODER_INPUT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENCODER_INPUT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENCODER_INPUT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_ENCODER_INPUT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENCODER_INPUT_before<Result>
#include "visitor/Type_ENCODER_INPUT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENCODER_INPUT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_ENCODER_INPUT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENCODER_INPUT_after<Result>
#include "visitor/Type_ENCODER_INPUT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENCODER_INPUT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_DECODER_INPUT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_DECODER_INPUT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_DECODER_INPUT
#include "visitor/Type_DECODER_INPUT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_DECODER_INPUT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_DECODER_INPUT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_DECODER_INPUT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_DECODER_INPUT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_DECODER_INPUT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_DECODER_INPUT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_DECODER_INPUT_before<Result>
#include "visitor/Type_DECODER_INPUT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_DECODER_INPUT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_DECODER_INPUT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_DECODER_INPUT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_DECODER_INPUT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_DECODER_INPUT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_DECODER_INPUT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_DECODER_INPUT_after<Result>
#include "visitor/Type_DECODER_INPUT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_DECODER_INPUT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_DECODER_INPUT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_DECODER_INPUT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_DECODER_INPUT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_PROPERTY_SETTER_RETURN_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_PROPERTY_SETTER_RETURN
#include "visitor/Type_PROPERTY_SETTER_RETURN_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_PROPERTY_SETTER_RETURN"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_PROPERTY_SETTER_RETURN_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_PROPERTY_SETTER_RETURN_before<Result>
#include "visitor/Type_PROPERTY_SETTER_RETURN_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_PROPERTY_SETTER_RETURN_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_PROPERTY_SETTER_RETURN_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_PROPERTY_SETTER_RETURN_after<Result>
#include "visitor/Type_PROPERTY_SETTER_RETURN_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_PROPERTY_SETTER_RETURN_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_OPTIONAL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_OPTIONAL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_OPTIONAL
#include "visitor/Type_OPTIONAL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_OPTIONAL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_OPTIONAL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_OPTIONAL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_OPTIONAL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_OPTIONAL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_OPTIONAL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_OPTIONAL_before<Result>
#include "visitor/Type_OPTIONAL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_OPTIONAL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_OPTIONAL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_OPTIONAL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_OPTIONAL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_OPTIONAL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_OPTIONAL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_OPTIONAL_after<Result>
#include "visitor/Type_OPTIONAL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_OPTIONAL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_OPTIONAL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_OPTIONAL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_OPTIONAL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_PTR_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_PTR>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_PTR
#include "visitor/Type_PTR_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_PTR"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_PTR>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_PTR>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PTR)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PTR 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_PTR>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_PTR_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_PTR_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_PTR_before<Result>
#include "visitor/Type_PTR_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_PTR_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_PTR_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_PTR_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_PTR_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_PTR_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_PTR_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_PTR_after<Result>
#include "visitor/Type_PTR_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_PTR_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_PTR_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_PTR_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_PTR_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_FUNCTION_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_FUNCTION>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_FUNCTION
#include "visitor/Type_FUNCTION_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_FUNCTION"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_FUNCTION>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_FUNCTION>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_FUNCTION>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_FUNCTION_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_FUNCTION_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_FUNCTION_before<Result>
#include "visitor/Type_FUNCTION_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_FUNCTION_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_FUNCTION_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_FUNCTION_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_FUNCTION_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_FUNCTION_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_FUNCTION_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_FUNCTION_after<Result>
#include "visitor/Type_FUNCTION_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_FUNCTION_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_FUNCTION_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_FUNCTION_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_FUNCTION_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_dispatch_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type
#include "visitor/Type_dispatch_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_before_dispatch_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_before<Result>
#include "visitor/Type_before_dispatch_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_after_dispatch_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_after<Result>
#include "visitor/Type_after_dispatch_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Type_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Types_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Types>>
#define CODEGEN_CONTEXT(dummy_name) Context_Types
#include "visitor/Types_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Types"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Types>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Types>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPES)
#define CODEGEN_EXPECTED_PRIORITY_TYPES 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Types>> {}; // Unimplemented
#endif
#if __has_include("visitor/Types_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Types_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Types_before<Result>
#include "visitor/Types_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Types_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Types_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Types_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPES_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPES_BEFORE 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Types_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Types_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Types_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Types_after<Result>
#include "visitor/Types_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Types_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Types_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Types_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPES_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPES_AFTER 0
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserHook<ebm2python::VisitorTag_Types_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/entry.hpp")
// Inlined hook for entry for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_entry>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_entry& ctx) {
        EBM2PYTHON_DECONSTRUCT_ENTRY(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/entry.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_entry>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_ENTRY)
#define CODEGEN_EXPECTED_PRIORITY_ENTRY 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_entry>> {}; // Unimplemented
#endif
#if __has_include("visitor/entry_before.hpp")
// Inlined hook for entry_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_entry_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_entry_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_ENTRY_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/entry_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_entry_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_ENTRY_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_ENTRY_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_entry_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/entry_after.hpp")
// Inlined hook for entry_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_entry_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_entry_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_ENTRY_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/entry_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_entry_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_ENTRY_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_ENTRY_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_entry_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/pre_visitor.hpp")
// Inlined hook for pre_visitor for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_pre_visitor>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_pre_visitor& ctx) {
        EBM2PYTHON_DECONSTRUCT_PRE_VISITOR(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/pre_visitor.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_pre_visitor>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR)
#define CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_pre_visitor>> {}; // Unimplemented
#endif
#if __has_include("visitor/pre_visitor_before.hpp")
// Inlined hook for pre_visitor_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_pre_visitor_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_pre_visitor_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_PRE_VISITOR_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/pre_visitor_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_pre_visitor_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_pre_visitor_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/pre_visitor_after.hpp")
// Inlined hook for pre_visitor_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_pre_visitor_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_pre_visitor_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_PRE_VISITOR_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/pre_visitor_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_pre_visitor_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_pre_visitor_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/post_entry.hpp")
// Inlined hook for post_entry for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_post_entry>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_post_entry<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_POST_ENTRY(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/post_entry.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_post_entry>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_POST_ENTRY)
#define CODEGEN_EXPECTED_PRIORITY_POST_ENTRY 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_post_entry>> {}; // Unimplemented
#endif
#if __has_include("visitor/post_entry_before.hpp")
// Inlined hook for post_entry_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_post_entry_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_post_entry_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_POST_ENTRY_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/post_entry_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_post_entry_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_post_entry_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/post_entry_after.hpp")
// Inlined hook for post_entry_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_post_entry_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_post_entry_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_POST_ENTRY_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/post_entry_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_post_entry_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_post_entry_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_BLOCK.hpp")
// Inlined hook for Statement_BLOCK for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_BLOCK>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_BLOCK& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_BLOCK(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_BLOCK.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_BLOCK>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_BLOCK>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_BLOCK_before.hpp")
// Inlined hook for Statement_BLOCK_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_BLOCK_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_BLOCK_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_BLOCK_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_BLOCK_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_BLOCK_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_BLOCK_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_BLOCK_after.hpp")
// Inlined hook for Statement_BLOCK_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_BLOCK_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_BLOCK_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_BLOCK_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_BLOCK_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_BLOCK_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_BLOCK_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ASSIGNMENT.hpp")
// Inlined hook for Statement_ASSIGNMENT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ASSIGNMENT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ASSIGNMENT& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ASSIGNMENT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_ASSIGNMENT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ASSIGNMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ASSIGNMENT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ASSIGNMENT_before.hpp")
// Inlined hook for Statement_ASSIGNMENT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ASSIGNMENT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ASSIGNMENT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_ASSIGNMENT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ASSIGNMENT_after.hpp")
// Inlined hook for Statement_ASSIGNMENT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ASSIGNMENT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ASSIGNMENT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_ASSIGNMENT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_YIELD.hpp")
// Inlined hook for Statement_YIELD for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_YIELD>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_YIELD& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_YIELD(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_YIELD.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_YIELD>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_YIELD>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_YIELD_before.hpp")
// Inlined hook for Statement_YIELD_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_YIELD_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_YIELD_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_YIELD_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_YIELD_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_YIELD_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_YIELD_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_YIELD_after.hpp")
// Inlined hook for Statement_YIELD_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_YIELD_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_YIELD_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_YIELD_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_YIELD_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_YIELD_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_YIELD_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_APPEND.hpp")
// Inlined hook for Statement_APPEND for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_APPEND>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_APPEND& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_APPEND(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_APPEND.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_APPEND>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_APPEND>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_APPEND_before.hpp")
// Inlined hook for Statement_APPEND_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_APPEND_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_APPEND_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_APPEND_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_APPEND_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_APPEND_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_APPEND_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_APPEND_after.hpp")
// Inlined hook for Statement_APPEND_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_APPEND_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_APPEND_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_APPEND_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_APPEND_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_APPEND_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_APPEND_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_RETURN.hpp")
// Inlined hook for Statement_RETURN for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_RETURN>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_RETURN& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_RETURN(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_RETURN.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_RETURN>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_RETURN_before.hpp")
// Inlined hook for Statement_RETURN_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_RETURN_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_RETURN_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_RETURN_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_RETURN_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_RETURN_after.hpp")
// Inlined hook for Statement_RETURN_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_RETURN_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_RETURN_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_RETURN_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_RETURN_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ERROR_RETURN.hpp")
// Inlined hook for Statement_ERROR_RETURN for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ERROR_RETURN>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ERROR_RETURN& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ERROR_RETURN(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_ERROR_RETURN.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ERROR_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ERROR_RETURN>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ERROR_RETURN_before.hpp")
// Inlined hook for Statement_ERROR_RETURN_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ERROR_RETURN_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ERROR_RETURN_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_ERROR_RETURN_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ERROR_RETURN_after.hpp")
// Inlined hook for Statement_ERROR_RETURN_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ERROR_RETURN_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ERROR_RETURN_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_ERROR_RETURN_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ASSERT.hpp")
// Inlined hook for Statement_ASSERT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ASSERT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ASSERT& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ASSERT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_ASSERT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ASSERT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ASSERT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ASSERT_before.hpp")
// Inlined hook for Statement_ASSERT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ASSERT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ASSERT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ASSERT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_ASSERT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ASSERT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ASSERT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ASSERT_after.hpp")
// Inlined hook for Statement_ASSERT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ASSERT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ASSERT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ASSERT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_ASSERT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ASSERT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ASSERT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_READ_DATA.hpp")
// Inlined hook for Statement_READ_DATA for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_READ_DATA>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_READ_DATA& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_READ_DATA(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_READ_DATA.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_READ_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_READ_DATA>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_READ_DATA_before.hpp")
// Inlined hook for Statement_READ_DATA_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_READ_DATA_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_READ_DATA_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_READ_DATA_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_READ_DATA_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_READ_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_READ_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_READ_DATA_after.hpp")
// Inlined hook for Statement_READ_DATA_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_READ_DATA_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_READ_DATA_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_READ_DATA_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_READ_DATA_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_READ_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_READ_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_WRITE_DATA.hpp")
// Inlined hook for Statement_WRITE_DATA for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_WRITE_DATA>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_WRITE_DATA& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_WRITE_DATA(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_WRITE_DATA.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_WRITE_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_WRITE_DATA>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_WRITE_DATA_before.hpp")
// Inlined hook for Statement_WRITE_DATA_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_WRITE_DATA_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_WRITE_DATA_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_WRITE_DATA_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_WRITE_DATA_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_WRITE_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_WRITE_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_WRITE_DATA_after.hpp")
// Inlined hook for Statement_WRITE_DATA_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_WRITE_DATA_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_WRITE_DATA_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_WRITE_DATA_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_WRITE_DATA_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_WRITE_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_WRITE_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_RESERVE_DATA.hpp")
// Inlined hook for Statement_RESERVE_DATA for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_RESERVE_DATA>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_RESERVE_DATA& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_RESERVE_DATA(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_RESERVE_DATA.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_RESERVE_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_RESERVE_DATA>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_RESERVE_DATA_before.hpp")
// Inlined hook for Statement_RESERVE_DATA_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_RESERVE_DATA_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_RESERVE_DATA_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_RESERVE_DATA_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_RESERVE_DATA_after.hpp")
// Inlined hook for Statement_RESERVE_DATA_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_RESERVE_DATA_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_RESERVE_DATA_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_RESERVE_DATA_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_IF_STATEMENT.hpp")
// Inlined hook for Statement_IF_STATEMENT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_IF_STATEMENT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_IF_STATEMENT& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_IF_STATEMENT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_IF_STATEMENT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_IF_STATEMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_IF_STATEMENT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_IF_STATEMENT_before.hpp")
// Inlined hook for Statement_IF_STATEMENT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_IF_STATEMENT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_IF_STATEMENT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_IF_STATEMENT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_IF_STATEMENT_after.hpp")
// Inlined hook for Statement_IF_STATEMENT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_IF_STATEMENT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_IF_STATEMENT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_IF_STATEMENT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_LOOP_STATEMENT.hpp")
// Inlined hook for Statement_LOOP_STATEMENT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_LOOP_STATEMENT& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_LOOP_STATEMENT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_LOOP_STATEMENT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_LOOP_STATEMENT_before.hpp")
// Inlined hook for Statement_LOOP_STATEMENT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_LOOP_STATEMENT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_LOOP_STATEMENT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_LOOP_STATEMENT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_LOOP_STATEMENT_after.hpp")
// Inlined hook for Statement_LOOP_STATEMENT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_LOOP_STATEMENT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_LOOP_STATEMENT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_LOOP_STATEMENT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_MATCH_STATEMENT.hpp")
// Inlined hook for Statement_MATCH_STATEMENT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_MATCH_STATEMENT& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_MATCH_STATEMENT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_MATCH_STATEMENT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_MATCH_STATEMENT_before.hpp")
// Inlined hook for Statement_MATCH_STATEMENT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_MATCH_STATEMENT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_MATCH_STATEMENT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_MATCH_STATEMENT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_MATCH_STATEMENT_after.hpp")
// Inlined hook for Statement_MATCH_STATEMENT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_MATCH_STATEMENT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_MATCH_STATEMENT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_MATCH_STATEMENT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_MATCH_BRANCH.hpp")
// Inlined hook for Statement_MATCH_BRANCH for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_MATCH_BRANCH& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_MATCH_BRANCH(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_MATCH_BRANCH.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_MATCH_BRANCH_before.hpp")
// Inlined hook for Statement_MATCH_BRANCH_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_MATCH_BRANCH_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_MATCH_BRANCH_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_MATCH_BRANCH_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_MATCH_BRANCH_after.hpp")
// Inlined hook for Statement_MATCH_BRANCH_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_MATCH_BRANCH_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_MATCH_BRANCH_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_MATCH_BRANCH_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_BREAK.hpp")
// Inlined hook for Statement_BREAK for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_BREAK>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_BREAK& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_BREAK(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_BREAK.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_BREAK>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_BREAK>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_BREAK_before.hpp")
// Inlined hook for Statement_BREAK_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_BREAK_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_BREAK_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_BREAK_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_BREAK_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_BREAK_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_BREAK_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_BREAK_after.hpp")
// Inlined hook for Statement_BREAK_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_BREAK_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_BREAK_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_BREAK_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_BREAK_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_BREAK_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_BREAK_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_CONTINUE.hpp")
// Inlined hook for Statement_CONTINUE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_CONTINUE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_CONTINUE& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_CONTINUE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_CONTINUE.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_CONTINUE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_CONTINUE>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_CONTINUE_before.hpp")
// Inlined hook for Statement_CONTINUE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_CONTINUE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_CONTINUE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_CONTINUE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_CONTINUE_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_CONTINUE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_CONTINUE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_CONTINUE_after.hpp")
// Inlined hook for Statement_CONTINUE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_CONTINUE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_CONTINUE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_CONTINUE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_CONTINUE_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_CONTINUE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_CONTINUE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_FUNCTION_DECL.hpp")
// Inlined hook for Statement_FUNCTION_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_FUNCTION_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_FUNCTION_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_FUNCTION_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_FUNCTION_DECL_before.hpp")
// Inlined hook for Statement_FUNCTION_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_FUNCTION_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_FUNCTION_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_FUNCTION_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_FUNCTION_DECL_after.hpp")
// Inlined hook for Statement_FUNCTION_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_FUNCTION_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_FUNCTION_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_FUNCTION_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_VARIABLE_DECL.hpp")
// Inlined hook for Statement_VARIABLE_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_VARIABLE_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_VARIABLE_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_VARIABLE_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_VARIABLE_DECL_before.hpp")
// Inlined hook for Statement_VARIABLE_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_VARIABLE_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_VARIABLE_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_VARIABLE_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_VARIABLE_DECL_after.hpp")
// Inlined hook for Statement_VARIABLE_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_VARIABLE_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_VARIABLE_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_VARIABLE_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_PARAMETER_DECL.hpp")
// Inlined hook for Statement_PARAMETER_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PARAMETER_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PARAMETER_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_PARAMETER_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_PARAMETER_DECL_before.hpp")
// Inlined hook for Statement_PARAMETER_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PARAMETER_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PARAMETER_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_PARAMETER_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_PARAMETER_DECL_after.hpp")
// Inlined hook for Statement_PARAMETER_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PARAMETER_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PARAMETER_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_PARAMETER_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_FIELD_DECL.hpp")
// Inlined hook for Statement_FIELD_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_FIELD_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_FIELD_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_FIELD_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_FIELD_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_FIELD_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_FIELD_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_FIELD_DECL_before.hpp")
// Inlined hook for Statement_FIELD_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_FIELD_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_FIELD_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_FIELD_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_FIELD_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_FIELD_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_FIELD_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_FIELD_DECL_after.hpp")
// Inlined hook for Statement_FIELD_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_FIELD_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_FIELD_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_FIELD_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_FIELD_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_FIELD_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_FIELD_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_COMPOSITE_FIELD_DECL.hpp")
// Inlined hook for Statement_COMPOSITE_FIELD_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_COMPOSITE_FIELD_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_COMPOSITE_FIELD_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_COMPOSITE_FIELD_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_COMPOSITE_FIELD_DECL_before.hpp")
// Inlined hook for Statement_COMPOSITE_FIELD_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_COMPOSITE_FIELD_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_COMPOSITE_FIELD_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_COMPOSITE_FIELD_DECL_after.hpp")
// Inlined hook for Statement_COMPOSITE_FIELD_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_COMPOSITE_FIELD_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_COMPOSITE_FIELD_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_COMPOSITE_FIELD_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ENUM_DECL.hpp")
// Inlined hook for Statement_ENUM_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENUM_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENUM_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENUM_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_ENUM_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENUM_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENUM_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ENUM_DECL_before.hpp")
// Inlined hook for Statement_ENUM_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENUM_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENUM_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENUM_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_ENUM_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENUM_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENUM_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ENUM_DECL_after.hpp")
// Inlined hook for Statement_ENUM_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENUM_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENUM_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENUM_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_ENUM_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENUM_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENUM_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ENUM_MEMBER_DECL.hpp")
// Inlined hook for Statement_ENUM_MEMBER_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENUM_MEMBER_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENUM_MEMBER_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_ENUM_MEMBER_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ENUM_MEMBER_DECL_before.hpp")
// Inlined hook for Statement_ENUM_MEMBER_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENUM_MEMBER_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENUM_MEMBER_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_ENUM_MEMBER_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ENUM_MEMBER_DECL_after.hpp")
// Inlined hook for Statement_ENUM_MEMBER_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENUM_MEMBER_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENUM_MEMBER_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_ENUM_MEMBER_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_STRUCT_DECL.hpp")
// Inlined hook for Statement_STRUCT_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_STRUCT_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_STRUCT_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_STRUCT_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_STRUCT_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_STRUCT_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_STRUCT_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_STRUCT_DECL_before.hpp")
// Inlined hook for Statement_STRUCT_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_STRUCT_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_STRUCT_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_STRUCT_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_STRUCT_DECL_after.hpp")
// Inlined hook for Statement_STRUCT_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_STRUCT_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_STRUCT_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_STRUCT_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_UNION_DECL.hpp")
// Inlined hook for Statement_UNION_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_UNION_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_UNION_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_UNION_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_UNION_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_UNION_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_UNION_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_UNION_DECL_before.hpp")
// Inlined hook for Statement_UNION_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_UNION_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_UNION_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_UNION_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_UNION_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_UNION_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_UNION_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_UNION_DECL_after.hpp")
// Inlined hook for Statement_UNION_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_UNION_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_UNION_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_UNION_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_UNION_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_UNION_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_UNION_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_UNION_MEMBER_DECL.hpp")
// Inlined hook for Statement_UNION_MEMBER_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_UNION_MEMBER_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_UNION_MEMBER_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_UNION_MEMBER_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_UNION_MEMBER_DECL_before.hpp")
// Inlined hook for Statement_UNION_MEMBER_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_UNION_MEMBER_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_UNION_MEMBER_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_UNION_MEMBER_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_UNION_MEMBER_DECL_after.hpp")
// Inlined hook for Statement_UNION_MEMBER_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_UNION_MEMBER_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_UNION_MEMBER_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_UNION_MEMBER_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_PROGRAM_DECL.hpp")
// Inlined hook for Statement_PROGRAM_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROGRAM_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROGRAM_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_PROGRAM_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_PROGRAM_DECL_before.hpp")
// Inlined hook for Statement_PROGRAM_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROGRAM_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROGRAM_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_PROGRAM_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_PROGRAM_DECL_after.hpp")
// Inlined hook for Statement_PROGRAM_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROGRAM_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROGRAM_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_PROGRAM_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_PROPERTY_DECL.hpp")
// Inlined hook for Statement_PROPERTY_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROPERTY_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROPERTY_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_PROPERTY_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_PROPERTY_DECL_before.hpp")
// Inlined hook for Statement_PROPERTY_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROPERTY_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROPERTY_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_PROPERTY_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_PROPERTY_DECL_after.hpp")
// Inlined hook for Statement_PROPERTY_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROPERTY_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROPERTY_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_PROPERTY_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_PROPERTY_MEMBER_DECL.hpp")
// Inlined hook for Statement_PROPERTY_MEMBER_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROPERTY_MEMBER_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROPERTY_MEMBER_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_PROPERTY_MEMBER_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_PROPERTY_MEMBER_DECL_before.hpp")
// Inlined hook for Statement_PROPERTY_MEMBER_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROPERTY_MEMBER_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_PROPERTY_MEMBER_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_PROPERTY_MEMBER_DECL_after.hpp")
// Inlined hook for Statement_PROPERTY_MEMBER_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROPERTY_MEMBER_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROPERTY_MEMBER_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_PROPERTY_MEMBER_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_METADATA.hpp")
// Inlined hook for Statement_METADATA for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_METADATA>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_METADATA& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_METADATA(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_METADATA.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_METADATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_METADATA>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_METADATA_before.hpp")
// Inlined hook for Statement_METADATA_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_METADATA_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_METADATA_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_METADATA_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_METADATA_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_METADATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_METADATA_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_METADATA_after.hpp")
// Inlined hook for Statement_METADATA_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_METADATA_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_METADATA_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_METADATA_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_METADATA_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_METADATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_METADATA_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_IMPORT_MODULE.hpp")
// Inlined hook for Statement_IMPORT_MODULE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_IMPORT_MODULE& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_IMPORT_MODULE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_IMPORT_MODULE.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_IMPORT_MODULE_before.hpp")
// Inlined hook for Statement_IMPORT_MODULE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_IMPORT_MODULE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_IMPORT_MODULE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_IMPORT_MODULE_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_IMPORT_MODULE_after.hpp")
// Inlined hook for Statement_IMPORT_MODULE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_IMPORT_MODULE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_IMPORT_MODULE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_IMPORT_MODULE_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_EXPRESSION.hpp")
// Inlined hook for Statement_EXPRESSION for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_EXPRESSION>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_EXPRESSION& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_EXPRESSION(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_EXPRESSION.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_EXPRESSION>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_EXPRESSION>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_EXPRESSION_before.hpp")
// Inlined hook for Statement_EXPRESSION_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_EXPRESSION_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_EXPRESSION_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_EXPRESSION_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_EXPRESSION_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_EXPRESSION_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_EXPRESSION_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_EXPRESSION_after.hpp")
// Inlined hook for Statement_EXPRESSION_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_EXPRESSION_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_EXPRESSION_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_EXPRESSION_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_EXPRESSION_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_EXPRESSION_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_EXPRESSION_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ERROR_REPORT.hpp")
// Inlined hook for Statement_ERROR_REPORT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ERROR_REPORT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ERROR_REPORT& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ERROR_REPORT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_ERROR_REPORT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ERROR_REPORT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ERROR_REPORT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ERROR_REPORT_before.hpp")
// Inlined hook for Statement_ERROR_REPORT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ERROR_REPORT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ERROR_REPORT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_ERROR_REPORT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ERROR_REPORT_after.hpp")
// Inlined hook for Statement_ERROR_REPORT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ERROR_REPORT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ERROR_REPORT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_ERROR_REPORT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_LOWERED_IO_STATEMENTS.hpp")
// Inlined hook for Statement_LOWERED_IO_STATEMENTS for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_LOWERED_IO_STATEMENTS& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_LOWERED_IO_STATEMENTS(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_LOWERED_IO_STATEMENTS.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_LOWERED_IO_STATEMENTS_before.hpp")
// Inlined hook for Statement_LOWERED_IO_STATEMENTS_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_LOWERED_IO_STATEMENTS_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_LOWERED_IO_STATEMENTS_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_LOWERED_IO_STATEMENTS_after.hpp")
// Inlined hook for Statement_LOWERED_IO_STATEMENTS_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_LOWERED_IO_STATEMENTS_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_LOWERED_IO_STATEMENTS_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_LOWERED_IO_STATEMENTS_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_SUB_BYTE_RANGE.hpp")
// Inlined hook for Statement_SUB_BYTE_RANGE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_SUB_BYTE_RANGE& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_SUB_BYTE_RANGE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_SUB_BYTE_RANGE.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_SUB_BYTE_RANGE_before.hpp")
// Inlined hook for Statement_SUB_BYTE_RANGE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_SUB_BYTE_RANGE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_SUB_BYTE_RANGE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_SUB_BYTE_RANGE_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_SUB_BYTE_RANGE_after.hpp")
// Inlined hook for Statement_SUB_BYTE_RANGE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_SUB_BYTE_RANGE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_SUB_BYTE_RANGE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_SUB_BYTE_RANGE_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_INIT_CHECK.hpp")
// Inlined hook for Statement_INIT_CHECK for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_INIT_CHECK>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_INIT_CHECK& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_INIT_CHECK(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_INIT_CHECK.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_INIT_CHECK>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_INIT_CHECK>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_INIT_CHECK_before.hpp")
// Inlined hook for Statement_INIT_CHECK_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_INIT_CHECK_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_INIT_CHECK_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_INIT_CHECK_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_INIT_CHECK_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_INIT_CHECK_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_INIT_CHECK_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_INIT_CHECK_after.hpp")
// Inlined hook for Statement_INIT_CHECK_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_INIT_CHECK_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_INIT_CHECK_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_INIT_CHECK_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_INIT_CHECK_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_INIT_CHECK_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_INIT_CHECK_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ENDIAN_VARIABLE.hpp")
// Inlined hook for Statement_ENDIAN_VARIABLE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENDIAN_VARIABLE& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENDIAN_VARIABLE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_ENDIAN_VARIABLE.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ENDIAN_VARIABLE_before.hpp")
// Inlined hook for Statement_ENDIAN_VARIABLE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENDIAN_VARIABLE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENDIAN_VARIABLE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_ENDIAN_VARIABLE_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_ENDIAN_VARIABLE_after.hpp")
// Inlined hook for Statement_ENDIAN_VARIABLE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENDIAN_VARIABLE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENDIAN_VARIABLE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_ENDIAN_VARIABLE_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_dispatch.hpp")
// Inlined hook for Statement for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_dispatch.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_before_dispatch.hpp")
// Inlined hook for Statement_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_before_dispatch.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Statement_after_dispatch.hpp")
// Inlined hook for Statement_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Statement_after_dispatch.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Statement_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Block.hpp")
// Inlined hook for Block for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Block>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Block& ctx) {
        EBM2PYTHON_DECONSTRUCT_BLOCK(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Block.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Block>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_BLOCK)
#define CODEGEN_EXPECTED_PRIORITY_BLOCK 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Block>> {}; // Unimplemented
#endif
#if __has_include("visitor/Block_before.hpp")
// Inlined hook for Block_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Block_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Block_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_BLOCK_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Block_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Block_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_BLOCK_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_BLOCK_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Block_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Block_after.hpp")
// Inlined hook for Block_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Block_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Block_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_BLOCK_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Block_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Block_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_BLOCK_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_BLOCK_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Block_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_INT.hpp")
// Inlined hook for Expression_LITERAL_INT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_INT& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_INT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_LITERAL_INT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_INT_before.hpp")
// Inlined hook for Expression_LITERAL_INT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_INT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_INT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_LITERAL_INT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_INT_after.hpp")
// Inlined hook for Expression_LITERAL_INT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_INT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_INT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_LITERAL_INT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_INT64.hpp")
// Inlined hook for Expression_LITERAL_INT64 for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT64>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_INT64& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_INT64(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_LITERAL_INT64.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT64>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT64>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_INT64_before.hpp")
// Inlined hook for Expression_LITERAL_INT64_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_INT64_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_INT64_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_LITERAL_INT64_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_INT64_after.hpp")
// Inlined hook for Expression_LITERAL_INT64_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_INT64_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_INT64_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_LITERAL_INT64_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_BOOL.hpp")
// Inlined hook for Expression_LITERAL_BOOL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_BOOL& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_BOOL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_LITERAL_BOOL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_BOOL_before.hpp")
// Inlined hook for Expression_LITERAL_BOOL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_BOOL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_BOOL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_LITERAL_BOOL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_BOOL_after.hpp")
// Inlined hook for Expression_LITERAL_BOOL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_BOOL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_BOOL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_LITERAL_BOOL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_STRING.hpp")
// Inlined hook for Expression_LITERAL_STRING for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_STRING>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_STRING& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_STRING(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_LITERAL_STRING.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_STRING>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_STRING>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_STRING_before.hpp")
// Inlined hook for Expression_LITERAL_STRING_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_STRING_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_STRING_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_LITERAL_STRING_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_STRING_after.hpp")
// Inlined hook for Expression_LITERAL_STRING_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_STRING_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_STRING_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_LITERAL_STRING_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_TYPE.hpp")
// Inlined hook for Expression_LITERAL_TYPE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_TYPE& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_TYPE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_LITERAL_TYPE.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_TYPE_before.hpp")
// Inlined hook for Expression_LITERAL_TYPE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_TYPE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_TYPE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_LITERAL_TYPE_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_TYPE_after.hpp")
// Inlined hook for Expression_LITERAL_TYPE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_TYPE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_TYPE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_LITERAL_TYPE_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_CHAR.hpp")
// Inlined hook for Expression_LITERAL_CHAR for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_CHAR& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_CHAR(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_LITERAL_CHAR.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_CHAR_before.hpp")
// Inlined hook for Expression_LITERAL_CHAR_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_CHAR_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_CHAR_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_LITERAL_CHAR_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_LITERAL_CHAR_after.hpp")
// Inlined hook for Expression_LITERAL_CHAR_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_CHAR_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_CHAR_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_LITERAL_CHAR_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_IDENTIFIER.hpp")
// Inlined hook for Expression_IDENTIFIER for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IDENTIFIER>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IDENTIFIER& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IDENTIFIER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_IDENTIFIER.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IDENTIFIER>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IDENTIFIER>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_IDENTIFIER_before.hpp")
// Inlined hook for Expression_IDENTIFIER_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IDENTIFIER_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IDENTIFIER_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IDENTIFIER_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_IDENTIFIER_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IDENTIFIER_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IDENTIFIER_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_IDENTIFIER_after.hpp")
// Inlined hook for Expression_IDENTIFIER_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IDENTIFIER_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IDENTIFIER_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IDENTIFIER_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_IDENTIFIER_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IDENTIFIER_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IDENTIFIER_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_BINARY_OP.hpp")
// Inlined hook for Expression_BINARY_OP for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_BINARY_OP>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_BINARY_OP& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_BINARY_OP(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_BINARY_OP.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_BINARY_OP>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_BINARY_OP>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_BINARY_OP_before.hpp")
// Inlined hook for Expression_BINARY_OP_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_BINARY_OP_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_BINARY_OP_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_BINARY_OP_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_BINARY_OP_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_BINARY_OP_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_BINARY_OP_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_BINARY_OP_after.hpp")
// Inlined hook for Expression_BINARY_OP_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_BINARY_OP_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_BINARY_OP_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_BINARY_OP_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_BINARY_OP_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_BINARY_OP_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_BINARY_OP_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_UNARY_OP.hpp")
// Inlined hook for Expression_UNARY_OP for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_UNARY_OP>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_UNARY_OP& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_UNARY_OP(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_UNARY_OP.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_UNARY_OP>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_UNARY_OP>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_UNARY_OP_before.hpp")
// Inlined hook for Expression_UNARY_OP_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_UNARY_OP_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_UNARY_OP_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_UNARY_OP_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_UNARY_OP_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_UNARY_OP_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_UNARY_OP_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_UNARY_OP_after.hpp")
// Inlined hook for Expression_UNARY_OP_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_UNARY_OP_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_UNARY_OP_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_UNARY_OP_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_UNARY_OP_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_UNARY_OP_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_UNARY_OP_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_CALL.hpp")
// Inlined hook for Expression_CALL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CALL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CALL& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CALL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_CALL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CALL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CALL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_CALL_before.hpp")
// Inlined hook for Expression_CALL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CALL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CALL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CALL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_CALL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CALL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CALL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_CALL_after.hpp")
// Inlined hook for Expression_CALL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CALL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CALL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CALL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_CALL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CALL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CALL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_INDEX_ACCESS.hpp")
// Inlined hook for Expression_INDEX_ACCESS for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_INDEX_ACCESS& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_INDEX_ACCESS(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_INDEX_ACCESS.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_INDEX_ACCESS_before.hpp")
// Inlined hook for Expression_INDEX_ACCESS_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_INDEX_ACCESS_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_INDEX_ACCESS_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_INDEX_ACCESS_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_INDEX_ACCESS_after.hpp")
// Inlined hook for Expression_INDEX_ACCESS_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_INDEX_ACCESS_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_INDEX_ACCESS_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_INDEX_ACCESS_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_MEMBER_ACCESS.hpp")
// Inlined hook for Expression_MEMBER_ACCESS for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_MEMBER_ACCESS& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_MEMBER_ACCESS(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_MEMBER_ACCESS.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_MEMBER_ACCESS_before.hpp")
// Inlined hook for Expression_MEMBER_ACCESS_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_MEMBER_ACCESS_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_MEMBER_ACCESS_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_MEMBER_ACCESS_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_MEMBER_ACCESS_after.hpp")
// Inlined hook for Expression_MEMBER_ACCESS_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_MEMBER_ACCESS_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_MEMBER_ACCESS_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_MEMBER_ACCESS_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_ENUM_MEMBER.hpp")
// Inlined hook for Expression_ENUM_MEMBER for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ENUM_MEMBER& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ENUM_MEMBER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_ENUM_MEMBER.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_ENUM_MEMBER_before.hpp")
// Inlined hook for Expression_ENUM_MEMBER_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ENUM_MEMBER_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ENUM_MEMBER_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_ENUM_MEMBER_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_ENUM_MEMBER_after.hpp")
// Inlined hook for Expression_ENUM_MEMBER_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ENUM_MEMBER_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ENUM_MEMBER_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_ENUM_MEMBER_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_TYPE_CAST.hpp")
// Inlined hook for Expression_TYPE_CAST for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_TYPE_CAST>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_TYPE_CAST& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_TYPE_CAST(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_TYPE_CAST.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_TYPE_CAST>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_TYPE_CAST>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_TYPE_CAST_before.hpp")
// Inlined hook for Expression_TYPE_CAST_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_TYPE_CAST_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_TYPE_CAST_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_TYPE_CAST_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_TYPE_CAST_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_TYPE_CAST_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_TYPE_CAST_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_TYPE_CAST_after.hpp")
// Inlined hook for Expression_TYPE_CAST_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_TYPE_CAST_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_TYPE_CAST_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_TYPE_CAST_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_TYPE_CAST_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_TYPE_CAST_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_TYPE_CAST_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_RANGE.hpp")
// Inlined hook for Expression_RANGE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_RANGE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_RANGE& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_RANGE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_RANGE.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_RANGE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_RANGE>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_RANGE_before.hpp")
// Inlined hook for Expression_RANGE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_RANGE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_RANGE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_RANGE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_RANGE_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_RANGE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_RANGE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_RANGE_after.hpp")
// Inlined hook for Expression_RANGE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_RANGE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_RANGE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_RANGE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_RANGE_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_RANGE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_RANGE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_DEFAULT_VALUE.hpp")
// Inlined hook for Expression_DEFAULT_VALUE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_DEFAULT_VALUE& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_DEFAULT_VALUE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_DEFAULT_VALUE.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_DEFAULT_VALUE_before.hpp")
// Inlined hook for Expression_DEFAULT_VALUE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_DEFAULT_VALUE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_DEFAULT_VALUE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_DEFAULT_VALUE_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_DEFAULT_VALUE_after.hpp")
// Inlined hook for Expression_DEFAULT_VALUE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_DEFAULT_VALUE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_DEFAULT_VALUE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_DEFAULT_VALUE_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_IS_LITTLE_ENDIAN.hpp")
// Inlined hook for Expression_IS_LITTLE_ENDIAN for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IS_LITTLE_ENDIAN& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IS_LITTLE_ENDIAN(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_IS_LITTLE_ENDIAN.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_IS_LITTLE_ENDIAN_before.hpp")
// Inlined hook for Expression_IS_LITTLE_ENDIAN_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IS_LITTLE_ENDIAN_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_IS_LITTLE_ENDIAN_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_IS_LITTLE_ENDIAN_after.hpp")
// Inlined hook for Expression_IS_LITTLE_ENDIAN_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IS_LITTLE_ENDIAN_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IS_LITTLE_ENDIAN_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_IS_LITTLE_ENDIAN_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_GET_STREAM_OFFSET.hpp")
// Inlined hook for Expression_GET_STREAM_OFFSET for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_GET_STREAM_OFFSET& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_GET_STREAM_OFFSET(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_GET_STREAM_OFFSET.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_GET_STREAM_OFFSET_before.hpp")
// Inlined hook for Expression_GET_STREAM_OFFSET_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_GET_STREAM_OFFSET_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_GET_STREAM_OFFSET_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_GET_STREAM_OFFSET_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_GET_STREAM_OFFSET_after.hpp")
// Inlined hook for Expression_GET_STREAM_OFFSET_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_GET_STREAM_OFFSET_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_GET_STREAM_OFFSET_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_GET_STREAM_OFFSET_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_GET_REMAINING_BYTES.hpp")
// Inlined hook for Expression_GET_REMAINING_BYTES for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_GET_REMAINING_BYTES& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_GET_REMAINING_BYTES(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_GET_REMAINING_BYTES.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_GET_REMAINING_BYTES_before.hpp")
// Inlined hook for Expression_GET_REMAINING_BYTES_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_GET_REMAINING_BYTES_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_GET_REMAINING_BYTES_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_GET_REMAINING_BYTES_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_GET_REMAINING_BYTES_after.hpp")
// Inlined hook for Expression_GET_REMAINING_BYTES_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_GET_REMAINING_BYTES_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_GET_REMAINING_BYTES_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_GET_REMAINING_BYTES_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_CAN_READ_STREAM.hpp")
// Inlined hook for Expression_CAN_READ_STREAM for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CAN_READ_STREAM& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CAN_READ_STREAM(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_CAN_READ_STREAM.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_CAN_READ_STREAM_before.hpp")
// Inlined hook for Expression_CAN_READ_STREAM_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CAN_READ_STREAM_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CAN_READ_STREAM_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_CAN_READ_STREAM_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_CAN_READ_STREAM_after.hpp")
// Inlined hook for Expression_CAN_READ_STREAM_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CAN_READ_STREAM_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CAN_READ_STREAM_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_CAN_READ_STREAM_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_ARRAY_SIZE.hpp")
// Inlined hook for Expression_ARRAY_SIZE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ARRAY_SIZE& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ARRAY_SIZE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_ARRAY_SIZE.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_ARRAY_SIZE_before.hpp")
// Inlined hook for Expression_ARRAY_SIZE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ARRAY_SIZE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ARRAY_SIZE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_ARRAY_SIZE_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_ARRAY_SIZE_after.hpp")
// Inlined hook for Expression_ARRAY_SIZE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ARRAY_SIZE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ARRAY_SIZE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_ARRAY_SIZE_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_ENUM_IS_DEFINED.hpp")
// Inlined hook for Expression_ENUM_IS_DEFINED for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ENUM_IS_DEFINED& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ENUM_IS_DEFINED(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_ENUM_IS_DEFINED.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_ENUM_IS_DEFINED_before.hpp")
// Inlined hook for Expression_ENUM_IS_DEFINED_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ENUM_IS_DEFINED_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ENUM_IS_DEFINED_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_ENUM_IS_DEFINED_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_ENUM_IS_DEFINED_after.hpp")
// Inlined hook for Expression_ENUM_IS_DEFINED_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ENUM_IS_DEFINED_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ENUM_IS_DEFINED_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_ENUM_IS_DEFINED_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_IS_ERROR.hpp")
// Inlined hook for Expression_IS_ERROR for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IS_ERROR>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IS_ERROR& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IS_ERROR(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_IS_ERROR.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IS_ERROR>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IS_ERROR>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_IS_ERROR_before.hpp")
// Inlined hook for Expression_IS_ERROR_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IS_ERROR_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IS_ERROR_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IS_ERROR_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_IS_ERROR_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IS_ERROR_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IS_ERROR_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_IS_ERROR_after.hpp")
// Inlined hook for Expression_IS_ERROR_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IS_ERROR_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IS_ERROR_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IS_ERROR_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_IS_ERROR_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IS_ERROR_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_IS_ERROR_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_MAX_VALUE.hpp")
// Inlined hook for Expression_MAX_VALUE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_MAX_VALUE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_MAX_VALUE& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_MAX_VALUE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_MAX_VALUE.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_MAX_VALUE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_MAX_VALUE>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_MAX_VALUE_before.hpp")
// Inlined hook for Expression_MAX_VALUE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_MAX_VALUE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_MAX_VALUE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_MAX_VALUE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_MAX_VALUE_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_MAX_VALUE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_MAX_VALUE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_MAX_VALUE_after.hpp")
// Inlined hook for Expression_MAX_VALUE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_MAX_VALUE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_MAX_VALUE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_MAX_VALUE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_MAX_VALUE_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_MAX_VALUE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_MAX_VALUE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_READ_DATA.hpp")
// Inlined hook for Expression_READ_DATA for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_READ_DATA>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_READ_DATA& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_READ_DATA(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_READ_DATA.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_READ_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_READ_DATA>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_READ_DATA_before.hpp")
// Inlined hook for Expression_READ_DATA_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_READ_DATA_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_READ_DATA_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_READ_DATA_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_READ_DATA_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_READ_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_READ_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_READ_DATA_after.hpp")
// Inlined hook for Expression_READ_DATA_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_READ_DATA_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_READ_DATA_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_READ_DATA_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_READ_DATA_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_READ_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_READ_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_WRITE_DATA.hpp")
// Inlined hook for Expression_WRITE_DATA for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_WRITE_DATA>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_WRITE_DATA& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_WRITE_DATA(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_WRITE_DATA.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_WRITE_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_WRITE_DATA>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_WRITE_DATA_before.hpp")
// Inlined hook for Expression_WRITE_DATA_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_WRITE_DATA_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_WRITE_DATA_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_WRITE_DATA_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_WRITE_DATA_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_WRITE_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_WRITE_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_WRITE_DATA_after.hpp")
// Inlined hook for Expression_WRITE_DATA_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_WRITE_DATA_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_WRITE_DATA_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_WRITE_DATA_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_WRITE_DATA_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_WRITE_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_WRITE_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_CONDITIONAL_STATEMENT.hpp")
// Inlined hook for Expression_CONDITIONAL_STATEMENT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CONDITIONAL_STATEMENT& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CONDITIONAL_STATEMENT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_CONDITIONAL_STATEMENT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_CONDITIONAL_STATEMENT_before.hpp")
// Inlined hook for Expression_CONDITIONAL_STATEMENT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CONDITIONAL_STATEMENT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_CONDITIONAL_STATEMENT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_CONDITIONAL_STATEMENT_after.hpp")
// Inlined hook for Expression_CONDITIONAL_STATEMENT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CONDITIONAL_STATEMENT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CONDITIONAL_STATEMENT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_CONDITIONAL_STATEMENT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_CONDITIONAL.hpp")
// Inlined hook for Expression_CONDITIONAL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CONDITIONAL& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CONDITIONAL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_CONDITIONAL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_CONDITIONAL_before.hpp")
// Inlined hook for Expression_CONDITIONAL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CONDITIONAL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CONDITIONAL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_CONDITIONAL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_CONDITIONAL_after.hpp")
// Inlined hook for Expression_CONDITIONAL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CONDITIONAL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CONDITIONAL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_CONDITIONAL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_AVAILABLE.hpp")
// Inlined hook for Expression_AVAILABLE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_AVAILABLE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_AVAILABLE& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_AVAILABLE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_AVAILABLE.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_AVAILABLE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_AVAILABLE>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_AVAILABLE_before.hpp")
// Inlined hook for Expression_AVAILABLE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_AVAILABLE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_AVAILABLE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_AVAILABLE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_AVAILABLE_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_AVAILABLE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_AVAILABLE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_AVAILABLE_after.hpp")
// Inlined hook for Expression_AVAILABLE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_AVAILABLE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_AVAILABLE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_AVAILABLE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_AVAILABLE_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_AVAILABLE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_AVAILABLE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_SIZEOF.hpp")
// Inlined hook for Expression_SIZEOF for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SIZEOF>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SIZEOF& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SIZEOF(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_SIZEOF.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SIZEOF>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SIZEOF>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_SIZEOF_before.hpp")
// Inlined hook for Expression_SIZEOF_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SIZEOF_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SIZEOF_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SIZEOF_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_SIZEOF_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SIZEOF_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SIZEOF_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_SIZEOF_after.hpp")
// Inlined hook for Expression_SIZEOF_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SIZEOF_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SIZEOF_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SIZEOF_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_SIZEOF_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SIZEOF_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SIZEOF_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_SUB_RANGE_INIT.hpp")
// Inlined hook for Expression_SUB_RANGE_INIT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SUB_RANGE_INIT& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SUB_RANGE_INIT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_SUB_RANGE_INIT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_SUB_RANGE_INIT_before.hpp")
// Inlined hook for Expression_SUB_RANGE_INIT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SUB_RANGE_INIT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SUB_RANGE_INIT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_SUB_RANGE_INIT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_SUB_RANGE_INIT_after.hpp")
// Inlined hook for Expression_SUB_RANGE_INIT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SUB_RANGE_INIT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SUB_RANGE_INIT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_SUB_RANGE_INIT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_OR_COND.hpp")
// Inlined hook for Expression_OR_COND for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_OR_COND>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_OR_COND& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_OR_COND(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_OR_COND.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_OR_COND>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_OR_COND>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_OR_COND_before.hpp")
// Inlined hook for Expression_OR_COND_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_OR_COND_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_OR_COND_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_OR_COND_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_OR_COND_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_OR_COND_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_OR_COND_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_OR_COND_after.hpp")
// Inlined hook for Expression_OR_COND_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_OR_COND_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_OR_COND_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_OR_COND_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_OR_COND_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_OR_COND_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_OR_COND_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_ADDRESS_OF.hpp")
// Inlined hook for Expression_ADDRESS_OF for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ADDRESS_OF>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ADDRESS_OF& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ADDRESS_OF(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_ADDRESS_OF.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ADDRESS_OF>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ADDRESS_OF>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_ADDRESS_OF_before.hpp")
// Inlined hook for Expression_ADDRESS_OF_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ADDRESS_OF_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ADDRESS_OF_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_ADDRESS_OF_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_ADDRESS_OF_after.hpp")
// Inlined hook for Expression_ADDRESS_OF_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ADDRESS_OF_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ADDRESS_OF_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_ADDRESS_OF_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_OPTIONAL_OF.hpp")
// Inlined hook for Expression_OPTIONAL_OF for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_OPTIONAL_OF& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_OPTIONAL_OF(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_OPTIONAL_OF.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_OPTIONAL_OF_before.hpp")
// Inlined hook for Expression_OPTIONAL_OF_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_OPTIONAL_OF_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_OPTIONAL_OF_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_OPTIONAL_OF_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_OPTIONAL_OF_after.hpp")
// Inlined hook for Expression_OPTIONAL_OF_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_OPTIONAL_OF_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_OPTIONAL_OF_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_OPTIONAL_OF_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_SETTER_STATUS.hpp")
// Inlined hook for Expression_SETTER_STATUS for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SETTER_STATUS>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SETTER_STATUS& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SETTER_STATUS(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_SETTER_STATUS.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SETTER_STATUS>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SETTER_STATUS>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_SETTER_STATUS_before.hpp")
// Inlined hook for Expression_SETTER_STATUS_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SETTER_STATUS_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SETTER_STATUS_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_SETTER_STATUS_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_SETTER_STATUS_after.hpp")
// Inlined hook for Expression_SETTER_STATUS_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SETTER_STATUS_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SETTER_STATUS_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_SETTER_STATUS_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_SELF.hpp")
// Inlined hook for Expression_SELF for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SELF>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SELF& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SELF(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_SELF.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SELF>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SELF>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_SELF_before.hpp")
// Inlined hook for Expression_SELF_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SELF_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SELF_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SELF_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_SELF_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SELF_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SELF_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_SELF_after.hpp")
// Inlined hook for Expression_SELF_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SELF_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SELF_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SELF_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_SELF_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SELF_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_SELF_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_AS_ARG.hpp")
// Inlined hook for Expression_AS_ARG for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_AS_ARG>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_AS_ARG& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_AS_ARG(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_AS_ARG.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_AS_ARG>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_AS_ARG>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_AS_ARG_before.hpp")
// Inlined hook for Expression_AS_ARG_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_AS_ARG_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_AS_ARG_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_AS_ARG_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_AS_ARG_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_AS_ARG_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_AS_ARG_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_AS_ARG_after.hpp")
// Inlined hook for Expression_AS_ARG_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_AS_ARG_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_AS_ARG_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_AS_ARG_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_AS_ARG_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_AS_ARG_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_AS_ARG_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_dispatch.hpp")
// Inlined hook for Expression for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_dispatch.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_before_dispatch.hpp")
// Inlined hook for Expression_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_before_dispatch.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expression_after_dispatch.hpp")
// Inlined hook for Expression_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expression_after_dispatch.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expression_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expressions.hpp")
// Inlined hook for Expressions for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expressions>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expressions& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSIONS(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expressions.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expressions>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expressions>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expressions_before.hpp")
// Inlined hook for Expressions_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expressions_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expressions_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSIONS_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expressions_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expressions_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expressions_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Expressions_after.hpp")
// Inlined hook for Expressions_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expressions_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expressions_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSIONS_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Expressions_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expressions_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Expressions_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_INT.hpp")
// Inlined hook for Type_INT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_INT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_INT& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_INT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_INT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_INT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_INT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_INT 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_INT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_INT_before.hpp")
// Inlined hook for Type_INT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_INT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_INT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_INT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_INT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_INT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_INT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_INT_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_INT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_INT_after.hpp")
// Inlined hook for Type_INT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_INT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_INT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_INT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_INT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_INT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_INT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_INT_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_INT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_UINT.hpp")
// Inlined hook for Type_UINT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_UINT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_UINT& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_UINT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_UINT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_UINT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_UINT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_UINT 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_UINT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_UINT_before.hpp")
// Inlined hook for Type_UINT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_UINT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_UINT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_UINT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_UINT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_UINT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_UINT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_UINT_after.hpp")
// Inlined hook for Type_UINT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_UINT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_UINT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_UINT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_UINT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_UINT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_UINT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_USIZE.hpp")
// Inlined hook for Type_USIZE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_USIZE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_USIZE& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_USIZE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_USIZE.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_USIZE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_USIZE>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_USIZE_before.hpp")
// Inlined hook for Type_USIZE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_USIZE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_USIZE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_USIZE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_USIZE_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_USIZE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_USIZE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_USIZE_after.hpp")
// Inlined hook for Type_USIZE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_USIZE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_USIZE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_USIZE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_USIZE_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_USIZE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_USIZE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_FLOAT.hpp")
// Inlined hook for Type_FLOAT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_FLOAT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_FLOAT& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_FLOAT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_FLOAT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_FLOAT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_FLOAT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_FLOAT_before.hpp")
// Inlined hook for Type_FLOAT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_FLOAT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_FLOAT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_FLOAT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_FLOAT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_FLOAT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_FLOAT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_FLOAT_after.hpp")
// Inlined hook for Type_FLOAT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_FLOAT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_FLOAT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_FLOAT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_FLOAT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_FLOAT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_FLOAT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_STRUCT.hpp")
// Inlined hook for Type_STRUCT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_STRUCT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_STRUCT& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_STRUCT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_STRUCT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_STRUCT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_STRUCT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_STRUCT_before.hpp")
// Inlined hook for Type_STRUCT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_STRUCT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_STRUCT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_STRUCT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_STRUCT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_STRUCT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_STRUCT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_STRUCT_after.hpp")
// Inlined hook for Type_STRUCT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_STRUCT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_STRUCT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_STRUCT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_STRUCT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_STRUCT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_STRUCT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_RECURSIVE_STRUCT.hpp")
// Inlined hook for Type_RECURSIVE_STRUCT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_RECURSIVE_STRUCT& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_RECURSIVE_STRUCT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_RECURSIVE_STRUCT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_RECURSIVE_STRUCT_before.hpp")
// Inlined hook for Type_RECURSIVE_STRUCT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_RECURSIVE_STRUCT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_RECURSIVE_STRUCT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_RECURSIVE_STRUCT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_RECURSIVE_STRUCT_after.hpp")
// Inlined hook for Type_RECURSIVE_STRUCT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_RECURSIVE_STRUCT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_RECURSIVE_STRUCT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_RECURSIVE_STRUCT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_BOOL.hpp")
// Inlined hook for Type_BOOL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_BOOL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_BOOL& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_BOOL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_BOOL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_BOOL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_BOOL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_BOOL_before.hpp")
// Inlined hook for Type_BOOL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_BOOL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_BOOL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_BOOL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_BOOL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_BOOL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_BOOL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_BOOL_after.hpp")
// Inlined hook for Type_BOOL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_BOOL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_BOOL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_BOOL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_BOOL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_BOOL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_BOOL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_VOID.hpp")
// Inlined hook for Type_VOID for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VOID>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VOID& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VOID(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_VOID.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VOID>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VOID)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VOID 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VOID>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_VOID_before.hpp")
// Inlined hook for Type_VOID_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VOID_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VOID_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VOID_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_VOID_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VOID_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VOID_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_VOID_after.hpp")
// Inlined hook for Type_VOID_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VOID_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VOID_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VOID_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_VOID_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VOID_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VOID_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_META.hpp")
// Inlined hook for Type_META for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_META>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_META& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_META(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_META.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_META>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_META)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_META 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_META>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_META_before.hpp")
// Inlined hook for Type_META_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_META_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_META_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_META_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_META_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_META_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_META_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_META_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_META_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_META_after.hpp")
// Inlined hook for Type_META_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_META_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_META_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_META_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_META_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_META_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_META_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_META_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_META_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_ENUM.hpp")
// Inlined hook for Type_ENUM for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENUM>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENUM& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENUM(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_ENUM.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENUM>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENUM>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_ENUM_before.hpp")
// Inlined hook for Type_ENUM_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENUM_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENUM_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENUM_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_ENUM_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENUM_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENUM_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_ENUM_after.hpp")
// Inlined hook for Type_ENUM_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENUM_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENUM_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENUM_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_ENUM_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENUM_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENUM_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_ARRAY.hpp")
// Inlined hook for Type_ARRAY for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ARRAY>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ARRAY& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ARRAY(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_ARRAY.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ARRAY>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ARRAY>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_ARRAY_before.hpp")
// Inlined hook for Type_ARRAY_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ARRAY_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ARRAY_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ARRAY_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_ARRAY_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ARRAY_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ARRAY_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_ARRAY_after.hpp")
// Inlined hook for Type_ARRAY_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ARRAY_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ARRAY_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ARRAY_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_ARRAY_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ARRAY_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ARRAY_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_VECTOR.hpp")
// Inlined hook for Type_VECTOR for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VECTOR>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VECTOR& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VECTOR(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_VECTOR.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VECTOR>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VECTOR>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_VECTOR_before.hpp")
// Inlined hook for Type_VECTOR_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VECTOR_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VECTOR_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VECTOR_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_VECTOR_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VECTOR_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VECTOR_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_VECTOR_after.hpp")
// Inlined hook for Type_VECTOR_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VECTOR_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VECTOR_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VECTOR_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_VECTOR_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VECTOR_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VECTOR_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_VARIANT.hpp")
// Inlined hook for Type_VARIANT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VARIANT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VARIANT& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VARIANT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_VARIANT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VARIANT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VARIANT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_VARIANT_before.hpp")
// Inlined hook for Type_VARIANT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VARIANT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VARIANT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VARIANT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_VARIANT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VARIANT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VARIANT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_VARIANT_after.hpp")
// Inlined hook for Type_VARIANT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VARIANT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VARIANT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VARIANT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_VARIANT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VARIANT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_VARIANT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_RANGE.hpp")
// Inlined hook for Type_RANGE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_RANGE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_RANGE& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_RANGE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_RANGE.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_RANGE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_RANGE>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_RANGE_before.hpp")
// Inlined hook for Type_RANGE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_RANGE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_RANGE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_RANGE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_RANGE_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_RANGE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_RANGE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_RANGE_after.hpp")
// Inlined hook for Type_RANGE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_RANGE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_RANGE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_RANGE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_RANGE_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_RANGE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_RANGE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_ENCODER_RETURN.hpp")
// Inlined hook for Type_ENCODER_RETURN for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENCODER_RETURN>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENCODER_RETURN& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENCODER_RETURN(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_ENCODER_RETURN.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENCODER_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENCODER_RETURN>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_ENCODER_RETURN_before.hpp")
// Inlined hook for Type_ENCODER_RETURN_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENCODER_RETURN_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENCODER_RETURN_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_ENCODER_RETURN_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_ENCODER_RETURN_after.hpp")
// Inlined hook for Type_ENCODER_RETURN_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENCODER_RETURN_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENCODER_RETURN_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_ENCODER_RETURN_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_DECODER_RETURN.hpp")
// Inlined hook for Type_DECODER_RETURN for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_DECODER_RETURN>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_DECODER_RETURN& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_DECODER_RETURN(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_DECODER_RETURN.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_DECODER_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_DECODER_RETURN>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_DECODER_RETURN_before.hpp")
// Inlined hook for Type_DECODER_RETURN_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_DECODER_RETURN_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_DECODER_RETURN_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_DECODER_RETURN_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_DECODER_RETURN_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_DECODER_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_DECODER_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_DECODER_RETURN_after.hpp")
// Inlined hook for Type_DECODER_RETURN_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_DECODER_RETURN_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_DECODER_RETURN_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_DECODER_RETURN_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_DECODER_RETURN_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_DECODER_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_DECODER_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_ENCODER_INPUT.hpp")
// Inlined hook for Type_ENCODER_INPUT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENCODER_INPUT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENCODER_INPUT& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENCODER_INPUT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_ENCODER_INPUT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENCODER_INPUT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENCODER_INPUT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_ENCODER_INPUT_before.hpp")
// Inlined hook for Type_ENCODER_INPUT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENCODER_INPUT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENCODER_INPUT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_ENCODER_INPUT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_ENCODER_INPUT_after.hpp")
// Inlined hook for Type_ENCODER_INPUT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENCODER_INPUT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENCODER_INPUT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_ENCODER_INPUT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_DECODER_INPUT.hpp")
// Inlined hook for Type_DECODER_INPUT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_DECODER_INPUT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_DECODER_INPUT& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_DECODER_INPUT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_DECODER_INPUT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_DECODER_INPUT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_DECODER_INPUT>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_DECODER_INPUT_before.hpp")
// Inlined hook for Type_DECODER_INPUT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_DECODER_INPUT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_DECODER_INPUT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_DECODER_INPUT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_DECODER_INPUT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_DECODER_INPUT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_DECODER_INPUT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_DECODER_INPUT_after.hpp")
// Inlined hook for Type_DECODER_INPUT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_DECODER_INPUT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_DECODER_INPUT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_DECODER_INPUT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_DECODER_INPUT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_DECODER_INPUT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_DECODER_INPUT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_PROPERTY_SETTER_RETURN.hpp")
// Inlined hook for Type_PROPERTY_SETTER_RETURN for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_PROPERTY_SETTER_RETURN& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_PROPERTY_SETTER_RETURN(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_PROPERTY_SETTER_RETURN.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_PROPERTY_SETTER_RETURN_before.hpp")
// Inlined hook for Type_PROPERTY_SETTER_RETURN_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_PROPERTY_SETTER_RETURN_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_PROPERTY_SETTER_RETURN_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_PROPERTY_SETTER_RETURN_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_PROPERTY_SETTER_RETURN_after.hpp")
// Inlined hook for Type_PROPERTY_SETTER_RETURN_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_PROPERTY_SETTER_RETURN_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_PROPERTY_SETTER_RETURN_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_PROPERTY_SETTER_RETURN_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_OPTIONAL.hpp")
// Inlined hook for Type_OPTIONAL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_OPTIONAL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_OPTIONAL& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_OPTIONAL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_OPTIONAL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_OPTIONAL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_OPTIONAL>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_OPTIONAL_before.hpp")
// Inlined hook for Type_OPTIONAL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_OPTIONAL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_OPTIONAL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_OPTIONAL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_OPTIONAL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_OPTIONAL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_OPTIONAL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_OPTIONAL_after.hpp")
// Inlined hook for Type_OPTIONAL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_OPTIONAL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_OPTIONAL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_OPTIONAL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_OPTIONAL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_OPTIONAL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_OPTIONAL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_PTR.hpp")
// Inlined hook for Type_PTR for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_PTR>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_PTR& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_PTR(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_PTR.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_PTR>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PTR)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PTR 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_PTR>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_PTR_before.hpp")
// Inlined hook for Type_PTR_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_PTR_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_PTR_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_PTR_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_PTR_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_PTR_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_PTR_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_PTR_after.hpp")
// Inlined hook for Type_PTR_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_PTR_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_PTR_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_PTR_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_PTR_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_PTR_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_PTR_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_FUNCTION.hpp")
// Inlined hook for Type_FUNCTION for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_FUNCTION>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_FUNCTION& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_FUNCTION(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_FUNCTION.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_FUNCTION>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_FUNCTION>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_FUNCTION_before.hpp")
// Inlined hook for Type_FUNCTION_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_FUNCTION_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_FUNCTION_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_FUNCTION_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_FUNCTION_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_FUNCTION_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_FUNCTION_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_FUNCTION_after.hpp")
// Inlined hook for Type_FUNCTION_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_FUNCTION_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_FUNCTION_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_FUNCTION_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_FUNCTION_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_FUNCTION_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_FUNCTION_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_dispatch.hpp")
// Inlined hook for Type for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_dispatch.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_before_dispatch.hpp")
// Inlined hook for Type_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_before_dispatch.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Type_after_dispatch.hpp")
// Inlined hook for Type_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Type_after_dispatch.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Type_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/Types.hpp")
// Inlined hook for Types for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Types>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Types& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPES(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Types.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Types>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPES)
#define CODEGEN_EXPECTED_PRIORITY_TYPES 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Types>> {}; // Unimplemented
#endif
#if __has_include("visitor/Types_before.hpp")
// Inlined hook for Types_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Types_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Types_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPES_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Types_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Types_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPES_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPES_BEFORE 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Types_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/Types_after.hpp")
// Inlined hook for Types_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Types_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Types_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPES_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/Types_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Types_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPES_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPES_AFTER 1
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedHook<ebm2python::VisitorTag_Types_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/entry_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_entry>>
#define CODEGEN_CONTEXT(dummy_name) Context_entry
#include "visitor/dsl/entry_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_entry"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_entry>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_entry>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_ENTRY)
#define CODEGEN_EXPECTED_PRIORITY_ENTRY 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_entry>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/entry_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_entry_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_entry_before<Result>
#include "visitor/dsl/entry_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_entry_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_entry_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_entry_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_ENTRY_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_ENTRY_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_entry_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/entry_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_entry_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_entry_after<Result>
#include "visitor/dsl/entry_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_entry_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_entry_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_entry_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_ENTRY_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_ENTRY_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_entry_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/pre_visitor_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_pre_visitor>>
#define CODEGEN_CONTEXT(dummy_name) Context_pre_visitor
#include "visitor/dsl/pre_visitor_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_pre_visitor"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_pre_visitor>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_pre_visitor>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR)
#define CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_pre_visitor>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/pre_visitor_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_pre_visitor_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_pre_visitor_before<Result>
#include "visitor/dsl/pre_visitor_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_pre_visitor_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_pre_visitor_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_pre_visitor_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_pre_visitor_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/pre_visitor_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_pre_visitor_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_pre_visitor_after<Result>
#include "visitor/dsl/pre_visitor_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_pre_visitor_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_pre_visitor_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_pre_visitor_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_pre_visitor_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/post_entry_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_post_entry>>
#define CODEGEN_CONTEXT(dummy_name) Context_post_entry<Result>
#include "visitor/dsl/post_entry_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_post_entry<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_post_entry>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_post_entry>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_POST_ENTRY)
#define CODEGEN_EXPECTED_PRIORITY_POST_ENTRY 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_post_entry>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/post_entry_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_post_entry_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_post_entry_before<Result>
#include "visitor/dsl/post_entry_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_post_entry_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_post_entry_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_post_entry_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_post_entry_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/post_entry_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_post_entry_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_post_entry_after<Result>
#include "visitor/dsl/post_entry_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_post_entry_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_post_entry_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_post_entry_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_post_entry_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_BLOCK_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_BLOCK>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_BLOCK
#include "visitor/dsl/Statement_BLOCK_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_BLOCK"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_BLOCK>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_BLOCK>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_BLOCK>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_BLOCK_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_BLOCK_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_BLOCK_before<Result>
#include "visitor/dsl/Statement_BLOCK_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_BLOCK_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_BLOCK_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_BLOCK_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_BLOCK_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_BLOCK_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_BLOCK_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_BLOCK_after<Result>
#include "visitor/dsl/Statement_BLOCK_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_BLOCK_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_BLOCK_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_BLOCK_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_BLOCK_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ASSIGNMENT_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ASSIGNMENT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ASSIGNMENT
#include "visitor/dsl/Statement_ASSIGNMENT_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ASSIGNMENT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ASSIGNMENT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ASSIGNMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ASSIGNMENT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ASSIGNMENT_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ASSIGNMENT_before<Result>
#include "visitor/dsl/Statement_ASSIGNMENT_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ASSIGNMENT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ASSIGNMENT_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ASSIGNMENT_after<Result>
#include "visitor/dsl/Statement_ASSIGNMENT_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ASSIGNMENT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_YIELD_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_YIELD>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_YIELD
#include "visitor/dsl/Statement_YIELD_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_YIELD"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_YIELD>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_YIELD>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_YIELD>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_YIELD_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_YIELD_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_YIELD_before<Result>
#include "visitor/dsl/Statement_YIELD_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_YIELD_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_YIELD_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_YIELD_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_YIELD_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_YIELD_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_YIELD_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_YIELD_after<Result>
#include "visitor/dsl/Statement_YIELD_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_YIELD_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_YIELD_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_YIELD_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_YIELD_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_APPEND_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_APPEND>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_APPEND
#include "visitor/dsl/Statement_APPEND_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_APPEND"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_APPEND>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_APPEND>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_APPEND>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_APPEND_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_APPEND_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_APPEND_before<Result>
#include "visitor/dsl/Statement_APPEND_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_APPEND_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_APPEND_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_APPEND_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_APPEND_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_APPEND_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_APPEND_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_APPEND_after<Result>
#include "visitor/dsl/Statement_APPEND_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_APPEND_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_APPEND_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_APPEND_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_APPEND_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_RETURN_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_RETURN>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_RETURN
#include "visitor/dsl/Statement_RETURN_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_RETURN"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_RETURN>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_RETURN>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_RETURN_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_RETURN_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_RETURN_before<Result>
#include "visitor/dsl/Statement_RETURN_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_RETURN_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_RETURN_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_RETURN_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_RETURN_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_RETURN_after<Result>
#include "visitor/dsl/Statement_RETURN_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_RETURN_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_RETURN_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ERROR_RETURN_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ERROR_RETURN>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ERROR_RETURN
#include "visitor/dsl/Statement_ERROR_RETURN_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ERROR_RETURN"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ERROR_RETURN>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ERROR_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ERROR_RETURN>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ERROR_RETURN_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ERROR_RETURN_before<Result>
#include "visitor/dsl/Statement_ERROR_RETURN_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ERROR_RETURN_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ERROR_RETURN_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ERROR_RETURN_after<Result>
#include "visitor/dsl/Statement_ERROR_RETURN_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ERROR_RETURN_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ASSERT_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ASSERT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ASSERT
#include "visitor/dsl/Statement_ASSERT_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ASSERT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ASSERT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ASSERT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ASSERT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ASSERT_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ASSERT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ASSERT_before<Result>
#include "visitor/dsl/Statement_ASSERT_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ASSERT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ASSERT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ASSERT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ASSERT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ASSERT_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ASSERT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ASSERT_after<Result>
#include "visitor/dsl/Statement_ASSERT_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ASSERT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ASSERT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ASSERT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ASSERT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_READ_DATA_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_READ_DATA>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_READ_DATA
#include "visitor/dsl/Statement_READ_DATA_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_READ_DATA"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_READ_DATA>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_READ_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_READ_DATA>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_READ_DATA_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_READ_DATA_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_READ_DATA_before<Result>
#include "visitor/dsl/Statement_READ_DATA_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_READ_DATA_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_READ_DATA_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_READ_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_READ_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_READ_DATA_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_READ_DATA_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_READ_DATA_after<Result>
#include "visitor/dsl/Statement_READ_DATA_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_READ_DATA_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_READ_DATA_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_READ_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_READ_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_WRITE_DATA_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_WRITE_DATA>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_WRITE_DATA
#include "visitor/dsl/Statement_WRITE_DATA_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_WRITE_DATA"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_WRITE_DATA>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_WRITE_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_WRITE_DATA>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_WRITE_DATA_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_WRITE_DATA_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_WRITE_DATA_before<Result>
#include "visitor/dsl/Statement_WRITE_DATA_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_WRITE_DATA_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_WRITE_DATA_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_WRITE_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_WRITE_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_WRITE_DATA_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_WRITE_DATA_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_WRITE_DATA_after<Result>
#include "visitor/dsl/Statement_WRITE_DATA_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_WRITE_DATA_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_WRITE_DATA_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_WRITE_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_WRITE_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_RESERVE_DATA_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_RESERVE_DATA>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_RESERVE_DATA
#include "visitor/dsl/Statement_RESERVE_DATA_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_RESERVE_DATA"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_RESERVE_DATA>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_RESERVE_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_RESERVE_DATA>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_RESERVE_DATA_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_RESERVE_DATA_before<Result>
#include "visitor/dsl/Statement_RESERVE_DATA_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_RESERVE_DATA_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_RESERVE_DATA_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_RESERVE_DATA_after<Result>
#include "visitor/dsl/Statement_RESERVE_DATA_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_RESERVE_DATA_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_IF_STATEMENT_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_IF_STATEMENT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_IF_STATEMENT
#include "visitor/dsl/Statement_IF_STATEMENT_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_IF_STATEMENT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_IF_STATEMENT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_IF_STATEMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_IF_STATEMENT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_IF_STATEMENT_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_IF_STATEMENT_before<Result>
#include "visitor/dsl/Statement_IF_STATEMENT_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_IF_STATEMENT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_IF_STATEMENT_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_IF_STATEMENT_after<Result>
#include "visitor/dsl/Statement_IF_STATEMENT_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_IF_STATEMENT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_LOOP_STATEMENT_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_LOOP_STATEMENT
#include "visitor/dsl/Statement_LOOP_STATEMENT_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_LOOP_STATEMENT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_LOOP_STATEMENT_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_LOOP_STATEMENT_before<Result>
#include "visitor/dsl/Statement_LOOP_STATEMENT_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_LOOP_STATEMENT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_LOOP_STATEMENT_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_LOOP_STATEMENT_after<Result>
#include "visitor/dsl/Statement_LOOP_STATEMENT_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_LOOP_STATEMENT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_MATCH_STATEMENT_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_MATCH_STATEMENT
#include "visitor/dsl/Statement_MATCH_STATEMENT_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_MATCH_STATEMENT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_MATCH_STATEMENT_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_MATCH_STATEMENT_before<Result>
#include "visitor/dsl/Statement_MATCH_STATEMENT_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_MATCH_STATEMENT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_MATCH_STATEMENT_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_MATCH_STATEMENT_after<Result>
#include "visitor/dsl/Statement_MATCH_STATEMENT_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_MATCH_STATEMENT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_MATCH_BRANCH_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_MATCH_BRANCH
#include "visitor/dsl/Statement_MATCH_BRANCH_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_MATCH_BRANCH"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_MATCH_BRANCH_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_MATCH_BRANCH_before<Result>
#include "visitor/dsl/Statement_MATCH_BRANCH_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_MATCH_BRANCH_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_MATCH_BRANCH_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_MATCH_BRANCH_after<Result>
#include "visitor/dsl/Statement_MATCH_BRANCH_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_MATCH_BRANCH_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_BREAK_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_BREAK>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_BREAK
#include "visitor/dsl/Statement_BREAK_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_BREAK"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_BREAK>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_BREAK>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_BREAK>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_BREAK_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_BREAK_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_BREAK_before<Result>
#include "visitor/dsl/Statement_BREAK_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_BREAK_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_BREAK_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_BREAK_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_BREAK_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_BREAK_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_BREAK_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_BREAK_after<Result>
#include "visitor/dsl/Statement_BREAK_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_BREAK_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_BREAK_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_BREAK_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_BREAK_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_CONTINUE_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_CONTINUE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_CONTINUE
#include "visitor/dsl/Statement_CONTINUE_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_CONTINUE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_CONTINUE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_CONTINUE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_CONTINUE>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_CONTINUE_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_CONTINUE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_CONTINUE_before<Result>
#include "visitor/dsl/Statement_CONTINUE_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_CONTINUE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_CONTINUE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_CONTINUE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_CONTINUE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_CONTINUE_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_CONTINUE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_CONTINUE_after<Result>
#include "visitor/dsl/Statement_CONTINUE_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_CONTINUE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_CONTINUE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_CONTINUE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_CONTINUE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_FUNCTION_DECL_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_FUNCTION_DECL
#include "visitor/dsl/Statement_FUNCTION_DECL_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_FUNCTION_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_FUNCTION_DECL_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_FUNCTION_DECL_before<Result>
#include "visitor/dsl/Statement_FUNCTION_DECL_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_FUNCTION_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_FUNCTION_DECL_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_FUNCTION_DECL_after<Result>
#include "visitor/dsl/Statement_FUNCTION_DECL_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_FUNCTION_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_VARIABLE_DECL_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_VARIABLE_DECL
#include "visitor/dsl/Statement_VARIABLE_DECL_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_VARIABLE_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_VARIABLE_DECL_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_VARIABLE_DECL_before<Result>
#include "visitor/dsl/Statement_VARIABLE_DECL_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_VARIABLE_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_VARIABLE_DECL_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_VARIABLE_DECL_after<Result>
#include "visitor/dsl/Statement_VARIABLE_DECL_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_VARIABLE_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_PARAMETER_DECL_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PARAMETER_DECL
#include "visitor/dsl/Statement_PARAMETER_DECL_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PARAMETER_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_PARAMETER_DECL_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PARAMETER_DECL_before<Result>
#include "visitor/dsl/Statement_PARAMETER_DECL_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PARAMETER_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_PARAMETER_DECL_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PARAMETER_DECL_after<Result>
#include "visitor/dsl/Statement_PARAMETER_DECL_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PARAMETER_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_FIELD_DECL_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_FIELD_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_FIELD_DECL
#include "visitor/dsl/Statement_FIELD_DECL_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_FIELD_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_FIELD_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_FIELD_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_FIELD_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_FIELD_DECL_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_FIELD_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_FIELD_DECL_before<Result>
#include "visitor/dsl/Statement_FIELD_DECL_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_FIELD_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_FIELD_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_FIELD_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_FIELD_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_FIELD_DECL_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_FIELD_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_FIELD_DECL_after<Result>
#include "visitor/dsl/Statement_FIELD_DECL_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_FIELD_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_FIELD_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_FIELD_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_FIELD_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_COMPOSITE_FIELD_DECL_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_COMPOSITE_FIELD_DECL
#include "visitor/dsl/Statement_COMPOSITE_FIELD_DECL_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_COMPOSITE_FIELD_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_COMPOSITE_FIELD_DECL_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_COMPOSITE_FIELD_DECL_before<Result>
#include "visitor/dsl/Statement_COMPOSITE_FIELD_DECL_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_COMPOSITE_FIELD_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_COMPOSITE_FIELD_DECL_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_COMPOSITE_FIELD_DECL_after<Result>
#include "visitor/dsl/Statement_COMPOSITE_FIELD_DECL_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_COMPOSITE_FIELD_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ENUM_DECL_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENUM_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENUM_DECL
#include "visitor/dsl/Statement_ENUM_DECL_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENUM_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENUM_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENUM_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENUM_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ENUM_DECL_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENUM_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENUM_DECL_before<Result>
#include "visitor/dsl/Statement_ENUM_DECL_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENUM_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENUM_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENUM_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENUM_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ENUM_DECL_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENUM_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENUM_DECL_after<Result>
#include "visitor/dsl/Statement_ENUM_DECL_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENUM_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENUM_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENUM_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENUM_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ENUM_MEMBER_DECL_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENUM_MEMBER_DECL
#include "visitor/dsl/Statement_ENUM_MEMBER_DECL_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENUM_MEMBER_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ENUM_MEMBER_DECL_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENUM_MEMBER_DECL_before<Result>
#include "visitor/dsl/Statement_ENUM_MEMBER_DECL_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENUM_MEMBER_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ENUM_MEMBER_DECL_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENUM_MEMBER_DECL_after<Result>
#include "visitor/dsl/Statement_ENUM_MEMBER_DECL_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENUM_MEMBER_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_STRUCT_DECL_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_STRUCT_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_STRUCT_DECL
#include "visitor/dsl/Statement_STRUCT_DECL_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_STRUCT_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_STRUCT_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_STRUCT_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_STRUCT_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_STRUCT_DECL_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_STRUCT_DECL_before<Result>
#include "visitor/dsl/Statement_STRUCT_DECL_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_STRUCT_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_STRUCT_DECL_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_STRUCT_DECL_after<Result>
#include "visitor/dsl/Statement_STRUCT_DECL_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_STRUCT_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_UNION_DECL_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_UNION_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_UNION_DECL
#include "visitor/dsl/Statement_UNION_DECL_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_UNION_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_UNION_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_UNION_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_UNION_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_UNION_DECL_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_UNION_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_UNION_DECL_before<Result>
#include "visitor/dsl/Statement_UNION_DECL_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_UNION_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_UNION_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_UNION_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_UNION_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_UNION_DECL_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_UNION_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_UNION_DECL_after<Result>
#include "visitor/dsl/Statement_UNION_DECL_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_UNION_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_UNION_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_UNION_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_UNION_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_UNION_MEMBER_DECL_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_UNION_MEMBER_DECL
#include "visitor/dsl/Statement_UNION_MEMBER_DECL_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_UNION_MEMBER_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_UNION_MEMBER_DECL_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_UNION_MEMBER_DECL_before<Result>
#include "visitor/dsl/Statement_UNION_MEMBER_DECL_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_UNION_MEMBER_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_UNION_MEMBER_DECL_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_UNION_MEMBER_DECL_after<Result>
#include "visitor/dsl/Statement_UNION_MEMBER_DECL_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_UNION_MEMBER_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_PROGRAM_DECL_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROGRAM_DECL
#include "visitor/dsl/Statement_PROGRAM_DECL_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROGRAM_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_PROGRAM_DECL_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROGRAM_DECL_before<Result>
#include "visitor/dsl/Statement_PROGRAM_DECL_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROGRAM_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_PROGRAM_DECL_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROGRAM_DECL_after<Result>
#include "visitor/dsl/Statement_PROGRAM_DECL_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROGRAM_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_PROPERTY_DECL_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROPERTY_DECL
#include "visitor/dsl/Statement_PROPERTY_DECL_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROPERTY_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_PROPERTY_DECL_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROPERTY_DECL_before<Result>
#include "visitor/dsl/Statement_PROPERTY_DECL_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROPERTY_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_PROPERTY_DECL_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROPERTY_DECL_after<Result>
#include "visitor/dsl/Statement_PROPERTY_DECL_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROPERTY_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_PROPERTY_MEMBER_DECL_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROPERTY_MEMBER_DECL
#include "visitor/dsl/Statement_PROPERTY_MEMBER_DECL_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROPERTY_MEMBER_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_PROPERTY_MEMBER_DECL_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROPERTY_MEMBER_DECL_before<Result>
#include "visitor/dsl/Statement_PROPERTY_MEMBER_DECL_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROPERTY_MEMBER_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_PROPERTY_MEMBER_DECL_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROPERTY_MEMBER_DECL_after<Result>
#include "visitor/dsl/Statement_PROPERTY_MEMBER_DECL_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROPERTY_MEMBER_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_METADATA_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_METADATA>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_METADATA
#include "visitor/dsl/Statement_METADATA_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_METADATA"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_METADATA>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_METADATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_METADATA>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_METADATA_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_METADATA_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_METADATA_before<Result>
#include "visitor/dsl/Statement_METADATA_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_METADATA_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_METADATA_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_METADATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_METADATA_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_METADATA_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_METADATA_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_METADATA_after<Result>
#include "visitor/dsl/Statement_METADATA_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_METADATA_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_METADATA_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_METADATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_METADATA_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_IMPORT_MODULE_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_IMPORT_MODULE
#include "visitor/dsl/Statement_IMPORT_MODULE_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_IMPORT_MODULE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_IMPORT_MODULE_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_IMPORT_MODULE_before<Result>
#include "visitor/dsl/Statement_IMPORT_MODULE_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_IMPORT_MODULE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_IMPORT_MODULE_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_IMPORT_MODULE_after<Result>
#include "visitor/dsl/Statement_IMPORT_MODULE_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_IMPORT_MODULE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_EXPRESSION_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_EXPRESSION>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_EXPRESSION
#include "visitor/dsl/Statement_EXPRESSION_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_EXPRESSION"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_EXPRESSION>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_EXPRESSION>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_EXPRESSION>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_EXPRESSION_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_EXPRESSION_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_EXPRESSION_before<Result>
#include "visitor/dsl/Statement_EXPRESSION_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_EXPRESSION_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_EXPRESSION_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_EXPRESSION_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_EXPRESSION_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_EXPRESSION_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_EXPRESSION_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_EXPRESSION_after<Result>
#include "visitor/dsl/Statement_EXPRESSION_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_EXPRESSION_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_EXPRESSION_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_EXPRESSION_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_EXPRESSION_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ERROR_REPORT_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ERROR_REPORT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ERROR_REPORT
#include "visitor/dsl/Statement_ERROR_REPORT_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ERROR_REPORT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ERROR_REPORT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ERROR_REPORT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ERROR_REPORT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ERROR_REPORT_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ERROR_REPORT_before<Result>
#include "visitor/dsl/Statement_ERROR_REPORT_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ERROR_REPORT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ERROR_REPORT_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ERROR_REPORT_after<Result>
#include "visitor/dsl/Statement_ERROR_REPORT_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ERROR_REPORT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_LOWERED_IO_STATEMENTS_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_LOWERED_IO_STATEMENTS
#include "visitor/dsl/Statement_LOWERED_IO_STATEMENTS_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_LOWERED_IO_STATEMENTS"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_LOWERED_IO_STATEMENTS_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_LOWERED_IO_STATEMENTS_before<Result>
#include "visitor/dsl/Statement_LOWERED_IO_STATEMENTS_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_LOWERED_IO_STATEMENTS_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_LOWERED_IO_STATEMENTS_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_LOWERED_IO_STATEMENTS_after<Result>
#include "visitor/dsl/Statement_LOWERED_IO_STATEMENTS_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_LOWERED_IO_STATEMENTS_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_SUB_BYTE_RANGE_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_SUB_BYTE_RANGE
#include "visitor/dsl/Statement_SUB_BYTE_RANGE_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_SUB_BYTE_RANGE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_SUB_BYTE_RANGE_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_SUB_BYTE_RANGE_before<Result>
#include "visitor/dsl/Statement_SUB_BYTE_RANGE_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_SUB_BYTE_RANGE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_SUB_BYTE_RANGE_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_SUB_BYTE_RANGE_after<Result>
#include "visitor/dsl/Statement_SUB_BYTE_RANGE_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_SUB_BYTE_RANGE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_INIT_CHECK_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_INIT_CHECK>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_INIT_CHECK
#include "visitor/dsl/Statement_INIT_CHECK_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_INIT_CHECK"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_INIT_CHECK>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_INIT_CHECK>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_INIT_CHECK>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_INIT_CHECK_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_INIT_CHECK_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_INIT_CHECK_before<Result>
#include "visitor/dsl/Statement_INIT_CHECK_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_INIT_CHECK_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_INIT_CHECK_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_INIT_CHECK_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_INIT_CHECK_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_INIT_CHECK_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_INIT_CHECK_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_INIT_CHECK_after<Result>
#include "visitor/dsl/Statement_INIT_CHECK_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_INIT_CHECK_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_INIT_CHECK_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_INIT_CHECK_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_INIT_CHECK_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ENDIAN_VARIABLE_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENDIAN_VARIABLE
#include "visitor/dsl/Statement_ENDIAN_VARIABLE_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENDIAN_VARIABLE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ENDIAN_VARIABLE_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENDIAN_VARIABLE_before<Result>
#include "visitor/dsl/Statement_ENDIAN_VARIABLE_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENDIAN_VARIABLE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ENDIAN_VARIABLE_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENDIAN_VARIABLE_after<Result>
#include "visitor/dsl/Statement_ENDIAN_VARIABLE_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENDIAN_VARIABLE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_dispatch_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement
#include "visitor/dsl/Statement_dispatch_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_before_dispatch_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_before<Result>
#include "visitor/dsl/Statement_before_dispatch_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_after_dispatch_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_after<Result>
#include "visitor/dsl/Statement_after_dispatch_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Statement_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Block_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Block>>
#define CODEGEN_CONTEXT(dummy_name) Context_Block
#include "visitor/dsl/Block_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Block"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Block>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Block>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_BLOCK)
#define CODEGEN_EXPECTED_PRIORITY_BLOCK 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Block>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Block_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Block_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Block_before<Result>
#include "visitor/dsl/Block_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Block_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Block_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Block_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_BLOCK_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_BLOCK_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Block_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Block_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Block_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Block_after<Result>
#include "visitor/dsl/Block_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Block_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Block_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Block_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_BLOCK_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_BLOCK_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Block_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_INT_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_INT
#include "visitor/dsl/Expression_LITERAL_INT_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_INT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_INT_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_INT_before<Result>
#include "visitor/dsl/Expression_LITERAL_INT_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_INT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_INT_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_INT_after<Result>
#include "visitor/dsl/Expression_LITERAL_INT_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_INT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_INT64_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT64>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_INT64
#include "visitor/dsl/Expression_LITERAL_INT64_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_INT64"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT64>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT64>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT64>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_INT64_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_INT64_before<Result>
#include "visitor/dsl/Expression_LITERAL_INT64_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_INT64_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_INT64_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_INT64_after<Result>
#include "visitor/dsl/Expression_LITERAL_INT64_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_INT64_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_BOOL_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_BOOL
#include "visitor/dsl/Expression_LITERAL_BOOL_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_BOOL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_BOOL_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_BOOL_before<Result>
#include "visitor/dsl/Expression_LITERAL_BOOL_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_BOOL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_BOOL_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_BOOL_after<Result>
#include "visitor/dsl/Expression_LITERAL_BOOL_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_BOOL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_STRING_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_STRING>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_STRING
#include "visitor/dsl/Expression_LITERAL_STRING_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_STRING"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_STRING>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_STRING>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_STRING>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_STRING_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_STRING_before<Result>
#include "visitor/dsl/Expression_LITERAL_STRING_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_STRING_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_STRING_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_STRING_after<Result>
#include "visitor/dsl/Expression_LITERAL_STRING_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_STRING_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_TYPE_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_TYPE
#include "visitor/dsl/Expression_LITERAL_TYPE_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_TYPE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_TYPE_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_TYPE_before<Result>
#include "visitor/dsl/Expression_LITERAL_TYPE_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_TYPE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_TYPE_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_TYPE_after<Result>
#include "visitor/dsl/Expression_LITERAL_TYPE_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_TYPE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_CHAR_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_CHAR
#include "visitor/dsl/Expression_LITERAL_CHAR_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_CHAR"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_CHAR_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_CHAR_before<Result>
#include "visitor/dsl/Expression_LITERAL_CHAR_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_CHAR_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_CHAR_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_CHAR_after<Result>
#include "visitor/dsl/Expression_LITERAL_CHAR_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_CHAR_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_IDENTIFIER_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IDENTIFIER>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IDENTIFIER
#include "visitor/dsl/Expression_IDENTIFIER_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IDENTIFIER"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IDENTIFIER>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IDENTIFIER>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IDENTIFIER>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_IDENTIFIER_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IDENTIFIER_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IDENTIFIER_before<Result>
#include "visitor/dsl/Expression_IDENTIFIER_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IDENTIFIER_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IDENTIFIER_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IDENTIFIER_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IDENTIFIER_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_IDENTIFIER_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IDENTIFIER_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IDENTIFIER_after<Result>
#include "visitor/dsl/Expression_IDENTIFIER_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IDENTIFIER_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IDENTIFIER_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IDENTIFIER_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IDENTIFIER_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_BINARY_OP_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_BINARY_OP>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_BINARY_OP
#include "visitor/dsl/Expression_BINARY_OP_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_BINARY_OP"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_BINARY_OP>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_BINARY_OP>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_BINARY_OP>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_BINARY_OP_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_BINARY_OP_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_BINARY_OP_before<Result>
#include "visitor/dsl/Expression_BINARY_OP_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_BINARY_OP_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_BINARY_OP_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_BINARY_OP_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_BINARY_OP_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_BINARY_OP_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_BINARY_OP_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_BINARY_OP_after<Result>
#include "visitor/dsl/Expression_BINARY_OP_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_BINARY_OP_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_BINARY_OP_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_BINARY_OP_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_BINARY_OP_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_UNARY_OP_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_UNARY_OP>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_UNARY_OP
#include "visitor/dsl/Expression_UNARY_OP_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_UNARY_OP"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_UNARY_OP>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_UNARY_OP>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_UNARY_OP>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_UNARY_OP_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_UNARY_OP_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_UNARY_OP_before<Result>
#include "visitor/dsl/Expression_UNARY_OP_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_UNARY_OP_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_UNARY_OP_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_UNARY_OP_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_UNARY_OP_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_UNARY_OP_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_UNARY_OP_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_UNARY_OP_after<Result>
#include "visitor/dsl/Expression_UNARY_OP_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_UNARY_OP_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_UNARY_OP_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_UNARY_OP_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_UNARY_OP_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_CALL_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CALL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CALL
#include "visitor/dsl/Expression_CALL_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CALL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CALL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CALL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CALL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_CALL_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CALL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CALL_before<Result>
#include "visitor/dsl/Expression_CALL_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CALL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CALL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CALL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CALL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_CALL_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CALL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CALL_after<Result>
#include "visitor/dsl/Expression_CALL_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CALL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CALL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CALL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CALL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_INDEX_ACCESS_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_INDEX_ACCESS
#include "visitor/dsl/Expression_INDEX_ACCESS_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_INDEX_ACCESS"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_INDEX_ACCESS_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_INDEX_ACCESS_before<Result>
#include "visitor/dsl/Expression_INDEX_ACCESS_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_INDEX_ACCESS_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_INDEX_ACCESS_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_INDEX_ACCESS_after<Result>
#include "visitor/dsl/Expression_INDEX_ACCESS_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_INDEX_ACCESS_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_MEMBER_ACCESS_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_MEMBER_ACCESS
#include "visitor/dsl/Expression_MEMBER_ACCESS_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_MEMBER_ACCESS"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_MEMBER_ACCESS_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_MEMBER_ACCESS_before<Result>
#include "visitor/dsl/Expression_MEMBER_ACCESS_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_MEMBER_ACCESS_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_MEMBER_ACCESS_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_MEMBER_ACCESS_after<Result>
#include "visitor/dsl/Expression_MEMBER_ACCESS_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_MEMBER_ACCESS_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_ENUM_MEMBER_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ENUM_MEMBER
#include "visitor/dsl/Expression_ENUM_MEMBER_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ENUM_MEMBER"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_ENUM_MEMBER_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ENUM_MEMBER_before<Result>
#include "visitor/dsl/Expression_ENUM_MEMBER_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ENUM_MEMBER_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_ENUM_MEMBER_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ENUM_MEMBER_after<Result>
#include "visitor/dsl/Expression_ENUM_MEMBER_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ENUM_MEMBER_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_TYPE_CAST_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_TYPE_CAST>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_TYPE_CAST
#include "visitor/dsl/Expression_TYPE_CAST_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_TYPE_CAST"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_TYPE_CAST>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_TYPE_CAST>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_TYPE_CAST>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_TYPE_CAST_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_TYPE_CAST_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_TYPE_CAST_before<Result>
#include "visitor/dsl/Expression_TYPE_CAST_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_TYPE_CAST_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_TYPE_CAST_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_TYPE_CAST_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_TYPE_CAST_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_TYPE_CAST_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_TYPE_CAST_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_TYPE_CAST_after<Result>
#include "visitor/dsl/Expression_TYPE_CAST_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_TYPE_CAST_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_TYPE_CAST_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_TYPE_CAST_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_TYPE_CAST_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_RANGE_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_RANGE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_RANGE
#include "visitor/dsl/Expression_RANGE_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_RANGE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_RANGE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_RANGE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_RANGE>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_RANGE_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_RANGE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_RANGE_before<Result>
#include "visitor/dsl/Expression_RANGE_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_RANGE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_RANGE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_RANGE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_RANGE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_RANGE_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_RANGE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_RANGE_after<Result>
#include "visitor/dsl/Expression_RANGE_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_RANGE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_RANGE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_RANGE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_RANGE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_DEFAULT_VALUE_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_DEFAULT_VALUE
#include "visitor/dsl/Expression_DEFAULT_VALUE_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_DEFAULT_VALUE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_DEFAULT_VALUE_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_DEFAULT_VALUE_before<Result>
#include "visitor/dsl/Expression_DEFAULT_VALUE_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_DEFAULT_VALUE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_DEFAULT_VALUE_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_DEFAULT_VALUE_after<Result>
#include "visitor/dsl/Expression_DEFAULT_VALUE_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_DEFAULT_VALUE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_IS_LITTLE_ENDIAN_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IS_LITTLE_ENDIAN
#include "visitor/dsl/Expression_IS_LITTLE_ENDIAN_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IS_LITTLE_ENDIAN"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_IS_LITTLE_ENDIAN_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IS_LITTLE_ENDIAN_before<Result>
#include "visitor/dsl/Expression_IS_LITTLE_ENDIAN_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IS_LITTLE_ENDIAN_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_IS_LITTLE_ENDIAN_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IS_LITTLE_ENDIAN_after<Result>
#include "visitor/dsl/Expression_IS_LITTLE_ENDIAN_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IS_LITTLE_ENDIAN_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_GET_STREAM_OFFSET_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_GET_STREAM_OFFSET
#include "visitor/dsl/Expression_GET_STREAM_OFFSET_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_GET_STREAM_OFFSET"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_GET_STREAM_OFFSET_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_GET_STREAM_OFFSET_before<Result>
#include "visitor/dsl/Expression_GET_STREAM_OFFSET_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_GET_STREAM_OFFSET_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_GET_STREAM_OFFSET_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_GET_STREAM_OFFSET_after<Result>
#include "visitor/dsl/Expression_GET_STREAM_OFFSET_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_GET_STREAM_OFFSET_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_GET_REMAINING_BYTES_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_GET_REMAINING_BYTES
#include "visitor/dsl/Expression_GET_REMAINING_BYTES_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_GET_REMAINING_BYTES"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_GET_REMAINING_BYTES_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_GET_REMAINING_BYTES_before<Result>
#include "visitor/dsl/Expression_GET_REMAINING_BYTES_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_GET_REMAINING_BYTES_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_GET_REMAINING_BYTES_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_GET_REMAINING_BYTES_after<Result>
#include "visitor/dsl/Expression_GET_REMAINING_BYTES_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_GET_REMAINING_BYTES_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_CAN_READ_STREAM_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CAN_READ_STREAM
#include "visitor/dsl/Expression_CAN_READ_STREAM_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CAN_READ_STREAM"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_CAN_READ_STREAM_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CAN_READ_STREAM_before<Result>
#include "visitor/dsl/Expression_CAN_READ_STREAM_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CAN_READ_STREAM_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_CAN_READ_STREAM_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CAN_READ_STREAM_after<Result>
#include "visitor/dsl/Expression_CAN_READ_STREAM_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CAN_READ_STREAM_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_ARRAY_SIZE_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ARRAY_SIZE
#include "visitor/dsl/Expression_ARRAY_SIZE_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ARRAY_SIZE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_ARRAY_SIZE_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ARRAY_SIZE_before<Result>
#include "visitor/dsl/Expression_ARRAY_SIZE_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ARRAY_SIZE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_ARRAY_SIZE_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ARRAY_SIZE_after<Result>
#include "visitor/dsl/Expression_ARRAY_SIZE_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ARRAY_SIZE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_ENUM_IS_DEFINED_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ENUM_IS_DEFINED
#include "visitor/dsl/Expression_ENUM_IS_DEFINED_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ENUM_IS_DEFINED"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_ENUM_IS_DEFINED_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ENUM_IS_DEFINED_before<Result>
#include "visitor/dsl/Expression_ENUM_IS_DEFINED_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ENUM_IS_DEFINED_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_ENUM_IS_DEFINED_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ENUM_IS_DEFINED_after<Result>
#include "visitor/dsl/Expression_ENUM_IS_DEFINED_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ENUM_IS_DEFINED_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_IS_ERROR_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IS_ERROR>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IS_ERROR
#include "visitor/dsl/Expression_IS_ERROR_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IS_ERROR"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IS_ERROR>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IS_ERROR>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IS_ERROR>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_IS_ERROR_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IS_ERROR_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IS_ERROR_before<Result>
#include "visitor/dsl/Expression_IS_ERROR_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IS_ERROR_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IS_ERROR_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IS_ERROR_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IS_ERROR_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_IS_ERROR_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IS_ERROR_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IS_ERROR_after<Result>
#include "visitor/dsl/Expression_IS_ERROR_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IS_ERROR_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IS_ERROR_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IS_ERROR_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_IS_ERROR_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_MAX_VALUE_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_MAX_VALUE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_MAX_VALUE
#include "visitor/dsl/Expression_MAX_VALUE_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_MAX_VALUE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_MAX_VALUE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_MAX_VALUE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_MAX_VALUE>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_MAX_VALUE_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_MAX_VALUE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_MAX_VALUE_before<Result>
#include "visitor/dsl/Expression_MAX_VALUE_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_MAX_VALUE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_MAX_VALUE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_MAX_VALUE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_MAX_VALUE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_MAX_VALUE_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_MAX_VALUE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_MAX_VALUE_after<Result>
#include "visitor/dsl/Expression_MAX_VALUE_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_MAX_VALUE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_MAX_VALUE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_MAX_VALUE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_MAX_VALUE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_READ_DATA_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_READ_DATA>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_READ_DATA
#include "visitor/dsl/Expression_READ_DATA_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_READ_DATA"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_READ_DATA>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_READ_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_READ_DATA>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_READ_DATA_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_READ_DATA_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_READ_DATA_before<Result>
#include "visitor/dsl/Expression_READ_DATA_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_READ_DATA_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_READ_DATA_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_READ_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_READ_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_READ_DATA_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_READ_DATA_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_READ_DATA_after<Result>
#include "visitor/dsl/Expression_READ_DATA_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_READ_DATA_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_READ_DATA_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_READ_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_READ_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_WRITE_DATA_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_WRITE_DATA>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_WRITE_DATA
#include "visitor/dsl/Expression_WRITE_DATA_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_WRITE_DATA"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_WRITE_DATA>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_WRITE_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_WRITE_DATA>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_WRITE_DATA_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_WRITE_DATA_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_WRITE_DATA_before<Result>
#include "visitor/dsl/Expression_WRITE_DATA_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_WRITE_DATA_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_WRITE_DATA_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_WRITE_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_WRITE_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_WRITE_DATA_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_WRITE_DATA_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_WRITE_DATA_after<Result>
#include "visitor/dsl/Expression_WRITE_DATA_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_WRITE_DATA_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_WRITE_DATA_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_WRITE_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_WRITE_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_CONDITIONAL_STATEMENT_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CONDITIONAL_STATEMENT
#include "visitor/dsl/Expression_CONDITIONAL_STATEMENT_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CONDITIONAL_STATEMENT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_CONDITIONAL_STATEMENT_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CONDITIONAL_STATEMENT_before<Result>
#include "visitor/dsl/Expression_CONDITIONAL_STATEMENT_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CONDITIONAL_STATEMENT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_CONDITIONAL_STATEMENT_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CONDITIONAL_STATEMENT_after<Result>
#include "visitor/dsl/Expression_CONDITIONAL_STATEMENT_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CONDITIONAL_STATEMENT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_CONDITIONAL_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CONDITIONAL
#include "visitor/dsl/Expression_CONDITIONAL_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CONDITIONAL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_CONDITIONAL_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CONDITIONAL_before<Result>
#include "visitor/dsl/Expression_CONDITIONAL_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CONDITIONAL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_CONDITIONAL_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CONDITIONAL_after<Result>
#include "visitor/dsl/Expression_CONDITIONAL_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CONDITIONAL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_AVAILABLE_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_AVAILABLE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_AVAILABLE
#include "visitor/dsl/Expression_AVAILABLE_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_AVAILABLE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_AVAILABLE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_AVAILABLE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_AVAILABLE>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_AVAILABLE_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_AVAILABLE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_AVAILABLE_before<Result>
#include "visitor/dsl/Expression_AVAILABLE_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_AVAILABLE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_AVAILABLE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_AVAILABLE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_AVAILABLE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_AVAILABLE_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_AVAILABLE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_AVAILABLE_after<Result>
#include "visitor/dsl/Expression_AVAILABLE_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_AVAILABLE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_AVAILABLE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_AVAILABLE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_AVAILABLE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_SIZEOF_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SIZEOF>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SIZEOF
#include "visitor/dsl/Expression_SIZEOF_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SIZEOF"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SIZEOF>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SIZEOF>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SIZEOF>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_SIZEOF_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SIZEOF_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SIZEOF_before<Result>
#include "visitor/dsl/Expression_SIZEOF_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SIZEOF_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SIZEOF_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SIZEOF_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SIZEOF_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_SIZEOF_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SIZEOF_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SIZEOF_after<Result>
#include "visitor/dsl/Expression_SIZEOF_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SIZEOF_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SIZEOF_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SIZEOF_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SIZEOF_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_SUB_RANGE_INIT_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SUB_RANGE_INIT
#include "visitor/dsl/Expression_SUB_RANGE_INIT_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SUB_RANGE_INIT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_SUB_RANGE_INIT_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SUB_RANGE_INIT_before<Result>
#include "visitor/dsl/Expression_SUB_RANGE_INIT_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SUB_RANGE_INIT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_SUB_RANGE_INIT_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SUB_RANGE_INIT_after<Result>
#include "visitor/dsl/Expression_SUB_RANGE_INIT_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SUB_RANGE_INIT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_OR_COND_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_OR_COND>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_OR_COND
#include "visitor/dsl/Expression_OR_COND_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_OR_COND"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_OR_COND>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_OR_COND>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_OR_COND>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_OR_COND_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_OR_COND_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_OR_COND_before<Result>
#include "visitor/dsl/Expression_OR_COND_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_OR_COND_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_OR_COND_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_OR_COND_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_OR_COND_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_OR_COND_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_OR_COND_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_OR_COND_after<Result>
#include "visitor/dsl/Expression_OR_COND_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_OR_COND_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_OR_COND_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_OR_COND_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_OR_COND_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_ADDRESS_OF_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ADDRESS_OF>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ADDRESS_OF
#include "visitor/dsl/Expression_ADDRESS_OF_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ADDRESS_OF"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ADDRESS_OF>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ADDRESS_OF>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ADDRESS_OF>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_ADDRESS_OF_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ADDRESS_OF_before<Result>
#include "visitor/dsl/Expression_ADDRESS_OF_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ADDRESS_OF_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_ADDRESS_OF_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ADDRESS_OF_after<Result>
#include "visitor/dsl/Expression_ADDRESS_OF_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ADDRESS_OF_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_OPTIONAL_OF_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_OPTIONAL_OF
#include "visitor/dsl/Expression_OPTIONAL_OF_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_OPTIONAL_OF"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_OPTIONAL_OF_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_OPTIONAL_OF_before<Result>
#include "visitor/dsl/Expression_OPTIONAL_OF_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_OPTIONAL_OF_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_OPTIONAL_OF_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_OPTIONAL_OF_after<Result>
#include "visitor/dsl/Expression_OPTIONAL_OF_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_OPTIONAL_OF_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_SETTER_STATUS_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SETTER_STATUS>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SETTER_STATUS
#include "visitor/dsl/Expression_SETTER_STATUS_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SETTER_STATUS"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SETTER_STATUS>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SETTER_STATUS>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SETTER_STATUS>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_SETTER_STATUS_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SETTER_STATUS_before<Result>
#include "visitor/dsl/Expression_SETTER_STATUS_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SETTER_STATUS_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_SETTER_STATUS_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SETTER_STATUS_after<Result>
#include "visitor/dsl/Expression_SETTER_STATUS_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SETTER_STATUS_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_SELF_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SELF>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SELF
#include "visitor/dsl/Expression_SELF_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SELF"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SELF>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SELF>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SELF>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_SELF_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SELF_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SELF_before<Result>
#include "visitor/dsl/Expression_SELF_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SELF_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SELF_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SELF_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SELF_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_SELF_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SELF_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SELF_after<Result>
#include "visitor/dsl/Expression_SELF_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SELF_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SELF_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SELF_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_SELF_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_AS_ARG_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_AS_ARG>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_AS_ARG
#include "visitor/dsl/Expression_AS_ARG_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_AS_ARG"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_AS_ARG>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_AS_ARG>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_AS_ARG>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_AS_ARG_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_AS_ARG_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_AS_ARG_before<Result>
#include "visitor/dsl/Expression_AS_ARG_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_AS_ARG_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_AS_ARG_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_AS_ARG_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_AS_ARG_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_AS_ARG_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_AS_ARG_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_AS_ARG_after<Result>
#include "visitor/dsl/Expression_AS_ARG_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_AS_ARG_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_AS_ARG_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_AS_ARG_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_AS_ARG_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_dispatch_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression
#include "visitor/dsl/Expression_dispatch_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_before_dispatch_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_before<Result>
#include "visitor/dsl/Expression_before_dispatch_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_after_dispatch_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_after<Result>
#include "visitor/dsl/Expression_after_dispatch_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expression_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expressions_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expressions>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expressions
#include "visitor/dsl/Expressions_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expressions"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expressions>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expressions>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expressions>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expressions_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expressions_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expressions_before<Result>
#include "visitor/dsl/Expressions_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expressions_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expressions_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expressions_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expressions_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expressions_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expressions_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expressions_after<Result>
#include "visitor/dsl/Expressions_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expressions_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expressions_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expressions_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Expressions_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_INT_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_INT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_INT
#include "visitor/dsl/Type_INT_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_INT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_INT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_INT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_INT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_INT 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_INT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_INT_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_INT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_INT_before<Result>
#include "visitor/dsl/Type_INT_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_INT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_INT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_INT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_INT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_INT_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_INT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_INT_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_INT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_INT_after<Result>
#include "visitor/dsl/Type_INT_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_INT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_INT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_INT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_INT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_INT_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_INT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_UINT_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_UINT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_UINT
#include "visitor/dsl/Type_UINT_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_UINT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_UINT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_UINT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_UINT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_UINT 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_UINT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_UINT_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_UINT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_UINT_before<Result>
#include "visitor/dsl/Type_UINT_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_UINT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_UINT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_UINT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_UINT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_UINT_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_UINT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_UINT_after<Result>
#include "visitor/dsl/Type_UINT_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_UINT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_UINT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_UINT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_UINT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_USIZE_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_USIZE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_USIZE
#include "visitor/dsl/Type_USIZE_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_USIZE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_USIZE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_USIZE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_USIZE>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_USIZE_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_USIZE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_USIZE_before<Result>
#include "visitor/dsl/Type_USIZE_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_USIZE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_USIZE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_USIZE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_USIZE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_USIZE_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_USIZE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_USIZE_after<Result>
#include "visitor/dsl/Type_USIZE_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_USIZE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_USIZE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_USIZE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_USIZE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_FLOAT_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_FLOAT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_FLOAT
#include "visitor/dsl/Type_FLOAT_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_FLOAT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_FLOAT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_FLOAT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_FLOAT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_FLOAT_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_FLOAT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_FLOAT_before<Result>
#include "visitor/dsl/Type_FLOAT_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_FLOAT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_FLOAT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_FLOAT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_FLOAT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_FLOAT_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_FLOAT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_FLOAT_after<Result>
#include "visitor/dsl/Type_FLOAT_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_FLOAT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_FLOAT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_FLOAT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_FLOAT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_STRUCT_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_STRUCT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_STRUCT
#include "visitor/dsl/Type_STRUCT_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_STRUCT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_STRUCT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_STRUCT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_STRUCT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_STRUCT_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_STRUCT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_STRUCT_before<Result>
#include "visitor/dsl/Type_STRUCT_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_STRUCT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_STRUCT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_STRUCT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_STRUCT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_STRUCT_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_STRUCT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_STRUCT_after<Result>
#include "visitor/dsl/Type_STRUCT_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_STRUCT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_STRUCT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_STRUCT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_STRUCT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_RECURSIVE_STRUCT_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_RECURSIVE_STRUCT
#include "visitor/dsl/Type_RECURSIVE_STRUCT_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_RECURSIVE_STRUCT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_RECURSIVE_STRUCT_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_RECURSIVE_STRUCT_before<Result>
#include "visitor/dsl/Type_RECURSIVE_STRUCT_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_RECURSIVE_STRUCT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_RECURSIVE_STRUCT_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_RECURSIVE_STRUCT_after<Result>
#include "visitor/dsl/Type_RECURSIVE_STRUCT_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_RECURSIVE_STRUCT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_BOOL_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_BOOL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_BOOL
#include "visitor/dsl/Type_BOOL_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_BOOL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_BOOL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_BOOL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_BOOL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_BOOL_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_BOOL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_BOOL_before<Result>
#include "visitor/dsl/Type_BOOL_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_BOOL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_BOOL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_BOOL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_BOOL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_BOOL_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_BOOL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_BOOL_after<Result>
#include "visitor/dsl/Type_BOOL_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_BOOL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_BOOL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_BOOL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_BOOL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_VOID_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VOID>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VOID
#include "visitor/dsl/Type_VOID_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VOID"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VOID>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VOID>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VOID)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VOID 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VOID>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_VOID_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VOID_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VOID_before<Result>
#include "visitor/dsl/Type_VOID_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VOID_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VOID_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VOID_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VOID_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_VOID_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VOID_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VOID_after<Result>
#include "visitor/dsl/Type_VOID_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VOID_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VOID_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VOID_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VOID_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_META_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_META>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_META
#include "visitor/dsl/Type_META_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_META"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_META>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_META>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_META)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_META 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_META>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_META_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_META_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_META_before<Result>
#include "visitor/dsl/Type_META_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_META_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_META_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_META_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_META_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_META_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_META_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_META_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_META_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_META_after<Result>
#include "visitor/dsl/Type_META_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_META_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_META_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_META_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_META_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_META_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_META_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_ENUM_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENUM>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENUM
#include "visitor/dsl/Type_ENUM_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENUM"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENUM>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENUM>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENUM>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_ENUM_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENUM_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENUM_before<Result>
#include "visitor/dsl/Type_ENUM_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENUM_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENUM_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENUM_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENUM_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_ENUM_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENUM_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENUM_after<Result>
#include "visitor/dsl/Type_ENUM_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENUM_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENUM_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENUM_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENUM_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_ARRAY_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ARRAY>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ARRAY
#include "visitor/dsl/Type_ARRAY_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ARRAY"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ARRAY>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ARRAY>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ARRAY>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_ARRAY_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ARRAY_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ARRAY_before<Result>
#include "visitor/dsl/Type_ARRAY_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ARRAY_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ARRAY_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ARRAY_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ARRAY_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_ARRAY_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ARRAY_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ARRAY_after<Result>
#include "visitor/dsl/Type_ARRAY_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ARRAY_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ARRAY_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ARRAY_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ARRAY_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_VECTOR_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VECTOR>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VECTOR
#include "visitor/dsl/Type_VECTOR_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VECTOR"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VECTOR>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VECTOR>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VECTOR>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_VECTOR_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VECTOR_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VECTOR_before<Result>
#include "visitor/dsl/Type_VECTOR_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VECTOR_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VECTOR_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VECTOR_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VECTOR_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_VECTOR_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VECTOR_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VECTOR_after<Result>
#include "visitor/dsl/Type_VECTOR_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VECTOR_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VECTOR_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VECTOR_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VECTOR_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_VARIANT_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VARIANT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VARIANT
#include "visitor/dsl/Type_VARIANT_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VARIANT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VARIANT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VARIANT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VARIANT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_VARIANT_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VARIANT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VARIANT_before<Result>
#include "visitor/dsl/Type_VARIANT_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VARIANT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VARIANT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VARIANT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VARIANT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_VARIANT_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VARIANT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VARIANT_after<Result>
#include "visitor/dsl/Type_VARIANT_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VARIANT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VARIANT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VARIANT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_VARIANT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_RANGE_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_RANGE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_RANGE
#include "visitor/dsl/Type_RANGE_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_RANGE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_RANGE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_RANGE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_RANGE>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_RANGE_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_RANGE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_RANGE_before<Result>
#include "visitor/dsl/Type_RANGE_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_RANGE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_RANGE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_RANGE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_RANGE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_RANGE_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_RANGE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_RANGE_after<Result>
#include "visitor/dsl/Type_RANGE_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_RANGE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_RANGE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_RANGE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_RANGE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_ENCODER_RETURN_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENCODER_RETURN>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENCODER_RETURN
#include "visitor/dsl/Type_ENCODER_RETURN_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENCODER_RETURN"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENCODER_RETURN>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENCODER_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENCODER_RETURN>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_ENCODER_RETURN_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENCODER_RETURN_before<Result>
#include "visitor/dsl/Type_ENCODER_RETURN_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENCODER_RETURN_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_ENCODER_RETURN_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENCODER_RETURN_after<Result>
#include "visitor/dsl/Type_ENCODER_RETURN_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENCODER_RETURN_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_DECODER_RETURN_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_DECODER_RETURN>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_DECODER_RETURN
#include "visitor/dsl/Type_DECODER_RETURN_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_DECODER_RETURN"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_DECODER_RETURN>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_DECODER_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_DECODER_RETURN>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_DECODER_RETURN_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_DECODER_RETURN_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_DECODER_RETURN_before<Result>
#include "visitor/dsl/Type_DECODER_RETURN_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_DECODER_RETURN_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_DECODER_RETURN_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_DECODER_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_DECODER_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_DECODER_RETURN_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_DECODER_RETURN_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_DECODER_RETURN_after<Result>
#include "visitor/dsl/Type_DECODER_RETURN_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_DECODER_RETURN_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_DECODER_RETURN_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_DECODER_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_DECODER_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_ENCODER_INPUT_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENCODER_INPUT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENCODER_INPUT
#include "visitor/dsl/Type_ENCODER_INPUT_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENCODER_INPUT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENCODER_INPUT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENCODER_INPUT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENCODER_INPUT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_ENCODER_INPUT_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENCODER_INPUT_before<Result>
#include "visitor/dsl/Type_ENCODER_INPUT_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENCODER_INPUT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_ENCODER_INPUT_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENCODER_INPUT_after<Result>
#include "visitor/dsl/Type_ENCODER_INPUT_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENCODER_INPUT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_DECODER_INPUT_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_DECODER_INPUT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_DECODER_INPUT
#include "visitor/dsl/Type_DECODER_INPUT_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_DECODER_INPUT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_DECODER_INPUT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_DECODER_INPUT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_DECODER_INPUT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_DECODER_INPUT_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_DECODER_INPUT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_DECODER_INPUT_before<Result>
#include "visitor/dsl/Type_DECODER_INPUT_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_DECODER_INPUT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_DECODER_INPUT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_DECODER_INPUT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_DECODER_INPUT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_DECODER_INPUT_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_DECODER_INPUT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_DECODER_INPUT_after<Result>
#include "visitor/dsl/Type_DECODER_INPUT_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_DECODER_INPUT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_DECODER_INPUT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_DECODER_INPUT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_DECODER_INPUT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_PROPERTY_SETTER_RETURN_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_PROPERTY_SETTER_RETURN
#include "visitor/dsl/Type_PROPERTY_SETTER_RETURN_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_PROPERTY_SETTER_RETURN"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_PROPERTY_SETTER_RETURN_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_PROPERTY_SETTER_RETURN_before<Result>
#include "visitor/dsl/Type_PROPERTY_SETTER_RETURN_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_PROPERTY_SETTER_RETURN_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_PROPERTY_SETTER_RETURN_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_PROPERTY_SETTER_RETURN_after<Result>
#include "visitor/dsl/Type_PROPERTY_SETTER_RETURN_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_PROPERTY_SETTER_RETURN_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_OPTIONAL_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_OPTIONAL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_OPTIONAL
#include "visitor/dsl/Type_OPTIONAL_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_OPTIONAL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_OPTIONAL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_OPTIONAL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_OPTIONAL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_OPTIONAL_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_OPTIONAL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_OPTIONAL_before<Result>
#include "visitor/dsl/Type_OPTIONAL_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_OPTIONAL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_OPTIONAL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_OPTIONAL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_OPTIONAL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_OPTIONAL_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_OPTIONAL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_OPTIONAL_after<Result>
#include "visitor/dsl/Type_OPTIONAL_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_OPTIONAL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_OPTIONAL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_OPTIONAL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_OPTIONAL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_PTR_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_PTR>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_PTR
#include "visitor/dsl/Type_PTR_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_PTR"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_PTR>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_PTR>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PTR)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PTR 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_PTR>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_PTR_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_PTR_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_PTR_before<Result>
#include "visitor/dsl/Type_PTR_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_PTR_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_PTR_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_PTR_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_PTR_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_PTR_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_PTR_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_PTR_after<Result>
#include "visitor/dsl/Type_PTR_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_PTR_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_PTR_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_PTR_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_PTR_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_FUNCTION_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_FUNCTION>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_FUNCTION
#include "visitor/dsl/Type_FUNCTION_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_FUNCTION"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_FUNCTION>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_FUNCTION>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_FUNCTION>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_FUNCTION_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_FUNCTION_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_FUNCTION_before<Result>
#include "visitor/dsl/Type_FUNCTION_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_FUNCTION_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_FUNCTION_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_FUNCTION_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_FUNCTION_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_FUNCTION_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_FUNCTION_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_FUNCTION_after<Result>
#include "visitor/dsl/Type_FUNCTION_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_FUNCTION_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_FUNCTION_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_FUNCTION_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_FUNCTION_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_dispatch_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type
#include "visitor/dsl/Type_dispatch_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_before_dispatch_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_before<Result>
#include "visitor/dsl/Type_before_dispatch_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_after_dispatch_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_after<Result>
#include "visitor/dsl/Type_after_dispatch_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Type_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Types_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Types>>
#define CODEGEN_CONTEXT(dummy_name) Context_Types
#include "visitor/dsl/Types_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Types"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Types>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Types>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPES)
#define CODEGEN_EXPECTED_PRIORITY_TYPES 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Types>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Types_before_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Types_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Types_before<Result>
#include "visitor/dsl/Types_before_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Types_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Types_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Types_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPES_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPES_BEFORE 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Types_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Types_after_dsl_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Types_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Types_after<Result>
#include "visitor/dsl/Types_after_dsl_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Types_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Types_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Types_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPES_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPES_AFTER 2
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserDSLHook<ebm2python::VisitorTag_Types_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/entry_dsl.hpp")
// Inlined hook for entry for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_entry>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_entry& ctx) {
        EBM2PYTHON_DECONSTRUCT_ENTRY(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/entry_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_entry>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_ENTRY)
#define CODEGEN_EXPECTED_PRIORITY_ENTRY 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_entry>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/entry_before_dsl.hpp")
// Inlined hook for entry_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_entry_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_entry_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_ENTRY_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/entry_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_entry_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_ENTRY_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_ENTRY_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_entry_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/entry_after_dsl.hpp")
// Inlined hook for entry_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_entry_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_entry_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_ENTRY_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/entry_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_entry_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_ENTRY_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_ENTRY_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_entry_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/pre_visitor_dsl.hpp")
// Inlined hook for pre_visitor for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_pre_visitor>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_pre_visitor& ctx) {
        EBM2PYTHON_DECONSTRUCT_PRE_VISITOR(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/pre_visitor_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_pre_visitor>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR)
#define CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_pre_visitor>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/pre_visitor_before_dsl.hpp")
// Inlined hook for pre_visitor_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_pre_visitor_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_pre_visitor_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_PRE_VISITOR_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/pre_visitor_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_pre_visitor_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_pre_visitor_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/pre_visitor_after_dsl.hpp")
// Inlined hook for pre_visitor_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_pre_visitor_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_pre_visitor_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_PRE_VISITOR_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/pre_visitor_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_pre_visitor_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_pre_visitor_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/post_entry_dsl.hpp")
// Inlined hook for post_entry for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_post_entry>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_post_entry<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_POST_ENTRY(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/post_entry_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_post_entry>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_POST_ENTRY)
#define CODEGEN_EXPECTED_PRIORITY_POST_ENTRY 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_post_entry>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/post_entry_before_dsl.hpp")
// Inlined hook for post_entry_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_post_entry_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_post_entry_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_POST_ENTRY_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/post_entry_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_post_entry_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_post_entry_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/post_entry_after_dsl.hpp")
// Inlined hook for post_entry_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_post_entry_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_post_entry_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_POST_ENTRY_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/post_entry_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_post_entry_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_post_entry_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_BLOCK_dsl.hpp")
// Inlined hook for Statement_BLOCK for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_BLOCK>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_BLOCK& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_BLOCK(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_BLOCK_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_BLOCK>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_BLOCK>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_BLOCK_before_dsl.hpp")
// Inlined hook for Statement_BLOCK_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_BLOCK_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_BLOCK_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_BLOCK_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_BLOCK_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_BLOCK_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_BLOCK_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_BLOCK_after_dsl.hpp")
// Inlined hook for Statement_BLOCK_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_BLOCK_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_BLOCK_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_BLOCK_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_BLOCK_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_BLOCK_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_BLOCK_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ASSIGNMENT_dsl.hpp")
// Inlined hook for Statement_ASSIGNMENT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ASSIGNMENT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ASSIGNMENT& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ASSIGNMENT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_ASSIGNMENT_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ASSIGNMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ASSIGNMENT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ASSIGNMENT_before_dsl.hpp")
// Inlined hook for Statement_ASSIGNMENT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ASSIGNMENT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ASSIGNMENT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_ASSIGNMENT_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ASSIGNMENT_after_dsl.hpp")
// Inlined hook for Statement_ASSIGNMENT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ASSIGNMENT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ASSIGNMENT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_ASSIGNMENT_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_YIELD_dsl.hpp")
// Inlined hook for Statement_YIELD for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_YIELD>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_YIELD& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_YIELD(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_YIELD_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_YIELD>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_YIELD>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_YIELD_before_dsl.hpp")
// Inlined hook for Statement_YIELD_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_YIELD_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_YIELD_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_YIELD_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_YIELD_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_YIELD_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_YIELD_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_YIELD_after_dsl.hpp")
// Inlined hook for Statement_YIELD_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_YIELD_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_YIELD_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_YIELD_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_YIELD_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_YIELD_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_YIELD_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_APPEND_dsl.hpp")
// Inlined hook for Statement_APPEND for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_APPEND>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_APPEND& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_APPEND(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_APPEND_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_APPEND>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_APPEND>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_APPEND_before_dsl.hpp")
// Inlined hook for Statement_APPEND_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_APPEND_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_APPEND_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_APPEND_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_APPEND_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_APPEND_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_APPEND_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_APPEND_after_dsl.hpp")
// Inlined hook for Statement_APPEND_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_APPEND_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_APPEND_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_APPEND_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_APPEND_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_APPEND_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_APPEND_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_RETURN_dsl.hpp")
// Inlined hook for Statement_RETURN for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_RETURN>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_RETURN& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_RETURN(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_RETURN_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_RETURN>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_RETURN_before_dsl.hpp")
// Inlined hook for Statement_RETURN_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_RETURN_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_RETURN_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_RETURN_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_RETURN_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_RETURN_after_dsl.hpp")
// Inlined hook for Statement_RETURN_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_RETURN_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_RETURN_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_RETURN_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_RETURN_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ERROR_RETURN_dsl.hpp")
// Inlined hook for Statement_ERROR_RETURN for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ERROR_RETURN>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ERROR_RETURN& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ERROR_RETURN(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_ERROR_RETURN_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ERROR_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ERROR_RETURN>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ERROR_RETURN_before_dsl.hpp")
// Inlined hook for Statement_ERROR_RETURN_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ERROR_RETURN_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ERROR_RETURN_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_ERROR_RETURN_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ERROR_RETURN_after_dsl.hpp")
// Inlined hook for Statement_ERROR_RETURN_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ERROR_RETURN_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ERROR_RETURN_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_ERROR_RETURN_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ASSERT_dsl.hpp")
// Inlined hook for Statement_ASSERT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ASSERT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ASSERT& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ASSERT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_ASSERT_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ASSERT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ASSERT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ASSERT_before_dsl.hpp")
// Inlined hook for Statement_ASSERT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ASSERT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ASSERT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ASSERT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_ASSERT_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ASSERT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ASSERT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ASSERT_after_dsl.hpp")
// Inlined hook for Statement_ASSERT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ASSERT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ASSERT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ASSERT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_ASSERT_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ASSERT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ASSERT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_READ_DATA_dsl.hpp")
// Inlined hook for Statement_READ_DATA for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_READ_DATA>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_READ_DATA& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_READ_DATA(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_READ_DATA_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_READ_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_READ_DATA>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_READ_DATA_before_dsl.hpp")
// Inlined hook for Statement_READ_DATA_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_READ_DATA_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_READ_DATA_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_READ_DATA_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_READ_DATA_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_READ_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_READ_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_READ_DATA_after_dsl.hpp")
// Inlined hook for Statement_READ_DATA_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_READ_DATA_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_READ_DATA_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_READ_DATA_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_READ_DATA_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_READ_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_READ_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_WRITE_DATA_dsl.hpp")
// Inlined hook for Statement_WRITE_DATA for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_WRITE_DATA>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_WRITE_DATA& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_WRITE_DATA(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_WRITE_DATA_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_WRITE_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_WRITE_DATA>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_WRITE_DATA_before_dsl.hpp")
// Inlined hook for Statement_WRITE_DATA_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_WRITE_DATA_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_WRITE_DATA_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_WRITE_DATA_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_WRITE_DATA_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_WRITE_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_WRITE_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_WRITE_DATA_after_dsl.hpp")
// Inlined hook for Statement_WRITE_DATA_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_WRITE_DATA_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_WRITE_DATA_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_WRITE_DATA_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_WRITE_DATA_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_WRITE_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_WRITE_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_RESERVE_DATA_dsl.hpp")
// Inlined hook for Statement_RESERVE_DATA for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_RESERVE_DATA>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_RESERVE_DATA& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_RESERVE_DATA(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_RESERVE_DATA_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_RESERVE_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_RESERVE_DATA>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_RESERVE_DATA_before_dsl.hpp")
// Inlined hook for Statement_RESERVE_DATA_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_RESERVE_DATA_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_RESERVE_DATA_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_RESERVE_DATA_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_RESERVE_DATA_after_dsl.hpp")
// Inlined hook for Statement_RESERVE_DATA_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_RESERVE_DATA_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_RESERVE_DATA_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_RESERVE_DATA_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_IF_STATEMENT_dsl.hpp")
// Inlined hook for Statement_IF_STATEMENT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_IF_STATEMENT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_IF_STATEMENT& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_IF_STATEMENT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_IF_STATEMENT_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_IF_STATEMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_IF_STATEMENT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_IF_STATEMENT_before_dsl.hpp")
// Inlined hook for Statement_IF_STATEMENT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_IF_STATEMENT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_IF_STATEMENT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_IF_STATEMENT_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_IF_STATEMENT_after_dsl.hpp")
// Inlined hook for Statement_IF_STATEMENT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_IF_STATEMENT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_IF_STATEMENT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_IF_STATEMENT_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_LOOP_STATEMENT_dsl.hpp")
// Inlined hook for Statement_LOOP_STATEMENT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_LOOP_STATEMENT& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_LOOP_STATEMENT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_LOOP_STATEMENT_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_LOOP_STATEMENT_before_dsl.hpp")
// Inlined hook for Statement_LOOP_STATEMENT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_LOOP_STATEMENT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_LOOP_STATEMENT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_LOOP_STATEMENT_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_LOOP_STATEMENT_after_dsl.hpp")
// Inlined hook for Statement_LOOP_STATEMENT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_LOOP_STATEMENT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_LOOP_STATEMENT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_LOOP_STATEMENT_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_MATCH_STATEMENT_dsl.hpp")
// Inlined hook for Statement_MATCH_STATEMENT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_MATCH_STATEMENT& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_MATCH_STATEMENT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_MATCH_STATEMENT_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_MATCH_STATEMENT_before_dsl.hpp")
// Inlined hook for Statement_MATCH_STATEMENT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_MATCH_STATEMENT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_MATCH_STATEMENT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_MATCH_STATEMENT_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_MATCH_STATEMENT_after_dsl.hpp")
// Inlined hook for Statement_MATCH_STATEMENT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_MATCH_STATEMENT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_MATCH_STATEMENT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_MATCH_STATEMENT_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_MATCH_BRANCH_dsl.hpp")
// Inlined hook for Statement_MATCH_BRANCH for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_MATCH_BRANCH& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_MATCH_BRANCH(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_MATCH_BRANCH_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_MATCH_BRANCH_before_dsl.hpp")
// Inlined hook for Statement_MATCH_BRANCH_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_MATCH_BRANCH_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_MATCH_BRANCH_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_MATCH_BRANCH_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_MATCH_BRANCH_after_dsl.hpp")
// Inlined hook for Statement_MATCH_BRANCH_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_MATCH_BRANCH_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_MATCH_BRANCH_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_MATCH_BRANCH_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_BREAK_dsl.hpp")
// Inlined hook for Statement_BREAK for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_BREAK>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_BREAK& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_BREAK(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_BREAK_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_BREAK>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_BREAK>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_BREAK_before_dsl.hpp")
// Inlined hook for Statement_BREAK_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_BREAK_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_BREAK_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_BREAK_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_BREAK_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_BREAK_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_BREAK_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_BREAK_after_dsl.hpp")
// Inlined hook for Statement_BREAK_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_BREAK_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_BREAK_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_BREAK_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_BREAK_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_BREAK_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_BREAK_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_CONTINUE_dsl.hpp")
// Inlined hook for Statement_CONTINUE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_CONTINUE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_CONTINUE& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_CONTINUE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_CONTINUE_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_CONTINUE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_CONTINUE>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_CONTINUE_before_dsl.hpp")
// Inlined hook for Statement_CONTINUE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_CONTINUE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_CONTINUE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_CONTINUE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_CONTINUE_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_CONTINUE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_CONTINUE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_CONTINUE_after_dsl.hpp")
// Inlined hook for Statement_CONTINUE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_CONTINUE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_CONTINUE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_CONTINUE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_CONTINUE_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_CONTINUE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_CONTINUE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_FUNCTION_DECL_dsl.hpp")
// Inlined hook for Statement_FUNCTION_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_FUNCTION_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_FUNCTION_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_FUNCTION_DECL_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_FUNCTION_DECL_before_dsl.hpp")
// Inlined hook for Statement_FUNCTION_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_FUNCTION_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_FUNCTION_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_FUNCTION_DECL_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_FUNCTION_DECL_after_dsl.hpp")
// Inlined hook for Statement_FUNCTION_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_FUNCTION_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_FUNCTION_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_FUNCTION_DECL_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_VARIABLE_DECL_dsl.hpp")
// Inlined hook for Statement_VARIABLE_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_VARIABLE_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_VARIABLE_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_VARIABLE_DECL_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_VARIABLE_DECL_before_dsl.hpp")
// Inlined hook for Statement_VARIABLE_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_VARIABLE_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_VARIABLE_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_VARIABLE_DECL_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_VARIABLE_DECL_after_dsl.hpp")
// Inlined hook for Statement_VARIABLE_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_VARIABLE_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_VARIABLE_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_VARIABLE_DECL_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_PARAMETER_DECL_dsl.hpp")
// Inlined hook for Statement_PARAMETER_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PARAMETER_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PARAMETER_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_PARAMETER_DECL_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_PARAMETER_DECL_before_dsl.hpp")
// Inlined hook for Statement_PARAMETER_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PARAMETER_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PARAMETER_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_PARAMETER_DECL_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_PARAMETER_DECL_after_dsl.hpp")
// Inlined hook for Statement_PARAMETER_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PARAMETER_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PARAMETER_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_PARAMETER_DECL_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_FIELD_DECL_dsl.hpp")
// Inlined hook for Statement_FIELD_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_FIELD_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_FIELD_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_FIELD_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_FIELD_DECL_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_FIELD_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_FIELD_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_FIELD_DECL_before_dsl.hpp")
// Inlined hook for Statement_FIELD_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_FIELD_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_FIELD_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_FIELD_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_FIELD_DECL_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_FIELD_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_FIELD_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_FIELD_DECL_after_dsl.hpp")
// Inlined hook for Statement_FIELD_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_FIELD_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_FIELD_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_FIELD_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_FIELD_DECL_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_FIELD_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_FIELD_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_COMPOSITE_FIELD_DECL_dsl.hpp")
// Inlined hook for Statement_COMPOSITE_FIELD_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_COMPOSITE_FIELD_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_COMPOSITE_FIELD_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_COMPOSITE_FIELD_DECL_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_COMPOSITE_FIELD_DECL_before_dsl.hpp")
// Inlined hook for Statement_COMPOSITE_FIELD_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_COMPOSITE_FIELD_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_COMPOSITE_FIELD_DECL_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_COMPOSITE_FIELD_DECL_after_dsl.hpp")
// Inlined hook for Statement_COMPOSITE_FIELD_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_COMPOSITE_FIELD_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_COMPOSITE_FIELD_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_COMPOSITE_FIELD_DECL_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ENUM_DECL_dsl.hpp")
// Inlined hook for Statement_ENUM_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENUM_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENUM_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENUM_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_ENUM_DECL_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENUM_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENUM_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ENUM_DECL_before_dsl.hpp")
// Inlined hook for Statement_ENUM_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENUM_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENUM_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENUM_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_ENUM_DECL_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENUM_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENUM_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ENUM_DECL_after_dsl.hpp")
// Inlined hook for Statement_ENUM_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENUM_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENUM_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENUM_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_ENUM_DECL_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENUM_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENUM_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ENUM_MEMBER_DECL_dsl.hpp")
// Inlined hook for Statement_ENUM_MEMBER_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENUM_MEMBER_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENUM_MEMBER_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_ENUM_MEMBER_DECL_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ENUM_MEMBER_DECL_before_dsl.hpp")
// Inlined hook for Statement_ENUM_MEMBER_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENUM_MEMBER_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENUM_MEMBER_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_ENUM_MEMBER_DECL_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ENUM_MEMBER_DECL_after_dsl.hpp")
// Inlined hook for Statement_ENUM_MEMBER_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENUM_MEMBER_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENUM_MEMBER_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_ENUM_MEMBER_DECL_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_STRUCT_DECL_dsl.hpp")
// Inlined hook for Statement_STRUCT_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_STRUCT_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_STRUCT_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_STRUCT_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_STRUCT_DECL_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_STRUCT_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_STRUCT_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_STRUCT_DECL_before_dsl.hpp")
// Inlined hook for Statement_STRUCT_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_STRUCT_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_STRUCT_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_STRUCT_DECL_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_STRUCT_DECL_after_dsl.hpp")
// Inlined hook for Statement_STRUCT_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_STRUCT_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_STRUCT_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_STRUCT_DECL_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_UNION_DECL_dsl.hpp")
// Inlined hook for Statement_UNION_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_UNION_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_UNION_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_UNION_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_UNION_DECL_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_UNION_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_UNION_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_UNION_DECL_before_dsl.hpp")
// Inlined hook for Statement_UNION_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_UNION_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_UNION_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_UNION_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_UNION_DECL_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_UNION_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_UNION_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_UNION_DECL_after_dsl.hpp")
// Inlined hook for Statement_UNION_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_UNION_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_UNION_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_UNION_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_UNION_DECL_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_UNION_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_UNION_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_UNION_MEMBER_DECL_dsl.hpp")
// Inlined hook for Statement_UNION_MEMBER_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_UNION_MEMBER_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_UNION_MEMBER_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_UNION_MEMBER_DECL_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_UNION_MEMBER_DECL_before_dsl.hpp")
// Inlined hook for Statement_UNION_MEMBER_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_UNION_MEMBER_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_UNION_MEMBER_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_UNION_MEMBER_DECL_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_UNION_MEMBER_DECL_after_dsl.hpp")
// Inlined hook for Statement_UNION_MEMBER_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_UNION_MEMBER_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_UNION_MEMBER_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_UNION_MEMBER_DECL_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_PROGRAM_DECL_dsl.hpp")
// Inlined hook for Statement_PROGRAM_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROGRAM_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROGRAM_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_PROGRAM_DECL_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_PROGRAM_DECL_before_dsl.hpp")
// Inlined hook for Statement_PROGRAM_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROGRAM_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROGRAM_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_PROGRAM_DECL_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_PROGRAM_DECL_after_dsl.hpp")
// Inlined hook for Statement_PROGRAM_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROGRAM_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROGRAM_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_PROGRAM_DECL_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_PROPERTY_DECL_dsl.hpp")
// Inlined hook for Statement_PROPERTY_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROPERTY_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROPERTY_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_PROPERTY_DECL_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_PROPERTY_DECL_before_dsl.hpp")
// Inlined hook for Statement_PROPERTY_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROPERTY_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROPERTY_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_PROPERTY_DECL_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_PROPERTY_DECL_after_dsl.hpp")
// Inlined hook for Statement_PROPERTY_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROPERTY_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROPERTY_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_PROPERTY_DECL_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_PROPERTY_MEMBER_DECL_dsl.hpp")
// Inlined hook for Statement_PROPERTY_MEMBER_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROPERTY_MEMBER_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROPERTY_MEMBER_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_PROPERTY_MEMBER_DECL_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_PROPERTY_MEMBER_DECL_before_dsl.hpp")
// Inlined hook for Statement_PROPERTY_MEMBER_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROPERTY_MEMBER_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_PROPERTY_MEMBER_DECL_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_PROPERTY_MEMBER_DECL_after_dsl.hpp")
// Inlined hook for Statement_PROPERTY_MEMBER_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROPERTY_MEMBER_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROPERTY_MEMBER_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_PROPERTY_MEMBER_DECL_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_METADATA_dsl.hpp")
// Inlined hook for Statement_METADATA for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_METADATA>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_METADATA& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_METADATA(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_METADATA_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_METADATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_METADATA>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_METADATA_before_dsl.hpp")
// Inlined hook for Statement_METADATA_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_METADATA_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_METADATA_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_METADATA_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_METADATA_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_METADATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_METADATA_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_METADATA_after_dsl.hpp")
// Inlined hook for Statement_METADATA_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_METADATA_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_METADATA_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_METADATA_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_METADATA_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_METADATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_METADATA_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_IMPORT_MODULE_dsl.hpp")
// Inlined hook for Statement_IMPORT_MODULE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_IMPORT_MODULE& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_IMPORT_MODULE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_IMPORT_MODULE_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_IMPORT_MODULE_before_dsl.hpp")
// Inlined hook for Statement_IMPORT_MODULE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_IMPORT_MODULE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_IMPORT_MODULE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_IMPORT_MODULE_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_IMPORT_MODULE_after_dsl.hpp")
// Inlined hook for Statement_IMPORT_MODULE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_IMPORT_MODULE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_IMPORT_MODULE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_IMPORT_MODULE_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_EXPRESSION_dsl.hpp")
// Inlined hook for Statement_EXPRESSION for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_EXPRESSION>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_EXPRESSION& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_EXPRESSION(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_EXPRESSION_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_EXPRESSION>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_EXPRESSION>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_EXPRESSION_before_dsl.hpp")
// Inlined hook for Statement_EXPRESSION_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_EXPRESSION_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_EXPRESSION_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_EXPRESSION_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_EXPRESSION_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_EXPRESSION_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_EXPRESSION_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_EXPRESSION_after_dsl.hpp")
// Inlined hook for Statement_EXPRESSION_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_EXPRESSION_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_EXPRESSION_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_EXPRESSION_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_EXPRESSION_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_EXPRESSION_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_EXPRESSION_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ERROR_REPORT_dsl.hpp")
// Inlined hook for Statement_ERROR_REPORT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ERROR_REPORT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ERROR_REPORT& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ERROR_REPORT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_ERROR_REPORT_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ERROR_REPORT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ERROR_REPORT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ERROR_REPORT_before_dsl.hpp")
// Inlined hook for Statement_ERROR_REPORT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ERROR_REPORT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ERROR_REPORT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_ERROR_REPORT_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ERROR_REPORT_after_dsl.hpp")
// Inlined hook for Statement_ERROR_REPORT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ERROR_REPORT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ERROR_REPORT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_ERROR_REPORT_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_LOWERED_IO_STATEMENTS_dsl.hpp")
// Inlined hook for Statement_LOWERED_IO_STATEMENTS for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_LOWERED_IO_STATEMENTS& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_LOWERED_IO_STATEMENTS(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_LOWERED_IO_STATEMENTS_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_LOWERED_IO_STATEMENTS_before_dsl.hpp")
// Inlined hook for Statement_LOWERED_IO_STATEMENTS_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_LOWERED_IO_STATEMENTS_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_LOWERED_IO_STATEMENTS_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_LOWERED_IO_STATEMENTS_after_dsl.hpp")
// Inlined hook for Statement_LOWERED_IO_STATEMENTS_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_LOWERED_IO_STATEMENTS_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_LOWERED_IO_STATEMENTS_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_LOWERED_IO_STATEMENTS_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_SUB_BYTE_RANGE_dsl.hpp")
// Inlined hook for Statement_SUB_BYTE_RANGE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_SUB_BYTE_RANGE& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_SUB_BYTE_RANGE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_SUB_BYTE_RANGE_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_SUB_BYTE_RANGE_before_dsl.hpp")
// Inlined hook for Statement_SUB_BYTE_RANGE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_SUB_BYTE_RANGE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_SUB_BYTE_RANGE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_SUB_BYTE_RANGE_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_SUB_BYTE_RANGE_after_dsl.hpp")
// Inlined hook for Statement_SUB_BYTE_RANGE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_SUB_BYTE_RANGE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_SUB_BYTE_RANGE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_SUB_BYTE_RANGE_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_INIT_CHECK_dsl.hpp")
// Inlined hook for Statement_INIT_CHECK for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_INIT_CHECK>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_INIT_CHECK& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_INIT_CHECK(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_INIT_CHECK_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_INIT_CHECK>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_INIT_CHECK>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_INIT_CHECK_before_dsl.hpp")
// Inlined hook for Statement_INIT_CHECK_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_INIT_CHECK_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_INIT_CHECK_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_INIT_CHECK_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_INIT_CHECK_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_INIT_CHECK_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_INIT_CHECK_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_INIT_CHECK_after_dsl.hpp")
// Inlined hook for Statement_INIT_CHECK_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_INIT_CHECK_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_INIT_CHECK_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_INIT_CHECK_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_INIT_CHECK_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_INIT_CHECK_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_INIT_CHECK_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ENDIAN_VARIABLE_dsl.hpp")
// Inlined hook for Statement_ENDIAN_VARIABLE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENDIAN_VARIABLE& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENDIAN_VARIABLE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_ENDIAN_VARIABLE_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ENDIAN_VARIABLE_before_dsl.hpp")
// Inlined hook for Statement_ENDIAN_VARIABLE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENDIAN_VARIABLE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENDIAN_VARIABLE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_ENDIAN_VARIABLE_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_ENDIAN_VARIABLE_after_dsl.hpp")
// Inlined hook for Statement_ENDIAN_VARIABLE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENDIAN_VARIABLE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENDIAN_VARIABLE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_ENDIAN_VARIABLE_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_dispatch_dsl.hpp")
// Inlined hook for Statement for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_dispatch_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_before_dispatch_dsl.hpp")
// Inlined hook for Statement_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_before_dispatch_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Statement_after_dispatch_dsl.hpp")
// Inlined hook for Statement_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Statement_after_dispatch_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Statement_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Block_dsl.hpp")
// Inlined hook for Block for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Block>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Block& ctx) {
        EBM2PYTHON_DECONSTRUCT_BLOCK(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Block_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Block>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_BLOCK)
#define CODEGEN_EXPECTED_PRIORITY_BLOCK 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Block>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Block_before_dsl.hpp")
// Inlined hook for Block_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Block_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Block_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_BLOCK_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Block_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Block_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_BLOCK_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_BLOCK_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Block_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Block_after_dsl.hpp")
// Inlined hook for Block_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Block_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Block_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_BLOCK_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Block_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Block_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_BLOCK_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_BLOCK_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Block_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_INT_dsl.hpp")
// Inlined hook for Expression_LITERAL_INT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_INT& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_INT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_LITERAL_INT_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_INT_before_dsl.hpp")
// Inlined hook for Expression_LITERAL_INT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_INT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_INT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_LITERAL_INT_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_INT_after_dsl.hpp")
// Inlined hook for Expression_LITERAL_INT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_INT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_INT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_LITERAL_INT_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_INT64_dsl.hpp")
// Inlined hook for Expression_LITERAL_INT64 for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT64>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_INT64& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_INT64(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_LITERAL_INT64_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT64>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT64>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_INT64_before_dsl.hpp")
// Inlined hook for Expression_LITERAL_INT64_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_INT64_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_INT64_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_LITERAL_INT64_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_INT64_after_dsl.hpp")
// Inlined hook for Expression_LITERAL_INT64_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_INT64_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_INT64_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_LITERAL_INT64_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_BOOL_dsl.hpp")
// Inlined hook for Expression_LITERAL_BOOL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_BOOL& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_BOOL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_LITERAL_BOOL_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_BOOL_before_dsl.hpp")
// Inlined hook for Expression_LITERAL_BOOL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_BOOL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_BOOL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_LITERAL_BOOL_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_BOOL_after_dsl.hpp")
// Inlined hook for Expression_LITERAL_BOOL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_BOOL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_BOOL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_LITERAL_BOOL_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_STRING_dsl.hpp")
// Inlined hook for Expression_LITERAL_STRING for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_STRING>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_STRING& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_STRING(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_LITERAL_STRING_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_STRING>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_STRING>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_STRING_before_dsl.hpp")
// Inlined hook for Expression_LITERAL_STRING_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_STRING_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_STRING_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_LITERAL_STRING_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_STRING_after_dsl.hpp")
// Inlined hook for Expression_LITERAL_STRING_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_STRING_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_STRING_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_LITERAL_STRING_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_TYPE_dsl.hpp")
// Inlined hook for Expression_LITERAL_TYPE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_TYPE& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_TYPE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_LITERAL_TYPE_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_TYPE_before_dsl.hpp")
// Inlined hook for Expression_LITERAL_TYPE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_TYPE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_TYPE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_LITERAL_TYPE_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_TYPE_after_dsl.hpp")
// Inlined hook for Expression_LITERAL_TYPE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_TYPE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_TYPE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_LITERAL_TYPE_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_CHAR_dsl.hpp")
// Inlined hook for Expression_LITERAL_CHAR for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_CHAR& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_CHAR(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_LITERAL_CHAR_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_CHAR_before_dsl.hpp")
// Inlined hook for Expression_LITERAL_CHAR_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_CHAR_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_CHAR_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_LITERAL_CHAR_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_LITERAL_CHAR_after_dsl.hpp")
// Inlined hook for Expression_LITERAL_CHAR_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_CHAR_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_CHAR_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_LITERAL_CHAR_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_IDENTIFIER_dsl.hpp")
// Inlined hook for Expression_IDENTIFIER for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IDENTIFIER>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IDENTIFIER& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IDENTIFIER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_IDENTIFIER_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IDENTIFIER>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IDENTIFIER>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_IDENTIFIER_before_dsl.hpp")
// Inlined hook for Expression_IDENTIFIER_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IDENTIFIER_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IDENTIFIER_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IDENTIFIER_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_IDENTIFIER_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IDENTIFIER_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IDENTIFIER_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_IDENTIFIER_after_dsl.hpp")
// Inlined hook for Expression_IDENTIFIER_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IDENTIFIER_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IDENTIFIER_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IDENTIFIER_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_IDENTIFIER_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IDENTIFIER_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IDENTIFIER_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_BINARY_OP_dsl.hpp")
// Inlined hook for Expression_BINARY_OP for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_BINARY_OP>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_BINARY_OP& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_BINARY_OP(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_BINARY_OP_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_BINARY_OP>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_BINARY_OP>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_BINARY_OP_before_dsl.hpp")
// Inlined hook for Expression_BINARY_OP_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_BINARY_OP_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_BINARY_OP_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_BINARY_OP_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_BINARY_OP_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_BINARY_OP_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_BINARY_OP_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_BINARY_OP_after_dsl.hpp")
// Inlined hook for Expression_BINARY_OP_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_BINARY_OP_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_BINARY_OP_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_BINARY_OP_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_BINARY_OP_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_BINARY_OP_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_BINARY_OP_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_UNARY_OP_dsl.hpp")
// Inlined hook for Expression_UNARY_OP for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_UNARY_OP>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_UNARY_OP& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_UNARY_OP(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_UNARY_OP_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_UNARY_OP>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_UNARY_OP>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_UNARY_OP_before_dsl.hpp")
// Inlined hook for Expression_UNARY_OP_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_UNARY_OP_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_UNARY_OP_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_UNARY_OP_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_UNARY_OP_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_UNARY_OP_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_UNARY_OP_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_UNARY_OP_after_dsl.hpp")
// Inlined hook for Expression_UNARY_OP_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_UNARY_OP_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_UNARY_OP_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_UNARY_OP_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_UNARY_OP_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_UNARY_OP_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_UNARY_OP_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_CALL_dsl.hpp")
// Inlined hook for Expression_CALL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CALL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CALL& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CALL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_CALL_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CALL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CALL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_CALL_before_dsl.hpp")
// Inlined hook for Expression_CALL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CALL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CALL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CALL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_CALL_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CALL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CALL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_CALL_after_dsl.hpp")
// Inlined hook for Expression_CALL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CALL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CALL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CALL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_CALL_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CALL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CALL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_INDEX_ACCESS_dsl.hpp")
// Inlined hook for Expression_INDEX_ACCESS for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_INDEX_ACCESS& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_INDEX_ACCESS(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_INDEX_ACCESS_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_INDEX_ACCESS_before_dsl.hpp")
// Inlined hook for Expression_INDEX_ACCESS_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_INDEX_ACCESS_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_INDEX_ACCESS_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_INDEX_ACCESS_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_INDEX_ACCESS_after_dsl.hpp")
// Inlined hook for Expression_INDEX_ACCESS_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_INDEX_ACCESS_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_INDEX_ACCESS_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_INDEX_ACCESS_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_MEMBER_ACCESS_dsl.hpp")
// Inlined hook for Expression_MEMBER_ACCESS for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_MEMBER_ACCESS& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_MEMBER_ACCESS(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_MEMBER_ACCESS_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_MEMBER_ACCESS_before_dsl.hpp")
// Inlined hook for Expression_MEMBER_ACCESS_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_MEMBER_ACCESS_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_MEMBER_ACCESS_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_MEMBER_ACCESS_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_MEMBER_ACCESS_after_dsl.hpp")
// Inlined hook for Expression_MEMBER_ACCESS_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_MEMBER_ACCESS_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_MEMBER_ACCESS_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_MEMBER_ACCESS_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_ENUM_MEMBER_dsl.hpp")
// Inlined hook for Expression_ENUM_MEMBER for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ENUM_MEMBER& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ENUM_MEMBER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_ENUM_MEMBER_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_ENUM_MEMBER_before_dsl.hpp")
// Inlined hook for Expression_ENUM_MEMBER_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ENUM_MEMBER_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ENUM_MEMBER_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_ENUM_MEMBER_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_ENUM_MEMBER_after_dsl.hpp")
// Inlined hook for Expression_ENUM_MEMBER_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ENUM_MEMBER_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ENUM_MEMBER_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_ENUM_MEMBER_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_TYPE_CAST_dsl.hpp")
// Inlined hook for Expression_TYPE_CAST for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_TYPE_CAST>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_TYPE_CAST& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_TYPE_CAST(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_TYPE_CAST_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_TYPE_CAST>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_TYPE_CAST>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_TYPE_CAST_before_dsl.hpp")
// Inlined hook for Expression_TYPE_CAST_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_TYPE_CAST_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_TYPE_CAST_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_TYPE_CAST_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_TYPE_CAST_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_TYPE_CAST_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_TYPE_CAST_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_TYPE_CAST_after_dsl.hpp")
// Inlined hook for Expression_TYPE_CAST_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_TYPE_CAST_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_TYPE_CAST_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_TYPE_CAST_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_TYPE_CAST_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_TYPE_CAST_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_TYPE_CAST_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_RANGE_dsl.hpp")
// Inlined hook for Expression_RANGE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_RANGE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_RANGE& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_RANGE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_RANGE_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_RANGE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_RANGE>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_RANGE_before_dsl.hpp")
// Inlined hook for Expression_RANGE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_RANGE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_RANGE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_RANGE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_RANGE_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_RANGE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_RANGE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_RANGE_after_dsl.hpp")
// Inlined hook for Expression_RANGE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_RANGE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_RANGE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_RANGE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_RANGE_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_RANGE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_RANGE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_DEFAULT_VALUE_dsl.hpp")
// Inlined hook for Expression_DEFAULT_VALUE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_DEFAULT_VALUE& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_DEFAULT_VALUE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_DEFAULT_VALUE_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_DEFAULT_VALUE_before_dsl.hpp")
// Inlined hook for Expression_DEFAULT_VALUE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_DEFAULT_VALUE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_DEFAULT_VALUE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_DEFAULT_VALUE_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_DEFAULT_VALUE_after_dsl.hpp")
// Inlined hook for Expression_DEFAULT_VALUE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_DEFAULT_VALUE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_DEFAULT_VALUE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_DEFAULT_VALUE_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_IS_LITTLE_ENDIAN_dsl.hpp")
// Inlined hook for Expression_IS_LITTLE_ENDIAN for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IS_LITTLE_ENDIAN& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IS_LITTLE_ENDIAN(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_IS_LITTLE_ENDIAN_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_IS_LITTLE_ENDIAN_before_dsl.hpp")
// Inlined hook for Expression_IS_LITTLE_ENDIAN_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IS_LITTLE_ENDIAN_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_IS_LITTLE_ENDIAN_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_IS_LITTLE_ENDIAN_after_dsl.hpp")
// Inlined hook for Expression_IS_LITTLE_ENDIAN_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IS_LITTLE_ENDIAN_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IS_LITTLE_ENDIAN_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_IS_LITTLE_ENDIAN_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_GET_STREAM_OFFSET_dsl.hpp")
// Inlined hook for Expression_GET_STREAM_OFFSET for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_GET_STREAM_OFFSET& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_GET_STREAM_OFFSET(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_GET_STREAM_OFFSET_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_GET_STREAM_OFFSET_before_dsl.hpp")
// Inlined hook for Expression_GET_STREAM_OFFSET_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_GET_STREAM_OFFSET_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_GET_STREAM_OFFSET_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_GET_STREAM_OFFSET_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_GET_STREAM_OFFSET_after_dsl.hpp")
// Inlined hook for Expression_GET_STREAM_OFFSET_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_GET_STREAM_OFFSET_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_GET_STREAM_OFFSET_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_GET_STREAM_OFFSET_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_GET_REMAINING_BYTES_dsl.hpp")
// Inlined hook for Expression_GET_REMAINING_BYTES for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_GET_REMAINING_BYTES& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_GET_REMAINING_BYTES(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_GET_REMAINING_BYTES_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_GET_REMAINING_BYTES_before_dsl.hpp")
// Inlined hook for Expression_GET_REMAINING_BYTES_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_GET_REMAINING_BYTES_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_GET_REMAINING_BYTES_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_GET_REMAINING_BYTES_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_GET_REMAINING_BYTES_after_dsl.hpp")
// Inlined hook for Expression_GET_REMAINING_BYTES_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_GET_REMAINING_BYTES_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_GET_REMAINING_BYTES_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_GET_REMAINING_BYTES_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_CAN_READ_STREAM_dsl.hpp")
// Inlined hook for Expression_CAN_READ_STREAM for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CAN_READ_STREAM& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CAN_READ_STREAM(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_CAN_READ_STREAM_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_CAN_READ_STREAM_before_dsl.hpp")
// Inlined hook for Expression_CAN_READ_STREAM_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CAN_READ_STREAM_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CAN_READ_STREAM_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_CAN_READ_STREAM_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_CAN_READ_STREAM_after_dsl.hpp")
// Inlined hook for Expression_CAN_READ_STREAM_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CAN_READ_STREAM_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CAN_READ_STREAM_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_CAN_READ_STREAM_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_ARRAY_SIZE_dsl.hpp")
// Inlined hook for Expression_ARRAY_SIZE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ARRAY_SIZE& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ARRAY_SIZE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_ARRAY_SIZE_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_ARRAY_SIZE_before_dsl.hpp")
// Inlined hook for Expression_ARRAY_SIZE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ARRAY_SIZE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ARRAY_SIZE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_ARRAY_SIZE_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_ARRAY_SIZE_after_dsl.hpp")
// Inlined hook for Expression_ARRAY_SIZE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ARRAY_SIZE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ARRAY_SIZE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_ARRAY_SIZE_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_ENUM_IS_DEFINED_dsl.hpp")
// Inlined hook for Expression_ENUM_IS_DEFINED for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ENUM_IS_DEFINED& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ENUM_IS_DEFINED(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_ENUM_IS_DEFINED_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_ENUM_IS_DEFINED_before_dsl.hpp")
// Inlined hook for Expression_ENUM_IS_DEFINED_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ENUM_IS_DEFINED_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ENUM_IS_DEFINED_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_ENUM_IS_DEFINED_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_ENUM_IS_DEFINED_after_dsl.hpp")
// Inlined hook for Expression_ENUM_IS_DEFINED_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ENUM_IS_DEFINED_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ENUM_IS_DEFINED_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_ENUM_IS_DEFINED_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_IS_ERROR_dsl.hpp")
// Inlined hook for Expression_IS_ERROR for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IS_ERROR>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IS_ERROR& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IS_ERROR(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_IS_ERROR_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IS_ERROR>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IS_ERROR>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_IS_ERROR_before_dsl.hpp")
// Inlined hook for Expression_IS_ERROR_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IS_ERROR_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IS_ERROR_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IS_ERROR_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_IS_ERROR_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IS_ERROR_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IS_ERROR_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_IS_ERROR_after_dsl.hpp")
// Inlined hook for Expression_IS_ERROR_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IS_ERROR_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IS_ERROR_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IS_ERROR_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_IS_ERROR_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IS_ERROR_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_IS_ERROR_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_MAX_VALUE_dsl.hpp")
// Inlined hook for Expression_MAX_VALUE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_MAX_VALUE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_MAX_VALUE& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_MAX_VALUE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_MAX_VALUE_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_MAX_VALUE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_MAX_VALUE>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_MAX_VALUE_before_dsl.hpp")
// Inlined hook for Expression_MAX_VALUE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_MAX_VALUE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_MAX_VALUE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_MAX_VALUE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_MAX_VALUE_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_MAX_VALUE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_MAX_VALUE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_MAX_VALUE_after_dsl.hpp")
// Inlined hook for Expression_MAX_VALUE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_MAX_VALUE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_MAX_VALUE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_MAX_VALUE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_MAX_VALUE_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_MAX_VALUE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_MAX_VALUE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_READ_DATA_dsl.hpp")
// Inlined hook for Expression_READ_DATA for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_READ_DATA>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_READ_DATA& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_READ_DATA(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_READ_DATA_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_READ_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_READ_DATA>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_READ_DATA_before_dsl.hpp")
// Inlined hook for Expression_READ_DATA_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_READ_DATA_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_READ_DATA_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_READ_DATA_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_READ_DATA_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_READ_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_READ_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_READ_DATA_after_dsl.hpp")
// Inlined hook for Expression_READ_DATA_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_READ_DATA_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_READ_DATA_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_READ_DATA_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_READ_DATA_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_READ_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_READ_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_WRITE_DATA_dsl.hpp")
// Inlined hook for Expression_WRITE_DATA for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_WRITE_DATA>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_WRITE_DATA& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_WRITE_DATA(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_WRITE_DATA_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_WRITE_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_WRITE_DATA>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_WRITE_DATA_before_dsl.hpp")
// Inlined hook for Expression_WRITE_DATA_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_WRITE_DATA_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_WRITE_DATA_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_WRITE_DATA_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_WRITE_DATA_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_WRITE_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_WRITE_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_WRITE_DATA_after_dsl.hpp")
// Inlined hook for Expression_WRITE_DATA_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_WRITE_DATA_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_WRITE_DATA_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_WRITE_DATA_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_WRITE_DATA_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_WRITE_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_WRITE_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_CONDITIONAL_STATEMENT_dsl.hpp")
// Inlined hook for Expression_CONDITIONAL_STATEMENT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CONDITIONAL_STATEMENT& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CONDITIONAL_STATEMENT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_CONDITIONAL_STATEMENT_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_CONDITIONAL_STATEMENT_before_dsl.hpp")
// Inlined hook for Expression_CONDITIONAL_STATEMENT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CONDITIONAL_STATEMENT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_CONDITIONAL_STATEMENT_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_CONDITIONAL_STATEMENT_after_dsl.hpp")
// Inlined hook for Expression_CONDITIONAL_STATEMENT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CONDITIONAL_STATEMENT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CONDITIONAL_STATEMENT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_CONDITIONAL_STATEMENT_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_CONDITIONAL_dsl.hpp")
// Inlined hook for Expression_CONDITIONAL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CONDITIONAL& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CONDITIONAL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_CONDITIONAL_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_CONDITIONAL_before_dsl.hpp")
// Inlined hook for Expression_CONDITIONAL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CONDITIONAL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CONDITIONAL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_CONDITIONAL_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_CONDITIONAL_after_dsl.hpp")
// Inlined hook for Expression_CONDITIONAL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CONDITIONAL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CONDITIONAL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_CONDITIONAL_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_CONDITIONAL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_AVAILABLE_dsl.hpp")
// Inlined hook for Expression_AVAILABLE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_AVAILABLE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_AVAILABLE& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_AVAILABLE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_AVAILABLE_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_AVAILABLE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_AVAILABLE>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_AVAILABLE_before_dsl.hpp")
// Inlined hook for Expression_AVAILABLE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_AVAILABLE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_AVAILABLE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_AVAILABLE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_AVAILABLE_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_AVAILABLE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_AVAILABLE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_AVAILABLE_after_dsl.hpp")
// Inlined hook for Expression_AVAILABLE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_AVAILABLE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_AVAILABLE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_AVAILABLE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_AVAILABLE_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_AVAILABLE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_AVAILABLE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_SIZEOF_dsl.hpp")
// Inlined hook for Expression_SIZEOF for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SIZEOF>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SIZEOF& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SIZEOF(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_SIZEOF_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SIZEOF>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SIZEOF>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_SIZEOF_before_dsl.hpp")
// Inlined hook for Expression_SIZEOF_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SIZEOF_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SIZEOF_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SIZEOF_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_SIZEOF_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SIZEOF_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SIZEOF_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_SIZEOF_after_dsl.hpp")
// Inlined hook for Expression_SIZEOF_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SIZEOF_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SIZEOF_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SIZEOF_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_SIZEOF_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SIZEOF_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SIZEOF_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_SUB_RANGE_INIT_dsl.hpp")
// Inlined hook for Expression_SUB_RANGE_INIT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SUB_RANGE_INIT& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SUB_RANGE_INIT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_SUB_RANGE_INIT_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_SUB_RANGE_INIT_before_dsl.hpp")
// Inlined hook for Expression_SUB_RANGE_INIT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SUB_RANGE_INIT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SUB_RANGE_INIT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_SUB_RANGE_INIT_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_SUB_RANGE_INIT_after_dsl.hpp")
// Inlined hook for Expression_SUB_RANGE_INIT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SUB_RANGE_INIT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SUB_RANGE_INIT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_SUB_RANGE_INIT_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_OR_COND_dsl.hpp")
// Inlined hook for Expression_OR_COND for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_OR_COND>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_OR_COND& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_OR_COND(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_OR_COND_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_OR_COND>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_OR_COND>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_OR_COND_before_dsl.hpp")
// Inlined hook for Expression_OR_COND_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_OR_COND_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_OR_COND_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_OR_COND_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_OR_COND_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_OR_COND_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_OR_COND_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_OR_COND_after_dsl.hpp")
// Inlined hook for Expression_OR_COND_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_OR_COND_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_OR_COND_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_OR_COND_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_OR_COND_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_OR_COND_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_OR_COND_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_ADDRESS_OF_dsl.hpp")
// Inlined hook for Expression_ADDRESS_OF for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ADDRESS_OF>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ADDRESS_OF& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ADDRESS_OF(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_ADDRESS_OF_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ADDRESS_OF>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ADDRESS_OF>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_ADDRESS_OF_before_dsl.hpp")
// Inlined hook for Expression_ADDRESS_OF_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ADDRESS_OF_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ADDRESS_OF_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_ADDRESS_OF_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_ADDRESS_OF_after_dsl.hpp")
// Inlined hook for Expression_ADDRESS_OF_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ADDRESS_OF_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ADDRESS_OF_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_ADDRESS_OF_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_OPTIONAL_OF_dsl.hpp")
// Inlined hook for Expression_OPTIONAL_OF for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_OPTIONAL_OF& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_OPTIONAL_OF(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_OPTIONAL_OF_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_OPTIONAL_OF_before_dsl.hpp")
// Inlined hook for Expression_OPTIONAL_OF_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_OPTIONAL_OF_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_OPTIONAL_OF_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_OPTIONAL_OF_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_OPTIONAL_OF_after_dsl.hpp")
// Inlined hook for Expression_OPTIONAL_OF_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_OPTIONAL_OF_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_OPTIONAL_OF_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_OPTIONAL_OF_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_SETTER_STATUS_dsl.hpp")
// Inlined hook for Expression_SETTER_STATUS for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SETTER_STATUS>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SETTER_STATUS& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SETTER_STATUS(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_SETTER_STATUS_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SETTER_STATUS>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SETTER_STATUS>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_SETTER_STATUS_before_dsl.hpp")
// Inlined hook for Expression_SETTER_STATUS_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SETTER_STATUS_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SETTER_STATUS_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_SETTER_STATUS_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_SETTER_STATUS_after_dsl.hpp")
// Inlined hook for Expression_SETTER_STATUS_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SETTER_STATUS_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SETTER_STATUS_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_SETTER_STATUS_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_SELF_dsl.hpp")
// Inlined hook for Expression_SELF for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SELF>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SELF& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SELF(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_SELF_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SELF>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SELF>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_SELF_before_dsl.hpp")
// Inlined hook for Expression_SELF_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SELF_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SELF_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SELF_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_SELF_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SELF_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SELF_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_SELF_after_dsl.hpp")
// Inlined hook for Expression_SELF_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SELF_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SELF_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SELF_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_SELF_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SELF_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_SELF_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_AS_ARG_dsl.hpp")
// Inlined hook for Expression_AS_ARG for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_AS_ARG>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_AS_ARG& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_AS_ARG(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_AS_ARG_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_AS_ARG>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_AS_ARG>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_AS_ARG_before_dsl.hpp")
// Inlined hook for Expression_AS_ARG_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_AS_ARG_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_AS_ARG_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_AS_ARG_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_AS_ARG_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_AS_ARG_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_AS_ARG_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_AS_ARG_after_dsl.hpp")
// Inlined hook for Expression_AS_ARG_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_AS_ARG_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_AS_ARG_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_AS_ARG_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_AS_ARG_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_AS_ARG_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_AS_ARG_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_dispatch_dsl.hpp")
// Inlined hook for Expression for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_dispatch_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_before_dispatch_dsl.hpp")
// Inlined hook for Expression_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_before_dispatch_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expression_after_dispatch_dsl.hpp")
// Inlined hook for Expression_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expression_after_dispatch_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expression_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expressions_dsl.hpp")
// Inlined hook for Expressions for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expressions>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expressions& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSIONS(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expressions_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expressions>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expressions>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expressions_before_dsl.hpp")
// Inlined hook for Expressions_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expressions_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expressions_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSIONS_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expressions_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expressions_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expressions_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Expressions_after_dsl.hpp")
// Inlined hook for Expressions_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expressions_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expressions_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSIONS_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Expressions_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expressions_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Expressions_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_INT_dsl.hpp")
// Inlined hook for Type_INT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_INT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_INT& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_INT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_INT_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_INT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_INT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_INT 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_INT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_INT_before_dsl.hpp")
// Inlined hook for Type_INT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_INT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_INT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_INT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_INT_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_INT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_INT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_INT_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_INT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_INT_after_dsl.hpp")
// Inlined hook for Type_INT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_INT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_INT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_INT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_INT_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_INT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_INT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_INT_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_INT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_UINT_dsl.hpp")
// Inlined hook for Type_UINT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_UINT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_UINT& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_UINT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_UINT_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_UINT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_UINT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_UINT 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_UINT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_UINT_before_dsl.hpp")
// Inlined hook for Type_UINT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_UINT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_UINT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_UINT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_UINT_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_UINT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_UINT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_UINT_after_dsl.hpp")
// Inlined hook for Type_UINT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_UINT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_UINT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_UINT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_UINT_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_UINT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_UINT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_USIZE_dsl.hpp")
// Inlined hook for Type_USIZE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_USIZE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_USIZE& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_USIZE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_USIZE_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_USIZE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_USIZE>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_USIZE_before_dsl.hpp")
// Inlined hook for Type_USIZE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_USIZE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_USIZE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_USIZE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_USIZE_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_USIZE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_USIZE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_USIZE_after_dsl.hpp")
// Inlined hook for Type_USIZE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_USIZE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_USIZE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_USIZE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_USIZE_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_USIZE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_USIZE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_FLOAT_dsl.hpp")
// Inlined hook for Type_FLOAT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_FLOAT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_FLOAT& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_FLOAT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_FLOAT_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_FLOAT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_FLOAT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_FLOAT_before_dsl.hpp")
// Inlined hook for Type_FLOAT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_FLOAT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_FLOAT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_FLOAT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_FLOAT_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_FLOAT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_FLOAT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_FLOAT_after_dsl.hpp")
// Inlined hook for Type_FLOAT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_FLOAT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_FLOAT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_FLOAT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_FLOAT_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_FLOAT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_FLOAT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_STRUCT_dsl.hpp")
// Inlined hook for Type_STRUCT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_STRUCT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_STRUCT& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_STRUCT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_STRUCT_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_STRUCT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_STRUCT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_STRUCT_before_dsl.hpp")
// Inlined hook for Type_STRUCT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_STRUCT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_STRUCT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_STRUCT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_STRUCT_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_STRUCT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_STRUCT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_STRUCT_after_dsl.hpp")
// Inlined hook for Type_STRUCT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_STRUCT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_STRUCT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_STRUCT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_STRUCT_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_STRUCT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_STRUCT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_RECURSIVE_STRUCT_dsl.hpp")
// Inlined hook for Type_RECURSIVE_STRUCT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_RECURSIVE_STRUCT& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_RECURSIVE_STRUCT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_RECURSIVE_STRUCT_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_RECURSIVE_STRUCT_before_dsl.hpp")
// Inlined hook for Type_RECURSIVE_STRUCT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_RECURSIVE_STRUCT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_RECURSIVE_STRUCT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_RECURSIVE_STRUCT_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_RECURSIVE_STRUCT_after_dsl.hpp")
// Inlined hook for Type_RECURSIVE_STRUCT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_RECURSIVE_STRUCT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_RECURSIVE_STRUCT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_RECURSIVE_STRUCT_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_BOOL_dsl.hpp")
// Inlined hook for Type_BOOL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_BOOL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_BOOL& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_BOOL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_BOOL_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_BOOL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_BOOL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_BOOL_before_dsl.hpp")
// Inlined hook for Type_BOOL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_BOOL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_BOOL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_BOOL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_BOOL_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_BOOL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_BOOL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_BOOL_after_dsl.hpp")
// Inlined hook for Type_BOOL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_BOOL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_BOOL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_BOOL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_BOOL_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_BOOL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_BOOL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_VOID_dsl.hpp")
// Inlined hook for Type_VOID for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VOID>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VOID& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VOID(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_VOID_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VOID>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VOID)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VOID 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VOID>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_VOID_before_dsl.hpp")
// Inlined hook for Type_VOID_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VOID_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VOID_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VOID_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_VOID_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VOID_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VOID_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_VOID_after_dsl.hpp")
// Inlined hook for Type_VOID_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VOID_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VOID_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VOID_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_VOID_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VOID_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VOID_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_META_dsl.hpp")
// Inlined hook for Type_META for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_META>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_META& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_META(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_META_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_META>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_META)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_META 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_META>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_META_before_dsl.hpp")
// Inlined hook for Type_META_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_META_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_META_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_META_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_META_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_META_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_META_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_META_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_META_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_META_after_dsl.hpp")
// Inlined hook for Type_META_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_META_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_META_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_META_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_META_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_META_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_META_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_META_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_META_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_ENUM_dsl.hpp")
// Inlined hook for Type_ENUM for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENUM>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENUM& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENUM(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_ENUM_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENUM>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENUM>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_ENUM_before_dsl.hpp")
// Inlined hook for Type_ENUM_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENUM_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENUM_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENUM_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_ENUM_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENUM_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENUM_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_ENUM_after_dsl.hpp")
// Inlined hook for Type_ENUM_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENUM_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENUM_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENUM_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_ENUM_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENUM_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENUM_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_ARRAY_dsl.hpp")
// Inlined hook for Type_ARRAY for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ARRAY>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ARRAY& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ARRAY(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_ARRAY_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ARRAY>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ARRAY>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_ARRAY_before_dsl.hpp")
// Inlined hook for Type_ARRAY_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ARRAY_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ARRAY_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ARRAY_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_ARRAY_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ARRAY_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ARRAY_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_ARRAY_after_dsl.hpp")
// Inlined hook for Type_ARRAY_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ARRAY_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ARRAY_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ARRAY_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_ARRAY_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ARRAY_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ARRAY_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_VECTOR_dsl.hpp")
// Inlined hook for Type_VECTOR for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VECTOR>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VECTOR& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VECTOR(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_VECTOR_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VECTOR>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VECTOR>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_VECTOR_before_dsl.hpp")
// Inlined hook for Type_VECTOR_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VECTOR_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VECTOR_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VECTOR_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_VECTOR_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VECTOR_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VECTOR_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_VECTOR_after_dsl.hpp")
// Inlined hook for Type_VECTOR_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VECTOR_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VECTOR_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VECTOR_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_VECTOR_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VECTOR_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VECTOR_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_VARIANT_dsl.hpp")
// Inlined hook for Type_VARIANT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VARIANT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VARIANT& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VARIANT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_VARIANT_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VARIANT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VARIANT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_VARIANT_before_dsl.hpp")
// Inlined hook for Type_VARIANT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VARIANT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VARIANT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VARIANT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_VARIANT_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VARIANT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VARIANT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_VARIANT_after_dsl.hpp")
// Inlined hook for Type_VARIANT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VARIANT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VARIANT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VARIANT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_VARIANT_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VARIANT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_VARIANT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_RANGE_dsl.hpp")
// Inlined hook for Type_RANGE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_RANGE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_RANGE& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_RANGE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_RANGE_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_RANGE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_RANGE>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_RANGE_before_dsl.hpp")
// Inlined hook for Type_RANGE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_RANGE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_RANGE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_RANGE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_RANGE_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_RANGE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_RANGE_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_RANGE_after_dsl.hpp")
// Inlined hook for Type_RANGE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_RANGE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_RANGE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_RANGE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_RANGE_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_RANGE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_RANGE_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_ENCODER_RETURN_dsl.hpp")
// Inlined hook for Type_ENCODER_RETURN for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENCODER_RETURN>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENCODER_RETURN& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENCODER_RETURN(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_ENCODER_RETURN_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENCODER_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENCODER_RETURN>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_ENCODER_RETURN_before_dsl.hpp")
// Inlined hook for Type_ENCODER_RETURN_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENCODER_RETURN_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENCODER_RETURN_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_ENCODER_RETURN_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_ENCODER_RETURN_after_dsl.hpp")
// Inlined hook for Type_ENCODER_RETURN_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENCODER_RETURN_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENCODER_RETURN_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_ENCODER_RETURN_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_DECODER_RETURN_dsl.hpp")
// Inlined hook for Type_DECODER_RETURN for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_DECODER_RETURN>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_DECODER_RETURN& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_DECODER_RETURN(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_DECODER_RETURN_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_DECODER_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_DECODER_RETURN>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_DECODER_RETURN_before_dsl.hpp")
// Inlined hook for Type_DECODER_RETURN_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_DECODER_RETURN_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_DECODER_RETURN_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_DECODER_RETURN_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_DECODER_RETURN_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_DECODER_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_DECODER_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_DECODER_RETURN_after_dsl.hpp")
// Inlined hook for Type_DECODER_RETURN_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_DECODER_RETURN_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_DECODER_RETURN_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_DECODER_RETURN_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_DECODER_RETURN_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_DECODER_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_DECODER_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_ENCODER_INPUT_dsl.hpp")
// Inlined hook for Type_ENCODER_INPUT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENCODER_INPUT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENCODER_INPUT& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENCODER_INPUT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_ENCODER_INPUT_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENCODER_INPUT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENCODER_INPUT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_ENCODER_INPUT_before_dsl.hpp")
// Inlined hook for Type_ENCODER_INPUT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENCODER_INPUT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENCODER_INPUT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_ENCODER_INPUT_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_ENCODER_INPUT_after_dsl.hpp")
// Inlined hook for Type_ENCODER_INPUT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENCODER_INPUT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENCODER_INPUT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_ENCODER_INPUT_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_DECODER_INPUT_dsl.hpp")
// Inlined hook for Type_DECODER_INPUT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_DECODER_INPUT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_DECODER_INPUT& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_DECODER_INPUT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_DECODER_INPUT_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_DECODER_INPUT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_DECODER_INPUT>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_DECODER_INPUT_before_dsl.hpp")
// Inlined hook for Type_DECODER_INPUT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_DECODER_INPUT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_DECODER_INPUT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_DECODER_INPUT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_DECODER_INPUT_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_DECODER_INPUT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_DECODER_INPUT_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_DECODER_INPUT_after_dsl.hpp")
// Inlined hook for Type_DECODER_INPUT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_DECODER_INPUT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_DECODER_INPUT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_DECODER_INPUT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_DECODER_INPUT_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_DECODER_INPUT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_DECODER_INPUT_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_PROPERTY_SETTER_RETURN_dsl.hpp")
// Inlined hook for Type_PROPERTY_SETTER_RETURN for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_PROPERTY_SETTER_RETURN& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_PROPERTY_SETTER_RETURN(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_PROPERTY_SETTER_RETURN_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_PROPERTY_SETTER_RETURN_before_dsl.hpp")
// Inlined hook for Type_PROPERTY_SETTER_RETURN_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_PROPERTY_SETTER_RETURN_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_PROPERTY_SETTER_RETURN_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_PROPERTY_SETTER_RETURN_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_PROPERTY_SETTER_RETURN_after_dsl.hpp")
// Inlined hook for Type_PROPERTY_SETTER_RETURN_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_PROPERTY_SETTER_RETURN_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_PROPERTY_SETTER_RETURN_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_PROPERTY_SETTER_RETURN_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_OPTIONAL_dsl.hpp")
// Inlined hook for Type_OPTIONAL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_OPTIONAL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_OPTIONAL& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_OPTIONAL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_OPTIONAL_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_OPTIONAL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_OPTIONAL>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_OPTIONAL_before_dsl.hpp")
// Inlined hook for Type_OPTIONAL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_OPTIONAL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_OPTIONAL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_OPTIONAL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_OPTIONAL_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_OPTIONAL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_OPTIONAL_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_OPTIONAL_after_dsl.hpp")
// Inlined hook for Type_OPTIONAL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_OPTIONAL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_OPTIONAL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_OPTIONAL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_OPTIONAL_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_OPTIONAL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_OPTIONAL_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_PTR_dsl.hpp")
// Inlined hook for Type_PTR for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_PTR>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_PTR& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_PTR(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_PTR_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_PTR>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PTR)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PTR 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_PTR>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_PTR_before_dsl.hpp")
// Inlined hook for Type_PTR_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_PTR_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_PTR_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_PTR_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_PTR_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_PTR_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_PTR_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_PTR_after_dsl.hpp")
// Inlined hook for Type_PTR_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_PTR_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_PTR_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_PTR_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_PTR_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_PTR_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_PTR_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_FUNCTION_dsl.hpp")
// Inlined hook for Type_FUNCTION for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_FUNCTION>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_FUNCTION& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_FUNCTION(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_FUNCTION_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_FUNCTION>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_FUNCTION>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_FUNCTION_before_dsl.hpp")
// Inlined hook for Type_FUNCTION_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_FUNCTION_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_FUNCTION_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_FUNCTION_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_FUNCTION_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_FUNCTION_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_FUNCTION_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_FUNCTION_after_dsl.hpp")
// Inlined hook for Type_FUNCTION_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_FUNCTION_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_FUNCTION_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_FUNCTION_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_FUNCTION_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_FUNCTION_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_FUNCTION_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_dispatch_dsl.hpp")
// Inlined hook for Type for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_dispatch_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_before_dispatch_dsl.hpp")
// Inlined hook for Type_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_before_dispatch_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Type_after_dispatch_dsl.hpp")
// Inlined hook for Type_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Type_after_dispatch_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Type_after>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Types_dsl.hpp")
// Inlined hook for Types for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Types>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Types& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPES(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Types_dsl.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Types>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPES)
#define CODEGEN_EXPECTED_PRIORITY_TYPES 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Types>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Types_before_dsl.hpp")
// Inlined hook for Types_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Types_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Types_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPES_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Types_before_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Types_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPES_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPES_BEFORE 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Types_before>> {}; // Unimplemented
#endif
#if __has_include("visitor/dsl/Types_after_dsl.hpp")
// Inlined hook for Types_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Types_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Types_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPES_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "visitor/dsl/Types_after_dsl.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Types_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPES_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPES_AFTER 3
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::UserInlinedDSLHook<ebm2python::VisitorTag_Types_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/entry_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_entry>>
#define CODEGEN_CONTEXT(dummy_name) Context_entry
#include "ebmcodegen/default_codegen_visitor/visitor/entry_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_entry"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_entry>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_entry>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_ENTRY)
#define CODEGEN_EXPECTED_PRIORITY_ENTRY 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_entry>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/entry_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_entry_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_entry_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/entry_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_entry_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_entry_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_entry_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_ENTRY_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_ENTRY_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_entry_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/entry_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_entry_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_entry_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/entry_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_entry_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_entry_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_entry_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_ENTRY_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_ENTRY_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_entry_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/pre_visitor_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_pre_visitor>>
#define CODEGEN_CONTEXT(dummy_name) Context_pre_visitor
#include "ebmcodegen/default_codegen_visitor/visitor/pre_visitor_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_pre_visitor"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_pre_visitor>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_pre_visitor>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR)
#define CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_pre_visitor>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/pre_visitor_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_pre_visitor_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_pre_visitor_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/pre_visitor_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_pre_visitor_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_pre_visitor_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_pre_visitor_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_pre_visitor_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/pre_visitor_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_pre_visitor_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_pre_visitor_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/pre_visitor_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_pre_visitor_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_pre_visitor_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_pre_visitor_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_pre_visitor_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/post_entry_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_post_entry>>
#define CODEGEN_CONTEXT(dummy_name) Context_post_entry<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/post_entry_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_post_entry<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_post_entry>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_post_entry>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_POST_ENTRY)
#define CODEGEN_EXPECTED_PRIORITY_POST_ENTRY 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_post_entry>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/post_entry_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_post_entry_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_post_entry_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/post_entry_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_post_entry_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_post_entry_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_post_entry_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_post_entry_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/post_entry_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_post_entry_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_post_entry_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/post_entry_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_post_entry_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_post_entry_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_post_entry_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_post_entry_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_BLOCK_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_BLOCK>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_BLOCK
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_BLOCK_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_BLOCK"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_BLOCK>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_BLOCK>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_BLOCK>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_BLOCK_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_BLOCK_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_BLOCK_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_BLOCK_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_BLOCK_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_BLOCK_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_BLOCK_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_BLOCK_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_BLOCK_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_BLOCK_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_BLOCK_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_BLOCK_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_BLOCK_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_BLOCK_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_BLOCK_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_BLOCK_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ASSIGNMENT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ASSIGNMENT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ASSIGNMENT
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_ASSIGNMENT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ASSIGNMENT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ASSIGNMENT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ASSIGNMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ASSIGNMENT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ASSIGNMENT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ASSIGNMENT_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_ASSIGNMENT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ASSIGNMENT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ASSIGNMENT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ASSIGNMENT_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_ASSIGNMENT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ASSIGNMENT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_YIELD_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_YIELD>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_YIELD
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_YIELD_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_YIELD"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_YIELD>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_YIELD>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_YIELD>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_YIELD_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_YIELD_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_YIELD_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_YIELD_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_YIELD_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_YIELD_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_YIELD_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_YIELD_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_YIELD_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_YIELD_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_YIELD_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_YIELD_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_YIELD_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_YIELD_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_YIELD_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_YIELD_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_APPEND_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_APPEND>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_APPEND
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_APPEND_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_APPEND"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_APPEND>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_APPEND>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_APPEND>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_APPEND_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_APPEND_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_APPEND_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_APPEND_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_APPEND_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_APPEND_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_APPEND_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_APPEND_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_APPEND_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_APPEND_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_APPEND_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_APPEND_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_APPEND_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_APPEND_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_APPEND_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_APPEND_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_RETURN_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_RETURN>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_RETURN
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_RETURN_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_RETURN"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_RETURN>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_RETURN>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_RETURN_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_RETURN_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_RETURN_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_RETURN_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_RETURN_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_RETURN_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_RETURN_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_RETURN_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_RETURN_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_RETURN_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_RETURN_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_RETURN_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ERROR_RETURN_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ERROR_RETURN>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ERROR_RETURN
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_ERROR_RETURN_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ERROR_RETURN"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ERROR_RETURN>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ERROR_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ERROR_RETURN>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ERROR_RETURN_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ERROR_RETURN_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_ERROR_RETURN_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ERROR_RETURN_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ERROR_RETURN_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ERROR_RETURN_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_ERROR_RETURN_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ERROR_RETURN_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ASSERT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ASSERT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ASSERT
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_ASSERT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ASSERT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ASSERT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ASSERT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ASSERT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ASSERT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ASSERT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ASSERT_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_ASSERT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ASSERT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ASSERT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ASSERT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ASSERT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ASSERT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ASSERT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ASSERT_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_ASSERT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ASSERT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ASSERT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ASSERT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ASSERT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_READ_DATA_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_READ_DATA>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_READ_DATA
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_READ_DATA_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_READ_DATA"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_READ_DATA>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_READ_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_READ_DATA>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_READ_DATA_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_READ_DATA_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_READ_DATA_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_READ_DATA_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_READ_DATA_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_READ_DATA_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_READ_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_READ_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_READ_DATA_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_READ_DATA_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_READ_DATA_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_READ_DATA_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_READ_DATA_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_READ_DATA_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_READ_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_READ_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_WRITE_DATA_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_WRITE_DATA>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_WRITE_DATA
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_WRITE_DATA_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_WRITE_DATA"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_WRITE_DATA>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_WRITE_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_WRITE_DATA>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_WRITE_DATA_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_WRITE_DATA_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_WRITE_DATA_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_WRITE_DATA_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_WRITE_DATA_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_WRITE_DATA_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_WRITE_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_WRITE_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_WRITE_DATA_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_WRITE_DATA_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_WRITE_DATA_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_WRITE_DATA_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_WRITE_DATA_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_WRITE_DATA_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_WRITE_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_WRITE_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_RESERVE_DATA_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_RESERVE_DATA>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_RESERVE_DATA
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_RESERVE_DATA_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_RESERVE_DATA"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_RESERVE_DATA>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_RESERVE_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_RESERVE_DATA>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_RESERVE_DATA_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_RESERVE_DATA_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_RESERVE_DATA_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_RESERVE_DATA_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_RESERVE_DATA_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_RESERVE_DATA_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_RESERVE_DATA_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_RESERVE_DATA_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_IF_STATEMENT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_IF_STATEMENT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_IF_STATEMENT
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_IF_STATEMENT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_IF_STATEMENT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_IF_STATEMENT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_IF_STATEMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_IF_STATEMENT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_IF_STATEMENT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_IF_STATEMENT_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_IF_STATEMENT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_IF_STATEMENT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_IF_STATEMENT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_IF_STATEMENT_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_IF_STATEMENT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_IF_STATEMENT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_LOOP_STATEMENT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_LOOP_STATEMENT
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_LOOP_STATEMENT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_LOOP_STATEMENT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_LOOP_STATEMENT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_LOOP_STATEMENT_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_LOOP_STATEMENT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_LOOP_STATEMENT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_LOOP_STATEMENT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_LOOP_STATEMENT_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_LOOP_STATEMENT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_LOOP_STATEMENT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_MATCH_STATEMENT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_MATCH_STATEMENT
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_MATCH_STATEMENT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_MATCH_STATEMENT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_MATCH_STATEMENT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_MATCH_STATEMENT_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_MATCH_STATEMENT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_MATCH_STATEMENT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_MATCH_STATEMENT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_MATCH_STATEMENT_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_MATCH_STATEMENT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_MATCH_STATEMENT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_MATCH_BRANCH_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_MATCH_BRANCH
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_MATCH_BRANCH_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_MATCH_BRANCH"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_MATCH_BRANCH_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_MATCH_BRANCH_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_MATCH_BRANCH_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_MATCH_BRANCH_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_MATCH_BRANCH_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_MATCH_BRANCH_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_MATCH_BRANCH_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_MATCH_BRANCH_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_BREAK_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_BREAK>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_BREAK
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_BREAK_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_BREAK"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_BREAK>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_BREAK>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_BREAK>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_BREAK_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_BREAK_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_BREAK_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_BREAK_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_BREAK_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_BREAK_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_BREAK_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_BREAK_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_BREAK_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_BREAK_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_BREAK_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_BREAK_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_BREAK_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_BREAK_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_BREAK_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_BREAK_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_CONTINUE_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_CONTINUE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_CONTINUE
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_CONTINUE_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_CONTINUE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_CONTINUE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_CONTINUE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_CONTINUE>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_CONTINUE_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_CONTINUE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_CONTINUE_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_CONTINUE_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_CONTINUE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_CONTINUE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_CONTINUE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_CONTINUE_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_CONTINUE_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_CONTINUE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_CONTINUE_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_CONTINUE_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_CONTINUE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_CONTINUE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_CONTINUE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_CONTINUE_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_FUNCTION_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_FUNCTION_DECL
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_FUNCTION_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_FUNCTION_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_FUNCTION_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_FUNCTION_DECL_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_FUNCTION_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_FUNCTION_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_FUNCTION_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_FUNCTION_DECL_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_FUNCTION_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_FUNCTION_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_VARIABLE_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_VARIABLE_DECL
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_VARIABLE_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_VARIABLE_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_VARIABLE_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_VARIABLE_DECL_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_VARIABLE_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_VARIABLE_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_VARIABLE_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_VARIABLE_DECL_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_VARIABLE_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_VARIABLE_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_PARAMETER_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PARAMETER_DECL
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_PARAMETER_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PARAMETER_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_PARAMETER_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PARAMETER_DECL_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_PARAMETER_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PARAMETER_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_PARAMETER_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PARAMETER_DECL_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_PARAMETER_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PARAMETER_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_FIELD_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_FIELD_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_FIELD_DECL
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_FIELD_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_FIELD_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_FIELD_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_FIELD_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_FIELD_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_FIELD_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_FIELD_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_FIELD_DECL_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_FIELD_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_FIELD_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_FIELD_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_FIELD_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_FIELD_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_FIELD_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_FIELD_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_FIELD_DECL_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_FIELD_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_FIELD_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_FIELD_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_FIELD_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_FIELD_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_COMPOSITE_FIELD_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_COMPOSITE_FIELD_DECL
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_COMPOSITE_FIELD_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_COMPOSITE_FIELD_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_COMPOSITE_FIELD_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_COMPOSITE_FIELD_DECL_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_COMPOSITE_FIELD_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_COMPOSITE_FIELD_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_COMPOSITE_FIELD_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_COMPOSITE_FIELD_DECL_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_COMPOSITE_FIELD_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_COMPOSITE_FIELD_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ENUM_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENUM_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENUM_DECL
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_ENUM_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENUM_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENUM_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENUM_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENUM_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ENUM_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENUM_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENUM_DECL_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_ENUM_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENUM_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENUM_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENUM_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENUM_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ENUM_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENUM_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENUM_DECL_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_ENUM_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENUM_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENUM_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENUM_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENUM_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ENUM_MEMBER_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENUM_MEMBER_DECL
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_ENUM_MEMBER_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENUM_MEMBER_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ENUM_MEMBER_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENUM_MEMBER_DECL_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_ENUM_MEMBER_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENUM_MEMBER_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ENUM_MEMBER_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENUM_MEMBER_DECL_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_ENUM_MEMBER_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENUM_MEMBER_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_STRUCT_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_STRUCT_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_STRUCT_DECL
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_STRUCT_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_STRUCT_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_STRUCT_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_STRUCT_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_STRUCT_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_STRUCT_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_STRUCT_DECL_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_STRUCT_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_STRUCT_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_STRUCT_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_STRUCT_DECL_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_STRUCT_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_STRUCT_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_UNION_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_UNION_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_UNION_DECL
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_UNION_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_UNION_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_UNION_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_UNION_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_UNION_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_UNION_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_UNION_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_UNION_DECL_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_UNION_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_UNION_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_UNION_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_UNION_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_UNION_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_UNION_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_UNION_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_UNION_DECL_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_UNION_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_UNION_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_UNION_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_UNION_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_UNION_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_UNION_MEMBER_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_UNION_MEMBER_DECL
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_UNION_MEMBER_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_UNION_MEMBER_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_UNION_MEMBER_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_UNION_MEMBER_DECL_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_UNION_MEMBER_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_UNION_MEMBER_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_UNION_MEMBER_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_UNION_MEMBER_DECL_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_UNION_MEMBER_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_UNION_MEMBER_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_PROGRAM_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROGRAM_DECL
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_PROGRAM_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROGRAM_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_PROGRAM_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROGRAM_DECL_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_PROGRAM_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROGRAM_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_PROGRAM_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROGRAM_DECL_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_PROGRAM_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROGRAM_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_PROPERTY_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROPERTY_DECL
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_PROPERTY_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROPERTY_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_PROPERTY_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROPERTY_DECL_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_PROPERTY_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROPERTY_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_PROPERTY_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROPERTY_DECL_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_PROPERTY_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROPERTY_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_PROPERTY_MEMBER_DECL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROPERTY_MEMBER_DECL
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_PROPERTY_MEMBER_DECL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROPERTY_MEMBER_DECL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_PROPERTY_MEMBER_DECL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROPERTY_MEMBER_DECL_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_PROPERTY_MEMBER_DECL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROPERTY_MEMBER_DECL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_PROPERTY_MEMBER_DECL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_PROPERTY_MEMBER_DECL_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_PROPERTY_MEMBER_DECL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_PROPERTY_MEMBER_DECL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_METADATA_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_METADATA>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_METADATA
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_METADATA_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_METADATA"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_METADATA>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_METADATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_METADATA>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_METADATA_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_METADATA_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_METADATA_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_METADATA_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_METADATA_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_METADATA_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_METADATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_METADATA_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_METADATA_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_METADATA_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_METADATA_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_METADATA_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_METADATA_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_METADATA_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_METADATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_METADATA_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_IMPORT_MODULE_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_IMPORT_MODULE
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_IMPORT_MODULE_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_IMPORT_MODULE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_IMPORT_MODULE_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_IMPORT_MODULE_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_IMPORT_MODULE_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_IMPORT_MODULE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_IMPORT_MODULE_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_IMPORT_MODULE_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_IMPORT_MODULE_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_IMPORT_MODULE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_EXPRESSION_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_EXPRESSION>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_EXPRESSION
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_EXPRESSION_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_EXPRESSION"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_EXPRESSION>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_EXPRESSION>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_EXPRESSION>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_EXPRESSION_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_EXPRESSION_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_EXPRESSION_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_EXPRESSION_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_EXPRESSION_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_EXPRESSION_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_EXPRESSION_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_EXPRESSION_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_EXPRESSION_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_EXPRESSION_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_EXPRESSION_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_EXPRESSION_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_EXPRESSION_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_EXPRESSION_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_EXPRESSION_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_EXPRESSION_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ERROR_REPORT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ERROR_REPORT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ERROR_REPORT
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_ERROR_REPORT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ERROR_REPORT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ERROR_REPORT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ERROR_REPORT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ERROR_REPORT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ERROR_REPORT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ERROR_REPORT_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_ERROR_REPORT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ERROR_REPORT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ERROR_REPORT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ERROR_REPORT_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_ERROR_REPORT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ERROR_REPORT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_LOWERED_IO_STATEMENTS_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_LOWERED_IO_STATEMENTS
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_LOWERED_IO_STATEMENTS_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_LOWERED_IO_STATEMENTS"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_LOWERED_IO_STATEMENTS_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_LOWERED_IO_STATEMENTS_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_LOWERED_IO_STATEMENTS_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_LOWERED_IO_STATEMENTS_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_LOWERED_IO_STATEMENTS_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_LOWERED_IO_STATEMENTS_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_LOWERED_IO_STATEMENTS_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_LOWERED_IO_STATEMENTS_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_SUB_BYTE_RANGE_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_SUB_BYTE_RANGE
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_SUB_BYTE_RANGE_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_SUB_BYTE_RANGE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_SUB_BYTE_RANGE_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_SUB_BYTE_RANGE_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_SUB_BYTE_RANGE_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_SUB_BYTE_RANGE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_SUB_BYTE_RANGE_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_SUB_BYTE_RANGE_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_SUB_BYTE_RANGE_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_SUB_BYTE_RANGE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_INIT_CHECK_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_INIT_CHECK>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_INIT_CHECK
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_INIT_CHECK_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_INIT_CHECK"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_INIT_CHECK>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_INIT_CHECK>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_INIT_CHECK>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_INIT_CHECK_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_INIT_CHECK_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_INIT_CHECK_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_INIT_CHECK_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_INIT_CHECK_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_INIT_CHECK_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_INIT_CHECK_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_INIT_CHECK_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_INIT_CHECK_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_INIT_CHECK_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_INIT_CHECK_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_INIT_CHECK_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_INIT_CHECK_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_INIT_CHECK_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_INIT_CHECK_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_INIT_CHECK_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ENDIAN_VARIABLE_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENDIAN_VARIABLE
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_ENDIAN_VARIABLE_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENDIAN_VARIABLE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ENDIAN_VARIABLE_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENDIAN_VARIABLE_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_ENDIAN_VARIABLE_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENDIAN_VARIABLE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ENDIAN_VARIABLE_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_ENDIAN_VARIABLE_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_ENDIAN_VARIABLE_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_ENDIAN_VARIABLE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_dispatch_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_dispatch_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_before_dispatch_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_before_dispatch_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_after_dispatch_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Statement_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Statement_after_dispatch_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Statement_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Statement_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Block_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Block>>
#define CODEGEN_CONTEXT(dummy_name) Context_Block
#include "ebmcodegen/default_codegen_visitor/visitor/Block_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Block"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Block>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Block>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_BLOCK)
#define CODEGEN_EXPECTED_PRIORITY_BLOCK 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Block>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Block_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Block_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Block_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Block_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Block_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Block_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Block_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_BLOCK_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_BLOCK_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Block_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Block_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Block_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Block_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Block_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Block_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Block_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Block_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_BLOCK_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_BLOCK_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Block_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_INT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_INT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_INT
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_INT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_INT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_INT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_INT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_INT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_INT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_INT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_INT_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_INT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_INT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_INT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_INT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_INT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_INT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_INT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_INT_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_INT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_INT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_INT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_INT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_INT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_INT64_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_INT64>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_INT64
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_INT64_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_INT64"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_INT64>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_INT64>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_INT64>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_INT64_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_INT64_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_INT64_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_INT64_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_INT64_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_INT64_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_INT64_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_INT64_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_BOOL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_BOOL
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_BOOL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_BOOL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_BOOL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_BOOL_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_BOOL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_BOOL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_BOOL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_BOOL_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_BOOL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_BOOL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_STRING_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_STRING>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_STRING
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_STRING_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_STRING"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_STRING>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_STRING>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_STRING>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_STRING_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_STRING_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_STRING_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_STRING_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_STRING_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_STRING_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_STRING_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_STRING_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_TYPE_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_TYPE
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_TYPE_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_TYPE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_TYPE_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_TYPE_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_TYPE_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_TYPE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_TYPE_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_TYPE_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_TYPE_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_TYPE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_CHAR_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_CHAR
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_CHAR_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_CHAR"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_CHAR_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_CHAR_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_CHAR_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_CHAR_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_CHAR_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_LITERAL_CHAR_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_CHAR_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_LITERAL_CHAR_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_IDENTIFIER_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IDENTIFIER>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IDENTIFIER
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_IDENTIFIER_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IDENTIFIER"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IDENTIFIER>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IDENTIFIER>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IDENTIFIER>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_IDENTIFIER_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IDENTIFIER_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IDENTIFIER_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_IDENTIFIER_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IDENTIFIER_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IDENTIFIER_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IDENTIFIER_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IDENTIFIER_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_IDENTIFIER_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IDENTIFIER_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IDENTIFIER_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_IDENTIFIER_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IDENTIFIER_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IDENTIFIER_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IDENTIFIER_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IDENTIFIER_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_BINARY_OP_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_BINARY_OP>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_BINARY_OP
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_BINARY_OP_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_BINARY_OP"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_BINARY_OP>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_BINARY_OP>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_BINARY_OP>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_BINARY_OP_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_BINARY_OP_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_BINARY_OP_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_BINARY_OP_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_BINARY_OP_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_BINARY_OP_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_BINARY_OP_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_BINARY_OP_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_BINARY_OP_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_BINARY_OP_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_BINARY_OP_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_BINARY_OP_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_BINARY_OP_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_BINARY_OP_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_BINARY_OP_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_BINARY_OP_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_UNARY_OP_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_UNARY_OP>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_UNARY_OP
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_UNARY_OP_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_UNARY_OP"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_UNARY_OP>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_UNARY_OP>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_UNARY_OP>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_UNARY_OP_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_UNARY_OP_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_UNARY_OP_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_UNARY_OP_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_UNARY_OP_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_UNARY_OP_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_UNARY_OP_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_UNARY_OP_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_UNARY_OP_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_UNARY_OP_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_UNARY_OP_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_UNARY_OP_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_UNARY_OP_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_UNARY_OP_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_UNARY_OP_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_UNARY_OP_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_CALL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CALL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CALL
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_CALL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CALL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CALL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CALL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CALL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_CALL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CALL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CALL_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_CALL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CALL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CALL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CALL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CALL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_CALL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CALL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CALL_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_CALL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CALL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CALL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CALL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CALL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_INDEX_ACCESS_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_INDEX_ACCESS
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_INDEX_ACCESS_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_INDEX_ACCESS"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_INDEX_ACCESS_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_INDEX_ACCESS_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_INDEX_ACCESS_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_INDEX_ACCESS_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_INDEX_ACCESS_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_INDEX_ACCESS_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_INDEX_ACCESS_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_INDEX_ACCESS_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_MEMBER_ACCESS_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_MEMBER_ACCESS
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_MEMBER_ACCESS_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_MEMBER_ACCESS"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_MEMBER_ACCESS_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_MEMBER_ACCESS_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_MEMBER_ACCESS_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_MEMBER_ACCESS_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_MEMBER_ACCESS_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_MEMBER_ACCESS_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_MEMBER_ACCESS_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_MEMBER_ACCESS_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_ENUM_MEMBER_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ENUM_MEMBER
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_ENUM_MEMBER_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ENUM_MEMBER"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_ENUM_MEMBER_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ENUM_MEMBER_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_ENUM_MEMBER_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ENUM_MEMBER_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_ENUM_MEMBER_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ENUM_MEMBER_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_ENUM_MEMBER_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ENUM_MEMBER_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_TYPE_CAST_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_TYPE_CAST>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_TYPE_CAST
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_TYPE_CAST_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_TYPE_CAST"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_TYPE_CAST>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_TYPE_CAST>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_TYPE_CAST>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_TYPE_CAST_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_TYPE_CAST_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_TYPE_CAST_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_TYPE_CAST_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_TYPE_CAST_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_TYPE_CAST_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_TYPE_CAST_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_TYPE_CAST_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_TYPE_CAST_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_TYPE_CAST_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_TYPE_CAST_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_TYPE_CAST_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_TYPE_CAST_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_TYPE_CAST_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_TYPE_CAST_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_TYPE_CAST_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_RANGE_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_RANGE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_RANGE
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_RANGE_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_RANGE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_RANGE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_RANGE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_RANGE>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_RANGE_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_RANGE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_RANGE_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_RANGE_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_RANGE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_RANGE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_RANGE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_RANGE_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_RANGE_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_RANGE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_RANGE_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_RANGE_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_RANGE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_RANGE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_RANGE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_RANGE_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_DEFAULT_VALUE_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_DEFAULT_VALUE
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_DEFAULT_VALUE_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_DEFAULT_VALUE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_DEFAULT_VALUE_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_DEFAULT_VALUE_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_DEFAULT_VALUE_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_DEFAULT_VALUE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_DEFAULT_VALUE_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_DEFAULT_VALUE_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_DEFAULT_VALUE_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_DEFAULT_VALUE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_IS_LITTLE_ENDIAN_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IS_LITTLE_ENDIAN
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_IS_LITTLE_ENDIAN_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IS_LITTLE_ENDIAN"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_IS_LITTLE_ENDIAN_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IS_LITTLE_ENDIAN_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_IS_LITTLE_ENDIAN_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IS_LITTLE_ENDIAN_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_IS_LITTLE_ENDIAN_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IS_LITTLE_ENDIAN_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_IS_LITTLE_ENDIAN_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IS_LITTLE_ENDIAN_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_GET_STREAM_OFFSET_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_GET_STREAM_OFFSET
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_GET_STREAM_OFFSET_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_GET_STREAM_OFFSET"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_GET_STREAM_OFFSET_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_GET_STREAM_OFFSET_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_GET_STREAM_OFFSET_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_GET_STREAM_OFFSET_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_GET_STREAM_OFFSET_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_GET_STREAM_OFFSET_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_GET_STREAM_OFFSET_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_GET_STREAM_OFFSET_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_GET_REMAINING_BYTES_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_GET_REMAINING_BYTES
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_GET_REMAINING_BYTES_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_GET_REMAINING_BYTES"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_GET_REMAINING_BYTES_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_GET_REMAINING_BYTES_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_GET_REMAINING_BYTES_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_GET_REMAINING_BYTES_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_GET_REMAINING_BYTES_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_GET_REMAINING_BYTES_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_GET_REMAINING_BYTES_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_GET_REMAINING_BYTES_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_CAN_READ_STREAM_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CAN_READ_STREAM
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_CAN_READ_STREAM_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CAN_READ_STREAM"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_CAN_READ_STREAM_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CAN_READ_STREAM_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_CAN_READ_STREAM_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CAN_READ_STREAM_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_CAN_READ_STREAM_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CAN_READ_STREAM_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_CAN_READ_STREAM_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CAN_READ_STREAM_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_ARRAY_SIZE_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ARRAY_SIZE
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_ARRAY_SIZE_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ARRAY_SIZE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_ARRAY_SIZE_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ARRAY_SIZE_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_ARRAY_SIZE_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ARRAY_SIZE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_ARRAY_SIZE_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ARRAY_SIZE_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_ARRAY_SIZE_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ARRAY_SIZE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_ENUM_IS_DEFINED_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ENUM_IS_DEFINED
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_ENUM_IS_DEFINED_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ENUM_IS_DEFINED"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_ENUM_IS_DEFINED_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ENUM_IS_DEFINED_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_ENUM_IS_DEFINED_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ENUM_IS_DEFINED_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_ENUM_IS_DEFINED_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ENUM_IS_DEFINED_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_ENUM_IS_DEFINED_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ENUM_IS_DEFINED_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_IS_ERROR_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IS_ERROR>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IS_ERROR
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_IS_ERROR_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IS_ERROR"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IS_ERROR>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IS_ERROR>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IS_ERROR>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_IS_ERROR_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IS_ERROR_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IS_ERROR_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_IS_ERROR_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IS_ERROR_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IS_ERROR_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IS_ERROR_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IS_ERROR_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_IS_ERROR_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IS_ERROR_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_IS_ERROR_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_IS_ERROR_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_IS_ERROR_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IS_ERROR_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IS_ERROR_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_IS_ERROR_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_MAX_VALUE_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_MAX_VALUE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_MAX_VALUE
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_MAX_VALUE_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_MAX_VALUE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_MAX_VALUE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_MAX_VALUE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_MAX_VALUE>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_MAX_VALUE_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_MAX_VALUE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_MAX_VALUE_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_MAX_VALUE_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_MAX_VALUE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_MAX_VALUE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_MAX_VALUE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_MAX_VALUE_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_MAX_VALUE_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_MAX_VALUE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_MAX_VALUE_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_MAX_VALUE_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_MAX_VALUE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_MAX_VALUE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_MAX_VALUE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_MAX_VALUE_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_READ_DATA_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_READ_DATA>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_READ_DATA
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_READ_DATA_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_READ_DATA"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_READ_DATA>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_READ_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_READ_DATA>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_READ_DATA_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_READ_DATA_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_READ_DATA_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_READ_DATA_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_READ_DATA_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_READ_DATA_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_READ_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_READ_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_READ_DATA_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_READ_DATA_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_READ_DATA_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_READ_DATA_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_READ_DATA_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_READ_DATA_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_READ_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_READ_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_WRITE_DATA_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_WRITE_DATA>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_WRITE_DATA
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_WRITE_DATA_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_WRITE_DATA"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_WRITE_DATA>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_WRITE_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_WRITE_DATA>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_WRITE_DATA_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_WRITE_DATA_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_WRITE_DATA_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_WRITE_DATA_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_WRITE_DATA_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_WRITE_DATA_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_WRITE_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_WRITE_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_WRITE_DATA_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_WRITE_DATA_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_WRITE_DATA_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_WRITE_DATA_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_WRITE_DATA_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_WRITE_DATA_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_WRITE_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_WRITE_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_CONDITIONAL_STATEMENT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CONDITIONAL_STATEMENT
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_CONDITIONAL_STATEMENT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CONDITIONAL_STATEMENT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_CONDITIONAL_STATEMENT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CONDITIONAL_STATEMENT_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_CONDITIONAL_STATEMENT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CONDITIONAL_STATEMENT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_CONDITIONAL_STATEMENT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CONDITIONAL_STATEMENT_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_CONDITIONAL_STATEMENT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CONDITIONAL_STATEMENT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_CONDITIONAL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CONDITIONAL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CONDITIONAL
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_CONDITIONAL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CONDITIONAL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CONDITIONAL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CONDITIONAL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CONDITIONAL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_CONDITIONAL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CONDITIONAL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CONDITIONAL_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_CONDITIONAL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CONDITIONAL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CONDITIONAL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CONDITIONAL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CONDITIONAL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_CONDITIONAL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CONDITIONAL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_CONDITIONAL_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_CONDITIONAL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_CONDITIONAL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CONDITIONAL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CONDITIONAL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_CONDITIONAL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_AVAILABLE_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_AVAILABLE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_AVAILABLE
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_AVAILABLE_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_AVAILABLE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_AVAILABLE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_AVAILABLE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_AVAILABLE>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_AVAILABLE_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_AVAILABLE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_AVAILABLE_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_AVAILABLE_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_AVAILABLE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_AVAILABLE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_AVAILABLE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_AVAILABLE_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_AVAILABLE_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_AVAILABLE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_AVAILABLE_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_AVAILABLE_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_AVAILABLE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_AVAILABLE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_AVAILABLE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_AVAILABLE_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_SIZEOF_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SIZEOF>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SIZEOF
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_SIZEOF_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SIZEOF"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SIZEOF>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SIZEOF>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SIZEOF>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_SIZEOF_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SIZEOF_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SIZEOF_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_SIZEOF_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SIZEOF_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SIZEOF_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SIZEOF_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SIZEOF_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_SIZEOF_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SIZEOF_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SIZEOF_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_SIZEOF_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SIZEOF_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SIZEOF_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SIZEOF_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SIZEOF_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_SUB_RANGE_INIT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SUB_RANGE_INIT
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_SUB_RANGE_INIT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SUB_RANGE_INIT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_SUB_RANGE_INIT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SUB_RANGE_INIT_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_SUB_RANGE_INIT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SUB_RANGE_INIT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_SUB_RANGE_INIT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SUB_RANGE_INIT_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_SUB_RANGE_INIT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SUB_RANGE_INIT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_OR_COND_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_OR_COND>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_OR_COND
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_OR_COND_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_OR_COND"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_OR_COND>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_OR_COND>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_OR_COND>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_OR_COND_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_OR_COND_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_OR_COND_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_OR_COND_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_OR_COND_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_OR_COND_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_OR_COND_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_OR_COND_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_OR_COND_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_OR_COND_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_OR_COND_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_OR_COND_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_OR_COND_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_OR_COND_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_OR_COND_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_OR_COND_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_ADDRESS_OF_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ADDRESS_OF>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ADDRESS_OF
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_ADDRESS_OF_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ADDRESS_OF"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ADDRESS_OF>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ADDRESS_OF>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ADDRESS_OF>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_ADDRESS_OF_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ADDRESS_OF_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_ADDRESS_OF_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ADDRESS_OF_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_ADDRESS_OF_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_ADDRESS_OF_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_ADDRESS_OF_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_ADDRESS_OF_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_OPTIONAL_OF_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_OPTIONAL_OF
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_OPTIONAL_OF_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_OPTIONAL_OF"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_OPTIONAL_OF_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_OPTIONAL_OF_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_OPTIONAL_OF_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_OPTIONAL_OF_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_OPTIONAL_OF_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_OPTIONAL_OF_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_OPTIONAL_OF_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_OPTIONAL_OF_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_SETTER_STATUS_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SETTER_STATUS>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SETTER_STATUS
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_SETTER_STATUS_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SETTER_STATUS"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SETTER_STATUS>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SETTER_STATUS>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SETTER_STATUS>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_SETTER_STATUS_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SETTER_STATUS_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_SETTER_STATUS_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SETTER_STATUS_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_SETTER_STATUS_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SETTER_STATUS_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_SETTER_STATUS_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SETTER_STATUS_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_SELF_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SELF>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SELF
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_SELF_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SELF"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SELF>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SELF>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SELF>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_SELF_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SELF_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SELF_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_SELF_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SELF_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SELF_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SELF_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SELF_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_SELF_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SELF_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_SELF_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_SELF_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_SELF_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SELF_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SELF_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_SELF_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_AS_ARG_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_AS_ARG>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_AS_ARG
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_AS_ARG_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_AS_ARG"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_AS_ARG>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_AS_ARG>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_AS_ARG>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_AS_ARG_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_AS_ARG_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_AS_ARG_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_AS_ARG_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_AS_ARG_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_AS_ARG_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_AS_ARG_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_AS_ARG_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_AS_ARG_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_AS_ARG_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_AS_ARG_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_AS_ARG_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_AS_ARG_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_AS_ARG_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_AS_ARG_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_AS_ARG_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_dispatch_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_dispatch_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_before_dispatch_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_before_dispatch_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_after_dispatch_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expression_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expression_after_dispatch_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expression_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expression_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expressions_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expressions>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expressions
#include "ebmcodegen/default_codegen_visitor/visitor/Expressions_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expressions"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expressions>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expressions>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expressions>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expressions_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expressions_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expressions_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expressions_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expressions_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expressions_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expressions_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expressions_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expressions_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expressions_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Expressions_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Expressions_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Expressions_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expressions_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expressions_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Expressions_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_INT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_INT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_INT
#include "ebmcodegen/default_codegen_visitor/visitor/Type_INT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_INT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_INT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_INT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_INT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_INT 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_INT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_INT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_INT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_INT_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_INT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_INT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_INT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_INT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_INT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_INT_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_INT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_INT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_INT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_INT_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_INT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_INT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_INT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_INT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_INT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_INT_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_INT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_UINT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_UINT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_UINT
#include "ebmcodegen/default_codegen_visitor/visitor/Type_UINT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_UINT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_UINT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_UINT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_UINT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_UINT 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_UINT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_UINT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_UINT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_UINT_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_UINT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_UINT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_UINT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_UINT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_UINT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_UINT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_UINT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_UINT_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_UINT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_UINT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_UINT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_UINT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_UINT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_USIZE_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_USIZE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_USIZE
#include "ebmcodegen/default_codegen_visitor/visitor/Type_USIZE_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_USIZE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_USIZE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_USIZE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_USIZE>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_USIZE_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_USIZE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_USIZE_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_USIZE_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_USIZE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_USIZE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_USIZE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_USIZE_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_USIZE_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_USIZE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_USIZE_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_USIZE_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_USIZE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_USIZE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_USIZE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_USIZE_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_FLOAT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_FLOAT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_FLOAT
#include "ebmcodegen/default_codegen_visitor/visitor/Type_FLOAT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_FLOAT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_FLOAT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_FLOAT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_FLOAT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_FLOAT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_FLOAT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_FLOAT_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_FLOAT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_FLOAT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_FLOAT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_FLOAT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_FLOAT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_FLOAT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_FLOAT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_FLOAT_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_FLOAT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_FLOAT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_FLOAT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_FLOAT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_FLOAT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_STRUCT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_STRUCT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_STRUCT
#include "ebmcodegen/default_codegen_visitor/visitor/Type_STRUCT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_STRUCT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_STRUCT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_STRUCT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_STRUCT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_STRUCT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_STRUCT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_STRUCT_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_STRUCT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_STRUCT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_STRUCT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_STRUCT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_STRUCT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_STRUCT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_STRUCT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_STRUCT_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_STRUCT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_STRUCT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_STRUCT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_STRUCT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_STRUCT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_RECURSIVE_STRUCT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_RECURSIVE_STRUCT
#include "ebmcodegen/default_codegen_visitor/visitor/Type_RECURSIVE_STRUCT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_RECURSIVE_STRUCT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_RECURSIVE_STRUCT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_RECURSIVE_STRUCT_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_RECURSIVE_STRUCT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_RECURSIVE_STRUCT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_RECURSIVE_STRUCT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_RECURSIVE_STRUCT_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_RECURSIVE_STRUCT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_RECURSIVE_STRUCT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_BOOL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_BOOL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_BOOL
#include "ebmcodegen/default_codegen_visitor/visitor/Type_BOOL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_BOOL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_BOOL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_BOOL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_BOOL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_BOOL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_BOOL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_BOOL_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_BOOL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_BOOL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_BOOL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_BOOL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_BOOL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_BOOL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_BOOL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_BOOL_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_BOOL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_BOOL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_BOOL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_BOOL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_BOOL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_VOID_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VOID>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VOID
#include "ebmcodegen/default_codegen_visitor/visitor/Type_VOID_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VOID"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VOID>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VOID>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VOID)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VOID 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VOID>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_VOID_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VOID_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VOID_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_VOID_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VOID_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VOID_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VOID_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VOID_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_VOID_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VOID_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VOID_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_VOID_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VOID_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VOID_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VOID_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VOID_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_META_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_META>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_META
#include "ebmcodegen/default_codegen_visitor/visitor/Type_META_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_META"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_META>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_META>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_META)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_META 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_META>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_META_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_META_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_META_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_META_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_META_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_META_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_META_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_META_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_META_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_META_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_META_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_META_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_META_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_META_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_META_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_META_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_META_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_META_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_META_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_META_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_ENUM_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENUM>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENUM
#include "ebmcodegen/default_codegen_visitor/visitor/Type_ENUM_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENUM"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENUM>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENUM>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENUM>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_ENUM_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENUM_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENUM_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_ENUM_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENUM_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENUM_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENUM_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENUM_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_ENUM_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENUM_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENUM_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_ENUM_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENUM_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENUM_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENUM_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENUM_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_ARRAY_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ARRAY>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ARRAY
#include "ebmcodegen/default_codegen_visitor/visitor/Type_ARRAY_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ARRAY"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ARRAY>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ARRAY>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ARRAY>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_ARRAY_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ARRAY_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ARRAY_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_ARRAY_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ARRAY_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ARRAY_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ARRAY_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ARRAY_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_ARRAY_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ARRAY_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ARRAY_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_ARRAY_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ARRAY_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ARRAY_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ARRAY_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ARRAY_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_VECTOR_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VECTOR>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VECTOR
#include "ebmcodegen/default_codegen_visitor/visitor/Type_VECTOR_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VECTOR"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VECTOR>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VECTOR>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VECTOR>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_VECTOR_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VECTOR_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VECTOR_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_VECTOR_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VECTOR_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VECTOR_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VECTOR_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VECTOR_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_VECTOR_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VECTOR_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VECTOR_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_VECTOR_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VECTOR_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VECTOR_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VECTOR_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VECTOR_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_VARIANT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VARIANT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VARIANT
#include "ebmcodegen/default_codegen_visitor/visitor/Type_VARIANT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VARIANT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VARIANT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VARIANT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VARIANT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_VARIANT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VARIANT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VARIANT_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_VARIANT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VARIANT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VARIANT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VARIANT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VARIANT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_VARIANT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VARIANT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_VARIANT_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_VARIANT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_VARIANT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VARIANT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VARIANT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_VARIANT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_RANGE_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_RANGE>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_RANGE
#include "ebmcodegen/default_codegen_visitor/visitor/Type_RANGE_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_RANGE"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_RANGE>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_RANGE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_RANGE>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_RANGE_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_RANGE_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_RANGE_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_RANGE_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_RANGE_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_RANGE_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_RANGE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_RANGE_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_RANGE_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_RANGE_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_RANGE_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_RANGE_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_RANGE_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_RANGE_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_RANGE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_RANGE_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_ENCODER_RETURN_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENCODER_RETURN>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENCODER_RETURN
#include "ebmcodegen/default_codegen_visitor/visitor/Type_ENCODER_RETURN_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENCODER_RETURN"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENCODER_RETURN>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENCODER_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENCODER_RETURN>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_ENCODER_RETURN_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENCODER_RETURN_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_ENCODER_RETURN_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENCODER_RETURN_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_ENCODER_RETURN_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENCODER_RETURN_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_ENCODER_RETURN_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENCODER_RETURN_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_DECODER_RETURN_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_DECODER_RETURN>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_DECODER_RETURN
#include "ebmcodegen/default_codegen_visitor/visitor/Type_DECODER_RETURN_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_DECODER_RETURN"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_DECODER_RETURN>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_DECODER_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_DECODER_RETURN>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_DECODER_RETURN_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_DECODER_RETURN_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_DECODER_RETURN_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_DECODER_RETURN_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_DECODER_RETURN_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_DECODER_RETURN_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_DECODER_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_DECODER_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_DECODER_RETURN_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_DECODER_RETURN_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_DECODER_RETURN_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_DECODER_RETURN_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_DECODER_RETURN_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_DECODER_RETURN_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_DECODER_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_DECODER_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_ENCODER_INPUT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENCODER_INPUT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENCODER_INPUT
#include "ebmcodegen/default_codegen_visitor/visitor/Type_ENCODER_INPUT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENCODER_INPUT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENCODER_INPUT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENCODER_INPUT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENCODER_INPUT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_ENCODER_INPUT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENCODER_INPUT_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_ENCODER_INPUT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENCODER_INPUT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_ENCODER_INPUT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_ENCODER_INPUT_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_ENCODER_INPUT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_ENCODER_INPUT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_DECODER_INPUT_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_DECODER_INPUT>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_DECODER_INPUT
#include "ebmcodegen/default_codegen_visitor/visitor/Type_DECODER_INPUT_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_DECODER_INPUT"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_DECODER_INPUT>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_DECODER_INPUT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_DECODER_INPUT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_DECODER_INPUT_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_DECODER_INPUT_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_DECODER_INPUT_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_DECODER_INPUT_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_DECODER_INPUT_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_DECODER_INPUT_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_DECODER_INPUT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_DECODER_INPUT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_DECODER_INPUT_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_DECODER_INPUT_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_DECODER_INPUT_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_DECODER_INPUT_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_DECODER_INPUT_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_DECODER_INPUT_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_DECODER_INPUT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_DECODER_INPUT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_PROPERTY_SETTER_RETURN_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_PROPERTY_SETTER_RETURN
#include "ebmcodegen/default_codegen_visitor/visitor/Type_PROPERTY_SETTER_RETURN_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_PROPERTY_SETTER_RETURN"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_PROPERTY_SETTER_RETURN_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_PROPERTY_SETTER_RETURN_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_PROPERTY_SETTER_RETURN_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_PROPERTY_SETTER_RETURN_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_PROPERTY_SETTER_RETURN_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_PROPERTY_SETTER_RETURN_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_PROPERTY_SETTER_RETURN_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_PROPERTY_SETTER_RETURN_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_OPTIONAL_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_OPTIONAL>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_OPTIONAL
#include "ebmcodegen/default_codegen_visitor/visitor/Type_OPTIONAL_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_OPTIONAL"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_OPTIONAL>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_OPTIONAL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_OPTIONAL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_OPTIONAL_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_OPTIONAL_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_OPTIONAL_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_OPTIONAL_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_OPTIONAL_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_OPTIONAL_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_OPTIONAL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_OPTIONAL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_OPTIONAL_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_OPTIONAL_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_OPTIONAL_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_OPTIONAL_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_OPTIONAL_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_OPTIONAL_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_OPTIONAL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_OPTIONAL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_PTR_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_PTR>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_PTR
#include "ebmcodegen/default_codegen_visitor/visitor/Type_PTR_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_PTR"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_PTR>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_PTR>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PTR)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PTR 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_PTR>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_PTR_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_PTR_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_PTR_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_PTR_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_PTR_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_PTR_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_PTR_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_PTR_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_PTR_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_PTR_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_PTR_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_PTR_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_PTR_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_PTR_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_PTR_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_PTR_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_FUNCTION_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_FUNCTION>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_FUNCTION
#include "ebmcodegen/default_codegen_visitor/visitor/Type_FUNCTION_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_FUNCTION"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_FUNCTION>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_FUNCTION>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_FUNCTION>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_FUNCTION_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_FUNCTION_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_FUNCTION_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_FUNCTION_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_FUNCTION_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_FUNCTION_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_FUNCTION_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_FUNCTION_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_FUNCTION_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_FUNCTION_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_FUNCTION_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_FUNCTION_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_FUNCTION_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_FUNCTION_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_FUNCTION_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_FUNCTION_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_dispatch_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type
#include "ebmcodegen/default_codegen_visitor/visitor/Type_dispatch_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_before_dispatch_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_before_dispatch_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_after_dispatch_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Type_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Type_after_dispatch_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Type_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Type_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Types_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Types>>
#define CODEGEN_CONTEXT(dummy_name) Context_Types
#include "ebmcodegen/default_codegen_visitor/visitor/Types_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Types"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Types>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Types>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPES)
#define CODEGEN_EXPECTED_PRIORITY_TYPES 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Types>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Types_before_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Types_before>>
#define CODEGEN_CONTEXT(dummy_name) Context_Types_before<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Types_before_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Types_before<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Types_before>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Types_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPES_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPES_BEFORE 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Types_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Types_after_class.hpp")
#define CODEGEN_VISITOR(dummy_name) ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Types_after>>
#define CODEGEN_CONTEXT(dummy_name) Context_Types_after<Result>
#include "ebmcodegen/default_codegen_visitor/visitor/Types_after_class.hpp"
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("Context_Types_after<Result>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_CONTEXT(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_CONTEXT
#define TEMPORARY_CHECK_MACRO(x) static_assert(std::string_view(#x) == std::string_view("ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Types_after>>"))
#define PASS_TO_CHECK(x) TEMPORARY_CHECK_MACRO(x)
PASS_TO_CHECK(CODEGEN_VISITOR(dummy_name));
#undef TEMPORARY_CHECK_MACRO
#undef PASS_TO_CHECK
#undef CODEGEN_VISITOR
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Types_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPES_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPES_AFTER 4
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorHook<ebm2python::VisitorTag_Types_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/entry.hpp")
// Inlined hook for entry for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_entry>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_entry& ctx) {
        EBM2PYTHON_DECONSTRUCT_ENTRY(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/entry.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_entry>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_ENTRY)
#define CODEGEN_EXPECTED_PRIORITY_ENTRY 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_entry>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/entry_before.hpp")
// Inlined hook for entry_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_entry_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_entry_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_ENTRY_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/entry_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_entry_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_ENTRY_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_ENTRY_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_entry_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/entry_after.hpp")
// Inlined hook for entry_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_entry_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_entry_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_ENTRY_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/entry_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_entry_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_ENTRY_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_ENTRY_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_entry_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/pre_visitor.hpp")
// Inlined hook for pre_visitor for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_pre_visitor>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_pre_visitor& ctx) {
        EBM2PYTHON_DECONSTRUCT_PRE_VISITOR(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/pre_visitor.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_pre_visitor>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR)
#define CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_pre_visitor>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/pre_visitor_before.hpp")
// Inlined hook for pre_visitor_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_pre_visitor_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_pre_visitor_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_PRE_VISITOR_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/pre_visitor_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_pre_visitor_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_pre_visitor_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/pre_visitor_after.hpp")
// Inlined hook for pre_visitor_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_pre_visitor_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_pre_visitor_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_PRE_VISITOR_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/pre_visitor_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_pre_visitor_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_pre_visitor_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/post_entry.hpp")
// Inlined hook for post_entry for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_post_entry>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_post_entry<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_POST_ENTRY(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/post_entry.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_post_entry>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_POST_ENTRY)
#define CODEGEN_EXPECTED_PRIORITY_POST_ENTRY 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_post_entry>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/post_entry_before.hpp")
// Inlined hook for post_entry_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_post_entry_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_post_entry_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_POST_ENTRY_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/post_entry_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_post_entry_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_post_entry_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/post_entry_after.hpp")
// Inlined hook for post_entry_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_post_entry_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_post_entry_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_POST_ENTRY_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/post_entry_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_post_entry_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_post_entry_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_BLOCK.hpp")
// Inlined hook for Statement_BLOCK for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_BLOCK>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_BLOCK& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_BLOCK(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_BLOCK.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_BLOCK>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_BLOCK>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_BLOCK_before.hpp")
// Inlined hook for Statement_BLOCK_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_BLOCK_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_BLOCK_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_BLOCK_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_BLOCK_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_BLOCK_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_BLOCK_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_BLOCK_after.hpp")
// Inlined hook for Statement_BLOCK_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_BLOCK_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_BLOCK_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_BLOCK_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_BLOCK_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_BLOCK_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_BLOCK_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ASSIGNMENT.hpp")
// Inlined hook for Statement_ASSIGNMENT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ASSIGNMENT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ASSIGNMENT& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ASSIGNMENT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_ASSIGNMENT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ASSIGNMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ASSIGNMENT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ASSIGNMENT_before.hpp")
// Inlined hook for Statement_ASSIGNMENT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ASSIGNMENT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ASSIGNMENT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_ASSIGNMENT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ASSIGNMENT_after.hpp")
// Inlined hook for Statement_ASSIGNMENT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ASSIGNMENT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ASSIGNMENT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_ASSIGNMENT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ASSIGNMENT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_YIELD.hpp")
// Inlined hook for Statement_YIELD for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_YIELD>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_YIELD& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_YIELD(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_YIELD.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_YIELD>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_YIELD>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_YIELD_before.hpp")
// Inlined hook for Statement_YIELD_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_YIELD_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_YIELD_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_YIELD_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_YIELD_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_YIELD_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_YIELD_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_YIELD_after.hpp")
// Inlined hook for Statement_YIELD_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_YIELD_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_YIELD_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_YIELD_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_YIELD_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_YIELD_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_YIELD_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_APPEND.hpp")
// Inlined hook for Statement_APPEND for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_APPEND>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_APPEND& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_APPEND(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_APPEND.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_APPEND>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_APPEND>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_APPEND_before.hpp")
// Inlined hook for Statement_APPEND_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_APPEND_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_APPEND_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_APPEND_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_APPEND_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_APPEND_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_APPEND_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_APPEND_after.hpp")
// Inlined hook for Statement_APPEND_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_APPEND_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_APPEND_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_APPEND_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_APPEND_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_APPEND_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_APPEND_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_RETURN.hpp")
// Inlined hook for Statement_RETURN for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_RETURN>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_RETURN& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_RETURN(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_RETURN.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_RETURN>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_RETURN_before.hpp")
// Inlined hook for Statement_RETURN_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_RETURN_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_RETURN_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_RETURN_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_RETURN_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_RETURN_after.hpp")
// Inlined hook for Statement_RETURN_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_RETURN_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_RETURN_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_RETURN_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_RETURN_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ERROR_RETURN.hpp")
// Inlined hook for Statement_ERROR_RETURN for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ERROR_RETURN>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ERROR_RETURN& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ERROR_RETURN(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_ERROR_RETURN.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ERROR_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ERROR_RETURN>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ERROR_RETURN_before.hpp")
// Inlined hook for Statement_ERROR_RETURN_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ERROR_RETURN_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ERROR_RETURN_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_ERROR_RETURN_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ERROR_RETURN_after.hpp")
// Inlined hook for Statement_ERROR_RETURN_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ERROR_RETURN_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ERROR_RETURN_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_ERROR_RETURN_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ERROR_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ASSERT.hpp")
// Inlined hook for Statement_ASSERT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ASSERT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ASSERT& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ASSERT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_ASSERT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ASSERT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ASSERT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ASSERT_before.hpp")
// Inlined hook for Statement_ASSERT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ASSERT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ASSERT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ASSERT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_ASSERT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ASSERT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ASSERT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ASSERT_after.hpp")
// Inlined hook for Statement_ASSERT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ASSERT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ASSERT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ASSERT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_ASSERT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ASSERT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ASSERT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_READ_DATA.hpp")
// Inlined hook for Statement_READ_DATA for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_READ_DATA>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_READ_DATA& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_READ_DATA(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_READ_DATA.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_READ_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_READ_DATA>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_READ_DATA_before.hpp")
// Inlined hook for Statement_READ_DATA_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_READ_DATA_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_READ_DATA_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_READ_DATA_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_READ_DATA_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_READ_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_READ_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_READ_DATA_after.hpp")
// Inlined hook for Statement_READ_DATA_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_READ_DATA_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_READ_DATA_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_READ_DATA_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_READ_DATA_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_READ_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_READ_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_WRITE_DATA.hpp")
// Inlined hook for Statement_WRITE_DATA for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_WRITE_DATA>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_WRITE_DATA& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_WRITE_DATA(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_WRITE_DATA.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_WRITE_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_WRITE_DATA>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_WRITE_DATA_before.hpp")
// Inlined hook for Statement_WRITE_DATA_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_WRITE_DATA_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_WRITE_DATA_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_WRITE_DATA_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_WRITE_DATA_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_WRITE_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_WRITE_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_WRITE_DATA_after.hpp")
// Inlined hook for Statement_WRITE_DATA_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_WRITE_DATA_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_WRITE_DATA_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_WRITE_DATA_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_WRITE_DATA_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_WRITE_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_WRITE_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_RESERVE_DATA.hpp")
// Inlined hook for Statement_RESERVE_DATA for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_RESERVE_DATA>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_RESERVE_DATA& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_RESERVE_DATA(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_RESERVE_DATA.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_RESERVE_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_RESERVE_DATA>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_RESERVE_DATA_before.hpp")
// Inlined hook for Statement_RESERVE_DATA_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_RESERVE_DATA_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_RESERVE_DATA_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_RESERVE_DATA_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_RESERVE_DATA_after.hpp")
// Inlined hook for Statement_RESERVE_DATA_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_RESERVE_DATA_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_RESERVE_DATA_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_RESERVE_DATA_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_RESERVE_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_IF_STATEMENT.hpp")
// Inlined hook for Statement_IF_STATEMENT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_IF_STATEMENT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_IF_STATEMENT& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_IF_STATEMENT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_IF_STATEMENT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_IF_STATEMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_IF_STATEMENT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_IF_STATEMENT_before.hpp")
// Inlined hook for Statement_IF_STATEMENT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_IF_STATEMENT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_IF_STATEMENT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_IF_STATEMENT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_IF_STATEMENT_after.hpp")
// Inlined hook for Statement_IF_STATEMENT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_IF_STATEMENT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_IF_STATEMENT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_IF_STATEMENT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_IF_STATEMENT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_LOOP_STATEMENT.hpp")
// Inlined hook for Statement_LOOP_STATEMENT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_LOOP_STATEMENT& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_LOOP_STATEMENT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_LOOP_STATEMENT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_LOOP_STATEMENT_before.hpp")
// Inlined hook for Statement_LOOP_STATEMENT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_LOOP_STATEMENT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_LOOP_STATEMENT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_LOOP_STATEMENT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_LOOP_STATEMENT_after.hpp")
// Inlined hook for Statement_LOOP_STATEMENT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_LOOP_STATEMENT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_LOOP_STATEMENT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_LOOP_STATEMENT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_LOOP_STATEMENT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_MATCH_STATEMENT.hpp")
// Inlined hook for Statement_MATCH_STATEMENT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_MATCH_STATEMENT& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_MATCH_STATEMENT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_MATCH_STATEMENT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_MATCH_STATEMENT_before.hpp")
// Inlined hook for Statement_MATCH_STATEMENT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_MATCH_STATEMENT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_MATCH_STATEMENT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_MATCH_STATEMENT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_MATCH_STATEMENT_after.hpp")
// Inlined hook for Statement_MATCH_STATEMENT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_MATCH_STATEMENT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_MATCH_STATEMENT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_MATCH_STATEMENT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_MATCH_STATEMENT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_MATCH_BRANCH.hpp")
// Inlined hook for Statement_MATCH_BRANCH for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_MATCH_BRANCH& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_MATCH_BRANCH(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_MATCH_BRANCH.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_MATCH_BRANCH_before.hpp")
// Inlined hook for Statement_MATCH_BRANCH_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_MATCH_BRANCH_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_MATCH_BRANCH_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_MATCH_BRANCH_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_MATCH_BRANCH_after.hpp")
// Inlined hook for Statement_MATCH_BRANCH_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_MATCH_BRANCH_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_MATCH_BRANCH_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_MATCH_BRANCH_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_MATCH_BRANCH_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_BREAK.hpp")
// Inlined hook for Statement_BREAK for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_BREAK>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_BREAK& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_BREAK(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_BREAK.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_BREAK>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_BREAK>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_BREAK_before.hpp")
// Inlined hook for Statement_BREAK_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_BREAK_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_BREAK_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_BREAK_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_BREAK_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_BREAK_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_BREAK_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_BREAK_after.hpp")
// Inlined hook for Statement_BREAK_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_BREAK_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_BREAK_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_BREAK_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_BREAK_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_BREAK_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_BREAK_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_CONTINUE.hpp")
// Inlined hook for Statement_CONTINUE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_CONTINUE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_CONTINUE& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_CONTINUE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_CONTINUE.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_CONTINUE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_CONTINUE>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_CONTINUE_before.hpp")
// Inlined hook for Statement_CONTINUE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_CONTINUE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_CONTINUE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_CONTINUE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_CONTINUE_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_CONTINUE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_CONTINUE_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_CONTINUE_after.hpp")
// Inlined hook for Statement_CONTINUE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_CONTINUE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_CONTINUE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_CONTINUE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_CONTINUE_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_CONTINUE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_CONTINUE_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_FUNCTION_DECL.hpp")
// Inlined hook for Statement_FUNCTION_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_FUNCTION_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_FUNCTION_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_FUNCTION_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_FUNCTION_DECL_before.hpp")
// Inlined hook for Statement_FUNCTION_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_FUNCTION_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_FUNCTION_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_FUNCTION_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_FUNCTION_DECL_after.hpp")
// Inlined hook for Statement_FUNCTION_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_FUNCTION_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_FUNCTION_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_FUNCTION_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_FUNCTION_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_VARIABLE_DECL.hpp")
// Inlined hook for Statement_VARIABLE_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_VARIABLE_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_VARIABLE_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_VARIABLE_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_VARIABLE_DECL_before.hpp")
// Inlined hook for Statement_VARIABLE_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_VARIABLE_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_VARIABLE_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_VARIABLE_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_VARIABLE_DECL_after.hpp")
// Inlined hook for Statement_VARIABLE_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_VARIABLE_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_VARIABLE_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_VARIABLE_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_VARIABLE_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_PARAMETER_DECL.hpp")
// Inlined hook for Statement_PARAMETER_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PARAMETER_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PARAMETER_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_PARAMETER_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_PARAMETER_DECL_before.hpp")
// Inlined hook for Statement_PARAMETER_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PARAMETER_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PARAMETER_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_PARAMETER_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_PARAMETER_DECL_after.hpp")
// Inlined hook for Statement_PARAMETER_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PARAMETER_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PARAMETER_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_PARAMETER_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PARAMETER_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_FIELD_DECL.hpp")
// Inlined hook for Statement_FIELD_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_FIELD_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_FIELD_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_FIELD_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_FIELD_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_FIELD_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_FIELD_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_FIELD_DECL_before.hpp")
// Inlined hook for Statement_FIELD_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_FIELD_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_FIELD_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_FIELD_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_FIELD_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_FIELD_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_FIELD_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_FIELD_DECL_after.hpp")
// Inlined hook for Statement_FIELD_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_FIELD_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_FIELD_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_FIELD_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_FIELD_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_FIELD_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_FIELD_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_COMPOSITE_FIELD_DECL.hpp")
// Inlined hook for Statement_COMPOSITE_FIELD_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_COMPOSITE_FIELD_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_COMPOSITE_FIELD_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_COMPOSITE_FIELD_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_COMPOSITE_FIELD_DECL_before.hpp")
// Inlined hook for Statement_COMPOSITE_FIELD_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_COMPOSITE_FIELD_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_COMPOSITE_FIELD_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_COMPOSITE_FIELD_DECL_after.hpp")
// Inlined hook for Statement_COMPOSITE_FIELD_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_COMPOSITE_FIELD_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_COMPOSITE_FIELD_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_COMPOSITE_FIELD_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ENUM_DECL.hpp")
// Inlined hook for Statement_ENUM_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENUM_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENUM_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENUM_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_ENUM_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENUM_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENUM_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ENUM_DECL_before.hpp")
// Inlined hook for Statement_ENUM_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENUM_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENUM_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENUM_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_ENUM_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENUM_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENUM_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ENUM_DECL_after.hpp")
// Inlined hook for Statement_ENUM_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENUM_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENUM_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENUM_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_ENUM_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENUM_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENUM_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ENUM_MEMBER_DECL.hpp")
// Inlined hook for Statement_ENUM_MEMBER_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENUM_MEMBER_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENUM_MEMBER_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_ENUM_MEMBER_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ENUM_MEMBER_DECL_before.hpp")
// Inlined hook for Statement_ENUM_MEMBER_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENUM_MEMBER_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENUM_MEMBER_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_ENUM_MEMBER_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ENUM_MEMBER_DECL_after.hpp")
// Inlined hook for Statement_ENUM_MEMBER_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENUM_MEMBER_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENUM_MEMBER_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_ENUM_MEMBER_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENUM_MEMBER_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_STRUCT_DECL.hpp")
// Inlined hook for Statement_STRUCT_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_STRUCT_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_STRUCT_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_STRUCT_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_STRUCT_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_STRUCT_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_STRUCT_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_STRUCT_DECL_before.hpp")
// Inlined hook for Statement_STRUCT_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_STRUCT_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_STRUCT_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_STRUCT_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_STRUCT_DECL_after.hpp")
// Inlined hook for Statement_STRUCT_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_STRUCT_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_STRUCT_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_STRUCT_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_STRUCT_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_UNION_DECL.hpp")
// Inlined hook for Statement_UNION_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_UNION_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_UNION_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_UNION_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_UNION_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_UNION_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_UNION_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_UNION_DECL_before.hpp")
// Inlined hook for Statement_UNION_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_UNION_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_UNION_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_UNION_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_UNION_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_UNION_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_UNION_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_UNION_DECL_after.hpp")
// Inlined hook for Statement_UNION_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_UNION_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_UNION_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_UNION_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_UNION_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_UNION_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_UNION_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_UNION_MEMBER_DECL.hpp")
// Inlined hook for Statement_UNION_MEMBER_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_UNION_MEMBER_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_UNION_MEMBER_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_UNION_MEMBER_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_UNION_MEMBER_DECL_before.hpp")
// Inlined hook for Statement_UNION_MEMBER_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_UNION_MEMBER_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_UNION_MEMBER_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_UNION_MEMBER_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_UNION_MEMBER_DECL_after.hpp")
// Inlined hook for Statement_UNION_MEMBER_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_UNION_MEMBER_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_UNION_MEMBER_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_UNION_MEMBER_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_UNION_MEMBER_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_PROGRAM_DECL.hpp")
// Inlined hook for Statement_PROGRAM_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROGRAM_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROGRAM_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_PROGRAM_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_PROGRAM_DECL_before.hpp")
// Inlined hook for Statement_PROGRAM_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROGRAM_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROGRAM_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_PROGRAM_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_PROGRAM_DECL_after.hpp")
// Inlined hook for Statement_PROGRAM_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROGRAM_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROGRAM_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_PROGRAM_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROGRAM_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_PROPERTY_DECL.hpp")
// Inlined hook for Statement_PROPERTY_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROPERTY_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROPERTY_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_PROPERTY_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_PROPERTY_DECL_before.hpp")
// Inlined hook for Statement_PROPERTY_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROPERTY_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROPERTY_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_PROPERTY_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_PROPERTY_DECL_after.hpp")
// Inlined hook for Statement_PROPERTY_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROPERTY_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROPERTY_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_PROPERTY_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_PROPERTY_MEMBER_DECL.hpp")
// Inlined hook for Statement_PROPERTY_MEMBER_DECL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROPERTY_MEMBER_DECL& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROPERTY_MEMBER_DECL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_PROPERTY_MEMBER_DECL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_PROPERTY_MEMBER_DECL_before.hpp")
// Inlined hook for Statement_PROPERTY_MEMBER_DECL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROPERTY_MEMBER_DECL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_PROPERTY_MEMBER_DECL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_PROPERTY_MEMBER_DECL_after.hpp")
// Inlined hook for Statement_PROPERTY_MEMBER_DECL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_PROPERTY_MEMBER_DECL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_PROPERTY_MEMBER_DECL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_PROPERTY_MEMBER_DECL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_METADATA.hpp")
// Inlined hook for Statement_METADATA for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_METADATA>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_METADATA& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_METADATA(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_METADATA.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_METADATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_METADATA>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_METADATA_before.hpp")
// Inlined hook for Statement_METADATA_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_METADATA_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_METADATA_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_METADATA_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_METADATA_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_METADATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_METADATA_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_METADATA_after.hpp")
// Inlined hook for Statement_METADATA_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_METADATA_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_METADATA_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_METADATA_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_METADATA_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_METADATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_METADATA_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_IMPORT_MODULE.hpp")
// Inlined hook for Statement_IMPORT_MODULE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_IMPORT_MODULE& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_IMPORT_MODULE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_IMPORT_MODULE.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_IMPORT_MODULE_before.hpp")
// Inlined hook for Statement_IMPORT_MODULE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_IMPORT_MODULE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_IMPORT_MODULE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_IMPORT_MODULE_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_IMPORT_MODULE_after.hpp")
// Inlined hook for Statement_IMPORT_MODULE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_IMPORT_MODULE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_IMPORT_MODULE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_IMPORT_MODULE_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_IMPORT_MODULE_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_EXPRESSION.hpp")
// Inlined hook for Statement_EXPRESSION for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_EXPRESSION>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_EXPRESSION& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_EXPRESSION(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_EXPRESSION.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_EXPRESSION>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_EXPRESSION>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_EXPRESSION_before.hpp")
// Inlined hook for Statement_EXPRESSION_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_EXPRESSION_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_EXPRESSION_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_EXPRESSION_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_EXPRESSION_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_EXPRESSION_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_EXPRESSION_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_EXPRESSION_after.hpp")
// Inlined hook for Statement_EXPRESSION_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_EXPRESSION_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_EXPRESSION_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_EXPRESSION_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_EXPRESSION_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_EXPRESSION_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_EXPRESSION_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ERROR_REPORT.hpp")
// Inlined hook for Statement_ERROR_REPORT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ERROR_REPORT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ERROR_REPORT& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ERROR_REPORT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_ERROR_REPORT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ERROR_REPORT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ERROR_REPORT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ERROR_REPORT_before.hpp")
// Inlined hook for Statement_ERROR_REPORT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ERROR_REPORT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ERROR_REPORT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_ERROR_REPORT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ERROR_REPORT_after.hpp")
// Inlined hook for Statement_ERROR_REPORT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ERROR_REPORT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ERROR_REPORT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_ERROR_REPORT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ERROR_REPORT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_LOWERED_IO_STATEMENTS.hpp")
// Inlined hook for Statement_LOWERED_IO_STATEMENTS for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_LOWERED_IO_STATEMENTS& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_LOWERED_IO_STATEMENTS(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_LOWERED_IO_STATEMENTS.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_LOWERED_IO_STATEMENTS_before.hpp")
// Inlined hook for Statement_LOWERED_IO_STATEMENTS_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_LOWERED_IO_STATEMENTS_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_LOWERED_IO_STATEMENTS_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_LOWERED_IO_STATEMENTS_after.hpp")
// Inlined hook for Statement_LOWERED_IO_STATEMENTS_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_LOWERED_IO_STATEMENTS_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_LOWERED_IO_STATEMENTS_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_LOWERED_IO_STATEMENTS_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_SUB_BYTE_RANGE.hpp")
// Inlined hook for Statement_SUB_BYTE_RANGE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_SUB_BYTE_RANGE& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_SUB_BYTE_RANGE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_SUB_BYTE_RANGE.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_SUB_BYTE_RANGE_before.hpp")
// Inlined hook for Statement_SUB_BYTE_RANGE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_SUB_BYTE_RANGE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_SUB_BYTE_RANGE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_SUB_BYTE_RANGE_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_SUB_BYTE_RANGE_after.hpp")
// Inlined hook for Statement_SUB_BYTE_RANGE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_SUB_BYTE_RANGE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_SUB_BYTE_RANGE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_SUB_BYTE_RANGE_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_SUB_BYTE_RANGE_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_INIT_CHECK.hpp")
// Inlined hook for Statement_INIT_CHECK for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_INIT_CHECK>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_INIT_CHECK& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_INIT_CHECK(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_INIT_CHECK.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_INIT_CHECK>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_INIT_CHECK>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_INIT_CHECK_before.hpp")
// Inlined hook for Statement_INIT_CHECK_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_INIT_CHECK_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_INIT_CHECK_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_INIT_CHECK_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_INIT_CHECK_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_INIT_CHECK_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_INIT_CHECK_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_INIT_CHECK_after.hpp")
// Inlined hook for Statement_INIT_CHECK_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_INIT_CHECK_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_INIT_CHECK_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_INIT_CHECK_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_INIT_CHECK_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_INIT_CHECK_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_INIT_CHECK_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ENDIAN_VARIABLE.hpp")
// Inlined hook for Statement_ENDIAN_VARIABLE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENDIAN_VARIABLE& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENDIAN_VARIABLE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_ENDIAN_VARIABLE.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ENDIAN_VARIABLE_before.hpp")
// Inlined hook for Statement_ENDIAN_VARIABLE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENDIAN_VARIABLE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENDIAN_VARIABLE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_ENDIAN_VARIABLE_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_ENDIAN_VARIABLE_after.hpp")
// Inlined hook for Statement_ENDIAN_VARIABLE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_ENDIAN_VARIABLE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_ENDIAN_VARIABLE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_ENDIAN_VARIABLE_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_ENDIAN_VARIABLE_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_dispatch.hpp")
// Inlined hook for Statement for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_dispatch.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_before_dispatch.hpp")
// Inlined hook for Statement_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_before_dispatch.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Statement_after_dispatch.hpp")
// Inlined hook for Statement_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Statement_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_STATEMENT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Statement_after_dispatch.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_STATEMENT_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Statement_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Block.hpp")
// Inlined hook for Block for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Block>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Block& ctx) {
        EBM2PYTHON_DECONSTRUCT_BLOCK(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Block.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Block>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_BLOCK)
#define CODEGEN_EXPECTED_PRIORITY_BLOCK 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Block>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Block_before.hpp")
// Inlined hook for Block_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Block_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Block_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_BLOCK_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Block_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Block_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_BLOCK_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_BLOCK_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Block_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Block_after.hpp")
// Inlined hook for Block_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Block_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Block_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_BLOCK_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Block_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Block_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_BLOCK_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_BLOCK_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Block_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_INT.hpp")
// Inlined hook for Expression_LITERAL_INT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_INT& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_INT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_INT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_INT_before.hpp")
// Inlined hook for Expression_LITERAL_INT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_INT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_INT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_INT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_INT_after.hpp")
// Inlined hook for Expression_LITERAL_INT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_INT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_INT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_INT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_INT64.hpp")
// Inlined hook for Expression_LITERAL_INT64 for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT64>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_INT64& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_INT64(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_INT64.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT64>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT64>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_INT64_before.hpp")
// Inlined hook for Expression_LITERAL_INT64_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_INT64_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_INT64_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_INT64_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_INT64_after.hpp")
// Inlined hook for Expression_LITERAL_INT64_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_INT64_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_INT64_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_INT64_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_INT64_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_BOOL.hpp")
// Inlined hook for Expression_LITERAL_BOOL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_BOOL& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_BOOL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_BOOL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_BOOL_before.hpp")
// Inlined hook for Expression_LITERAL_BOOL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_BOOL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_BOOL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_BOOL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_BOOL_after.hpp")
// Inlined hook for Expression_LITERAL_BOOL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_BOOL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_BOOL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_BOOL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_BOOL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_STRING.hpp")
// Inlined hook for Expression_LITERAL_STRING for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_STRING>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_STRING& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_STRING(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_STRING.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_STRING>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_STRING>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_STRING_before.hpp")
// Inlined hook for Expression_LITERAL_STRING_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_STRING_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_STRING_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_STRING_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_STRING_after.hpp")
// Inlined hook for Expression_LITERAL_STRING_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_STRING_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_STRING_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_STRING_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_STRING_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_TYPE.hpp")
// Inlined hook for Expression_LITERAL_TYPE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_TYPE& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_TYPE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_TYPE.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_TYPE_before.hpp")
// Inlined hook for Expression_LITERAL_TYPE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_TYPE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_TYPE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_TYPE_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_TYPE_after.hpp")
// Inlined hook for Expression_LITERAL_TYPE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_TYPE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_TYPE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_TYPE_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_TYPE_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_CHAR.hpp")
// Inlined hook for Expression_LITERAL_CHAR for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_CHAR& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_CHAR(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_CHAR.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_CHAR_before.hpp")
// Inlined hook for Expression_LITERAL_CHAR_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_CHAR_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_CHAR_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_CHAR_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_CHAR_after.hpp")
// Inlined hook for Expression_LITERAL_CHAR_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_LITERAL_CHAR_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_LITERAL_CHAR_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_LITERAL_CHAR_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_LITERAL_CHAR_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_IDENTIFIER.hpp")
// Inlined hook for Expression_IDENTIFIER for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IDENTIFIER>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IDENTIFIER& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IDENTIFIER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_IDENTIFIER.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IDENTIFIER>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IDENTIFIER>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_IDENTIFIER_before.hpp")
// Inlined hook for Expression_IDENTIFIER_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IDENTIFIER_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IDENTIFIER_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IDENTIFIER_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_IDENTIFIER_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IDENTIFIER_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IDENTIFIER_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_IDENTIFIER_after.hpp")
// Inlined hook for Expression_IDENTIFIER_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IDENTIFIER_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IDENTIFIER_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IDENTIFIER_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_IDENTIFIER_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IDENTIFIER_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IDENTIFIER_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_BINARY_OP.hpp")
// Inlined hook for Expression_BINARY_OP for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_BINARY_OP>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_BINARY_OP& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_BINARY_OP(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_BINARY_OP.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_BINARY_OP>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_BINARY_OP>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_BINARY_OP_before.hpp")
// Inlined hook for Expression_BINARY_OP_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_BINARY_OP_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_BINARY_OP_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_BINARY_OP_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_BINARY_OP_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_BINARY_OP_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_BINARY_OP_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_BINARY_OP_after.hpp")
// Inlined hook for Expression_BINARY_OP_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_BINARY_OP_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_BINARY_OP_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_BINARY_OP_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_BINARY_OP_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_BINARY_OP_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_BINARY_OP_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_UNARY_OP.hpp")
// Inlined hook for Expression_UNARY_OP for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_UNARY_OP>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_UNARY_OP& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_UNARY_OP(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_UNARY_OP.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_UNARY_OP>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_UNARY_OP>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_UNARY_OP_before.hpp")
// Inlined hook for Expression_UNARY_OP_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_UNARY_OP_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_UNARY_OP_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_UNARY_OP_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_UNARY_OP_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_UNARY_OP_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_UNARY_OP_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_UNARY_OP_after.hpp")
// Inlined hook for Expression_UNARY_OP_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_UNARY_OP_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_UNARY_OP_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_UNARY_OP_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_UNARY_OP_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_UNARY_OP_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_UNARY_OP_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_CALL.hpp")
// Inlined hook for Expression_CALL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CALL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CALL& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CALL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_CALL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CALL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CALL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_CALL_before.hpp")
// Inlined hook for Expression_CALL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CALL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CALL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CALL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_CALL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CALL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CALL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_CALL_after.hpp")
// Inlined hook for Expression_CALL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CALL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CALL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CALL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_CALL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CALL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CALL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_INDEX_ACCESS.hpp")
// Inlined hook for Expression_INDEX_ACCESS for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_INDEX_ACCESS& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_INDEX_ACCESS(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_INDEX_ACCESS.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_INDEX_ACCESS_before.hpp")
// Inlined hook for Expression_INDEX_ACCESS_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_INDEX_ACCESS_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_INDEX_ACCESS_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_INDEX_ACCESS_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_INDEX_ACCESS_after.hpp")
// Inlined hook for Expression_INDEX_ACCESS_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_INDEX_ACCESS_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_INDEX_ACCESS_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_INDEX_ACCESS_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_INDEX_ACCESS_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_MEMBER_ACCESS.hpp")
// Inlined hook for Expression_MEMBER_ACCESS for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_MEMBER_ACCESS& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_MEMBER_ACCESS(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_MEMBER_ACCESS.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_MEMBER_ACCESS_before.hpp")
// Inlined hook for Expression_MEMBER_ACCESS_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_MEMBER_ACCESS_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_MEMBER_ACCESS_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_MEMBER_ACCESS_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_MEMBER_ACCESS_after.hpp")
// Inlined hook for Expression_MEMBER_ACCESS_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_MEMBER_ACCESS_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_MEMBER_ACCESS_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_MEMBER_ACCESS_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_MEMBER_ACCESS_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_ENUM_MEMBER.hpp")
// Inlined hook for Expression_ENUM_MEMBER for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ENUM_MEMBER& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ENUM_MEMBER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_ENUM_MEMBER.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_ENUM_MEMBER_before.hpp")
// Inlined hook for Expression_ENUM_MEMBER_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ENUM_MEMBER_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ENUM_MEMBER_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_ENUM_MEMBER_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_ENUM_MEMBER_after.hpp")
// Inlined hook for Expression_ENUM_MEMBER_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ENUM_MEMBER_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ENUM_MEMBER_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_ENUM_MEMBER_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ENUM_MEMBER_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_TYPE_CAST.hpp")
// Inlined hook for Expression_TYPE_CAST for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_TYPE_CAST>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_TYPE_CAST& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_TYPE_CAST(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_TYPE_CAST.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_TYPE_CAST>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_TYPE_CAST>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_TYPE_CAST_before.hpp")
// Inlined hook for Expression_TYPE_CAST_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_TYPE_CAST_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_TYPE_CAST_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_TYPE_CAST_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_TYPE_CAST_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_TYPE_CAST_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_TYPE_CAST_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_TYPE_CAST_after.hpp")
// Inlined hook for Expression_TYPE_CAST_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_TYPE_CAST_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_TYPE_CAST_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_TYPE_CAST_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_TYPE_CAST_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_TYPE_CAST_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_TYPE_CAST_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_RANGE.hpp")
// Inlined hook for Expression_RANGE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_RANGE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_RANGE& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_RANGE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_RANGE.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_RANGE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_RANGE>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_RANGE_before.hpp")
// Inlined hook for Expression_RANGE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_RANGE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_RANGE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_RANGE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_RANGE_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_RANGE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_RANGE_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_RANGE_after.hpp")
// Inlined hook for Expression_RANGE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_RANGE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_RANGE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_RANGE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_RANGE_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_RANGE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_RANGE_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_DEFAULT_VALUE.hpp")
// Inlined hook for Expression_DEFAULT_VALUE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_DEFAULT_VALUE& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_DEFAULT_VALUE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_DEFAULT_VALUE.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_DEFAULT_VALUE_before.hpp")
// Inlined hook for Expression_DEFAULT_VALUE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_DEFAULT_VALUE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_DEFAULT_VALUE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_DEFAULT_VALUE_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_DEFAULT_VALUE_after.hpp")
// Inlined hook for Expression_DEFAULT_VALUE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_DEFAULT_VALUE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_DEFAULT_VALUE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_DEFAULT_VALUE_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_DEFAULT_VALUE_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_IS_LITTLE_ENDIAN.hpp")
// Inlined hook for Expression_IS_LITTLE_ENDIAN for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IS_LITTLE_ENDIAN& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IS_LITTLE_ENDIAN(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_IS_LITTLE_ENDIAN.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_IS_LITTLE_ENDIAN_before.hpp")
// Inlined hook for Expression_IS_LITTLE_ENDIAN_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IS_LITTLE_ENDIAN_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_IS_LITTLE_ENDIAN_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_IS_LITTLE_ENDIAN_after.hpp")
// Inlined hook for Expression_IS_LITTLE_ENDIAN_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IS_LITTLE_ENDIAN_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IS_LITTLE_ENDIAN_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_IS_LITTLE_ENDIAN_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IS_LITTLE_ENDIAN_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_GET_STREAM_OFFSET.hpp")
// Inlined hook for Expression_GET_STREAM_OFFSET for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_GET_STREAM_OFFSET& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_GET_STREAM_OFFSET(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_GET_STREAM_OFFSET.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_GET_STREAM_OFFSET_before.hpp")
// Inlined hook for Expression_GET_STREAM_OFFSET_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_GET_STREAM_OFFSET_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_GET_STREAM_OFFSET_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_GET_STREAM_OFFSET_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_GET_STREAM_OFFSET_after.hpp")
// Inlined hook for Expression_GET_STREAM_OFFSET_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_GET_STREAM_OFFSET_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_GET_STREAM_OFFSET_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_GET_STREAM_OFFSET_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_GET_STREAM_OFFSET_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_GET_REMAINING_BYTES.hpp")
// Inlined hook for Expression_GET_REMAINING_BYTES for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_GET_REMAINING_BYTES& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_GET_REMAINING_BYTES(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_GET_REMAINING_BYTES.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_GET_REMAINING_BYTES_before.hpp")
// Inlined hook for Expression_GET_REMAINING_BYTES_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_GET_REMAINING_BYTES_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_GET_REMAINING_BYTES_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_GET_REMAINING_BYTES_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_GET_REMAINING_BYTES_after.hpp")
// Inlined hook for Expression_GET_REMAINING_BYTES_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_GET_REMAINING_BYTES_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_GET_REMAINING_BYTES_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_GET_REMAINING_BYTES_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_GET_REMAINING_BYTES_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_CAN_READ_STREAM.hpp")
// Inlined hook for Expression_CAN_READ_STREAM for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CAN_READ_STREAM& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CAN_READ_STREAM(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_CAN_READ_STREAM.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_CAN_READ_STREAM_before.hpp")
// Inlined hook for Expression_CAN_READ_STREAM_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CAN_READ_STREAM_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CAN_READ_STREAM_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_CAN_READ_STREAM_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_CAN_READ_STREAM_after.hpp")
// Inlined hook for Expression_CAN_READ_STREAM_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CAN_READ_STREAM_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CAN_READ_STREAM_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_CAN_READ_STREAM_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CAN_READ_STREAM_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_ARRAY_SIZE.hpp")
// Inlined hook for Expression_ARRAY_SIZE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ARRAY_SIZE& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ARRAY_SIZE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_ARRAY_SIZE.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_ARRAY_SIZE_before.hpp")
// Inlined hook for Expression_ARRAY_SIZE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ARRAY_SIZE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ARRAY_SIZE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_ARRAY_SIZE_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_ARRAY_SIZE_after.hpp")
// Inlined hook for Expression_ARRAY_SIZE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ARRAY_SIZE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ARRAY_SIZE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_ARRAY_SIZE_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ARRAY_SIZE_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_ENUM_IS_DEFINED.hpp")
// Inlined hook for Expression_ENUM_IS_DEFINED for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ENUM_IS_DEFINED& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ENUM_IS_DEFINED(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_ENUM_IS_DEFINED.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_ENUM_IS_DEFINED_before.hpp")
// Inlined hook for Expression_ENUM_IS_DEFINED_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ENUM_IS_DEFINED_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ENUM_IS_DEFINED_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_ENUM_IS_DEFINED_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_ENUM_IS_DEFINED_after.hpp")
// Inlined hook for Expression_ENUM_IS_DEFINED_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ENUM_IS_DEFINED_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ENUM_IS_DEFINED_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_ENUM_IS_DEFINED_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ENUM_IS_DEFINED_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_IS_ERROR.hpp")
// Inlined hook for Expression_IS_ERROR for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IS_ERROR>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IS_ERROR& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IS_ERROR(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_IS_ERROR.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IS_ERROR>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IS_ERROR>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_IS_ERROR_before.hpp")
// Inlined hook for Expression_IS_ERROR_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IS_ERROR_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IS_ERROR_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IS_ERROR_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_IS_ERROR_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IS_ERROR_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IS_ERROR_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_IS_ERROR_after.hpp")
// Inlined hook for Expression_IS_ERROR_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IS_ERROR_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_IS_ERROR_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_IS_ERROR_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_IS_ERROR_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IS_ERROR_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_IS_ERROR_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_MAX_VALUE.hpp")
// Inlined hook for Expression_MAX_VALUE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_MAX_VALUE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_MAX_VALUE& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_MAX_VALUE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_MAX_VALUE.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_MAX_VALUE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_MAX_VALUE>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_MAX_VALUE_before.hpp")
// Inlined hook for Expression_MAX_VALUE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_MAX_VALUE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_MAX_VALUE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_MAX_VALUE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_MAX_VALUE_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_MAX_VALUE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_MAX_VALUE_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_MAX_VALUE_after.hpp")
// Inlined hook for Expression_MAX_VALUE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_MAX_VALUE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_MAX_VALUE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_MAX_VALUE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_MAX_VALUE_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_MAX_VALUE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_MAX_VALUE_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_READ_DATA.hpp")
// Inlined hook for Expression_READ_DATA for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_READ_DATA>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_READ_DATA& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_READ_DATA(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_READ_DATA.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_READ_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_READ_DATA>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_READ_DATA_before.hpp")
// Inlined hook for Expression_READ_DATA_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_READ_DATA_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_READ_DATA_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_READ_DATA_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_READ_DATA_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_READ_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_READ_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_READ_DATA_after.hpp")
// Inlined hook for Expression_READ_DATA_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_READ_DATA_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_READ_DATA_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_READ_DATA_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_READ_DATA_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_READ_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_READ_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_WRITE_DATA.hpp")
// Inlined hook for Expression_WRITE_DATA for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_WRITE_DATA>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_WRITE_DATA& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_WRITE_DATA(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_WRITE_DATA.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_WRITE_DATA>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_WRITE_DATA>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_WRITE_DATA_before.hpp")
// Inlined hook for Expression_WRITE_DATA_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_WRITE_DATA_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_WRITE_DATA_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_WRITE_DATA_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_WRITE_DATA_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_WRITE_DATA_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_WRITE_DATA_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_WRITE_DATA_after.hpp")
// Inlined hook for Expression_WRITE_DATA_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_WRITE_DATA_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_WRITE_DATA_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_WRITE_DATA_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_WRITE_DATA_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_WRITE_DATA_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_WRITE_DATA_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_CONDITIONAL_STATEMENT.hpp")
// Inlined hook for Expression_CONDITIONAL_STATEMENT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CONDITIONAL_STATEMENT& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CONDITIONAL_STATEMENT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_CONDITIONAL_STATEMENT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_CONDITIONAL_STATEMENT_before.hpp")
// Inlined hook for Expression_CONDITIONAL_STATEMENT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CONDITIONAL_STATEMENT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_CONDITIONAL_STATEMENT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_CONDITIONAL_STATEMENT_after.hpp")
// Inlined hook for Expression_CONDITIONAL_STATEMENT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CONDITIONAL_STATEMENT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CONDITIONAL_STATEMENT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_CONDITIONAL_STATEMENT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_STATEMENT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_CONDITIONAL.hpp")
// Inlined hook for Expression_CONDITIONAL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CONDITIONAL& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CONDITIONAL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_CONDITIONAL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_CONDITIONAL_before.hpp")
// Inlined hook for Expression_CONDITIONAL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CONDITIONAL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CONDITIONAL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_CONDITIONAL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_CONDITIONAL_after.hpp")
// Inlined hook for Expression_CONDITIONAL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_CONDITIONAL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_CONDITIONAL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_CONDITIONAL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_CONDITIONAL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_AVAILABLE.hpp")
// Inlined hook for Expression_AVAILABLE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_AVAILABLE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_AVAILABLE& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_AVAILABLE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_AVAILABLE.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_AVAILABLE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_AVAILABLE>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_AVAILABLE_before.hpp")
// Inlined hook for Expression_AVAILABLE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_AVAILABLE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_AVAILABLE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_AVAILABLE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_AVAILABLE_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_AVAILABLE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_AVAILABLE_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_AVAILABLE_after.hpp")
// Inlined hook for Expression_AVAILABLE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_AVAILABLE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_AVAILABLE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_AVAILABLE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_AVAILABLE_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_AVAILABLE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_AVAILABLE_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_SIZEOF.hpp")
// Inlined hook for Expression_SIZEOF for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SIZEOF>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SIZEOF& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SIZEOF(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_SIZEOF.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SIZEOF>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SIZEOF>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_SIZEOF_before.hpp")
// Inlined hook for Expression_SIZEOF_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SIZEOF_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SIZEOF_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SIZEOF_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_SIZEOF_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SIZEOF_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SIZEOF_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_SIZEOF_after.hpp")
// Inlined hook for Expression_SIZEOF_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SIZEOF_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SIZEOF_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SIZEOF_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_SIZEOF_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SIZEOF_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SIZEOF_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_SUB_RANGE_INIT.hpp")
// Inlined hook for Expression_SUB_RANGE_INIT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SUB_RANGE_INIT& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SUB_RANGE_INIT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_SUB_RANGE_INIT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_SUB_RANGE_INIT_before.hpp")
// Inlined hook for Expression_SUB_RANGE_INIT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SUB_RANGE_INIT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SUB_RANGE_INIT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_SUB_RANGE_INIT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_SUB_RANGE_INIT_after.hpp")
// Inlined hook for Expression_SUB_RANGE_INIT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SUB_RANGE_INIT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SUB_RANGE_INIT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_SUB_RANGE_INIT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SUB_RANGE_INIT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_OR_COND.hpp")
// Inlined hook for Expression_OR_COND for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_OR_COND>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_OR_COND& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_OR_COND(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_OR_COND.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_OR_COND>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_OR_COND>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_OR_COND_before.hpp")
// Inlined hook for Expression_OR_COND_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_OR_COND_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_OR_COND_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_OR_COND_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_OR_COND_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_OR_COND_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_OR_COND_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_OR_COND_after.hpp")
// Inlined hook for Expression_OR_COND_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_OR_COND_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_OR_COND_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_OR_COND_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_OR_COND_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_OR_COND_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_OR_COND_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_ADDRESS_OF.hpp")
// Inlined hook for Expression_ADDRESS_OF for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ADDRESS_OF>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ADDRESS_OF& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ADDRESS_OF(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_ADDRESS_OF.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ADDRESS_OF>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ADDRESS_OF>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_ADDRESS_OF_before.hpp")
// Inlined hook for Expression_ADDRESS_OF_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ADDRESS_OF_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ADDRESS_OF_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_ADDRESS_OF_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_ADDRESS_OF_after.hpp")
// Inlined hook for Expression_ADDRESS_OF_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_ADDRESS_OF_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_ADDRESS_OF_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_ADDRESS_OF_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_ADDRESS_OF_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_OPTIONAL_OF.hpp")
// Inlined hook for Expression_OPTIONAL_OF for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_OPTIONAL_OF& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_OPTIONAL_OF(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_OPTIONAL_OF.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_OPTIONAL_OF_before.hpp")
// Inlined hook for Expression_OPTIONAL_OF_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_OPTIONAL_OF_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_OPTIONAL_OF_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_OPTIONAL_OF_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_OPTIONAL_OF_after.hpp")
// Inlined hook for Expression_OPTIONAL_OF_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_OPTIONAL_OF_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_OPTIONAL_OF_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_OPTIONAL_OF_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_OPTIONAL_OF_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_SETTER_STATUS.hpp")
// Inlined hook for Expression_SETTER_STATUS for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SETTER_STATUS>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SETTER_STATUS& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SETTER_STATUS(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_SETTER_STATUS.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SETTER_STATUS>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SETTER_STATUS>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_SETTER_STATUS_before.hpp")
// Inlined hook for Expression_SETTER_STATUS_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SETTER_STATUS_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SETTER_STATUS_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_SETTER_STATUS_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_SETTER_STATUS_after.hpp")
// Inlined hook for Expression_SETTER_STATUS_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SETTER_STATUS_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SETTER_STATUS_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_SETTER_STATUS_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SETTER_STATUS_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_SELF.hpp")
// Inlined hook for Expression_SELF for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SELF>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SELF& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SELF(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_SELF.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SELF>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SELF>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_SELF_before.hpp")
// Inlined hook for Expression_SELF_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SELF_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SELF_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SELF_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_SELF_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SELF_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SELF_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_SELF_after.hpp")
// Inlined hook for Expression_SELF_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SELF_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_SELF_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_SELF_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_SELF_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SELF_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_SELF_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_AS_ARG.hpp")
// Inlined hook for Expression_AS_ARG for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_AS_ARG>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_AS_ARG& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_AS_ARG(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_AS_ARG.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_AS_ARG>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_AS_ARG>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_AS_ARG_before.hpp")
// Inlined hook for Expression_AS_ARG_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_AS_ARG_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_AS_ARG_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_AS_ARG_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_AS_ARG_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_AS_ARG_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_AS_ARG_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_AS_ARG_after.hpp")
// Inlined hook for Expression_AS_ARG_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_AS_ARG_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_AS_ARG_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_AS_ARG_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_AS_ARG_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_AS_ARG_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_AS_ARG_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_dispatch.hpp")
// Inlined hook for Expression for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_dispatch.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_before_dispatch.hpp")
// Inlined hook for Expression_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_before_dispatch.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expression_after_dispatch.hpp")
// Inlined hook for Expression_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expression_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSION_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expression_after_dispatch.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expression_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expressions.hpp")
// Inlined hook for Expressions for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expressions>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expressions& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSIONS(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expressions.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expressions>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expressions>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expressions_before.hpp")
// Inlined hook for Expressions_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expressions_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expressions_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSIONS_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expressions_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expressions_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expressions_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Expressions_after.hpp")
// Inlined hook for Expressions_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expressions_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Expressions_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_EXPRESSIONS_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Expressions_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expressions_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Expressions_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_INT.hpp")
// Inlined hook for Type_INT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_INT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_INT& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_INT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_INT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_INT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_INT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_INT 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_INT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_INT_before.hpp")
// Inlined hook for Type_INT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_INT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_INT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_INT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_INT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_INT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_INT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_INT_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_INT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_INT_after.hpp")
// Inlined hook for Type_INT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_INT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_INT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_INT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_INT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_INT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_INT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_INT_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_INT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_UINT.hpp")
// Inlined hook for Type_UINT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_UINT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_UINT& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_UINT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_UINT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_UINT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_UINT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_UINT 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_UINT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_UINT_before.hpp")
// Inlined hook for Type_UINT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_UINT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_UINT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_UINT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_UINT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_UINT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_UINT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_UINT_after.hpp")
// Inlined hook for Type_UINT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_UINT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_UINT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_UINT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_UINT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_UINT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_UINT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_USIZE.hpp")
// Inlined hook for Type_USIZE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_USIZE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_USIZE& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_USIZE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_USIZE.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_USIZE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_USIZE>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_USIZE_before.hpp")
// Inlined hook for Type_USIZE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_USIZE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_USIZE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_USIZE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_USIZE_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_USIZE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_USIZE_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_USIZE_after.hpp")
// Inlined hook for Type_USIZE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_USIZE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_USIZE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_USIZE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_USIZE_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_USIZE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_USIZE_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_FLOAT.hpp")
// Inlined hook for Type_FLOAT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_FLOAT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_FLOAT& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_FLOAT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_FLOAT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_FLOAT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_FLOAT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_FLOAT_before.hpp")
// Inlined hook for Type_FLOAT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_FLOAT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_FLOAT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_FLOAT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_FLOAT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_FLOAT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_FLOAT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_FLOAT_after.hpp")
// Inlined hook for Type_FLOAT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_FLOAT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_FLOAT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_FLOAT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_FLOAT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_FLOAT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_FLOAT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_STRUCT.hpp")
// Inlined hook for Type_STRUCT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_STRUCT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_STRUCT& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_STRUCT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_STRUCT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_STRUCT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_STRUCT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_STRUCT_before.hpp")
// Inlined hook for Type_STRUCT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_STRUCT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_STRUCT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_STRUCT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_STRUCT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_STRUCT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_STRUCT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_STRUCT_after.hpp")
// Inlined hook for Type_STRUCT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_STRUCT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_STRUCT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_STRUCT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_STRUCT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_STRUCT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_STRUCT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_RECURSIVE_STRUCT.hpp")
// Inlined hook for Type_RECURSIVE_STRUCT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_RECURSIVE_STRUCT& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_RECURSIVE_STRUCT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_RECURSIVE_STRUCT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_RECURSIVE_STRUCT_before.hpp")
// Inlined hook for Type_RECURSIVE_STRUCT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_RECURSIVE_STRUCT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_RECURSIVE_STRUCT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_RECURSIVE_STRUCT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_RECURSIVE_STRUCT_after.hpp")
// Inlined hook for Type_RECURSIVE_STRUCT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_RECURSIVE_STRUCT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_RECURSIVE_STRUCT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_RECURSIVE_STRUCT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_RECURSIVE_STRUCT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_BOOL.hpp")
// Inlined hook for Type_BOOL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_BOOL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_BOOL& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_BOOL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_BOOL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_BOOL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_BOOL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_BOOL_before.hpp")
// Inlined hook for Type_BOOL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_BOOL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_BOOL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_BOOL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_BOOL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_BOOL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_BOOL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_BOOL_after.hpp")
// Inlined hook for Type_BOOL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_BOOL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_BOOL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_BOOL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_BOOL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_BOOL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_BOOL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_VOID.hpp")
// Inlined hook for Type_VOID for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VOID>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VOID& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VOID(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_VOID.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VOID>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VOID)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VOID 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VOID>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_VOID_before.hpp")
// Inlined hook for Type_VOID_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VOID_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VOID_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VOID_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_VOID_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VOID_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VOID_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_VOID_after.hpp")
// Inlined hook for Type_VOID_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VOID_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VOID_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VOID_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_VOID_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VOID_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VOID_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_META.hpp")
// Inlined hook for Type_META for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_META>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_META& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_META(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_META.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_META>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_META)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_META 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_META>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_META_before.hpp")
// Inlined hook for Type_META_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_META_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_META_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_META_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_META_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_META_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_META_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_META_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_META_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_META_after.hpp")
// Inlined hook for Type_META_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_META_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_META_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_META_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_META_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_META_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_META_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_META_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_META_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_ENUM.hpp")
// Inlined hook for Type_ENUM for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENUM>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENUM& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENUM(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_ENUM.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENUM>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENUM>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_ENUM_before.hpp")
// Inlined hook for Type_ENUM_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENUM_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENUM_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENUM_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_ENUM_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENUM_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENUM_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_ENUM_after.hpp")
// Inlined hook for Type_ENUM_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENUM_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENUM_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENUM_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_ENUM_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENUM_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENUM_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_ARRAY.hpp")
// Inlined hook for Type_ARRAY for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ARRAY>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ARRAY& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ARRAY(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_ARRAY.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ARRAY>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ARRAY>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_ARRAY_before.hpp")
// Inlined hook for Type_ARRAY_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ARRAY_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ARRAY_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ARRAY_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_ARRAY_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ARRAY_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ARRAY_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_ARRAY_after.hpp")
// Inlined hook for Type_ARRAY_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ARRAY_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ARRAY_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ARRAY_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_ARRAY_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ARRAY_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ARRAY_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_VECTOR.hpp")
// Inlined hook for Type_VECTOR for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VECTOR>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VECTOR& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VECTOR(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_VECTOR.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VECTOR>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VECTOR>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_VECTOR_before.hpp")
// Inlined hook for Type_VECTOR_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VECTOR_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VECTOR_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VECTOR_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_VECTOR_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VECTOR_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VECTOR_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_VECTOR_after.hpp")
// Inlined hook for Type_VECTOR_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VECTOR_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VECTOR_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VECTOR_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_VECTOR_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VECTOR_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VECTOR_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_VARIANT.hpp")
// Inlined hook for Type_VARIANT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VARIANT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VARIANT& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VARIANT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_VARIANT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VARIANT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VARIANT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_VARIANT_before.hpp")
// Inlined hook for Type_VARIANT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VARIANT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VARIANT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VARIANT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_VARIANT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VARIANT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VARIANT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_VARIANT_after.hpp")
// Inlined hook for Type_VARIANT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VARIANT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_VARIANT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_VARIANT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_VARIANT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VARIANT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_VARIANT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_RANGE.hpp")
// Inlined hook for Type_RANGE for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_RANGE>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_RANGE& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_RANGE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_RANGE.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_RANGE>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_RANGE>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_RANGE_before.hpp")
// Inlined hook for Type_RANGE_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_RANGE_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_RANGE_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_RANGE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_RANGE_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_RANGE_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_RANGE_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_RANGE_after.hpp")
// Inlined hook for Type_RANGE_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_RANGE_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_RANGE_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_RANGE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_RANGE_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_RANGE_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_RANGE_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_ENCODER_RETURN.hpp")
// Inlined hook for Type_ENCODER_RETURN for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENCODER_RETURN>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENCODER_RETURN& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENCODER_RETURN(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_ENCODER_RETURN.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENCODER_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENCODER_RETURN>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_ENCODER_RETURN_before.hpp")
// Inlined hook for Type_ENCODER_RETURN_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENCODER_RETURN_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENCODER_RETURN_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_ENCODER_RETURN_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_ENCODER_RETURN_after.hpp")
// Inlined hook for Type_ENCODER_RETURN_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENCODER_RETURN_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENCODER_RETURN_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_ENCODER_RETURN_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENCODER_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_DECODER_RETURN.hpp")
// Inlined hook for Type_DECODER_RETURN for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_DECODER_RETURN>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_DECODER_RETURN& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_DECODER_RETURN(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_DECODER_RETURN.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_DECODER_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_DECODER_RETURN>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_DECODER_RETURN_before.hpp")
// Inlined hook for Type_DECODER_RETURN_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_DECODER_RETURN_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_DECODER_RETURN_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_DECODER_RETURN_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_DECODER_RETURN_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_DECODER_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_DECODER_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_DECODER_RETURN_after.hpp")
// Inlined hook for Type_DECODER_RETURN_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_DECODER_RETURN_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_DECODER_RETURN_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_DECODER_RETURN_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_DECODER_RETURN_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_DECODER_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_DECODER_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_ENCODER_INPUT.hpp")
// Inlined hook for Type_ENCODER_INPUT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENCODER_INPUT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENCODER_INPUT& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENCODER_INPUT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_ENCODER_INPUT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENCODER_INPUT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENCODER_INPUT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_ENCODER_INPUT_before.hpp")
// Inlined hook for Type_ENCODER_INPUT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENCODER_INPUT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENCODER_INPUT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_ENCODER_INPUT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_ENCODER_INPUT_after.hpp")
// Inlined hook for Type_ENCODER_INPUT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_ENCODER_INPUT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_ENCODER_INPUT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_ENCODER_INPUT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_ENCODER_INPUT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_DECODER_INPUT.hpp")
// Inlined hook for Type_DECODER_INPUT for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_DECODER_INPUT>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_DECODER_INPUT& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_DECODER_INPUT(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_DECODER_INPUT.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_DECODER_INPUT>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_DECODER_INPUT>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_DECODER_INPUT_before.hpp")
// Inlined hook for Type_DECODER_INPUT_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_DECODER_INPUT_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_DECODER_INPUT_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_DECODER_INPUT_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_DECODER_INPUT_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_DECODER_INPUT_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_DECODER_INPUT_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_DECODER_INPUT_after.hpp")
// Inlined hook for Type_DECODER_INPUT_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_DECODER_INPUT_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_DECODER_INPUT_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_DECODER_INPUT_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_DECODER_INPUT_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_DECODER_INPUT_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_DECODER_INPUT_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_PROPERTY_SETTER_RETURN.hpp")
// Inlined hook for Type_PROPERTY_SETTER_RETURN for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_PROPERTY_SETTER_RETURN& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_PROPERTY_SETTER_RETURN(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_PROPERTY_SETTER_RETURN.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_PROPERTY_SETTER_RETURN_before.hpp")
// Inlined hook for Type_PROPERTY_SETTER_RETURN_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_PROPERTY_SETTER_RETURN_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_PROPERTY_SETTER_RETURN_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_PROPERTY_SETTER_RETURN_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_PROPERTY_SETTER_RETURN_after.hpp")
// Inlined hook for Type_PROPERTY_SETTER_RETURN_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_PROPERTY_SETTER_RETURN_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_PROPERTY_SETTER_RETURN_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_PROPERTY_SETTER_RETURN_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_PROPERTY_SETTER_RETURN_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_OPTIONAL.hpp")
// Inlined hook for Type_OPTIONAL for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_OPTIONAL>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_OPTIONAL& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_OPTIONAL(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_OPTIONAL.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_OPTIONAL>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_OPTIONAL>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_OPTIONAL_before.hpp")
// Inlined hook for Type_OPTIONAL_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_OPTIONAL_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_OPTIONAL_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_OPTIONAL_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_OPTIONAL_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_OPTIONAL_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_OPTIONAL_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_OPTIONAL_after.hpp")
// Inlined hook for Type_OPTIONAL_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_OPTIONAL_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_OPTIONAL_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_OPTIONAL_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_OPTIONAL_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_OPTIONAL_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_OPTIONAL_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_PTR.hpp")
// Inlined hook for Type_PTR for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_PTR>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_PTR& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_PTR(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_PTR.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_PTR>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PTR)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PTR 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_PTR>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_PTR_before.hpp")
// Inlined hook for Type_PTR_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_PTR_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_PTR_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_PTR_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_PTR_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_PTR_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_PTR_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_PTR_after.hpp")
// Inlined hook for Type_PTR_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_PTR_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_PTR_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_PTR_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_PTR_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_PTR_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_PTR_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_FUNCTION.hpp")
// Inlined hook for Type_FUNCTION for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_FUNCTION>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_FUNCTION& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_FUNCTION(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_FUNCTION.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_FUNCTION>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_FUNCTION>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_FUNCTION_before.hpp")
// Inlined hook for Type_FUNCTION_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_FUNCTION_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_FUNCTION_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_FUNCTION_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_FUNCTION_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_FUNCTION_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_FUNCTION_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_FUNCTION_after.hpp")
// Inlined hook for Type_FUNCTION_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_FUNCTION_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_FUNCTION_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_FUNCTION_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_FUNCTION_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_FUNCTION_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_FUNCTION_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_dispatch.hpp")
// Inlined hook for Type for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_dispatch.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_before_dispatch.hpp")
// Inlined hook for Type_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_before_dispatch.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Type_after_dispatch.hpp")
// Inlined hook for Type_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Type_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPE_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Type_after_dispatch.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPE_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Type_after>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Types.hpp")
// Inlined hook for Types for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Types>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Types& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPES(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Types.hpp"
        return {};
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Types>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPES)
#define CODEGEN_EXPECTED_PRIORITY_TYPES 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Types>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Types_before.hpp")
// Inlined hook for Types_before for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Types_before>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Types_before<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPES_BEFORE(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Types_before.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Types_before>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPES_BEFORE)
#define CODEGEN_EXPECTED_PRIORITY_TYPES_BEFORE 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Types_before>> {}; // Unimplemented
#endif
#if __has_include("ebmcodegen/default_codegen_visitor/visitor/Types_after.hpp")
// Inlined hook for Types_after for backward compatibility
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Types_after>> {
    // for backward compatibility
    ebm2python::MergedVisitor* __legacy_compat_ptr = nullptr;
    expected<Result> visit(Context_Types_after<Result>& ctx) {
        EBM2PYTHON_DECONSTRUCT_TYPES_AFTER(ctx);
        auto& program_name = ctx.visitor.program_name;
        auto& module_ = ctx.visitor.module_;
        auto& flags = ctx.visitor.flags;
        auto& output = ctx.visitor.output;
        auto& wm = ctx.visitor.wm;
        __legacy_compat_ptr = ctx.visitor.__legacy_compat_ptr;
        // for backward compatibility
        auto& root = wm.root;
        auto add_writer = [&]{ return wm.add_writer(); };
        auto get_writer = [&]{ return wm.get_writer(); };
        using namespace ebm2python;
        #include "ebmcodegen/default_codegen_visitor/visitor/Types_after.hpp"
        return pass;
    }
};
static_assert(sizeof(ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Types_after>>)); // ensure included
#if !defined(CODEGEN_EXPECTED_PRIORITY_TYPES_AFTER)
#define CODEGEN_EXPECTED_PRIORITY_TYPES_AFTER 5
#endif
#else
template <>
struct ebm2python::Visitor<ebm2python::DefaultCodegenVisitorInlinedHook<ebm2python::VisitorTag_Types_after>> {}; // Unimplemented
#endif
namespace ebm2python {
    template <typename Tag>
    struct GeneratorDefaultHook {}; // Hook tag
    template<typename Result,typename Context>
    expected<Result> dispatch_entry(Context&& ctx){
        auto main_logic = [&]() -> expected<Result>{
            Context_entry new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_entry_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_entry_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_entry(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_pre_visitor(Context&& ctx,ebm::ExtendedBinaryModule& ebm){
        auto main_logic = [&]() -> expected<Result>{
            Context_pre_visitor new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .ebm = ebm,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_pre_visitor_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .ebm = ebm,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_pre_visitor_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .ebm = ebm,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_pre_visitor(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_post_entry(Context&& ctx,expected<Result>& entry_result){
        auto main_logic = [&]() -> expected<Result>{
            Context_post_entry<Result> new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .entry_result = entry_result,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_post_entry_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .entry_result = entry_result,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_post_entry_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .entry_result = entry_result,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_post_entry(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_BLOCK(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.block()) {
            return unexpect_error("Unexpected null pointer for StatementBody::block");
        }
        auto& block = *in.body.block();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_BLOCK new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .block = block,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_BLOCK_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .block = block,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_BLOCK_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .block = block,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_BLOCK(UserContext&& ctx,TypeContext&& type_ctx) {
        auto result_block = dispatch_Block_default<Result>(std::forward<UserContext>(ctx),type_ctx.block);
        if (!result_block) {
            return unexpect_error(std::move(result_block.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_ASSIGNMENT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.previous_assignment()) {
            return unexpect_error("Unexpected null pointer for StatementBody::previous_assignment");
        }
        auto& previous_assignment = *in.body.previous_assignment();
        if (!in.body.target()) {
            return unexpect_error("Unexpected null pointer for StatementBody::target");
        }
        auto& target = *in.body.target();
        if (!in.body.value()) {
            return unexpect_error("Unexpected null pointer for StatementBody::value");
        }
        auto& value = *in.body.value();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_ASSIGNMENT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .previous_assignment = previous_assignment,
                .target = target,
                .value = value,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_ASSIGNMENT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .previous_assignment = previous_assignment,
            .target = target,
            .value = value,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_ASSIGNMENT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .previous_assignment = previous_assignment,
            .target = target,
            .value = value,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ASSIGNMENT(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.target)) {
            auto result_target = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target);
            if (!result_target) {
                return unexpect_error(std::move(result_target.error()));
            }
        }
        if (!is_nil(type_ctx.value)) {
            auto result_value = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.value);
            if (!result_value) {
                return unexpect_error(std::move(result_value.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_YIELD(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.previous_assignment()) {
            return unexpect_error("Unexpected null pointer for StatementBody::previous_assignment");
        }
        auto& previous_assignment = *in.body.previous_assignment();
        if (!in.body.target()) {
            return unexpect_error("Unexpected null pointer for StatementBody::target");
        }
        auto& target = *in.body.target();
        if (!in.body.value()) {
            return unexpect_error("Unexpected null pointer for StatementBody::value");
        }
        auto& value = *in.body.value();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_YIELD new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .previous_assignment = previous_assignment,
                .target = target,
                .value = value,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_YIELD_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .previous_assignment = previous_assignment,
            .target = target,
            .value = value,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_YIELD_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .previous_assignment = previous_assignment,
            .target = target,
            .value = value,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_YIELD(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.target)) {
            auto result_target = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target);
            if (!result_target) {
                return unexpect_error(std::move(result_target.error()));
            }
        }
        if (!is_nil(type_ctx.value)) {
            auto result_value = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.value);
            if (!result_value) {
                return unexpect_error(std::move(result_value.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_APPEND(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.target()) {
            return unexpect_error("Unexpected null pointer for StatementBody::target");
        }
        auto& target = *in.body.target();
        if (!in.body.value()) {
            return unexpect_error("Unexpected null pointer for StatementBody::value");
        }
        auto& value = *in.body.value();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_APPEND new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .target = target,
                .value = value,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_APPEND_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .target = target,
            .value = value,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_APPEND_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .target = target,
            .value = value,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_APPEND(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.target)) {
            auto result_target = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target);
            if (!result_target) {
                return unexpect_error(std::move(result_target.error()));
            }
        }
        if (!is_nil(type_ctx.value)) {
            auto result_value = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.value);
            if (!result_value) {
                return unexpect_error(std::move(result_value.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_RETURN(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.value()) {
            return unexpect_error("Unexpected null pointer for StatementBody::value");
        }
        auto& value = *in.body.value();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_RETURN new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .value = value,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_RETURN_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .value = value,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_RETURN_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .value = value,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_RETURN(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.value)) {
            auto result_value = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.value);
            if (!result_value) {
                return unexpect_error(std::move(result_value.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_ERROR_RETURN(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.value()) {
            return unexpect_error("Unexpected null pointer for StatementBody::value");
        }
        auto& value = *in.body.value();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_ERROR_RETURN new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .value = value,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_ERROR_RETURN_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .value = value,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_ERROR_RETURN_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .value = value,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ERROR_RETURN(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.value)) {
            auto result_value = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.value);
            if (!result_value) {
                return unexpect_error(std::move(result_value.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_ASSERT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.assert_desc()) {
            return unexpect_error("Unexpected null pointer for StatementBody::assert_desc");
        }
        auto& assert_desc = *in.body.assert_desc();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_ASSERT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .assert_desc = assert_desc,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_ASSERT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .assert_desc = assert_desc,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_ASSERT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .assert_desc = assert_desc,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ASSERT(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.assert_desc.condition.cond)) {
            auto result_cond = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.assert_desc.condition.cond);
            if (!result_cond) {
                return unexpect_error(std::move(result_cond.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_READ_DATA(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.read_data()) {
            return unexpect_error("Unexpected null pointer for StatementBody::read_data");
        }
        auto& read_data = *in.body.read_data();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_READ_DATA new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .read_data = read_data,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_READ_DATA_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .read_data = read_data,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_READ_DATA_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .read_data = read_data,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_READ_DATA(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.read_data.io_ref)) {
            auto result_io_ref = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.read_data.io_ref);
            if (!result_io_ref) {
                return unexpect_error(std::move(result_io_ref.error()));
            }
        }
        if (!is_nil(type_ctx.read_data.field)) {
            auto result_field = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.read_data.field);
            if (!result_field) {
                return unexpect_error(std::move(result_field.error()));
            }
        }
        if (!is_nil(type_ctx.read_data.target)) {
            auto result_target = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.read_data.target);
            if (!result_target) {
                return unexpect_error(std::move(result_target.error()));
            }
        }
        if (!is_nil(type_ctx.read_data.data_type)) {
            auto result_data_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.read_data.data_type);
            if (!result_data_type) {
                return unexpect_error(std::move(result_data_type.error()));
            }
        }
        if (auto ptr = type_ctx.read_data.attribute.dynamic_ref()) {
            if (!is_nil((*ptr))) {
                auto result_dynamic_ref = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_dynamic_ref) {
                    return unexpect_error(std::move(result_dynamic_ref.error()));
                }
            }
        }
        if (auto ptr = type_ctx.read_data.size.ref()) {
            if (!is_nil((*ptr))) {
                auto result_ref = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_ref) {
                    return unexpect_error(std::move(result_ref.error()));
                }
            }
        }
        if (auto ptr_lowered_statement = type_ctx.read_data.lowered_statement()) {
        }
        if (auto ptr = type_ctx.read_data.offset()) {
            if (!is_nil((*ptr))) {
                auto result_offset = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_offset) {
                    return unexpect_error(std::move(result_offset.error()));
                }
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_WRITE_DATA(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.write_data()) {
            return unexpect_error("Unexpected null pointer for StatementBody::write_data");
        }
        auto& write_data = *in.body.write_data();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_WRITE_DATA new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .write_data = write_data,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_WRITE_DATA_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .write_data = write_data,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_WRITE_DATA_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .write_data = write_data,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_WRITE_DATA(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.write_data.io_ref)) {
            auto result_io_ref = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.write_data.io_ref);
            if (!result_io_ref) {
                return unexpect_error(std::move(result_io_ref.error()));
            }
        }
        if (!is_nil(type_ctx.write_data.field)) {
            auto result_field = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.write_data.field);
            if (!result_field) {
                return unexpect_error(std::move(result_field.error()));
            }
        }
        if (!is_nil(type_ctx.write_data.target)) {
            auto result_target = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.write_data.target);
            if (!result_target) {
                return unexpect_error(std::move(result_target.error()));
            }
        }
        if (!is_nil(type_ctx.write_data.data_type)) {
            auto result_data_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.write_data.data_type);
            if (!result_data_type) {
                return unexpect_error(std::move(result_data_type.error()));
            }
        }
        if (auto ptr = type_ctx.write_data.attribute.dynamic_ref()) {
            if (!is_nil((*ptr))) {
                auto result_dynamic_ref = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_dynamic_ref) {
                    return unexpect_error(std::move(result_dynamic_ref.error()));
                }
            }
        }
        if (auto ptr = type_ctx.write_data.size.ref()) {
            if (!is_nil((*ptr))) {
                auto result_ref = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_ref) {
                    return unexpect_error(std::move(result_ref.error()));
                }
            }
        }
        if (auto ptr_lowered_statement = type_ctx.write_data.lowered_statement()) {
        }
        if (auto ptr = type_ctx.write_data.offset()) {
            if (!is_nil((*ptr))) {
                auto result_offset = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_offset) {
                    return unexpect_error(std::move(result_offset.error()));
                }
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_RESERVE_DATA(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.reserve_data()) {
            return unexpect_error("Unexpected null pointer for StatementBody::reserve_data");
        }
        auto& reserve_data = *in.body.reserve_data();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_RESERVE_DATA new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .reserve_data = reserve_data,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_RESERVE_DATA_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .reserve_data = reserve_data,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_RESERVE_DATA_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .reserve_data = reserve_data,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_RESERVE_DATA(UserContext&& ctx,TypeContext&& type_ctx) {
        if (auto ptr = type_ctx.reserve_data.size.ref()) {
            if (!is_nil((*ptr))) {
                auto result_ref = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_ref) {
                    return unexpect_error(std::move(result_ref.error()));
                }
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_IF_STATEMENT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.if_statement()) {
            return unexpect_error("Unexpected null pointer for StatementBody::if_statement");
        }
        auto& if_statement = *in.body.if_statement();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_IF_STATEMENT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .if_statement = if_statement,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_IF_STATEMENT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .if_statement = if_statement,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_IF_STATEMENT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .if_statement = if_statement,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_IF_STATEMENT(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.if_statement.condition.cond)) {
            auto result_cond = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.if_statement.condition.cond);
            if (!result_cond) {
                return unexpect_error(std::move(result_cond.error()));
            }
        }
        if (!is_nil(type_ctx.if_statement.then_block)) {
            auto result_then_block = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.if_statement.then_block);
            if (!result_then_block) {
                return unexpect_error(std::move(result_then_block.error()));
            }
        }
        if (!is_nil(type_ctx.if_statement.else_block)) {
            auto result_else_block = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.if_statement.else_block);
            if (!result_else_block) {
                return unexpect_error(std::move(result_else_block.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_LOOP_STATEMENT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.loop()) {
            return unexpect_error("Unexpected null pointer for StatementBody::loop");
        }
        auto& loop = *in.body.loop();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_LOOP_STATEMENT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .loop = loop,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_LOOP_STATEMENT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .loop = loop,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_LOOP_STATEMENT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .loop = loop,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_LOOP_STATEMENT(UserContext&& ctx,TypeContext&& type_ctx) {
        if (auto ptr = type_ctx.loop.collection()) {
            if (!is_nil((*ptr))) {
                auto result_collection = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_collection) {
                    return unexpect_error(std::move(result_collection.error()));
                }
            }
        }
        if (auto ptr_condition = type_ctx.loop.condition()) {
            if (!is_nil((*ptr_condition).cond)) {
                auto result_cond = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr_condition).cond);
                if (!result_cond) {
                    return unexpect_error(std::move(result_cond.error()));
                }
            }
        }
        if (auto ptr = type_ctx.loop.increment()) {
            if (!is_nil((*ptr))) {
                auto result_increment = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_increment) {
                    return unexpect_error(std::move(result_increment.error()));
                }
            }
        }
        if (auto ptr = type_ctx.loop.init()) {
            if (!is_nil((*ptr))) {
                auto result_init = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_init) {
                    return unexpect_error(std::move(result_init.error()));
                }
            }
        }
        if (auto ptr = type_ctx.loop.item_var()) {
            if (!is_nil((*ptr))) {
                auto result_item_var = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_item_var) {
                    return unexpect_error(std::move(result_item_var.error()));
                }
            }
        }
        if (!is_nil(type_ctx.loop.body)) {
            auto result_body = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.loop.body);
            if (!result_body) {
                return unexpect_error(std::move(result_body.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_MATCH_STATEMENT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.match_statement()) {
            return unexpect_error("Unexpected null pointer for StatementBody::match_statement");
        }
        auto& match_statement = *in.body.match_statement();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_MATCH_STATEMENT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .match_statement = match_statement,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_MATCH_STATEMENT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .match_statement = match_statement,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_MATCH_STATEMENT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .match_statement = match_statement,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_MATCH_STATEMENT(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.match_statement.target)) {
            auto result_target = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.match_statement.target);
            if (!result_target) {
                return unexpect_error(std::move(result_target.error()));
            }
        }
        auto result_branches = dispatch_Block_default<Result>(std::forward<UserContext>(ctx),type_ctx.match_statement.branches);
        if (!result_branches) {
            return unexpect_error(std::move(result_branches.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_MATCH_BRANCH(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.match_branch()) {
            return unexpect_error("Unexpected null pointer for StatementBody::match_branch");
        }
        auto& match_branch = *in.body.match_branch();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_MATCH_BRANCH new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .match_branch = match_branch,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_MATCH_BRANCH_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .match_branch = match_branch,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_MATCH_BRANCH_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .match_branch = match_branch,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_MATCH_BRANCH(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.match_branch.condition.cond)) {
            auto result_cond = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.match_branch.condition.cond);
            if (!result_cond) {
                return unexpect_error(std::move(result_cond.error()));
            }
        }
        if (!is_nil(type_ctx.match_branch.body)) {
            auto result_body = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.match_branch.body);
            if (!result_body) {
                return unexpect_error(std::move(result_body.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_BREAK(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.break_()) {
            return unexpect_error("Unexpected null pointer for StatementBody::break_");
        }
        auto& break_ = *in.body.break_();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_BREAK new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .break_ = break_,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_BREAK_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .break_ = break_,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_BREAK_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .break_ = break_,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_BREAK(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_CONTINUE(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.continue_()) {
            return unexpect_error("Unexpected null pointer for StatementBody::continue_");
        }
        auto& continue_ = *in.body.continue_();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_CONTINUE new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .continue_ = continue_,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_CONTINUE_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .continue_ = continue_,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_CONTINUE_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .continue_ = continue_,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_CONTINUE(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_FUNCTION_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.func_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::func_decl");
        }
        auto& func_decl = *in.body.func_decl();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_FUNCTION_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .func_decl = func_decl,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_FUNCTION_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .func_decl = func_decl,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_FUNCTION_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .func_decl = func_decl,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_FUNCTION_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.func_decl.return_type)) {
            auto result_return_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.func_decl.return_type);
            if (!result_return_type) {
                return unexpect_error(std::move(result_return_type.error()));
            }
        }
        auto result_params = dispatch_Block_default<Result>(std::forward<UserContext>(ctx),type_ctx.func_decl.params);
        if (!result_params) {
            return unexpect_error(std::move(result_params.error()));
        }
        if (!is_nil(type_ctx.func_decl.body)) {
            auto result_body = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.func_decl.body);
            if (!result_body) {
                return unexpect_error(std::move(result_body.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_VARIABLE_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.var_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::var_decl");
        }
        auto& var_decl = *in.body.var_decl();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_VARIABLE_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .var_decl = var_decl,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_VARIABLE_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .var_decl = var_decl,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_VARIABLE_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .var_decl = var_decl,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_VARIABLE_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.var_decl.var_type)) {
            auto result_var_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.var_decl.var_type);
            if (!result_var_type) {
                return unexpect_error(std::move(result_var_type.error()));
            }
        }
        if (!is_nil(type_ctx.var_decl.initial_value)) {
            auto result_initial_value = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.var_decl.initial_value);
            if (!result_initial_value) {
                return unexpect_error(std::move(result_initial_value.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_PARAMETER_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.param_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::param_decl");
        }
        auto& param_decl = *in.body.param_decl();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_PARAMETER_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .param_decl = param_decl,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_PARAMETER_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .param_decl = param_decl,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_PARAMETER_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .param_decl = param_decl,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_PARAMETER_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.param_decl.param_type)) {
            auto result_param_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.param_decl.param_type);
            if (!result_param_type) {
                return unexpect_error(std::move(result_param_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_FIELD_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.field_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::field_decl");
        }
        auto& field_decl = *in.body.field_decl();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_FIELD_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .field_decl = field_decl,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_FIELD_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .field_decl = field_decl,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_FIELD_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .field_decl = field_decl,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_FIELD_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.field_decl.field_type)) {
            auto result_field_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.field_decl.field_type);
            if (!result_field_type) {
                return unexpect_error(std::move(result_field_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_COMPOSITE_FIELD_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.composite_field_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::composite_field_decl");
        }
        auto& composite_field_decl = *in.body.composite_field_decl();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_COMPOSITE_FIELD_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .composite_field_decl = composite_field_decl,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_COMPOSITE_FIELD_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .composite_field_decl = composite_field_decl,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_COMPOSITE_FIELD_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .composite_field_decl = composite_field_decl,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_COMPOSITE_FIELD_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        auto result_fields = dispatch_Block_default<Result>(std::forward<UserContext>(ctx),type_ctx.composite_field_decl.fields);
        if (!result_fields) {
            return unexpect_error(std::move(result_fields.error()));
        }
        if (!is_nil(type_ctx.composite_field_decl.composite_type)) {
            auto result_composite_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.composite_field_decl.composite_type);
            if (!result_composite_type) {
                return unexpect_error(std::move(result_composite_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_ENUM_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.enum_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::enum_decl");
        }
        auto& enum_decl = *in.body.enum_decl();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_ENUM_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .enum_decl = enum_decl,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_ENUM_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .enum_decl = enum_decl,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_ENUM_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .enum_decl = enum_decl,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ENUM_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.enum_decl.base_type)) {
            auto result_base_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.enum_decl.base_type);
            if (!result_base_type) {
                return unexpect_error(std::move(result_base_type.error()));
            }
        }
        auto result_members = dispatch_Block_default<Result>(std::forward<UserContext>(ctx),type_ctx.enum_decl.members);
        if (!result_members) {
            return unexpect_error(std::move(result_members.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_ENUM_MEMBER_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.enum_member_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::enum_member_decl");
        }
        auto& enum_member_decl = *in.body.enum_member_decl();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_ENUM_MEMBER_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .enum_member_decl = enum_member_decl,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_ENUM_MEMBER_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .enum_member_decl = enum_member_decl,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_ENUM_MEMBER_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .enum_member_decl = enum_member_decl,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ENUM_MEMBER_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.enum_member_decl.value)) {
            auto result_value = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.enum_member_decl.value);
            if (!result_value) {
                return unexpect_error(std::move(result_value.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_STRUCT_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.struct_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::struct_decl");
        }
        auto& struct_decl = *in.body.struct_decl();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_STRUCT_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .struct_decl = struct_decl,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_STRUCT_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .struct_decl = struct_decl,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_STRUCT_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .struct_decl = struct_decl,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_STRUCT_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        auto result_fields = dispatch_Block_default<Result>(std::forward<UserContext>(ctx),type_ctx.struct_decl.fields);
        if (!result_fields) {
            return unexpect_error(std::move(result_fields.error()));
        }
        if (auto ptr = type_ctx.struct_decl.related_variant()) {
            if (!is_nil((*ptr))) {
                auto result_related_variant = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_related_variant) {
                    return unexpect_error(std::move(result_related_variant.error()));
                }
            }
        }
        if (auto ptr_size = type_ctx.struct_decl.size()) {
            if (auto ptr = (*ptr_size).ref()) {
                if (!is_nil((*ptr))) {
                    auto result_ref = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                    if (!result_ref) {
                        return unexpect_error(std::move(result_ref.error()));
                    }
                }
            }
        }
        if (auto ptr = type_ctx.struct_decl.decode_fn()) {
            if (!is_nil((*ptr))) {
                auto result_decode_fn = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_decode_fn) {
                    return unexpect_error(std::move(result_decode_fn.error()));
                }
            }
        }
        if (auto ptr = type_ctx.struct_decl.encode_fn()) {
            if (!is_nil((*ptr))) {
                auto result_encode_fn = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_encode_fn) {
                    return unexpect_error(std::move(result_encode_fn.error()));
                }
            }
        }
        if (auto ptr = type_ctx.struct_decl.methods()) {
            auto result_methods = dispatch_Block_default<Result>(std::forward<UserContext>(ctx),(*ptr));
            if (!result_methods) {
                return unexpect_error(std::move(result_methods.error()));
            }
        }
        if (auto ptr = type_ctx.struct_decl.properties()) {
            auto result_properties = dispatch_Block_default<Result>(std::forward<UserContext>(ctx),(*ptr));
            if (!result_properties) {
                return unexpect_error(std::move(result_properties.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_UNION_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_UNION_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_UNION_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_UNION_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_UNION_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_UNION_MEMBER_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_UNION_MEMBER_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_UNION_MEMBER_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_UNION_MEMBER_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_UNION_MEMBER_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_PROGRAM_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.block()) {
            return unexpect_error("Unexpected null pointer for StatementBody::block");
        }
        auto& block = *in.body.block();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_PROGRAM_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .block = block,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_PROGRAM_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .block = block,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_PROGRAM_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .block = block,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_PROGRAM_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        auto result_block = dispatch_Block_default<Result>(std::forward<UserContext>(ctx),type_ctx.block);
        if (!result_block) {
            return unexpect_error(std::move(result_block.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_PROPERTY_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.property_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::property_decl");
        }
        auto& property_decl = *in.body.property_decl();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_PROPERTY_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .property_decl = property_decl,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_PROPERTY_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .property_decl = property_decl,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_PROPERTY_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .property_decl = property_decl,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_PROPERTY_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.property_decl.property_type)) {
            auto result_property_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.property_decl.property_type);
            if (!result_property_type) {
                return unexpect_error(std::move(result_property_type.error()));
            }
        }
        if (!is_nil(type_ctx.property_decl.setter_condition)) {
            auto result_setter_condition = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.property_decl.setter_condition);
            if (!result_setter_condition) {
                return unexpect_error(std::move(result_setter_condition.error()));
            }
        }
        if (!is_nil(type_ctx.property_decl.getter_condition)) {
            auto result_getter_condition = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.property_decl.getter_condition);
            if (!result_getter_condition) {
                return unexpect_error(std::move(result_getter_condition.error()));
            }
        }
        auto result_members = dispatch_Block_default<Result>(std::forward<UserContext>(ctx),type_ctx.property_decl.members);
        if (!result_members) {
            return unexpect_error(std::move(result_members.error()));
        }
        if (auto ptr = type_ctx.property_decl.derived_from()) {
            auto result_derived_from = dispatch_Block_default<Result>(std::forward<UserContext>(ctx),(*ptr));
            if (!result_derived_from) {
                return unexpect_error(std::move(result_derived_from.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_PROPERTY_MEMBER_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.property_member_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::property_member_decl");
        }
        auto& property_member_decl = *in.body.property_member_decl();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_PROPERTY_MEMBER_DECL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .property_member_decl = property_member_decl,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_PROPERTY_MEMBER_DECL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .property_member_decl = property_member_decl,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_PROPERTY_MEMBER_DECL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .property_member_decl = property_member_decl,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_PROPERTY_MEMBER_DECL(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.property_member_decl.setter_condition)) {
            auto result_setter_condition = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.property_member_decl.setter_condition);
            if (!result_setter_condition) {
                return unexpect_error(std::move(result_setter_condition.error()));
            }
        }
        if (!is_nil(type_ctx.property_member_decl.getter_condition)) {
            auto result_getter_condition = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.property_member_decl.getter_condition);
            if (!result_getter_condition) {
                return unexpect_error(std::move(result_getter_condition.error()));
            }
        }
        if (!is_nil(type_ctx.property_member_decl.field)) {
            auto result_field = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.property_member_decl.field);
            if (!result_field) {
                return unexpect_error(std::move(result_field.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_METADATA(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.metadata()) {
            return unexpect_error("Unexpected null pointer for StatementBody::metadata");
        }
        auto& metadata = *in.body.metadata();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_METADATA new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .metadata = metadata,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_METADATA_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .metadata = metadata,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_METADATA_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .metadata = metadata,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_METADATA(UserContext&& ctx,TypeContext&& type_ctx) {
        auto result_values = dispatch_Expressions_default<Result>(std::forward<UserContext>(ctx),type_ctx.metadata.values);
        if (!result_values) {
            return unexpect_error(std::move(result_values.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_IMPORT_MODULE(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.import_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::import_decl");
        }
        auto& import_decl = *in.body.import_decl();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_IMPORT_MODULE new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .import_decl = import_decl,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_IMPORT_MODULE_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .import_decl = import_decl,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_IMPORT_MODULE_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .import_decl = import_decl,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_IMPORT_MODULE(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.import_decl.program)) {
            auto result_program = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.import_decl.program);
            if (!result_program) {
                return unexpect_error(std::move(result_program.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_EXPRESSION(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.expression()) {
            return unexpect_error("Unexpected null pointer for StatementBody::expression");
        }
        auto& expression = *in.body.expression();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_EXPRESSION new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .expression = expression,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_EXPRESSION_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .expression = expression,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_EXPRESSION_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .expression = expression,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_EXPRESSION(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.expression)) {
            auto result_expression = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.expression);
            if (!result_expression) {
                return unexpect_error(std::move(result_expression.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_ERROR_REPORT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.error_report()) {
            return unexpect_error("Unexpected null pointer for StatementBody::error_report");
        }
        auto& error_report = *in.body.error_report();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_ERROR_REPORT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .error_report = error_report,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_ERROR_REPORT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .error_report = error_report,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_ERROR_REPORT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .error_report = error_report,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ERROR_REPORT(UserContext&& ctx,TypeContext&& type_ctx) {
        auto result_arguments = dispatch_Expressions_default<Result>(std::forward<UserContext>(ctx),type_ctx.error_report.arguments);
        if (!result_arguments) {
            return unexpect_error(std::move(result_arguments.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_LOWERED_IO_STATEMENTS(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.lowered_io_statements()) {
            return unexpect_error("Unexpected null pointer for StatementBody::lowered_io_statements");
        }
        auto& lowered_io_statements = *in.body.lowered_io_statements();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_LOWERED_IO_STATEMENTS new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .lowered_io_statements = lowered_io_statements,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_LOWERED_IO_STATEMENTS_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .lowered_io_statements = lowered_io_statements,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_LOWERED_IO_STATEMENTS_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .lowered_io_statements = lowered_io_statements,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_LOWERED_IO_STATEMENTS(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_SUB_BYTE_RANGE(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.sub_byte_range()) {
            return unexpect_error("Unexpected null pointer for StatementBody::sub_byte_range");
        }
        auto& sub_byte_range = *in.body.sub_byte_range();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_SUB_BYTE_RANGE new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .sub_byte_range = sub_byte_range,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_SUB_BYTE_RANGE_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .sub_byte_range = sub_byte_range,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_SUB_BYTE_RANGE_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .sub_byte_range = sub_byte_range,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_SUB_BYTE_RANGE(UserContext&& ctx,TypeContext&& type_ctx) {
        if (auto ptr = type_ctx.sub_byte_range.expression()) {
            if (!is_nil((*ptr))) {
                auto result_expression = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_expression) {
                    return unexpect_error(std::move(result_expression.error()));
                }
            }
        }
        if (auto ptr = type_ctx.sub_byte_range.length()) {
            if (!is_nil((*ptr))) {
                auto result_length = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_length) {
                    return unexpect_error(std::move(result_length.error()));
                }
            }
        }
        if (auto ptr = type_ctx.sub_byte_range.offset()) {
            if (!is_nil((*ptr))) {
                auto result_offset = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_offset) {
                    return unexpect_error(std::move(result_offset.error()));
                }
            }
        }
        if (!is_nil(type_ctx.sub_byte_range.io_ref)) {
            auto result_io_ref = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.sub_byte_range.io_ref);
            if (!result_io_ref) {
                return unexpect_error(std::move(result_io_ref.error()));
            }
        }
        if (!is_nil(type_ctx.sub_byte_range.io_statement)) {
            auto result_io_statement = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.sub_byte_range.io_statement);
            if (!result_io_statement) {
                return unexpect_error(std::move(result_io_statement.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_INIT_CHECK(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.init_check()) {
            return unexpect_error("Unexpected null pointer for StatementBody::init_check");
        }
        auto& init_check = *in.body.init_check();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_INIT_CHECK new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .init_check = init_check,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_INIT_CHECK_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .init_check = init_check,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_INIT_CHECK_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .init_check = init_check,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_INIT_CHECK(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.init_check.target_field)) {
            auto result_target_field = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.init_check.target_field);
            if (!result_target_field) {
                return unexpect_error(std::move(result_target_field.error()));
            }
        }
        if (!is_nil(type_ctx.init_check.expect_value)) {
            auto result_expect_value = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.init_check.expect_value);
            if (!result_expect_value) {
                return unexpect_error(std::move(result_expect_value.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement_ENDIAN_VARIABLE(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.endian_variable()) {
            return unexpect_error("Unexpected null pointer for StatementBody::endian_variable");
        }
        auto& endian_variable = *in.body.endian_variable();
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement_ENDIAN_VARIABLE new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .endian_variable = endian_variable,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_ENDIAN_VARIABLE_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .endian_variable = endian_variable,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_ENDIAN_VARIABLE_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .endian_variable = endian_variable,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement_ENDIAN_VARIABLE(UserContext&& ctx,TypeContext&& type_ctx) {
        if (auto ptr = type_ctx.endian_variable.dynamic_expr()) {
            if (!is_nil((*ptr))) {
                auto result_dynamic_expr = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_dynamic_expr) {
                    return unexpect_error(std::move(result_dynamic_expr.error()));
                }
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Statement(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref){
        auto main_logic = [&]() -> expected<Result>{
            Context_Statement new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .in = in,
                .alias_ref = alias_ref,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Statement_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .in = in,
            .alias_ref = alias_ref,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Statement_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .in = in,
            .alias_ref = alias_ref,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Statement(UserContext&& ctx,TypeContext&& type_ctx) {
        auto result_in = dispatch_Statement_default<Result>(std::forward<UserContext>(ctx),type_ctx.in,type_ctx.alias_ref);
        if (!result_in) {
            return unexpect_error(std::move(result_in.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Block(Context&& ctx,const ebm::Block& in){
        auto main_logic = [&]() -> expected<Result>{
            Context_Block new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .in = in,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Block_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .in = in,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Block_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .in = in,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Block(UserContext&& ctx,TypeContext&& type_ctx) {
        auto result_in = dispatch_Block_default<Result>(std::forward<UserContext>(ctx),type_ctx.in);
        if (!result_in) {
            return unexpect_error(std::move(result_in.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_LITERAL_INT(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.int_value()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::int_value");
        }
        auto& int_value = *in.body.int_value();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_LITERAL_INT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .int_value = int_value,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_LITERAL_INT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .int_value = int_value,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_LITERAL_INT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .int_value = int_value,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_LITERAL_INT(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_LITERAL_INT64(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.int64_value()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::int64_value");
        }
        auto& int64_value = *in.body.int64_value();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_LITERAL_INT64 new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .int64_value = int64_value,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_LITERAL_INT64_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .int64_value = int64_value,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_LITERAL_INT64_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .int64_value = int64_value,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_LITERAL_INT64(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_LITERAL_BOOL(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.bool_value()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::bool_value");
        }
        auto& bool_value = *in.body.bool_value();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_LITERAL_BOOL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .bool_value = bool_value,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_LITERAL_BOOL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .bool_value = bool_value,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_LITERAL_BOOL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .bool_value = bool_value,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_LITERAL_BOOL(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_LITERAL_STRING(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.string_value()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::string_value");
        }
        auto& string_value = *in.body.string_value();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_LITERAL_STRING new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .string_value = string_value,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_LITERAL_STRING_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .string_value = string_value,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_LITERAL_STRING_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .string_value = string_value,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_LITERAL_STRING(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_LITERAL_TYPE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.type_ref()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::type_ref");
        }
        auto& type_ref = *in.body.type_ref();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_LITERAL_TYPE new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .type_ref = type_ref,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_LITERAL_TYPE_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .type_ref = type_ref,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_LITERAL_TYPE_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .type_ref = type_ref,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_LITERAL_TYPE(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.type_ref)) {
            auto result_type_ref = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type_ref);
            if (!result_type_ref) {
                return unexpect_error(std::move(result_type_ref.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_LITERAL_CHAR(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.char_value()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::char_value");
        }
        auto& char_value = *in.body.char_value();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_LITERAL_CHAR new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .char_value = char_value,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_LITERAL_CHAR_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .char_value = char_value,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_LITERAL_CHAR_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .char_value = char_value,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_LITERAL_CHAR(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_IDENTIFIER(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.id()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::id");
        }
        auto& id = *in.body.id();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_IDENTIFIER new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .id = id,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_IDENTIFIER_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .id = id,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_IDENTIFIER_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .id = id,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_IDENTIFIER(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_BINARY_OP(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.bop()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::bop");
        }
        auto& bop = *in.body.bop();
        if (!in.body.left()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::left");
        }
        auto& left = *in.body.left();
        if (!in.body.right()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::right");
        }
        auto& right = *in.body.right();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_BINARY_OP new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .bop = bop,
                .left = left,
                .right = right,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_BINARY_OP_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .bop = bop,
            .left = left,
            .right = right,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_BINARY_OP_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .bop = bop,
            .left = left,
            .right = right,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_BINARY_OP(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.left)) {
            auto result_left = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.left);
            if (!result_left) {
                return unexpect_error(std::move(result_left.error()));
            }
        }
        if (!is_nil(type_ctx.right)) {
            auto result_right = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.right);
            if (!result_right) {
                return unexpect_error(std::move(result_right.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_UNARY_OP(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.operand()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::operand");
        }
        auto& operand = *in.body.operand();
        if (!in.body.uop()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::uop");
        }
        auto& uop = *in.body.uop();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_UNARY_OP new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .operand = operand,
                .uop = uop,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_UNARY_OP_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .operand = operand,
            .uop = uop,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_UNARY_OP_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .operand = operand,
            .uop = uop,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_UNARY_OP(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.operand)) {
            auto result_operand = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.operand);
            if (!result_operand) {
                return unexpect_error(std::move(result_operand.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_CALL(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.call_desc()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::call_desc");
        }
        auto& call_desc = *in.body.call_desc();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_CALL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .call_desc = call_desc,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_CALL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .call_desc = call_desc,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_CALL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .call_desc = call_desc,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_CALL(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.call_desc.callee)) {
            auto result_callee = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.call_desc.callee);
            if (!result_callee) {
                return unexpect_error(std::move(result_callee.error()));
            }
        }
        auto result_arguments = dispatch_Expressions_default<Result>(std::forward<UserContext>(ctx),type_ctx.call_desc.arguments);
        if (!result_arguments) {
            return unexpect_error(std::move(result_arguments.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_INDEX_ACCESS(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.base()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::base");
        }
        auto& base = *in.body.base();
        if (!in.body.index()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::index");
        }
        auto& index = *in.body.index();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_INDEX_ACCESS new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .base = base,
                .index = index,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_INDEX_ACCESS_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .base = base,
            .index = index,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_INDEX_ACCESS_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .base = base,
            .index = index,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_INDEX_ACCESS(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.base)) {
            auto result_base = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.base);
            if (!result_base) {
                return unexpect_error(std::move(result_base.error()));
            }
        }
        if (!is_nil(type_ctx.index)) {
            auto result_index = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.index);
            if (!result_index) {
                return unexpect_error(std::move(result_index.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_MEMBER_ACCESS(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.base()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::base");
        }
        auto& base = *in.body.base();
        if (!in.body.member()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::member");
        }
        auto& member = *in.body.member();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_MEMBER_ACCESS new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .base = base,
                .member = member,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_MEMBER_ACCESS_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .base = base,
            .member = member,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_MEMBER_ACCESS_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .base = base,
            .member = member,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_MEMBER_ACCESS(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.base)) {
            auto result_base = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.base);
            if (!result_base) {
                return unexpect_error(std::move(result_base.error()));
            }
        }
        if (!is_nil(type_ctx.member)) {
            auto result_member = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.member);
            if (!result_member) {
                return unexpect_error(std::move(result_member.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_ENUM_MEMBER(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.enum_decl()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::enum_decl");
        }
        auto& enum_decl = *in.body.enum_decl();
        if (!in.body.member()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::member");
        }
        auto& member = *in.body.member();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_ENUM_MEMBER new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .enum_decl = enum_decl,
                .member = member,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_ENUM_MEMBER_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .enum_decl = enum_decl,
            .member = member,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_ENUM_MEMBER_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .enum_decl = enum_decl,
            .member = member,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_ENUM_MEMBER(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.enum_decl)) {
            auto result_enum_decl = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.enum_decl);
            if (!result_enum_decl) {
                return unexpect_error(std::move(result_enum_decl.error()));
            }
        }
        if (!is_nil(type_ctx.member)) {
            auto result_member = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.member);
            if (!result_member) {
                return unexpect_error(std::move(result_member.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_TYPE_CAST(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.cast_kind()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::cast_kind");
        }
        auto& cast_kind = *in.body.cast_kind();
        if (!in.body.from_type()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::from_type");
        }
        auto& from_type = *in.body.from_type();
        if (!in.body.source_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::source_expr");
        }
        auto& source_expr = *in.body.source_expr();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_TYPE_CAST new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .cast_kind = cast_kind,
                .from_type = from_type,
                .source_expr = source_expr,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_TYPE_CAST_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .cast_kind = cast_kind,
            .from_type = from_type,
            .source_expr = source_expr,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_TYPE_CAST_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .cast_kind = cast_kind,
            .from_type = from_type,
            .source_expr = source_expr,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_TYPE_CAST(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.from_type)) {
            auto result_from_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.from_type);
            if (!result_from_type) {
                return unexpect_error(std::move(result_from_type.error()));
            }
        }
        if (!is_nil(type_ctx.source_expr)) {
            auto result_source_expr = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.source_expr);
            if (!result_source_expr) {
                return unexpect_error(std::move(result_source_expr.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_RANGE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.end()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::end");
        }
        auto& end = *in.body.end();
        if (!in.body.start()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::start");
        }
        auto& start = *in.body.start();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_RANGE new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .end = end,
                .start = start,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_RANGE_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .end = end,
            .start = start,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_RANGE_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .end = end,
            .start = start,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_RANGE(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.end)) {
            auto result_end = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.end);
            if (!result_end) {
                return unexpect_error(std::move(result_end.error()));
            }
        }
        if (!is_nil(type_ctx.start)) {
            auto result_start = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.start);
            if (!result_start) {
                return unexpect_error(std::move(result_start.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_DEFAULT_VALUE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_DEFAULT_VALUE new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_DEFAULT_VALUE_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_DEFAULT_VALUE_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_DEFAULT_VALUE(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_IS_LITTLE_ENDIAN(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.endian_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::endian_expr");
        }
        auto& endian_expr = *in.body.endian_expr();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_IS_LITTLE_ENDIAN new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .endian_expr = endian_expr,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_IS_LITTLE_ENDIAN_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .endian_expr = endian_expr,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_IS_LITTLE_ENDIAN_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .endian_expr = endian_expr,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_IS_LITTLE_ENDIAN(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.endian_expr)) {
            auto result_endian_expr = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.endian_expr);
            if (!result_endian_expr) {
                return unexpect_error(std::move(result_endian_expr.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_GET_STREAM_OFFSET(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.io_ref()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::io_ref");
        }
        auto& io_ref = *in.body.io_ref();
        if (!in.body.stream_type()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::stream_type");
        }
        auto& stream_type = *in.body.stream_type();
        if (!in.body.unit()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::unit");
        }
        auto& unit = *in.body.unit();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_GET_STREAM_OFFSET new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .io_ref = io_ref,
                .stream_type = stream_type,
                .unit = unit,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_GET_STREAM_OFFSET_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .io_ref = io_ref,
            .stream_type = stream_type,
            .unit = unit,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_GET_STREAM_OFFSET_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .io_ref = io_ref,
            .stream_type = stream_type,
            .unit = unit,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_GET_STREAM_OFFSET(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.io_ref)) {
            auto result_io_ref = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.io_ref);
            if (!result_io_ref) {
                return unexpect_error(std::move(result_io_ref.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_GET_REMAINING_BYTES(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.io_ref()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::io_ref");
        }
        auto& io_ref = *in.body.io_ref();
        if (!in.body.stream_type()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::stream_type");
        }
        auto& stream_type = *in.body.stream_type();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_GET_REMAINING_BYTES new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .io_ref = io_ref,
                .stream_type = stream_type,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_GET_REMAINING_BYTES_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .io_ref = io_ref,
            .stream_type = stream_type,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_GET_REMAINING_BYTES_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .io_ref = io_ref,
            .stream_type = stream_type,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_GET_REMAINING_BYTES(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.io_ref)) {
            auto result_io_ref = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.io_ref);
            if (!result_io_ref) {
                return unexpect_error(std::move(result_io_ref.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_CAN_READ_STREAM(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.io_ref()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::io_ref");
        }
        auto& io_ref = *in.body.io_ref();
        if (!in.body.num_bytes()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::num_bytes");
        }
        auto& num_bytes = *in.body.num_bytes();
        if (!in.body.stream_type()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::stream_type");
        }
        auto& stream_type = *in.body.stream_type();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_CAN_READ_STREAM new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .io_ref = io_ref,
                .num_bytes = num_bytes,
                .stream_type = stream_type,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_CAN_READ_STREAM_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .io_ref = io_ref,
            .num_bytes = num_bytes,
            .stream_type = stream_type,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_CAN_READ_STREAM_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .io_ref = io_ref,
            .num_bytes = num_bytes,
            .stream_type = stream_type,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_CAN_READ_STREAM(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.io_ref)) {
            auto result_io_ref = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.io_ref);
            if (!result_io_ref) {
                return unexpect_error(std::move(result_io_ref.error()));
            }
        }
        if (auto ptr = type_ctx.num_bytes.ref()) {
            if (!is_nil((*ptr))) {
                auto result_ref = visit_Object<Result>(std::forward<UserContext>(ctx),(*ptr));
                if (!result_ref) {
                    return unexpect_error(std::move(result_ref.error()));
                }
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_ARRAY_SIZE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.array_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::array_expr");
        }
        auto& array_expr = *in.body.array_expr();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_ARRAY_SIZE new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .array_expr = array_expr,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_ARRAY_SIZE_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .array_expr = array_expr,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_ARRAY_SIZE_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .array_expr = array_expr,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_ARRAY_SIZE(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.array_expr)) {
            auto result_array_expr = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.array_expr);
            if (!result_array_expr) {
                return unexpect_error(std::move(result_array_expr.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_ENUM_IS_DEFINED(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.lowered_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::lowered_expr");
        }
        auto& lowered_expr = *in.body.lowered_expr();
        if (!in.body.target_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::target_expr");
        }
        auto& target_expr = *in.body.target_expr();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_ENUM_IS_DEFINED new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .lowered_expr = lowered_expr,
                .target_expr = target_expr,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_ENUM_IS_DEFINED_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .lowered_expr = lowered_expr,
            .target_expr = target_expr,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_ENUM_IS_DEFINED_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .lowered_expr = lowered_expr,
            .target_expr = target_expr,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_ENUM_IS_DEFINED(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.target_expr)) {
            auto result_target_expr = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target_expr);
            if (!result_target_expr) {
                return unexpect_error(std::move(result_target_expr.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_IS_ERROR(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.target_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::target_expr");
        }
        auto& target_expr = *in.body.target_expr();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_IS_ERROR new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .target_expr = target_expr,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_IS_ERROR_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .target_expr = target_expr,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_IS_ERROR_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .target_expr = target_expr,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_IS_ERROR(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.target_expr)) {
            auto result_target_expr = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target_expr);
            if (!result_target_expr) {
                return unexpect_error(std::move(result_target_expr.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_MAX_VALUE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.lowered_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::lowered_expr");
        }
        auto& lowered_expr = *in.body.lowered_expr();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_MAX_VALUE new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .lowered_expr = lowered_expr,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_MAX_VALUE_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .lowered_expr = lowered_expr,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_MAX_VALUE_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .lowered_expr = lowered_expr,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_MAX_VALUE(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_READ_DATA(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.io_statement()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::io_statement");
        }
        auto& io_statement = *in.body.io_statement();
        if (!in.body.target_stmt()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::target_stmt");
        }
        auto& target_stmt = *in.body.target_stmt();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_READ_DATA new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .io_statement = io_statement,
                .target_stmt = target_stmt,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_READ_DATA_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .io_statement = io_statement,
            .target_stmt = target_stmt,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_READ_DATA_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .io_statement = io_statement,
            .target_stmt = target_stmt,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_READ_DATA(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.io_statement)) {
            auto result_io_statement = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.io_statement);
            if (!result_io_statement) {
                return unexpect_error(std::move(result_io_statement.error()));
            }
        }
        if (!is_nil(type_ctx.target_stmt)) {
            auto result_target_stmt = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target_stmt);
            if (!result_target_stmt) {
                return unexpect_error(std::move(result_target_stmt.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_WRITE_DATA(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.io_statement()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::io_statement");
        }
        auto& io_statement = *in.body.io_statement();
        if (!in.body.target_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::target_expr");
        }
        auto& target_expr = *in.body.target_expr();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_WRITE_DATA new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .io_statement = io_statement,
                .target_expr = target_expr,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_WRITE_DATA_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .io_statement = io_statement,
            .target_expr = target_expr,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_WRITE_DATA_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .io_statement = io_statement,
            .target_expr = target_expr,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_WRITE_DATA(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.io_statement)) {
            auto result_io_statement = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.io_statement);
            if (!result_io_statement) {
                return unexpect_error(std::move(result_io_statement.error()));
            }
        }
        if (!is_nil(type_ctx.target_expr)) {
            auto result_target_expr = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target_expr);
            if (!result_target_expr) {
                return unexpect_error(std::move(result_target_expr.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_CONDITIONAL_STATEMENT(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.conditional_stmt()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::conditional_stmt");
        }
        auto& conditional_stmt = *in.body.conditional_stmt();
        if (!in.body.target_stmt()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::target_stmt");
        }
        auto& target_stmt = *in.body.target_stmt();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_CONDITIONAL_STATEMENT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .conditional_stmt = conditional_stmt,
                .target_stmt = target_stmt,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_CONDITIONAL_STATEMENT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .conditional_stmt = conditional_stmt,
            .target_stmt = target_stmt,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_CONDITIONAL_STATEMENT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .conditional_stmt = conditional_stmt,
            .target_stmt = target_stmt,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_CONDITIONAL_STATEMENT(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.conditional_stmt)) {
            auto result_conditional_stmt = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.conditional_stmt);
            if (!result_conditional_stmt) {
                return unexpect_error(std::move(result_conditional_stmt.error()));
            }
        }
        if (!is_nil(type_ctx.target_stmt)) {
            auto result_target_stmt = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target_stmt);
            if (!result_target_stmt) {
                return unexpect_error(std::move(result_target_stmt.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_CONDITIONAL(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.condition()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::condition");
        }
        auto& condition = *in.body.condition();
        if (!in.body.else_()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::else_");
        }
        auto& else_ = *in.body.else_();
        if (!in.body.lowered_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::lowered_expr");
        }
        auto& lowered_expr = *in.body.lowered_expr();
        if (!in.body.then()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::then");
        }
        auto& then = *in.body.then();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_CONDITIONAL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .condition = condition,
                .else_ = else_,
                .lowered_expr = lowered_expr,
                .then = then,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_CONDITIONAL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .condition = condition,
            .else_ = else_,
            .lowered_expr = lowered_expr,
            .then = then,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_CONDITIONAL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .condition = condition,
            .else_ = else_,
            .lowered_expr = lowered_expr,
            .then = then,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_CONDITIONAL(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.condition)) {
            auto result_condition = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.condition);
            if (!result_condition) {
                return unexpect_error(std::move(result_condition.error()));
            }
        }
        if (!is_nil(type_ctx.else_)) {
            auto result_else_ = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.else_);
            if (!result_else_) {
                return unexpect_error(std::move(result_else_.error()));
            }
        }
        if (!is_nil(type_ctx.then)) {
            auto result_then = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.then);
            if (!result_then) {
                return unexpect_error(std::move(result_then.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_AVAILABLE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.lowered_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::lowered_expr");
        }
        auto& lowered_expr = *in.body.lowered_expr();
        if (!in.body.target_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::target_expr");
        }
        auto& target_expr = *in.body.target_expr();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_AVAILABLE new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .lowered_expr = lowered_expr,
                .target_expr = target_expr,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_AVAILABLE_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .lowered_expr = lowered_expr,
            .target_expr = target_expr,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_AVAILABLE_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .lowered_expr = lowered_expr,
            .target_expr = target_expr,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_AVAILABLE(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.target_expr)) {
            auto result_target_expr = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target_expr);
            if (!result_target_expr) {
                return unexpect_error(std::move(result_target_expr.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_SIZEOF(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.lowered_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::lowered_expr");
        }
        auto& lowered_expr = *in.body.lowered_expr();
        if (!in.body.target_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::target_expr");
        }
        auto& target_expr = *in.body.target_expr();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_SIZEOF new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .lowered_expr = lowered_expr,
                .target_expr = target_expr,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_SIZEOF_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .lowered_expr = lowered_expr,
            .target_expr = target_expr,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_SIZEOF_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .lowered_expr = lowered_expr,
            .target_expr = target_expr,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_SIZEOF(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.target_expr)) {
            auto result_target_expr = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target_expr);
            if (!result_target_expr) {
                return unexpect_error(std::move(result_target_expr.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_SUB_RANGE_INIT(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.sub_range()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::sub_range");
        }
        auto& sub_range = *in.body.sub_range();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_SUB_RANGE_INIT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .sub_range = sub_range,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_SUB_RANGE_INIT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .sub_range = sub_range,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_SUB_RANGE_INIT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .sub_range = sub_range,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_SUB_RANGE_INIT(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.sub_range)) {
            auto result_sub_range = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.sub_range);
            if (!result_sub_range) {
                return unexpect_error(std::move(result_sub_range.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_OR_COND(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.or_cond()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::or_cond");
        }
        auto& or_cond = *in.body.or_cond();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_OR_COND new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .or_cond = or_cond,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_OR_COND_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .or_cond = or_cond,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_OR_COND_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .or_cond = or_cond,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_OR_COND(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        auto result_or_cond = dispatch_Expressions_default<Result>(std::forward<UserContext>(ctx),type_ctx.or_cond);
        if (!result_or_cond) {
            return unexpect_error(std::move(result_or_cond.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_ADDRESS_OF(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.target_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::target_expr");
        }
        auto& target_expr = *in.body.target_expr();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_ADDRESS_OF new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .target_expr = target_expr,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_ADDRESS_OF_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .target_expr = target_expr,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_ADDRESS_OF_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .target_expr = target_expr,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_ADDRESS_OF(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.target_expr)) {
            auto result_target_expr = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target_expr);
            if (!result_target_expr) {
                return unexpect_error(std::move(result_target_expr.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_OPTIONAL_OF(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.target_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::target_expr");
        }
        auto& target_expr = *in.body.target_expr();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_OPTIONAL_OF new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .target_expr = target_expr,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_OPTIONAL_OF_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .target_expr = target_expr,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_OPTIONAL_OF_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .target_expr = target_expr,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_OPTIONAL_OF(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.target_expr)) {
            auto result_target_expr = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target_expr);
            if (!result_target_expr) {
                return unexpect_error(std::move(result_target_expr.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_SETTER_STATUS(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.setter_status()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::setter_status");
        }
        auto& setter_status = *in.body.setter_status();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_SETTER_STATUS new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .setter_status = setter_status,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_SETTER_STATUS_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .setter_status = setter_status,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_SETTER_STATUS_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .setter_status = setter_status,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_SETTER_STATUS(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_SELF(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_SELF new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_SELF_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_SELF_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_SELF(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression_AS_ARG(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.target_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::target_expr");
        }
        auto& target_expr = *in.body.target_expr();
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression_AS_ARG new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .type = type,
                .kind = kind,
                .target_expr = target_expr,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_AS_ARG_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .target_expr = target_expr,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_AS_ARG_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .type = type,
            .kind = kind,
            .target_expr = target_expr,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression_AS_ARG(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.type)) {
            auto result_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.type);
            if (!result_type) {
                return unexpect_error(std::move(result_type.error()));
            }
        }
        if (!is_nil(type_ctx.target_expr)) {
            auto result_target_expr = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.target_expr);
            if (!result_target_expr) {
                return unexpect_error(std::move(result_target_expr.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expression(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref){
        auto main_logic = [&]() -> expected<Result>{
            Context_Expression new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .in = in,
                .alias_ref = alias_ref,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expression_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .in = in,
            .alias_ref = alias_ref,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expression_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .in = in,
            .alias_ref = alias_ref,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expression(UserContext&& ctx,TypeContext&& type_ctx) {
        auto result_in = dispatch_Expression_default<Result>(std::forward<UserContext>(ctx),type_ctx.in,type_ctx.alias_ref);
        if (!result_in) {
            return unexpect_error(std::move(result_in.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Expressions(Context&& ctx,const ebm::Expressions& in){
        auto main_logic = [&]() -> expected<Result>{
            Context_Expressions new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .in = in,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Expressions_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .in = in,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Expressions_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .in = in,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Expressions(UserContext&& ctx,TypeContext&& type_ctx) {
        auto result_in = dispatch_Expressions_default<Result>(std::forward<UserContext>(ctx),type_ctx.in);
        if (!result_in) {
            return unexpect_error(std::move(result_in.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_INT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.size()) {
            return unexpect_error("Unexpected null pointer for TypeBody::size");
        }
        auto& size = *in.body.size();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_INT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .size = size,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_INT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .size = size,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Type_INT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .size = size,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_INT(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_UINT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.size()) {
            return unexpect_error("Unexpected null pointer for TypeBody::size");
        }
        auto& size = *in.body.size();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_UINT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .size = size,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_UINT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .size = size,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Type_UINT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .size = size,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_UINT(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_USIZE(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_USIZE new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_USIZE_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Type_USIZE_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_USIZE(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_FLOAT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.size()) {
            return unexpect_error("Unexpected null pointer for TypeBody::size");
        }
        auto& size = *in.body.size();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_FLOAT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .size = size,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_FLOAT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .size = size,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Type_FLOAT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .size = size,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_FLOAT(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_STRUCT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.id()) {
            return unexpect_error("Unexpected null pointer for TypeBody::id");
        }
        auto& id = *in.body.id();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_STRUCT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .id = id,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_STRUCT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .id = id,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Type_STRUCT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .id = id,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_STRUCT(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_RECURSIVE_STRUCT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.id()) {
            return unexpect_error("Unexpected null pointer for TypeBody::id");
        }
        auto& id = *in.body.id();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_RECURSIVE_STRUCT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .id = id,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_RECURSIVE_STRUCT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .id = id,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Type_RECURSIVE_STRUCT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .id = id,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_RECURSIVE_STRUCT(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_BOOL(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_BOOL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_BOOL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Type_BOOL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_BOOL(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_VOID(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_VOID new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_VOID_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Type_VOID_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_VOID(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_META(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_META new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_META_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Type_META_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_META(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_ENUM(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.base_type()) {
            return unexpect_error("Unexpected null pointer for TypeBody::base_type");
        }
        auto& base_type = *in.body.base_type();
        if (!in.body.id()) {
            return unexpect_error("Unexpected null pointer for TypeBody::id");
        }
        auto& id = *in.body.id();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_ENUM new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .base_type = base_type,
                .id = id,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_ENUM_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .base_type = base_type,
            .id = id,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Type_ENUM_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .base_type = base_type,
            .id = id,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_ENUM(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.base_type)) {
            auto result_base_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.base_type);
            if (!result_base_type) {
                return unexpect_error(std::move(result_base_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_ARRAY(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.array_annotation()) {
            return unexpect_error("Unexpected null pointer for TypeBody::array_annotation");
        }
        auto& array_annotation = *in.body.array_annotation();
        if (!in.body.element_type()) {
            return unexpect_error("Unexpected null pointer for TypeBody::element_type");
        }
        auto& element_type = *in.body.element_type();
        if (!in.body.length()) {
            return unexpect_error("Unexpected null pointer for TypeBody::length");
        }
        auto& length = *in.body.length();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_ARRAY new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .array_annotation = array_annotation,
                .element_type = element_type,
                .length = length,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_ARRAY_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .array_annotation = array_annotation,
            .element_type = element_type,
            .length = length,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Type_ARRAY_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .array_annotation = array_annotation,
            .element_type = element_type,
            .length = length,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_ARRAY(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.element_type)) {
            auto result_element_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.element_type);
            if (!result_element_type) {
                return unexpect_error(std::move(result_element_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_VECTOR(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.element_type()) {
            return unexpect_error("Unexpected null pointer for TypeBody::element_type");
        }
        auto& element_type = *in.body.element_type();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_VECTOR new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .element_type = element_type,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_VECTOR_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .element_type = element_type,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Type_VECTOR_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .element_type = element_type,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_VECTOR(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.element_type)) {
            auto result_element_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.element_type);
            if (!result_element_type) {
                return unexpect_error(std::move(result_element_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_VARIANT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.variant_desc()) {
            return unexpect_error("Unexpected null pointer for TypeBody::variant_desc");
        }
        auto& variant_desc = *in.body.variant_desc();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_VARIANT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .variant_desc = variant_desc,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_VARIANT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .variant_desc = variant_desc,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Type_VARIANT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .variant_desc = variant_desc,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_VARIANT(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.variant_desc.common_type)) {
            auto result_common_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.variant_desc.common_type);
            if (!result_common_type) {
                return unexpect_error(std::move(result_common_type.error()));
            }
        }
        auto result_members = dispatch_Types_default<Result>(std::forward<UserContext>(ctx),type_ctx.variant_desc.members);
        if (!result_members) {
            return unexpect_error(std::move(result_members.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_RANGE(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.base_type()) {
            return unexpect_error("Unexpected null pointer for TypeBody::base_type");
        }
        auto& base_type = *in.body.base_type();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_RANGE new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .base_type = base_type,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_RANGE_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .base_type = base_type,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Type_RANGE_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .base_type = base_type,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_RANGE(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.base_type)) {
            auto result_base_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.base_type);
            if (!result_base_type) {
                return unexpect_error(std::move(result_base_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_ENCODER_RETURN(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_ENCODER_RETURN new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_ENCODER_RETURN_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Type_ENCODER_RETURN_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_ENCODER_RETURN(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_DECODER_RETURN(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_DECODER_RETURN new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_DECODER_RETURN_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Type_DECODER_RETURN_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_DECODER_RETURN(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_ENCODER_INPUT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_ENCODER_INPUT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_ENCODER_INPUT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Type_ENCODER_INPUT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_ENCODER_INPUT(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_DECODER_INPUT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_DECODER_INPUT new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_DECODER_INPUT_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Type_DECODER_INPUT_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_DECODER_INPUT(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_PROPERTY_SETTER_RETURN(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_PROPERTY_SETTER_RETURN new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_PROPERTY_SETTER_RETURN_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Type_PROPERTY_SETTER_RETURN_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_PROPERTY_SETTER_RETURN(UserContext&& ctx,TypeContext&& type_ctx) {
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_OPTIONAL(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.inner_type()) {
            return unexpect_error("Unexpected null pointer for TypeBody::inner_type");
        }
        auto& inner_type = *in.body.inner_type();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_OPTIONAL new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .inner_type = inner_type,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_OPTIONAL_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .inner_type = inner_type,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Type_OPTIONAL_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .inner_type = inner_type,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_OPTIONAL(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.inner_type)) {
            auto result_inner_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.inner_type);
            if (!result_inner_type) {
                return unexpect_error(std::move(result_inner_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_PTR(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.pointee_type()) {
            return unexpect_error("Unexpected null pointer for TypeBody::pointee_type");
        }
        auto& pointee_type = *in.body.pointee_type();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_PTR new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .pointee_type = pointee_type,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_PTR_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .pointee_type = pointee_type,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Type_PTR_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .pointee_type = pointee_type,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_PTR(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.pointee_type)) {
            auto result_pointee_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.pointee_type);
            if (!result_pointee_type) {
                return unexpect_error(std::move(result_pointee_type.error()));
            }
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type_FUNCTION(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto& kind = in.body.kind;
        if (!in.body.func_desc()) {
            return unexpect_error("Unexpected null pointer for TypeBody::func_desc");
        }
        auto& func_desc = *in.body.func_desc();
        auto main_logic = [&]() -> expected<Result>{
            Context_Type_FUNCTION new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .item_id = is_nil(alias_ref) ? in.id : alias_ref,
                .kind = kind,
                .func_desc = func_desc,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_FUNCTION_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .func_desc = func_desc,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Type_FUNCTION_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .item_id = is_nil(alias_ref) ? in.id : alias_ref,
            .kind = kind,
            .func_desc = func_desc,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type_FUNCTION(UserContext&& ctx,TypeContext&& type_ctx) {
        if (!is_nil(type_ctx.func_desc.return_type)) {
            auto result_return_type = visit_Object<Result>(std::forward<UserContext>(ctx),type_ctx.func_desc.return_type);
            if (!result_return_type) {
                return unexpect_error(std::move(result_return_type.error()));
            }
        }
        auto result_params = dispatch_Types_default<Result>(std::forward<UserContext>(ctx),type_ctx.func_desc.params);
        if (!result_params) {
            return unexpect_error(std::move(result_params.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Type(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref){
        auto main_logic = [&]() -> expected<Result>{
            Context_Type new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .in = in,
                .alias_ref = alias_ref,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Type_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .in = in,
            .alias_ref = alias_ref,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Type_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .in = in,
            .alias_ref = alias_ref,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Type(UserContext&& ctx,TypeContext&& type_ctx) {
        auto result_in = dispatch_Type_default<Result>(std::forward<UserContext>(ctx),type_ctx.in,type_ctx.alias_ref);
        if (!result_in) {
            return unexpect_error(std::move(result_in.error()));
        }
        return {};
    }
    template<typename Result,typename Context>
    expected<Result> dispatch_Types(Context&& ctx,const ebm::Types& in){
        auto main_logic = [&]() -> expected<Result>{
            Context_Types new_ctx{
                .visitor = get_visitor_arg_from_context(ctx),
                .in = in,
            };
            return get_visitor_from_context<Result>(ctx,new_ctx).visit(new_ctx);
        };
        Context_Types_before<Result> before_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .in = in,
            .main_logic = main_logic,
        };
        expected<Result> before_result = get_visitor_from_context<Result>(ctx,before_ctx).visit(before_ctx);
        if (!before_result) {
            if(!ebmcodegen::util::is_pass_error(before_result.error())) {
                return ebmgen::unexpect_error(std::move(before_result.error())); // for trace
            }
        }
        else { // if hijacked
            return before_result;
        }
        expected<Result> main_result = main_logic();
        Context_Types_after<Result> after_ctx{
            .visitor = get_visitor_arg_from_context(ctx),
            .in = in,
            .main_logic = main_logic,
            .result = main_result,
        };
        expected<Result> after_result = get_visitor_from_context<Result>(ctx,after_ctx).visit(after_ctx);
        if (!after_result) {
            if(!ebmcodegen::util::is_pass_error(after_result.error())) {
                return ebmgen::unexpect_error(std::move(after_result.error())); // for trace
            }
        }
        else { // if hijacked
            return after_result;
        }
        return main_result;
    }
    template<typename Result, typename UserContext,typename TypeContext>
    expected<Result> traverse_children_Types(UserContext&& ctx,TypeContext&& type_ctx) {
        auto result_in = dispatch_Types_default<Result>(std::forward<UserContext>(ctx),type_ctx.in);
        if (!result_in) {
            return unexpect_error(std::move(result_in.error()));
        }
        return {};
    }
    template<typename Result, typename UserContext, typename TypeContext>
    expected<Result> traverse_children(UserContext&& uctx, TypeContext&& type_ctx) {
        using TypeContextType = std::decay_t<TypeContext>;
        if constexpr (false) {}
        else if constexpr (std::is_same_v<TypeContextType,Context_entry> || std::is_same_v<TypeContextType,Context_entry_before<Result>> || std::is_same_v<TypeContextType,Context_entry_after<Result>>) {
            return traverse_children_entry<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_pre_visitor> || std::is_same_v<TypeContextType,Context_pre_visitor_before<Result>> || std::is_same_v<TypeContextType,Context_pre_visitor_after<Result>>) {
            return traverse_children_pre_visitor<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_post_entry<Result>> || std::is_same_v<TypeContextType,Context_post_entry_before<Result>> || std::is_same_v<TypeContextType,Context_post_entry_after<Result>>) {
            return traverse_children_post_entry<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_BLOCK> || std::is_same_v<TypeContextType,Context_Statement_BLOCK_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_BLOCK_after<Result>>) {
            return traverse_children_Statement_BLOCK<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_ASSIGNMENT> || std::is_same_v<TypeContextType,Context_Statement_ASSIGNMENT_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_ASSIGNMENT_after<Result>>) {
            return traverse_children_Statement_ASSIGNMENT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_YIELD> || std::is_same_v<TypeContextType,Context_Statement_YIELD_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_YIELD_after<Result>>) {
            return traverse_children_Statement_YIELD<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_APPEND> || std::is_same_v<TypeContextType,Context_Statement_APPEND_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_APPEND_after<Result>>) {
            return traverse_children_Statement_APPEND<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_RETURN> || std::is_same_v<TypeContextType,Context_Statement_RETURN_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_RETURN_after<Result>>) {
            return traverse_children_Statement_RETURN<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_ERROR_RETURN> || std::is_same_v<TypeContextType,Context_Statement_ERROR_RETURN_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_ERROR_RETURN_after<Result>>) {
            return traverse_children_Statement_ERROR_RETURN<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_ASSERT> || std::is_same_v<TypeContextType,Context_Statement_ASSERT_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_ASSERT_after<Result>>) {
            return traverse_children_Statement_ASSERT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_READ_DATA> || std::is_same_v<TypeContextType,Context_Statement_READ_DATA_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_READ_DATA_after<Result>>) {
            return traverse_children_Statement_READ_DATA<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_WRITE_DATA> || std::is_same_v<TypeContextType,Context_Statement_WRITE_DATA_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_WRITE_DATA_after<Result>>) {
            return traverse_children_Statement_WRITE_DATA<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_RESERVE_DATA> || std::is_same_v<TypeContextType,Context_Statement_RESERVE_DATA_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_RESERVE_DATA_after<Result>>) {
            return traverse_children_Statement_RESERVE_DATA<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_IF_STATEMENT> || std::is_same_v<TypeContextType,Context_Statement_IF_STATEMENT_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_IF_STATEMENT_after<Result>>) {
            return traverse_children_Statement_IF_STATEMENT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_LOOP_STATEMENT> || std::is_same_v<TypeContextType,Context_Statement_LOOP_STATEMENT_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_LOOP_STATEMENT_after<Result>>) {
            return traverse_children_Statement_LOOP_STATEMENT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_MATCH_STATEMENT> || std::is_same_v<TypeContextType,Context_Statement_MATCH_STATEMENT_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_MATCH_STATEMENT_after<Result>>) {
            return traverse_children_Statement_MATCH_STATEMENT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_MATCH_BRANCH> || std::is_same_v<TypeContextType,Context_Statement_MATCH_BRANCH_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_MATCH_BRANCH_after<Result>>) {
            return traverse_children_Statement_MATCH_BRANCH<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_BREAK> || std::is_same_v<TypeContextType,Context_Statement_BREAK_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_BREAK_after<Result>>) {
            return traverse_children_Statement_BREAK<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_CONTINUE> || std::is_same_v<TypeContextType,Context_Statement_CONTINUE_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_CONTINUE_after<Result>>) {
            return traverse_children_Statement_CONTINUE<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_FUNCTION_DECL> || std::is_same_v<TypeContextType,Context_Statement_FUNCTION_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_FUNCTION_DECL_after<Result>>) {
            return traverse_children_Statement_FUNCTION_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_VARIABLE_DECL> || std::is_same_v<TypeContextType,Context_Statement_VARIABLE_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_VARIABLE_DECL_after<Result>>) {
            return traverse_children_Statement_VARIABLE_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_PARAMETER_DECL> || std::is_same_v<TypeContextType,Context_Statement_PARAMETER_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_PARAMETER_DECL_after<Result>>) {
            return traverse_children_Statement_PARAMETER_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_FIELD_DECL> || std::is_same_v<TypeContextType,Context_Statement_FIELD_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_FIELD_DECL_after<Result>>) {
            return traverse_children_Statement_FIELD_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_COMPOSITE_FIELD_DECL> || std::is_same_v<TypeContextType,Context_Statement_COMPOSITE_FIELD_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_COMPOSITE_FIELD_DECL_after<Result>>) {
            return traverse_children_Statement_COMPOSITE_FIELD_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_ENUM_DECL> || std::is_same_v<TypeContextType,Context_Statement_ENUM_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_ENUM_DECL_after<Result>>) {
            return traverse_children_Statement_ENUM_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_ENUM_MEMBER_DECL> || std::is_same_v<TypeContextType,Context_Statement_ENUM_MEMBER_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_ENUM_MEMBER_DECL_after<Result>>) {
            return traverse_children_Statement_ENUM_MEMBER_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_STRUCT_DECL> || std::is_same_v<TypeContextType,Context_Statement_STRUCT_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_STRUCT_DECL_after<Result>>) {
            return traverse_children_Statement_STRUCT_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_UNION_DECL> || std::is_same_v<TypeContextType,Context_Statement_UNION_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_UNION_DECL_after<Result>>) {
            return traverse_children_Statement_UNION_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_UNION_MEMBER_DECL> || std::is_same_v<TypeContextType,Context_Statement_UNION_MEMBER_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_UNION_MEMBER_DECL_after<Result>>) {
            return traverse_children_Statement_UNION_MEMBER_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_PROGRAM_DECL> || std::is_same_v<TypeContextType,Context_Statement_PROGRAM_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_PROGRAM_DECL_after<Result>>) {
            return traverse_children_Statement_PROGRAM_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_PROPERTY_DECL> || std::is_same_v<TypeContextType,Context_Statement_PROPERTY_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_PROPERTY_DECL_after<Result>>) {
            return traverse_children_Statement_PROPERTY_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_PROPERTY_MEMBER_DECL> || std::is_same_v<TypeContextType,Context_Statement_PROPERTY_MEMBER_DECL_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_PROPERTY_MEMBER_DECL_after<Result>>) {
            return traverse_children_Statement_PROPERTY_MEMBER_DECL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_METADATA> || std::is_same_v<TypeContextType,Context_Statement_METADATA_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_METADATA_after<Result>>) {
            return traverse_children_Statement_METADATA<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_IMPORT_MODULE> || std::is_same_v<TypeContextType,Context_Statement_IMPORT_MODULE_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_IMPORT_MODULE_after<Result>>) {
            return traverse_children_Statement_IMPORT_MODULE<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_EXPRESSION> || std::is_same_v<TypeContextType,Context_Statement_EXPRESSION_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_EXPRESSION_after<Result>>) {
            return traverse_children_Statement_EXPRESSION<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_ERROR_REPORT> || std::is_same_v<TypeContextType,Context_Statement_ERROR_REPORT_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_ERROR_REPORT_after<Result>>) {
            return traverse_children_Statement_ERROR_REPORT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_LOWERED_IO_STATEMENTS> || std::is_same_v<TypeContextType,Context_Statement_LOWERED_IO_STATEMENTS_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_LOWERED_IO_STATEMENTS_after<Result>>) {
            return traverse_children_Statement_LOWERED_IO_STATEMENTS<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_SUB_BYTE_RANGE> || std::is_same_v<TypeContextType,Context_Statement_SUB_BYTE_RANGE_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_SUB_BYTE_RANGE_after<Result>>) {
            return traverse_children_Statement_SUB_BYTE_RANGE<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_INIT_CHECK> || std::is_same_v<TypeContextType,Context_Statement_INIT_CHECK_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_INIT_CHECK_after<Result>>) {
            return traverse_children_Statement_INIT_CHECK<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement_ENDIAN_VARIABLE> || std::is_same_v<TypeContextType,Context_Statement_ENDIAN_VARIABLE_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_ENDIAN_VARIABLE_after<Result>>) {
            return traverse_children_Statement_ENDIAN_VARIABLE<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Statement> || std::is_same_v<TypeContextType,Context_Statement_before<Result>> || std::is_same_v<TypeContextType,Context_Statement_after<Result>>) {
            return traverse_children_Statement<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Block> || std::is_same_v<TypeContextType,Context_Block_before<Result>> || std::is_same_v<TypeContextType,Context_Block_after<Result>>) {
            return traverse_children_Block<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_LITERAL_INT> || std::is_same_v<TypeContextType,Context_Expression_LITERAL_INT_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_LITERAL_INT_after<Result>>) {
            return traverse_children_Expression_LITERAL_INT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_LITERAL_INT64> || std::is_same_v<TypeContextType,Context_Expression_LITERAL_INT64_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_LITERAL_INT64_after<Result>>) {
            return traverse_children_Expression_LITERAL_INT64<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_LITERAL_BOOL> || std::is_same_v<TypeContextType,Context_Expression_LITERAL_BOOL_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_LITERAL_BOOL_after<Result>>) {
            return traverse_children_Expression_LITERAL_BOOL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_LITERAL_STRING> || std::is_same_v<TypeContextType,Context_Expression_LITERAL_STRING_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_LITERAL_STRING_after<Result>>) {
            return traverse_children_Expression_LITERAL_STRING<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_LITERAL_TYPE> || std::is_same_v<TypeContextType,Context_Expression_LITERAL_TYPE_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_LITERAL_TYPE_after<Result>>) {
            return traverse_children_Expression_LITERAL_TYPE<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_LITERAL_CHAR> || std::is_same_v<TypeContextType,Context_Expression_LITERAL_CHAR_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_LITERAL_CHAR_after<Result>>) {
            return traverse_children_Expression_LITERAL_CHAR<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_IDENTIFIER> || std::is_same_v<TypeContextType,Context_Expression_IDENTIFIER_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_IDENTIFIER_after<Result>>) {
            return traverse_children_Expression_IDENTIFIER<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_BINARY_OP> || std::is_same_v<TypeContextType,Context_Expression_BINARY_OP_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_BINARY_OP_after<Result>>) {
            return traverse_children_Expression_BINARY_OP<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_UNARY_OP> || std::is_same_v<TypeContextType,Context_Expression_UNARY_OP_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_UNARY_OP_after<Result>>) {
            return traverse_children_Expression_UNARY_OP<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_CALL> || std::is_same_v<TypeContextType,Context_Expression_CALL_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_CALL_after<Result>>) {
            return traverse_children_Expression_CALL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_INDEX_ACCESS> || std::is_same_v<TypeContextType,Context_Expression_INDEX_ACCESS_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_INDEX_ACCESS_after<Result>>) {
            return traverse_children_Expression_INDEX_ACCESS<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_MEMBER_ACCESS> || std::is_same_v<TypeContextType,Context_Expression_MEMBER_ACCESS_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_MEMBER_ACCESS_after<Result>>) {
            return traverse_children_Expression_MEMBER_ACCESS<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_ENUM_MEMBER> || std::is_same_v<TypeContextType,Context_Expression_ENUM_MEMBER_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_ENUM_MEMBER_after<Result>>) {
            return traverse_children_Expression_ENUM_MEMBER<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_TYPE_CAST> || std::is_same_v<TypeContextType,Context_Expression_TYPE_CAST_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_TYPE_CAST_after<Result>>) {
            return traverse_children_Expression_TYPE_CAST<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_RANGE> || std::is_same_v<TypeContextType,Context_Expression_RANGE_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_RANGE_after<Result>>) {
            return traverse_children_Expression_RANGE<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_DEFAULT_VALUE> || std::is_same_v<TypeContextType,Context_Expression_DEFAULT_VALUE_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_DEFAULT_VALUE_after<Result>>) {
            return traverse_children_Expression_DEFAULT_VALUE<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_IS_LITTLE_ENDIAN> || std::is_same_v<TypeContextType,Context_Expression_IS_LITTLE_ENDIAN_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_IS_LITTLE_ENDIAN_after<Result>>) {
            return traverse_children_Expression_IS_LITTLE_ENDIAN<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_GET_STREAM_OFFSET> || std::is_same_v<TypeContextType,Context_Expression_GET_STREAM_OFFSET_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_GET_STREAM_OFFSET_after<Result>>) {
            return traverse_children_Expression_GET_STREAM_OFFSET<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_GET_REMAINING_BYTES> || std::is_same_v<TypeContextType,Context_Expression_GET_REMAINING_BYTES_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_GET_REMAINING_BYTES_after<Result>>) {
            return traverse_children_Expression_GET_REMAINING_BYTES<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_CAN_READ_STREAM> || std::is_same_v<TypeContextType,Context_Expression_CAN_READ_STREAM_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_CAN_READ_STREAM_after<Result>>) {
            return traverse_children_Expression_CAN_READ_STREAM<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_ARRAY_SIZE> || std::is_same_v<TypeContextType,Context_Expression_ARRAY_SIZE_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_ARRAY_SIZE_after<Result>>) {
            return traverse_children_Expression_ARRAY_SIZE<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_ENUM_IS_DEFINED> || std::is_same_v<TypeContextType,Context_Expression_ENUM_IS_DEFINED_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_ENUM_IS_DEFINED_after<Result>>) {
            return traverse_children_Expression_ENUM_IS_DEFINED<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_IS_ERROR> || std::is_same_v<TypeContextType,Context_Expression_IS_ERROR_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_IS_ERROR_after<Result>>) {
            return traverse_children_Expression_IS_ERROR<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_MAX_VALUE> || std::is_same_v<TypeContextType,Context_Expression_MAX_VALUE_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_MAX_VALUE_after<Result>>) {
            return traverse_children_Expression_MAX_VALUE<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_READ_DATA> || std::is_same_v<TypeContextType,Context_Expression_READ_DATA_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_READ_DATA_after<Result>>) {
            return traverse_children_Expression_READ_DATA<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_WRITE_DATA> || std::is_same_v<TypeContextType,Context_Expression_WRITE_DATA_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_WRITE_DATA_after<Result>>) {
            return traverse_children_Expression_WRITE_DATA<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_CONDITIONAL_STATEMENT> || std::is_same_v<TypeContextType,Context_Expression_CONDITIONAL_STATEMENT_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_CONDITIONAL_STATEMENT_after<Result>>) {
            return traverse_children_Expression_CONDITIONAL_STATEMENT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_CONDITIONAL> || std::is_same_v<TypeContextType,Context_Expression_CONDITIONAL_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_CONDITIONAL_after<Result>>) {
            return traverse_children_Expression_CONDITIONAL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_AVAILABLE> || std::is_same_v<TypeContextType,Context_Expression_AVAILABLE_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_AVAILABLE_after<Result>>) {
            return traverse_children_Expression_AVAILABLE<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_SIZEOF> || std::is_same_v<TypeContextType,Context_Expression_SIZEOF_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_SIZEOF_after<Result>>) {
            return traverse_children_Expression_SIZEOF<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_SUB_RANGE_INIT> || std::is_same_v<TypeContextType,Context_Expression_SUB_RANGE_INIT_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_SUB_RANGE_INIT_after<Result>>) {
            return traverse_children_Expression_SUB_RANGE_INIT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_OR_COND> || std::is_same_v<TypeContextType,Context_Expression_OR_COND_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_OR_COND_after<Result>>) {
            return traverse_children_Expression_OR_COND<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_ADDRESS_OF> || std::is_same_v<TypeContextType,Context_Expression_ADDRESS_OF_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_ADDRESS_OF_after<Result>>) {
            return traverse_children_Expression_ADDRESS_OF<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_OPTIONAL_OF> || std::is_same_v<TypeContextType,Context_Expression_OPTIONAL_OF_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_OPTIONAL_OF_after<Result>>) {
            return traverse_children_Expression_OPTIONAL_OF<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_SETTER_STATUS> || std::is_same_v<TypeContextType,Context_Expression_SETTER_STATUS_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_SETTER_STATUS_after<Result>>) {
            return traverse_children_Expression_SETTER_STATUS<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_SELF> || std::is_same_v<TypeContextType,Context_Expression_SELF_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_SELF_after<Result>>) {
            return traverse_children_Expression_SELF<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression_AS_ARG> || std::is_same_v<TypeContextType,Context_Expression_AS_ARG_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_AS_ARG_after<Result>>) {
            return traverse_children_Expression_AS_ARG<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expression> || std::is_same_v<TypeContextType,Context_Expression_before<Result>> || std::is_same_v<TypeContextType,Context_Expression_after<Result>>) {
            return traverse_children_Expression<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Expressions> || std::is_same_v<TypeContextType,Context_Expressions_before<Result>> || std::is_same_v<TypeContextType,Context_Expressions_after<Result>>) {
            return traverse_children_Expressions<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_INT> || std::is_same_v<TypeContextType,Context_Type_INT_before<Result>> || std::is_same_v<TypeContextType,Context_Type_INT_after<Result>>) {
            return traverse_children_Type_INT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_UINT> || std::is_same_v<TypeContextType,Context_Type_UINT_before<Result>> || std::is_same_v<TypeContextType,Context_Type_UINT_after<Result>>) {
            return traverse_children_Type_UINT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_USIZE> || std::is_same_v<TypeContextType,Context_Type_USIZE_before<Result>> || std::is_same_v<TypeContextType,Context_Type_USIZE_after<Result>>) {
            return traverse_children_Type_USIZE<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_FLOAT> || std::is_same_v<TypeContextType,Context_Type_FLOAT_before<Result>> || std::is_same_v<TypeContextType,Context_Type_FLOAT_after<Result>>) {
            return traverse_children_Type_FLOAT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_STRUCT> || std::is_same_v<TypeContextType,Context_Type_STRUCT_before<Result>> || std::is_same_v<TypeContextType,Context_Type_STRUCT_after<Result>>) {
            return traverse_children_Type_STRUCT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_RECURSIVE_STRUCT> || std::is_same_v<TypeContextType,Context_Type_RECURSIVE_STRUCT_before<Result>> || std::is_same_v<TypeContextType,Context_Type_RECURSIVE_STRUCT_after<Result>>) {
            return traverse_children_Type_RECURSIVE_STRUCT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_BOOL> || std::is_same_v<TypeContextType,Context_Type_BOOL_before<Result>> || std::is_same_v<TypeContextType,Context_Type_BOOL_after<Result>>) {
            return traverse_children_Type_BOOL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_VOID> || std::is_same_v<TypeContextType,Context_Type_VOID_before<Result>> || std::is_same_v<TypeContextType,Context_Type_VOID_after<Result>>) {
            return traverse_children_Type_VOID<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_META> || std::is_same_v<TypeContextType,Context_Type_META_before<Result>> || std::is_same_v<TypeContextType,Context_Type_META_after<Result>>) {
            return traverse_children_Type_META<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_ENUM> || std::is_same_v<TypeContextType,Context_Type_ENUM_before<Result>> || std::is_same_v<TypeContextType,Context_Type_ENUM_after<Result>>) {
            return traverse_children_Type_ENUM<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_ARRAY> || std::is_same_v<TypeContextType,Context_Type_ARRAY_before<Result>> || std::is_same_v<TypeContextType,Context_Type_ARRAY_after<Result>>) {
            return traverse_children_Type_ARRAY<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_VECTOR> || std::is_same_v<TypeContextType,Context_Type_VECTOR_before<Result>> || std::is_same_v<TypeContextType,Context_Type_VECTOR_after<Result>>) {
            return traverse_children_Type_VECTOR<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_VARIANT> || std::is_same_v<TypeContextType,Context_Type_VARIANT_before<Result>> || std::is_same_v<TypeContextType,Context_Type_VARIANT_after<Result>>) {
            return traverse_children_Type_VARIANT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_RANGE> || std::is_same_v<TypeContextType,Context_Type_RANGE_before<Result>> || std::is_same_v<TypeContextType,Context_Type_RANGE_after<Result>>) {
            return traverse_children_Type_RANGE<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_ENCODER_RETURN> || std::is_same_v<TypeContextType,Context_Type_ENCODER_RETURN_before<Result>> || std::is_same_v<TypeContextType,Context_Type_ENCODER_RETURN_after<Result>>) {
            return traverse_children_Type_ENCODER_RETURN<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_DECODER_RETURN> || std::is_same_v<TypeContextType,Context_Type_DECODER_RETURN_before<Result>> || std::is_same_v<TypeContextType,Context_Type_DECODER_RETURN_after<Result>>) {
            return traverse_children_Type_DECODER_RETURN<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_ENCODER_INPUT> || std::is_same_v<TypeContextType,Context_Type_ENCODER_INPUT_before<Result>> || std::is_same_v<TypeContextType,Context_Type_ENCODER_INPUT_after<Result>>) {
            return traverse_children_Type_ENCODER_INPUT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_DECODER_INPUT> || std::is_same_v<TypeContextType,Context_Type_DECODER_INPUT_before<Result>> || std::is_same_v<TypeContextType,Context_Type_DECODER_INPUT_after<Result>>) {
            return traverse_children_Type_DECODER_INPUT<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_PROPERTY_SETTER_RETURN> || std::is_same_v<TypeContextType,Context_Type_PROPERTY_SETTER_RETURN_before<Result>> || std::is_same_v<TypeContextType,Context_Type_PROPERTY_SETTER_RETURN_after<Result>>) {
            return traverse_children_Type_PROPERTY_SETTER_RETURN<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_OPTIONAL> || std::is_same_v<TypeContextType,Context_Type_OPTIONAL_before<Result>> || std::is_same_v<TypeContextType,Context_Type_OPTIONAL_after<Result>>) {
            return traverse_children_Type_OPTIONAL<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_PTR> || std::is_same_v<TypeContextType,Context_Type_PTR_before<Result>> || std::is_same_v<TypeContextType,Context_Type_PTR_after<Result>>) {
            return traverse_children_Type_PTR<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type_FUNCTION> || std::is_same_v<TypeContextType,Context_Type_FUNCTION_before<Result>> || std::is_same_v<TypeContextType,Context_Type_FUNCTION_after<Result>>) {
            return traverse_children_Type_FUNCTION<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Type> || std::is_same_v<TypeContextType,Context_Type_before<Result>> || std::is_same_v<TypeContextType,Context_Type_after<Result>>) {
            return traverse_children_Type<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else if constexpr (std::is_same_v<TypeContextType,Context_Types> || std::is_same_v<TypeContextType,Context_Types_before<Result>> || std::is_same_v<TypeContextType,Context_Types_after<Result>>) {
            return traverse_children_Types<Result>(std::forward<UserContext>(uctx),std::forward<TypeContext>(type_ctx));
        }
        else {
            static_assert(dependent_false<TypeContext>, "traverse_children not implemented for this context type");
        }
    }
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_entry>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"entry",0);
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_ENTRY)
    #define CODEGEN_EXPECTED_PRIORITY_ENTRY 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_entry_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_ENTRY_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_ENTRY_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_entry_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_ENTRY_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_ENTRY_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_pre_visitor>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR)
    #define CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_pre_visitor_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_pre_visitor_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_post_entry>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_POST_ENTRY)
    #define CODEGEN_EXPECTED_PRIORITY_POST_ENTRY 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_post_entry_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_post_entry_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_BLOCK>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_BLOCK",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_BLOCK_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_BLOCK_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_ASSIGNMENT>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_ASSIGNMENT",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_ASSIGNMENT_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_ASSIGNMENT_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_YIELD>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_YIELD",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_YIELD_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_YIELD_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_APPEND>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_APPEND",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_APPEND_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_APPEND_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_RETURN>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_RETURN",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_RETURN_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_RETURN_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_ERROR_RETURN>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_ERROR_RETURN",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_ERROR_RETURN_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_ERROR_RETURN_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_ASSERT>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_ASSERT",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_ASSERT_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_ASSERT_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_READ_DATA>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_READ_DATA",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_READ_DATA_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_READ_DATA_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_WRITE_DATA>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_WRITE_DATA",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_WRITE_DATA_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_WRITE_DATA_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_RESERVE_DATA>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_RESERVE_DATA",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_RESERVE_DATA_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_RESERVE_DATA_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_IF_STATEMENT>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_IF_STATEMENT",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_IF_STATEMENT_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_IF_STATEMENT_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_LOOP_STATEMENT>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_LOOP_STATEMENT",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_LOOP_STATEMENT_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_LOOP_STATEMENT_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_MATCH_STATEMENT>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_MATCH_STATEMENT",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_MATCH_STATEMENT_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_MATCH_STATEMENT_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_MATCH_BRANCH>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_MATCH_BRANCH",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_MATCH_BRANCH_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_MATCH_BRANCH_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_BREAK>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_BREAK",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_BREAK_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_BREAK_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_CONTINUE>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_CONTINUE",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_CONTINUE_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_CONTINUE_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_FUNCTION_DECL>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_FUNCTION_DECL",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_FUNCTION_DECL_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_FUNCTION_DECL_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_VARIABLE_DECL>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_VARIABLE_DECL",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_VARIABLE_DECL_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_VARIABLE_DECL_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_PARAMETER_DECL>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_PARAMETER_DECL",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_PARAMETER_DECL_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_PARAMETER_DECL_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_FIELD_DECL>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_FIELD_DECL",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_FIELD_DECL_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_FIELD_DECL_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_COMPOSITE_FIELD_DECL>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_COMPOSITE_FIELD_DECL",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_ENUM_DECL>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_ENUM_DECL",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_ENUM_DECL_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_ENUM_DECL_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_ENUM_MEMBER_DECL>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_ENUM_MEMBER_DECL",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_ENUM_MEMBER_DECL_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_ENUM_MEMBER_DECL_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_STRUCT_DECL>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_STRUCT_DECL",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_STRUCT_DECL_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_STRUCT_DECL_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_UNION_DECL>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_UNION_DECL",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_UNION_DECL_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_UNION_DECL_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_UNION_MEMBER_DECL>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_UNION_MEMBER_DECL",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_UNION_MEMBER_DECL_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_UNION_MEMBER_DECL_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_PROGRAM_DECL>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_PROGRAM_DECL",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_PROGRAM_DECL_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_PROGRAM_DECL_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_PROPERTY_DECL>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_PROPERTY_DECL",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_PROPERTY_DECL_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_PROPERTY_DECL_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_PROPERTY_MEMBER_DECL>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_PROPERTY_MEMBER_DECL",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_METADATA>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_METADATA",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_METADATA_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_METADATA_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_IMPORT_MODULE>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_IMPORT_MODULE",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_IMPORT_MODULE_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_IMPORT_MODULE_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_EXPRESSION>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_EXPRESSION",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_EXPRESSION_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_EXPRESSION_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_ERROR_REPORT>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_ERROR_REPORT",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_ERROR_REPORT_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_ERROR_REPORT_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_LOWERED_IO_STATEMENTS>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_LOWERED_IO_STATEMENTS",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_SUB_BYTE_RANGE>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_SUB_BYTE_RANGE",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_SUB_BYTE_RANGE_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_SUB_BYTE_RANGE_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_INIT_CHECK>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_INIT_CHECK",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_INIT_CHECK_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_INIT_CHECK_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_ENDIAN_VARIABLE>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Statement_ENDIAN_VARIABLE",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_ENDIAN_VARIABLE_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_ENDIAN_VARIABLE_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return dispatch_Statement_default(ctx,ctx.in,ctx.alias_ref);
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Statement_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_STATEMENT_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_STATEMENT_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Block>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return dispatch_Block_default(ctx,ctx.in);
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_BLOCK)
    #define CODEGEN_EXPECTED_PRIORITY_BLOCK 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Block_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_BLOCK_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_BLOCK_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Block_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_BLOCK_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_BLOCK_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_INT>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_LITERAL_INT",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_INT_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_INT_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_INT64>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_LITERAL_INT64",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_INT64_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_INT64_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_BOOL>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_LITERAL_BOOL",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_BOOL_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_BOOL_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_STRING>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_LITERAL_STRING",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_STRING_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_STRING_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_TYPE>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_LITERAL_TYPE",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_TYPE_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_TYPE_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_CHAR>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_LITERAL_CHAR",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_CHAR_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_CHAR_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_IDENTIFIER>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_IDENTIFIER",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_IDENTIFIER_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_IDENTIFIER_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_BINARY_OP>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_BINARY_OP",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_BINARY_OP_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_BINARY_OP_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_UNARY_OP>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_UNARY_OP",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_UNARY_OP_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_UNARY_OP_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_CALL>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_CALL",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_CALL_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_CALL_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_INDEX_ACCESS>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_INDEX_ACCESS",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_INDEX_ACCESS_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_INDEX_ACCESS_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_MEMBER_ACCESS>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_MEMBER_ACCESS",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_MEMBER_ACCESS_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_MEMBER_ACCESS_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_ENUM_MEMBER>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_ENUM_MEMBER",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_ENUM_MEMBER_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_ENUM_MEMBER_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_TYPE_CAST>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_TYPE_CAST",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_TYPE_CAST_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_TYPE_CAST_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_RANGE>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_RANGE",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_RANGE_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_RANGE_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_DEFAULT_VALUE>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_DEFAULT_VALUE",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_DEFAULT_VALUE_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_DEFAULT_VALUE_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_IS_LITTLE_ENDIAN>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_IS_LITTLE_ENDIAN",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_IS_LITTLE_ENDIAN_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_IS_LITTLE_ENDIAN_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_GET_STREAM_OFFSET>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_GET_STREAM_OFFSET",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_GET_STREAM_OFFSET_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_GET_STREAM_OFFSET_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_GET_REMAINING_BYTES>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_GET_REMAINING_BYTES",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_GET_REMAINING_BYTES_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_GET_REMAINING_BYTES_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_CAN_READ_STREAM>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_CAN_READ_STREAM",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_CAN_READ_STREAM_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_CAN_READ_STREAM_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_ARRAY_SIZE>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_ARRAY_SIZE",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_ARRAY_SIZE_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_ARRAY_SIZE_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_ENUM_IS_DEFINED>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_ENUM_IS_DEFINED",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_ENUM_IS_DEFINED_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_ENUM_IS_DEFINED_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_IS_ERROR>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_IS_ERROR",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_IS_ERROR_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_IS_ERROR_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_MAX_VALUE>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_MAX_VALUE",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_MAX_VALUE_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_MAX_VALUE_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_READ_DATA>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_READ_DATA",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_READ_DATA_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_READ_DATA_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_WRITE_DATA>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_WRITE_DATA",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_WRITE_DATA_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_WRITE_DATA_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_CONDITIONAL_STATEMENT>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_CONDITIONAL_STATEMENT",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_CONDITIONAL_STATEMENT_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_CONDITIONAL_STATEMENT_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_CONDITIONAL>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_CONDITIONAL",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_CONDITIONAL_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_CONDITIONAL_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_AVAILABLE>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_AVAILABLE",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_AVAILABLE_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_AVAILABLE_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_SIZEOF>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_SIZEOF",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_SIZEOF_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_SIZEOF_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_SUB_RANGE_INIT>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_SUB_RANGE_INIT",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_SUB_RANGE_INIT_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_SUB_RANGE_INIT_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_OR_COND>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_OR_COND",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_OR_COND_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_OR_COND_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_ADDRESS_OF>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_ADDRESS_OF",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_ADDRESS_OF_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_ADDRESS_OF_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_OPTIONAL_OF>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_OPTIONAL_OF",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_OPTIONAL_OF_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_OPTIONAL_OF_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_SETTER_STATUS>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_SETTER_STATUS",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_SETTER_STATUS_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_SETTER_STATUS_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_SELF>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_SELF",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_SELF_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_SELF_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_AS_ARG>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Expression_AS_ARG",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_AS_ARG_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_AS_ARG_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return dispatch_Expression_default(ctx,ctx.in,ctx.alias_ref);
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expression_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expressions>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return dispatch_Expressions_default(ctx,ctx.in);
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expressions_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Expressions_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_INT>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Type_INT",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_INT)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_INT 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_INT_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_INT_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_INT_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_INT_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_INT_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_INT_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_UINT>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Type_UINT",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_UINT)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_UINT 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_UINT_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_UINT_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_USIZE>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Type_USIZE",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_USIZE_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_USIZE_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_FLOAT>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Type_FLOAT",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_FLOAT_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_FLOAT_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_STRUCT>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Type_STRUCT",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_STRUCT_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_STRUCT_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_RECURSIVE_STRUCT>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Type_RECURSIVE_STRUCT",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_RECURSIVE_STRUCT_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_RECURSIVE_STRUCT_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_BOOL>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Type_BOOL",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_BOOL_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_BOOL_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_VOID>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Type_VOID",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VOID)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_VOID 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_VOID_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_VOID_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_META>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Type_META",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_META)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_META 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_META_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_META_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_META_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_META_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_META_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_META_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_ENUM>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Type_ENUM",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_ENUM_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_ENUM_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_ARRAY>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Type_ARRAY",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_ARRAY_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_ARRAY_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_VECTOR>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Type_VECTOR",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_VECTOR_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_VECTOR_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_VARIANT>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Type_VARIANT",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_VARIANT_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_VARIANT_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_RANGE>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Type_RANGE",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_RANGE_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_RANGE_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_ENCODER_RETURN>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Type_ENCODER_RETURN",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_ENCODER_RETURN_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_ENCODER_RETURN_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_DECODER_RETURN>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Type_DECODER_RETURN",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_DECODER_RETURN_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_DECODER_RETURN_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_ENCODER_INPUT>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Type_ENCODER_INPUT",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_ENCODER_INPUT_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_ENCODER_INPUT_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_DECODER_INPUT>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Type_DECODER_INPUT",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_DECODER_INPUT_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_DECODER_INPUT_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_PROPERTY_SETTER_RETURN>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Type_PROPERTY_SETTER_RETURN",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_PROPERTY_SETTER_RETURN_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_PROPERTY_SETTER_RETURN_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_OPTIONAL>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Type_OPTIONAL",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_OPTIONAL_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_OPTIONAL_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_PTR>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Type_PTR",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PTR)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_PTR 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_PTR_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_PTR_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_FUNCTION>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return visit_unimplemented(get_visitor_arg_from_context(ctx),"Type_FUNCTION",get_id(ctx.item_id));
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_FUNCTION_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_FUNCTION_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return dispatch_Type_default(ctx,ctx.in,ctx.alias_ref);
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Type_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPE_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_TYPE_AFTER 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Types>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return dispatch_Types_default(ctx,ctx.in);
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPES)
    #define CODEGEN_EXPECTED_PRIORITY_TYPES 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Types_before>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPES_BEFORE)
    #define CODEGEN_EXPECTED_PRIORITY_TYPES_BEFORE 6
    #endif
    template <>
    struct Visitor<GeneratorDefaultHook<VisitorTag_Types_after>> {
        template<typename Context>
        auto visit(Context&& ctx) {
            return pass;
        }
    };
    #if !defined(CODEGEN_EXPECTED_PRIORITY_TYPES_AFTER)
    #define CODEGEN_EXPECTED_PRIORITY_TYPES_AFTER 6
    #endif
    struct VisitorsImpl {
        Visitor<UserHook<VisitorTag_entry>> visitor_entry_UserHook;
        Visitor<UserInlinedHook<VisitorTag_entry>> visitor_entry_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_entry>> visitor_entry_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_entry>> visitor_entry_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_entry>> visitor_entry_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_entry>> visitor_entry_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_entry>> visitor_entry_GeneratorDefaultHook;
        auto& get_visitor_entry(const Context_entry&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_ENTRY == 0) {
                return visitor_entry_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_ENTRY == 1) {
                return visitor_entry_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_ENTRY == 2) {
                return visitor_entry_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_ENTRY == 3) {
                return visitor_entry_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_ENTRY == 4) {
                return visitor_entry_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_ENTRY == 5) {
                return visitor_entry_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_ENTRY == 6) {
                return visitor_entry_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_ENTRY>= 0 && CODEGEN_EXPECTED_PRIORITY_ENTRY < 7, "No suitable visitor hook found for entry");
            }
        }
        Visitor<UserHook<VisitorTag_entry_before>> visitor_entry_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_entry_before>> visitor_entry_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_entry_before>> visitor_entry_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_entry_before>> visitor_entry_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_entry_before>> visitor_entry_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_entry_before>> visitor_entry_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_entry_before>> visitor_entry_before_GeneratorDefaultHook;
        auto& get_visitor_entry_before(const Context_entry_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_ENTRY_BEFORE == 0) {
                return visitor_entry_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_ENTRY_BEFORE == 1) {
                return visitor_entry_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_ENTRY_BEFORE == 2) {
                return visitor_entry_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_ENTRY_BEFORE == 3) {
                return visitor_entry_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_ENTRY_BEFORE == 4) {
                return visitor_entry_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_ENTRY_BEFORE == 5) {
                return visitor_entry_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_ENTRY_BEFORE == 6) {
                return visitor_entry_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_ENTRY_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_ENTRY_BEFORE < 7, "No suitable visitor hook found for entry_before");
            }
        }
        Visitor<UserHook<VisitorTag_entry_after>> visitor_entry_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_entry_after>> visitor_entry_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_entry_after>> visitor_entry_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_entry_after>> visitor_entry_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_entry_after>> visitor_entry_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_entry_after>> visitor_entry_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_entry_after>> visitor_entry_after_GeneratorDefaultHook;
        auto& get_visitor_entry_after(const Context_entry_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_ENTRY_AFTER == 0) {
                return visitor_entry_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_ENTRY_AFTER == 1) {
                return visitor_entry_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_ENTRY_AFTER == 2) {
                return visitor_entry_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_ENTRY_AFTER == 3) {
                return visitor_entry_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_ENTRY_AFTER == 4) {
                return visitor_entry_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_ENTRY_AFTER == 5) {
                return visitor_entry_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_ENTRY_AFTER == 6) {
                return visitor_entry_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_ENTRY_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_ENTRY_AFTER < 7, "No suitable visitor hook found for entry_after");
            }
        }
        Visitor<UserHook<VisitorTag_pre_visitor>> visitor_pre_visitor_UserHook;
        Visitor<UserInlinedHook<VisitorTag_pre_visitor>> visitor_pre_visitor_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_pre_visitor>> visitor_pre_visitor_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_pre_visitor>> visitor_pre_visitor_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_pre_visitor>> visitor_pre_visitor_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_pre_visitor>> visitor_pre_visitor_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_pre_visitor>> visitor_pre_visitor_GeneratorDefaultHook;
        auto& get_visitor_pre_visitor(const Context_pre_visitor&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR == 0) {
                return visitor_pre_visitor_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR == 1) {
                return visitor_pre_visitor_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR == 2) {
                return visitor_pre_visitor_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR == 3) {
                return visitor_pre_visitor_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR == 4) {
                return visitor_pre_visitor_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR == 5) {
                return visitor_pre_visitor_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR == 6) {
                return visitor_pre_visitor_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR>= 0 && CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR < 7, "No suitable visitor hook found for pre_visitor");
            }
        }
        Visitor<UserHook<VisitorTag_pre_visitor_before>> visitor_pre_visitor_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_pre_visitor_before>> visitor_pre_visitor_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_pre_visitor_before>> visitor_pre_visitor_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_pre_visitor_before>> visitor_pre_visitor_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_pre_visitor_before>> visitor_pre_visitor_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_pre_visitor_before>> visitor_pre_visitor_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_pre_visitor_before>> visitor_pre_visitor_before_GeneratorDefaultHook;
        auto& get_visitor_pre_visitor_before(const Context_pre_visitor_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_BEFORE == 0) {
                return visitor_pre_visitor_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_BEFORE == 1) {
                return visitor_pre_visitor_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_BEFORE == 2) {
                return visitor_pre_visitor_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_BEFORE == 3) {
                return visitor_pre_visitor_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_BEFORE == 4) {
                return visitor_pre_visitor_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_BEFORE == 5) {
                return visitor_pre_visitor_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_BEFORE == 6) {
                return visitor_pre_visitor_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_BEFORE < 7, "No suitable visitor hook found for pre_visitor_before");
            }
        }
        Visitor<UserHook<VisitorTag_pre_visitor_after>> visitor_pre_visitor_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_pre_visitor_after>> visitor_pre_visitor_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_pre_visitor_after>> visitor_pre_visitor_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_pre_visitor_after>> visitor_pre_visitor_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_pre_visitor_after>> visitor_pre_visitor_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_pre_visitor_after>> visitor_pre_visitor_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_pre_visitor_after>> visitor_pre_visitor_after_GeneratorDefaultHook;
        auto& get_visitor_pre_visitor_after(const Context_pre_visitor_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_AFTER == 0) {
                return visitor_pre_visitor_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_AFTER == 1) {
                return visitor_pre_visitor_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_AFTER == 2) {
                return visitor_pre_visitor_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_AFTER == 3) {
                return visitor_pre_visitor_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_AFTER == 4) {
                return visitor_pre_visitor_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_AFTER == 5) {
                return visitor_pre_visitor_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_AFTER == 6) {
                return visitor_pre_visitor_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_PRE_VISITOR_AFTER < 7, "No suitable visitor hook found for pre_visitor_after");
            }
        }
        Visitor<UserHook<VisitorTag_post_entry>> visitor_post_entry_UserHook;
        Visitor<UserInlinedHook<VisitorTag_post_entry>> visitor_post_entry_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_post_entry>> visitor_post_entry_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_post_entry>> visitor_post_entry_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_post_entry>> visitor_post_entry_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_post_entry>> visitor_post_entry_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_post_entry>> visitor_post_entry_GeneratorDefaultHook;
        auto& get_visitor_post_entry(const Context_post_entry<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_POST_ENTRY == 0) {
                return visitor_post_entry_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_POST_ENTRY == 1) {
                return visitor_post_entry_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_POST_ENTRY == 2) {
                return visitor_post_entry_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_POST_ENTRY == 3) {
                return visitor_post_entry_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_POST_ENTRY == 4) {
                return visitor_post_entry_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_POST_ENTRY == 5) {
                return visitor_post_entry_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_POST_ENTRY == 6) {
                return visitor_post_entry_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_POST_ENTRY>= 0 && CODEGEN_EXPECTED_PRIORITY_POST_ENTRY < 7, "No suitable visitor hook found for post_entry");
            }
        }
        Visitor<UserHook<VisitorTag_post_entry_before>> visitor_post_entry_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_post_entry_before>> visitor_post_entry_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_post_entry_before>> visitor_post_entry_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_post_entry_before>> visitor_post_entry_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_post_entry_before>> visitor_post_entry_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_post_entry_before>> visitor_post_entry_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_post_entry_before>> visitor_post_entry_before_GeneratorDefaultHook;
        auto& get_visitor_post_entry_before(const Context_post_entry_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_BEFORE == 0) {
                return visitor_post_entry_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_BEFORE == 1) {
                return visitor_post_entry_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_BEFORE == 2) {
                return visitor_post_entry_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_BEFORE == 3) {
                return visitor_post_entry_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_BEFORE == 4) {
                return visitor_post_entry_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_BEFORE == 5) {
                return visitor_post_entry_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_BEFORE == 6) {
                return visitor_post_entry_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_BEFORE < 7, "No suitable visitor hook found for post_entry_before");
            }
        }
        Visitor<UserHook<VisitorTag_post_entry_after>> visitor_post_entry_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_post_entry_after>> visitor_post_entry_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_post_entry_after>> visitor_post_entry_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_post_entry_after>> visitor_post_entry_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_post_entry_after>> visitor_post_entry_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_post_entry_after>> visitor_post_entry_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_post_entry_after>> visitor_post_entry_after_GeneratorDefaultHook;
        auto& get_visitor_post_entry_after(const Context_post_entry_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_AFTER == 0) {
                return visitor_post_entry_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_AFTER == 1) {
                return visitor_post_entry_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_AFTER == 2) {
                return visitor_post_entry_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_AFTER == 3) {
                return visitor_post_entry_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_AFTER == 4) {
                return visitor_post_entry_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_AFTER == 5) {
                return visitor_post_entry_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_AFTER == 6) {
                return visitor_post_entry_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_POST_ENTRY_AFTER < 7, "No suitable visitor hook found for post_entry_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_BLOCK>> visitor_Statement_BLOCK_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_BLOCK>> visitor_Statement_BLOCK_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_BLOCK>> visitor_Statement_BLOCK_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_BLOCK>> visitor_Statement_BLOCK_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_BLOCK>> visitor_Statement_BLOCK_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_BLOCK>> visitor_Statement_BLOCK_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_BLOCK>> visitor_Statement_BLOCK_GeneratorDefaultHook;
        auto& get_visitor_Statement_BLOCK(const Context_Statement_BLOCK&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK == 0) {
                return visitor_Statement_BLOCK_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK == 1) {
                return visitor_Statement_BLOCK_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK == 2) {
                return visitor_Statement_BLOCK_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK == 3) {
                return visitor_Statement_BLOCK_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK == 4) {
                return visitor_Statement_BLOCK_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK == 5) {
                return visitor_Statement_BLOCK_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK == 6) {
                return visitor_Statement_BLOCK_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK < 7, "No suitable visitor hook found for Statement_BLOCK");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_BLOCK_before>> visitor_Statement_BLOCK_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_BLOCK_before>> visitor_Statement_BLOCK_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_BLOCK_before>> visitor_Statement_BLOCK_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_BLOCK_before>> visitor_Statement_BLOCK_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_BLOCK_before>> visitor_Statement_BLOCK_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_BLOCK_before>> visitor_Statement_BLOCK_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_BLOCK_before>> visitor_Statement_BLOCK_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_BLOCK_before(const Context_Statement_BLOCK_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_BEFORE == 0) {
                return visitor_Statement_BLOCK_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_BEFORE == 1) {
                return visitor_Statement_BLOCK_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_BEFORE == 2) {
                return visitor_Statement_BLOCK_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_BEFORE == 3) {
                return visitor_Statement_BLOCK_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_BEFORE == 4) {
                return visitor_Statement_BLOCK_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_BEFORE == 5) {
                return visitor_Statement_BLOCK_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_BEFORE == 6) {
                return visitor_Statement_BLOCK_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_BEFORE < 7, "No suitable visitor hook found for Statement_BLOCK_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_BLOCK_after>> visitor_Statement_BLOCK_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_BLOCK_after>> visitor_Statement_BLOCK_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_BLOCK_after>> visitor_Statement_BLOCK_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_BLOCK_after>> visitor_Statement_BLOCK_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_BLOCK_after>> visitor_Statement_BLOCK_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_BLOCK_after>> visitor_Statement_BLOCK_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_BLOCK_after>> visitor_Statement_BLOCK_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_BLOCK_after(const Context_Statement_BLOCK_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_AFTER == 0) {
                return visitor_Statement_BLOCK_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_AFTER == 1) {
                return visitor_Statement_BLOCK_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_AFTER == 2) {
                return visitor_Statement_BLOCK_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_AFTER == 3) {
                return visitor_Statement_BLOCK_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_AFTER == 4) {
                return visitor_Statement_BLOCK_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_AFTER == 5) {
                return visitor_Statement_BLOCK_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_AFTER == 6) {
                return visitor_Statement_BLOCK_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_BLOCK_AFTER < 7, "No suitable visitor hook found for Statement_BLOCK_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_ASSIGNMENT>> visitor_Statement_ASSIGNMENT_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_ASSIGNMENT>> visitor_Statement_ASSIGNMENT_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_ASSIGNMENT>> visitor_Statement_ASSIGNMENT_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_ASSIGNMENT>> visitor_Statement_ASSIGNMENT_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_ASSIGNMENT>> visitor_Statement_ASSIGNMENT_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_ASSIGNMENT>> visitor_Statement_ASSIGNMENT_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_ASSIGNMENT>> visitor_Statement_ASSIGNMENT_GeneratorDefaultHook;
        auto& get_visitor_Statement_ASSIGNMENT(const Context_Statement_ASSIGNMENT&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT == 0) {
                return visitor_Statement_ASSIGNMENT_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT == 1) {
                return visitor_Statement_ASSIGNMENT_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT == 2) {
                return visitor_Statement_ASSIGNMENT_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT == 3) {
                return visitor_Statement_ASSIGNMENT_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT == 4) {
                return visitor_Statement_ASSIGNMENT_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT == 5) {
                return visitor_Statement_ASSIGNMENT_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT == 6) {
                return visitor_Statement_ASSIGNMENT_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT < 7, "No suitable visitor hook found for Statement_ASSIGNMENT");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_ASSIGNMENT_before>> visitor_Statement_ASSIGNMENT_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_ASSIGNMENT_before>> visitor_Statement_ASSIGNMENT_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_ASSIGNMENT_before>> visitor_Statement_ASSIGNMENT_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_ASSIGNMENT_before>> visitor_Statement_ASSIGNMENT_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_ASSIGNMENT_before>> visitor_Statement_ASSIGNMENT_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_ASSIGNMENT_before>> visitor_Statement_ASSIGNMENT_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_ASSIGNMENT_before>> visitor_Statement_ASSIGNMENT_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_ASSIGNMENT_before(const Context_Statement_ASSIGNMENT_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_BEFORE == 0) {
                return visitor_Statement_ASSIGNMENT_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_BEFORE == 1) {
                return visitor_Statement_ASSIGNMENT_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_BEFORE == 2) {
                return visitor_Statement_ASSIGNMENT_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_BEFORE == 3) {
                return visitor_Statement_ASSIGNMENT_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_BEFORE == 4) {
                return visitor_Statement_ASSIGNMENT_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_BEFORE == 5) {
                return visitor_Statement_ASSIGNMENT_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_BEFORE == 6) {
                return visitor_Statement_ASSIGNMENT_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_BEFORE < 7, "No suitable visitor hook found for Statement_ASSIGNMENT_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_ASSIGNMENT_after>> visitor_Statement_ASSIGNMENT_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_ASSIGNMENT_after>> visitor_Statement_ASSIGNMENT_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_ASSIGNMENT_after>> visitor_Statement_ASSIGNMENT_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_ASSIGNMENT_after>> visitor_Statement_ASSIGNMENT_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_ASSIGNMENT_after>> visitor_Statement_ASSIGNMENT_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_ASSIGNMENT_after>> visitor_Statement_ASSIGNMENT_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_ASSIGNMENT_after>> visitor_Statement_ASSIGNMENT_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_ASSIGNMENT_after(const Context_Statement_ASSIGNMENT_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_AFTER == 0) {
                return visitor_Statement_ASSIGNMENT_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_AFTER == 1) {
                return visitor_Statement_ASSIGNMENT_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_AFTER == 2) {
                return visitor_Statement_ASSIGNMENT_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_AFTER == 3) {
                return visitor_Statement_ASSIGNMENT_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_AFTER == 4) {
                return visitor_Statement_ASSIGNMENT_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_AFTER == 5) {
                return visitor_Statement_ASSIGNMENT_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_AFTER == 6) {
                return visitor_Statement_ASSIGNMENT_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSIGNMENT_AFTER < 7, "No suitable visitor hook found for Statement_ASSIGNMENT_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_YIELD>> visitor_Statement_YIELD_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_YIELD>> visitor_Statement_YIELD_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_YIELD>> visitor_Statement_YIELD_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_YIELD>> visitor_Statement_YIELD_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_YIELD>> visitor_Statement_YIELD_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_YIELD>> visitor_Statement_YIELD_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_YIELD>> visitor_Statement_YIELD_GeneratorDefaultHook;
        auto& get_visitor_Statement_YIELD(const Context_Statement_YIELD&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD == 0) {
                return visitor_Statement_YIELD_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD == 1) {
                return visitor_Statement_YIELD_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD == 2) {
                return visitor_Statement_YIELD_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD == 3) {
                return visitor_Statement_YIELD_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD == 4) {
                return visitor_Statement_YIELD_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD == 5) {
                return visitor_Statement_YIELD_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD == 6) {
                return visitor_Statement_YIELD_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD < 7, "No suitable visitor hook found for Statement_YIELD");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_YIELD_before>> visitor_Statement_YIELD_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_YIELD_before>> visitor_Statement_YIELD_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_YIELD_before>> visitor_Statement_YIELD_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_YIELD_before>> visitor_Statement_YIELD_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_YIELD_before>> visitor_Statement_YIELD_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_YIELD_before>> visitor_Statement_YIELD_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_YIELD_before>> visitor_Statement_YIELD_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_YIELD_before(const Context_Statement_YIELD_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_BEFORE == 0) {
                return visitor_Statement_YIELD_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_BEFORE == 1) {
                return visitor_Statement_YIELD_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_BEFORE == 2) {
                return visitor_Statement_YIELD_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_BEFORE == 3) {
                return visitor_Statement_YIELD_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_BEFORE == 4) {
                return visitor_Statement_YIELD_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_BEFORE == 5) {
                return visitor_Statement_YIELD_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_BEFORE == 6) {
                return visitor_Statement_YIELD_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_BEFORE < 7, "No suitable visitor hook found for Statement_YIELD_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_YIELD_after>> visitor_Statement_YIELD_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_YIELD_after>> visitor_Statement_YIELD_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_YIELD_after>> visitor_Statement_YIELD_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_YIELD_after>> visitor_Statement_YIELD_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_YIELD_after>> visitor_Statement_YIELD_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_YIELD_after>> visitor_Statement_YIELD_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_YIELD_after>> visitor_Statement_YIELD_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_YIELD_after(const Context_Statement_YIELD_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_AFTER == 0) {
                return visitor_Statement_YIELD_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_AFTER == 1) {
                return visitor_Statement_YIELD_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_AFTER == 2) {
                return visitor_Statement_YIELD_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_AFTER == 3) {
                return visitor_Statement_YIELD_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_AFTER == 4) {
                return visitor_Statement_YIELD_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_AFTER == 5) {
                return visitor_Statement_YIELD_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_AFTER == 6) {
                return visitor_Statement_YIELD_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_YIELD_AFTER < 7, "No suitable visitor hook found for Statement_YIELD_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_APPEND>> visitor_Statement_APPEND_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_APPEND>> visitor_Statement_APPEND_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_APPEND>> visitor_Statement_APPEND_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_APPEND>> visitor_Statement_APPEND_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_APPEND>> visitor_Statement_APPEND_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_APPEND>> visitor_Statement_APPEND_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_APPEND>> visitor_Statement_APPEND_GeneratorDefaultHook;
        auto& get_visitor_Statement_APPEND(const Context_Statement_APPEND&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND == 0) {
                return visitor_Statement_APPEND_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND == 1) {
                return visitor_Statement_APPEND_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND == 2) {
                return visitor_Statement_APPEND_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND == 3) {
                return visitor_Statement_APPEND_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND == 4) {
                return visitor_Statement_APPEND_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND == 5) {
                return visitor_Statement_APPEND_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND == 6) {
                return visitor_Statement_APPEND_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND < 7, "No suitable visitor hook found for Statement_APPEND");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_APPEND_before>> visitor_Statement_APPEND_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_APPEND_before>> visitor_Statement_APPEND_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_APPEND_before>> visitor_Statement_APPEND_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_APPEND_before>> visitor_Statement_APPEND_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_APPEND_before>> visitor_Statement_APPEND_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_APPEND_before>> visitor_Statement_APPEND_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_APPEND_before>> visitor_Statement_APPEND_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_APPEND_before(const Context_Statement_APPEND_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_BEFORE == 0) {
                return visitor_Statement_APPEND_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_BEFORE == 1) {
                return visitor_Statement_APPEND_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_BEFORE == 2) {
                return visitor_Statement_APPEND_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_BEFORE == 3) {
                return visitor_Statement_APPEND_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_BEFORE == 4) {
                return visitor_Statement_APPEND_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_BEFORE == 5) {
                return visitor_Statement_APPEND_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_BEFORE == 6) {
                return visitor_Statement_APPEND_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_BEFORE < 7, "No suitable visitor hook found for Statement_APPEND_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_APPEND_after>> visitor_Statement_APPEND_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_APPEND_after>> visitor_Statement_APPEND_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_APPEND_after>> visitor_Statement_APPEND_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_APPEND_after>> visitor_Statement_APPEND_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_APPEND_after>> visitor_Statement_APPEND_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_APPEND_after>> visitor_Statement_APPEND_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_APPEND_after>> visitor_Statement_APPEND_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_APPEND_after(const Context_Statement_APPEND_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_AFTER == 0) {
                return visitor_Statement_APPEND_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_AFTER == 1) {
                return visitor_Statement_APPEND_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_AFTER == 2) {
                return visitor_Statement_APPEND_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_AFTER == 3) {
                return visitor_Statement_APPEND_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_AFTER == 4) {
                return visitor_Statement_APPEND_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_AFTER == 5) {
                return visitor_Statement_APPEND_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_AFTER == 6) {
                return visitor_Statement_APPEND_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_APPEND_AFTER < 7, "No suitable visitor hook found for Statement_APPEND_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_RETURN>> visitor_Statement_RETURN_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_RETURN>> visitor_Statement_RETURN_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_RETURN>> visitor_Statement_RETURN_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_RETURN>> visitor_Statement_RETURN_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_RETURN>> visitor_Statement_RETURN_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_RETURN>> visitor_Statement_RETURN_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_RETURN>> visitor_Statement_RETURN_GeneratorDefaultHook;
        auto& get_visitor_Statement_RETURN(const Context_Statement_RETURN&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN == 0) {
                return visitor_Statement_RETURN_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN == 1) {
                return visitor_Statement_RETURN_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN == 2) {
                return visitor_Statement_RETURN_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN == 3) {
                return visitor_Statement_RETURN_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN == 4) {
                return visitor_Statement_RETURN_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN == 5) {
                return visitor_Statement_RETURN_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN == 6) {
                return visitor_Statement_RETURN_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN < 7, "No suitable visitor hook found for Statement_RETURN");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_RETURN_before>> visitor_Statement_RETURN_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_RETURN_before>> visitor_Statement_RETURN_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_RETURN_before>> visitor_Statement_RETURN_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_RETURN_before>> visitor_Statement_RETURN_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_RETURN_before>> visitor_Statement_RETURN_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_RETURN_before>> visitor_Statement_RETURN_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_RETURN_before>> visitor_Statement_RETURN_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_RETURN_before(const Context_Statement_RETURN_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_BEFORE == 0) {
                return visitor_Statement_RETURN_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_BEFORE == 1) {
                return visitor_Statement_RETURN_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_BEFORE == 2) {
                return visitor_Statement_RETURN_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_BEFORE == 3) {
                return visitor_Statement_RETURN_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_BEFORE == 4) {
                return visitor_Statement_RETURN_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_BEFORE == 5) {
                return visitor_Statement_RETURN_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_BEFORE == 6) {
                return visitor_Statement_RETURN_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_BEFORE < 7, "No suitable visitor hook found for Statement_RETURN_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_RETURN_after>> visitor_Statement_RETURN_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_RETURN_after>> visitor_Statement_RETURN_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_RETURN_after>> visitor_Statement_RETURN_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_RETURN_after>> visitor_Statement_RETURN_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_RETURN_after>> visitor_Statement_RETURN_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_RETURN_after>> visitor_Statement_RETURN_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_RETURN_after>> visitor_Statement_RETURN_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_RETURN_after(const Context_Statement_RETURN_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_AFTER == 0) {
                return visitor_Statement_RETURN_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_AFTER == 1) {
                return visitor_Statement_RETURN_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_AFTER == 2) {
                return visitor_Statement_RETURN_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_AFTER == 3) {
                return visitor_Statement_RETURN_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_AFTER == 4) {
                return visitor_Statement_RETURN_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_AFTER == 5) {
                return visitor_Statement_RETURN_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_AFTER == 6) {
                return visitor_Statement_RETURN_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_RETURN_AFTER < 7, "No suitable visitor hook found for Statement_RETURN_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_ERROR_RETURN>> visitor_Statement_ERROR_RETURN_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_ERROR_RETURN>> visitor_Statement_ERROR_RETURN_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_ERROR_RETURN>> visitor_Statement_ERROR_RETURN_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_ERROR_RETURN>> visitor_Statement_ERROR_RETURN_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_ERROR_RETURN>> visitor_Statement_ERROR_RETURN_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_ERROR_RETURN>> visitor_Statement_ERROR_RETURN_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_ERROR_RETURN>> visitor_Statement_ERROR_RETURN_GeneratorDefaultHook;
        auto& get_visitor_Statement_ERROR_RETURN(const Context_Statement_ERROR_RETURN&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN == 0) {
                return visitor_Statement_ERROR_RETURN_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN == 1) {
                return visitor_Statement_ERROR_RETURN_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN == 2) {
                return visitor_Statement_ERROR_RETURN_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN == 3) {
                return visitor_Statement_ERROR_RETURN_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN == 4) {
                return visitor_Statement_ERROR_RETURN_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN == 5) {
                return visitor_Statement_ERROR_RETURN_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN == 6) {
                return visitor_Statement_ERROR_RETURN_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN < 7, "No suitable visitor hook found for Statement_ERROR_RETURN");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_ERROR_RETURN_before>> visitor_Statement_ERROR_RETURN_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_ERROR_RETURN_before>> visitor_Statement_ERROR_RETURN_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_ERROR_RETURN_before>> visitor_Statement_ERROR_RETURN_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_ERROR_RETURN_before>> visitor_Statement_ERROR_RETURN_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_ERROR_RETURN_before>> visitor_Statement_ERROR_RETURN_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_ERROR_RETURN_before>> visitor_Statement_ERROR_RETURN_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_ERROR_RETURN_before>> visitor_Statement_ERROR_RETURN_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_ERROR_RETURN_before(const Context_Statement_ERROR_RETURN_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_BEFORE == 0) {
                return visitor_Statement_ERROR_RETURN_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_BEFORE == 1) {
                return visitor_Statement_ERROR_RETURN_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_BEFORE == 2) {
                return visitor_Statement_ERROR_RETURN_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_BEFORE == 3) {
                return visitor_Statement_ERROR_RETURN_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_BEFORE == 4) {
                return visitor_Statement_ERROR_RETURN_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_BEFORE == 5) {
                return visitor_Statement_ERROR_RETURN_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_BEFORE == 6) {
                return visitor_Statement_ERROR_RETURN_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_BEFORE < 7, "No suitable visitor hook found for Statement_ERROR_RETURN_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_ERROR_RETURN_after>> visitor_Statement_ERROR_RETURN_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_ERROR_RETURN_after>> visitor_Statement_ERROR_RETURN_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_ERROR_RETURN_after>> visitor_Statement_ERROR_RETURN_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_ERROR_RETURN_after>> visitor_Statement_ERROR_RETURN_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_ERROR_RETURN_after>> visitor_Statement_ERROR_RETURN_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_ERROR_RETURN_after>> visitor_Statement_ERROR_RETURN_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_ERROR_RETURN_after>> visitor_Statement_ERROR_RETURN_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_ERROR_RETURN_after(const Context_Statement_ERROR_RETURN_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_AFTER == 0) {
                return visitor_Statement_ERROR_RETURN_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_AFTER == 1) {
                return visitor_Statement_ERROR_RETURN_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_AFTER == 2) {
                return visitor_Statement_ERROR_RETURN_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_AFTER == 3) {
                return visitor_Statement_ERROR_RETURN_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_AFTER == 4) {
                return visitor_Statement_ERROR_RETURN_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_AFTER == 5) {
                return visitor_Statement_ERROR_RETURN_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_AFTER == 6) {
                return visitor_Statement_ERROR_RETURN_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_RETURN_AFTER < 7, "No suitable visitor hook found for Statement_ERROR_RETURN_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_ASSERT>> visitor_Statement_ASSERT_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_ASSERT>> visitor_Statement_ASSERT_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_ASSERT>> visitor_Statement_ASSERT_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_ASSERT>> visitor_Statement_ASSERT_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_ASSERT>> visitor_Statement_ASSERT_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_ASSERT>> visitor_Statement_ASSERT_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_ASSERT>> visitor_Statement_ASSERT_GeneratorDefaultHook;
        auto& get_visitor_Statement_ASSERT(const Context_Statement_ASSERT&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT == 0) {
                return visitor_Statement_ASSERT_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT == 1) {
                return visitor_Statement_ASSERT_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT == 2) {
                return visitor_Statement_ASSERT_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT == 3) {
                return visitor_Statement_ASSERT_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT == 4) {
                return visitor_Statement_ASSERT_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT == 5) {
                return visitor_Statement_ASSERT_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT == 6) {
                return visitor_Statement_ASSERT_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT < 7, "No suitable visitor hook found for Statement_ASSERT");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_ASSERT_before>> visitor_Statement_ASSERT_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_ASSERT_before>> visitor_Statement_ASSERT_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_ASSERT_before>> visitor_Statement_ASSERT_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_ASSERT_before>> visitor_Statement_ASSERT_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_ASSERT_before>> visitor_Statement_ASSERT_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_ASSERT_before>> visitor_Statement_ASSERT_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_ASSERT_before>> visitor_Statement_ASSERT_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_ASSERT_before(const Context_Statement_ASSERT_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_BEFORE == 0) {
                return visitor_Statement_ASSERT_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_BEFORE == 1) {
                return visitor_Statement_ASSERT_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_BEFORE == 2) {
                return visitor_Statement_ASSERT_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_BEFORE == 3) {
                return visitor_Statement_ASSERT_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_BEFORE == 4) {
                return visitor_Statement_ASSERT_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_BEFORE == 5) {
                return visitor_Statement_ASSERT_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_BEFORE == 6) {
                return visitor_Statement_ASSERT_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_BEFORE < 7, "No suitable visitor hook found for Statement_ASSERT_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_ASSERT_after>> visitor_Statement_ASSERT_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_ASSERT_after>> visitor_Statement_ASSERT_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_ASSERT_after>> visitor_Statement_ASSERT_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_ASSERT_after>> visitor_Statement_ASSERT_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_ASSERT_after>> visitor_Statement_ASSERT_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_ASSERT_after>> visitor_Statement_ASSERT_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_ASSERT_after>> visitor_Statement_ASSERT_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_ASSERT_after(const Context_Statement_ASSERT_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_AFTER == 0) {
                return visitor_Statement_ASSERT_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_AFTER == 1) {
                return visitor_Statement_ASSERT_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_AFTER == 2) {
                return visitor_Statement_ASSERT_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_AFTER == 3) {
                return visitor_Statement_ASSERT_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_AFTER == 4) {
                return visitor_Statement_ASSERT_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_AFTER == 5) {
                return visitor_Statement_ASSERT_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_AFTER == 6) {
                return visitor_Statement_ASSERT_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_ASSERT_AFTER < 7, "No suitable visitor hook found for Statement_ASSERT_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_READ_DATA>> visitor_Statement_READ_DATA_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_READ_DATA>> visitor_Statement_READ_DATA_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_READ_DATA>> visitor_Statement_READ_DATA_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_READ_DATA>> visitor_Statement_READ_DATA_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_READ_DATA>> visitor_Statement_READ_DATA_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_READ_DATA>> visitor_Statement_READ_DATA_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_READ_DATA>> visitor_Statement_READ_DATA_GeneratorDefaultHook;
        auto& get_visitor_Statement_READ_DATA(const Context_Statement_READ_DATA&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA == 0) {
                return visitor_Statement_READ_DATA_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA == 1) {
                return visitor_Statement_READ_DATA_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA == 2) {
                return visitor_Statement_READ_DATA_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA == 3) {
                return visitor_Statement_READ_DATA_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA == 4) {
                return visitor_Statement_READ_DATA_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA == 5) {
                return visitor_Statement_READ_DATA_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA == 6) {
                return visitor_Statement_READ_DATA_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA < 7, "No suitable visitor hook found for Statement_READ_DATA");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_READ_DATA_before>> visitor_Statement_READ_DATA_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_READ_DATA_before>> visitor_Statement_READ_DATA_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_READ_DATA_before>> visitor_Statement_READ_DATA_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_READ_DATA_before>> visitor_Statement_READ_DATA_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_READ_DATA_before>> visitor_Statement_READ_DATA_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_READ_DATA_before>> visitor_Statement_READ_DATA_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_READ_DATA_before>> visitor_Statement_READ_DATA_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_READ_DATA_before(const Context_Statement_READ_DATA_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_BEFORE == 0) {
                return visitor_Statement_READ_DATA_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_BEFORE == 1) {
                return visitor_Statement_READ_DATA_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_BEFORE == 2) {
                return visitor_Statement_READ_DATA_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_BEFORE == 3) {
                return visitor_Statement_READ_DATA_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_BEFORE == 4) {
                return visitor_Statement_READ_DATA_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_BEFORE == 5) {
                return visitor_Statement_READ_DATA_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_BEFORE == 6) {
                return visitor_Statement_READ_DATA_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_BEFORE < 7, "No suitable visitor hook found for Statement_READ_DATA_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_READ_DATA_after>> visitor_Statement_READ_DATA_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_READ_DATA_after>> visitor_Statement_READ_DATA_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_READ_DATA_after>> visitor_Statement_READ_DATA_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_READ_DATA_after>> visitor_Statement_READ_DATA_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_READ_DATA_after>> visitor_Statement_READ_DATA_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_READ_DATA_after>> visitor_Statement_READ_DATA_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_READ_DATA_after>> visitor_Statement_READ_DATA_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_READ_DATA_after(const Context_Statement_READ_DATA_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_AFTER == 0) {
                return visitor_Statement_READ_DATA_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_AFTER == 1) {
                return visitor_Statement_READ_DATA_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_AFTER == 2) {
                return visitor_Statement_READ_DATA_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_AFTER == 3) {
                return visitor_Statement_READ_DATA_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_AFTER == 4) {
                return visitor_Statement_READ_DATA_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_AFTER == 5) {
                return visitor_Statement_READ_DATA_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_AFTER == 6) {
                return visitor_Statement_READ_DATA_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_READ_DATA_AFTER < 7, "No suitable visitor hook found for Statement_READ_DATA_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_WRITE_DATA>> visitor_Statement_WRITE_DATA_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_WRITE_DATA>> visitor_Statement_WRITE_DATA_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_WRITE_DATA>> visitor_Statement_WRITE_DATA_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_WRITE_DATA>> visitor_Statement_WRITE_DATA_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_WRITE_DATA>> visitor_Statement_WRITE_DATA_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_WRITE_DATA>> visitor_Statement_WRITE_DATA_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_WRITE_DATA>> visitor_Statement_WRITE_DATA_GeneratorDefaultHook;
        auto& get_visitor_Statement_WRITE_DATA(const Context_Statement_WRITE_DATA&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA == 0) {
                return visitor_Statement_WRITE_DATA_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA == 1) {
                return visitor_Statement_WRITE_DATA_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA == 2) {
                return visitor_Statement_WRITE_DATA_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA == 3) {
                return visitor_Statement_WRITE_DATA_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA == 4) {
                return visitor_Statement_WRITE_DATA_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA == 5) {
                return visitor_Statement_WRITE_DATA_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA == 6) {
                return visitor_Statement_WRITE_DATA_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA < 7, "No suitable visitor hook found for Statement_WRITE_DATA");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_WRITE_DATA_before>> visitor_Statement_WRITE_DATA_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_WRITE_DATA_before>> visitor_Statement_WRITE_DATA_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_WRITE_DATA_before>> visitor_Statement_WRITE_DATA_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_WRITE_DATA_before>> visitor_Statement_WRITE_DATA_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_WRITE_DATA_before>> visitor_Statement_WRITE_DATA_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_WRITE_DATA_before>> visitor_Statement_WRITE_DATA_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_WRITE_DATA_before>> visitor_Statement_WRITE_DATA_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_WRITE_DATA_before(const Context_Statement_WRITE_DATA_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_BEFORE == 0) {
                return visitor_Statement_WRITE_DATA_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_BEFORE == 1) {
                return visitor_Statement_WRITE_DATA_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_BEFORE == 2) {
                return visitor_Statement_WRITE_DATA_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_BEFORE == 3) {
                return visitor_Statement_WRITE_DATA_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_BEFORE == 4) {
                return visitor_Statement_WRITE_DATA_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_BEFORE == 5) {
                return visitor_Statement_WRITE_DATA_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_BEFORE == 6) {
                return visitor_Statement_WRITE_DATA_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_BEFORE < 7, "No suitable visitor hook found for Statement_WRITE_DATA_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_WRITE_DATA_after>> visitor_Statement_WRITE_DATA_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_WRITE_DATA_after>> visitor_Statement_WRITE_DATA_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_WRITE_DATA_after>> visitor_Statement_WRITE_DATA_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_WRITE_DATA_after>> visitor_Statement_WRITE_DATA_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_WRITE_DATA_after>> visitor_Statement_WRITE_DATA_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_WRITE_DATA_after>> visitor_Statement_WRITE_DATA_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_WRITE_DATA_after>> visitor_Statement_WRITE_DATA_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_WRITE_DATA_after(const Context_Statement_WRITE_DATA_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_AFTER == 0) {
                return visitor_Statement_WRITE_DATA_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_AFTER == 1) {
                return visitor_Statement_WRITE_DATA_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_AFTER == 2) {
                return visitor_Statement_WRITE_DATA_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_AFTER == 3) {
                return visitor_Statement_WRITE_DATA_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_AFTER == 4) {
                return visitor_Statement_WRITE_DATA_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_AFTER == 5) {
                return visitor_Statement_WRITE_DATA_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_AFTER == 6) {
                return visitor_Statement_WRITE_DATA_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_WRITE_DATA_AFTER < 7, "No suitable visitor hook found for Statement_WRITE_DATA_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_RESERVE_DATA>> visitor_Statement_RESERVE_DATA_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_RESERVE_DATA>> visitor_Statement_RESERVE_DATA_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_RESERVE_DATA>> visitor_Statement_RESERVE_DATA_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_RESERVE_DATA>> visitor_Statement_RESERVE_DATA_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_RESERVE_DATA>> visitor_Statement_RESERVE_DATA_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_RESERVE_DATA>> visitor_Statement_RESERVE_DATA_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_RESERVE_DATA>> visitor_Statement_RESERVE_DATA_GeneratorDefaultHook;
        auto& get_visitor_Statement_RESERVE_DATA(const Context_Statement_RESERVE_DATA&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA == 0) {
                return visitor_Statement_RESERVE_DATA_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA == 1) {
                return visitor_Statement_RESERVE_DATA_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA == 2) {
                return visitor_Statement_RESERVE_DATA_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA == 3) {
                return visitor_Statement_RESERVE_DATA_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA == 4) {
                return visitor_Statement_RESERVE_DATA_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA == 5) {
                return visitor_Statement_RESERVE_DATA_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA == 6) {
                return visitor_Statement_RESERVE_DATA_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA < 7, "No suitable visitor hook found for Statement_RESERVE_DATA");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_RESERVE_DATA_before>> visitor_Statement_RESERVE_DATA_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_RESERVE_DATA_before>> visitor_Statement_RESERVE_DATA_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_RESERVE_DATA_before>> visitor_Statement_RESERVE_DATA_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_RESERVE_DATA_before>> visitor_Statement_RESERVE_DATA_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_RESERVE_DATA_before>> visitor_Statement_RESERVE_DATA_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_RESERVE_DATA_before>> visitor_Statement_RESERVE_DATA_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_RESERVE_DATA_before>> visitor_Statement_RESERVE_DATA_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_RESERVE_DATA_before(const Context_Statement_RESERVE_DATA_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_BEFORE == 0) {
                return visitor_Statement_RESERVE_DATA_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_BEFORE == 1) {
                return visitor_Statement_RESERVE_DATA_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_BEFORE == 2) {
                return visitor_Statement_RESERVE_DATA_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_BEFORE == 3) {
                return visitor_Statement_RESERVE_DATA_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_BEFORE == 4) {
                return visitor_Statement_RESERVE_DATA_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_BEFORE == 5) {
                return visitor_Statement_RESERVE_DATA_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_BEFORE == 6) {
                return visitor_Statement_RESERVE_DATA_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_BEFORE < 7, "No suitable visitor hook found for Statement_RESERVE_DATA_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_RESERVE_DATA_after>> visitor_Statement_RESERVE_DATA_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_RESERVE_DATA_after>> visitor_Statement_RESERVE_DATA_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_RESERVE_DATA_after>> visitor_Statement_RESERVE_DATA_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_RESERVE_DATA_after>> visitor_Statement_RESERVE_DATA_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_RESERVE_DATA_after>> visitor_Statement_RESERVE_DATA_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_RESERVE_DATA_after>> visitor_Statement_RESERVE_DATA_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_RESERVE_DATA_after>> visitor_Statement_RESERVE_DATA_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_RESERVE_DATA_after(const Context_Statement_RESERVE_DATA_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_AFTER == 0) {
                return visitor_Statement_RESERVE_DATA_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_AFTER == 1) {
                return visitor_Statement_RESERVE_DATA_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_AFTER == 2) {
                return visitor_Statement_RESERVE_DATA_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_AFTER == 3) {
                return visitor_Statement_RESERVE_DATA_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_AFTER == 4) {
                return visitor_Statement_RESERVE_DATA_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_AFTER == 5) {
                return visitor_Statement_RESERVE_DATA_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_AFTER == 6) {
                return visitor_Statement_RESERVE_DATA_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_RESERVE_DATA_AFTER < 7, "No suitable visitor hook found for Statement_RESERVE_DATA_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_IF_STATEMENT>> visitor_Statement_IF_STATEMENT_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_IF_STATEMENT>> visitor_Statement_IF_STATEMENT_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_IF_STATEMENT>> visitor_Statement_IF_STATEMENT_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_IF_STATEMENT>> visitor_Statement_IF_STATEMENT_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_IF_STATEMENT>> visitor_Statement_IF_STATEMENT_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_IF_STATEMENT>> visitor_Statement_IF_STATEMENT_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_IF_STATEMENT>> visitor_Statement_IF_STATEMENT_GeneratorDefaultHook;
        auto& get_visitor_Statement_IF_STATEMENT(const Context_Statement_IF_STATEMENT&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT == 0) {
                return visitor_Statement_IF_STATEMENT_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT == 1) {
                return visitor_Statement_IF_STATEMENT_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT == 2) {
                return visitor_Statement_IF_STATEMENT_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT == 3) {
                return visitor_Statement_IF_STATEMENT_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT == 4) {
                return visitor_Statement_IF_STATEMENT_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT == 5) {
                return visitor_Statement_IF_STATEMENT_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT == 6) {
                return visitor_Statement_IF_STATEMENT_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT < 7, "No suitable visitor hook found for Statement_IF_STATEMENT");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_IF_STATEMENT_before>> visitor_Statement_IF_STATEMENT_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_IF_STATEMENT_before>> visitor_Statement_IF_STATEMENT_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_IF_STATEMENT_before>> visitor_Statement_IF_STATEMENT_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_IF_STATEMENT_before>> visitor_Statement_IF_STATEMENT_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_IF_STATEMENT_before>> visitor_Statement_IF_STATEMENT_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_IF_STATEMENT_before>> visitor_Statement_IF_STATEMENT_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_IF_STATEMENT_before>> visitor_Statement_IF_STATEMENT_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_IF_STATEMENT_before(const Context_Statement_IF_STATEMENT_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_BEFORE == 0) {
                return visitor_Statement_IF_STATEMENT_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_BEFORE == 1) {
                return visitor_Statement_IF_STATEMENT_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_BEFORE == 2) {
                return visitor_Statement_IF_STATEMENT_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_BEFORE == 3) {
                return visitor_Statement_IF_STATEMENT_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_BEFORE == 4) {
                return visitor_Statement_IF_STATEMENT_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_BEFORE == 5) {
                return visitor_Statement_IF_STATEMENT_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_BEFORE == 6) {
                return visitor_Statement_IF_STATEMENT_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_BEFORE < 7, "No suitable visitor hook found for Statement_IF_STATEMENT_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_IF_STATEMENT_after>> visitor_Statement_IF_STATEMENT_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_IF_STATEMENT_after>> visitor_Statement_IF_STATEMENT_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_IF_STATEMENT_after>> visitor_Statement_IF_STATEMENT_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_IF_STATEMENT_after>> visitor_Statement_IF_STATEMENT_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_IF_STATEMENT_after>> visitor_Statement_IF_STATEMENT_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_IF_STATEMENT_after>> visitor_Statement_IF_STATEMENT_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_IF_STATEMENT_after>> visitor_Statement_IF_STATEMENT_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_IF_STATEMENT_after(const Context_Statement_IF_STATEMENT_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_AFTER == 0) {
                return visitor_Statement_IF_STATEMENT_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_AFTER == 1) {
                return visitor_Statement_IF_STATEMENT_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_AFTER == 2) {
                return visitor_Statement_IF_STATEMENT_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_AFTER == 3) {
                return visitor_Statement_IF_STATEMENT_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_AFTER == 4) {
                return visitor_Statement_IF_STATEMENT_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_AFTER == 5) {
                return visitor_Statement_IF_STATEMENT_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_AFTER == 6) {
                return visitor_Statement_IF_STATEMENT_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_IF_STATEMENT_AFTER < 7, "No suitable visitor hook found for Statement_IF_STATEMENT_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_LOOP_STATEMENT>> visitor_Statement_LOOP_STATEMENT_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_LOOP_STATEMENT>> visitor_Statement_LOOP_STATEMENT_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_LOOP_STATEMENT>> visitor_Statement_LOOP_STATEMENT_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_LOOP_STATEMENT>> visitor_Statement_LOOP_STATEMENT_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_LOOP_STATEMENT>> visitor_Statement_LOOP_STATEMENT_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_LOOP_STATEMENT>> visitor_Statement_LOOP_STATEMENT_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_LOOP_STATEMENT>> visitor_Statement_LOOP_STATEMENT_GeneratorDefaultHook;
        auto& get_visitor_Statement_LOOP_STATEMENT(const Context_Statement_LOOP_STATEMENT&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT == 0) {
                return visitor_Statement_LOOP_STATEMENT_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT == 1) {
                return visitor_Statement_LOOP_STATEMENT_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT == 2) {
                return visitor_Statement_LOOP_STATEMENT_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT == 3) {
                return visitor_Statement_LOOP_STATEMENT_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT == 4) {
                return visitor_Statement_LOOP_STATEMENT_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT == 5) {
                return visitor_Statement_LOOP_STATEMENT_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT == 6) {
                return visitor_Statement_LOOP_STATEMENT_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT < 7, "No suitable visitor hook found for Statement_LOOP_STATEMENT");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_LOOP_STATEMENT_before>> visitor_Statement_LOOP_STATEMENT_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_LOOP_STATEMENT_before>> visitor_Statement_LOOP_STATEMENT_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_LOOP_STATEMENT_before>> visitor_Statement_LOOP_STATEMENT_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_LOOP_STATEMENT_before>> visitor_Statement_LOOP_STATEMENT_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_LOOP_STATEMENT_before>> visitor_Statement_LOOP_STATEMENT_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_LOOP_STATEMENT_before>> visitor_Statement_LOOP_STATEMENT_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_LOOP_STATEMENT_before>> visitor_Statement_LOOP_STATEMENT_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_LOOP_STATEMENT_before(const Context_Statement_LOOP_STATEMENT_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_BEFORE == 0) {
                return visitor_Statement_LOOP_STATEMENT_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_BEFORE == 1) {
                return visitor_Statement_LOOP_STATEMENT_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_BEFORE == 2) {
                return visitor_Statement_LOOP_STATEMENT_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_BEFORE == 3) {
                return visitor_Statement_LOOP_STATEMENT_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_BEFORE == 4) {
                return visitor_Statement_LOOP_STATEMENT_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_BEFORE == 5) {
                return visitor_Statement_LOOP_STATEMENT_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_BEFORE == 6) {
                return visitor_Statement_LOOP_STATEMENT_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_BEFORE < 7, "No suitable visitor hook found for Statement_LOOP_STATEMENT_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_LOOP_STATEMENT_after>> visitor_Statement_LOOP_STATEMENT_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_LOOP_STATEMENT_after>> visitor_Statement_LOOP_STATEMENT_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_LOOP_STATEMENT_after>> visitor_Statement_LOOP_STATEMENT_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_LOOP_STATEMENT_after>> visitor_Statement_LOOP_STATEMENT_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_LOOP_STATEMENT_after>> visitor_Statement_LOOP_STATEMENT_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_LOOP_STATEMENT_after>> visitor_Statement_LOOP_STATEMENT_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_LOOP_STATEMENT_after>> visitor_Statement_LOOP_STATEMENT_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_LOOP_STATEMENT_after(const Context_Statement_LOOP_STATEMENT_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_AFTER == 0) {
                return visitor_Statement_LOOP_STATEMENT_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_AFTER == 1) {
                return visitor_Statement_LOOP_STATEMENT_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_AFTER == 2) {
                return visitor_Statement_LOOP_STATEMENT_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_AFTER == 3) {
                return visitor_Statement_LOOP_STATEMENT_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_AFTER == 4) {
                return visitor_Statement_LOOP_STATEMENT_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_AFTER == 5) {
                return visitor_Statement_LOOP_STATEMENT_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_AFTER == 6) {
                return visitor_Statement_LOOP_STATEMENT_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOOP_STATEMENT_AFTER < 7, "No suitable visitor hook found for Statement_LOOP_STATEMENT_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_MATCH_STATEMENT>> visitor_Statement_MATCH_STATEMENT_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_MATCH_STATEMENT>> visitor_Statement_MATCH_STATEMENT_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_MATCH_STATEMENT>> visitor_Statement_MATCH_STATEMENT_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_MATCH_STATEMENT>> visitor_Statement_MATCH_STATEMENT_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_MATCH_STATEMENT>> visitor_Statement_MATCH_STATEMENT_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_MATCH_STATEMENT>> visitor_Statement_MATCH_STATEMENT_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_MATCH_STATEMENT>> visitor_Statement_MATCH_STATEMENT_GeneratorDefaultHook;
        auto& get_visitor_Statement_MATCH_STATEMENT(const Context_Statement_MATCH_STATEMENT&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT == 0) {
                return visitor_Statement_MATCH_STATEMENT_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT == 1) {
                return visitor_Statement_MATCH_STATEMENT_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT == 2) {
                return visitor_Statement_MATCH_STATEMENT_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT == 3) {
                return visitor_Statement_MATCH_STATEMENT_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT == 4) {
                return visitor_Statement_MATCH_STATEMENT_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT == 5) {
                return visitor_Statement_MATCH_STATEMENT_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT == 6) {
                return visitor_Statement_MATCH_STATEMENT_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT < 7, "No suitable visitor hook found for Statement_MATCH_STATEMENT");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_MATCH_STATEMENT_before>> visitor_Statement_MATCH_STATEMENT_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_MATCH_STATEMENT_before>> visitor_Statement_MATCH_STATEMENT_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_MATCH_STATEMENT_before>> visitor_Statement_MATCH_STATEMENT_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_MATCH_STATEMENT_before>> visitor_Statement_MATCH_STATEMENT_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_MATCH_STATEMENT_before>> visitor_Statement_MATCH_STATEMENT_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_MATCH_STATEMENT_before>> visitor_Statement_MATCH_STATEMENT_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_MATCH_STATEMENT_before>> visitor_Statement_MATCH_STATEMENT_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_MATCH_STATEMENT_before(const Context_Statement_MATCH_STATEMENT_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_BEFORE == 0) {
                return visitor_Statement_MATCH_STATEMENT_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_BEFORE == 1) {
                return visitor_Statement_MATCH_STATEMENT_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_BEFORE == 2) {
                return visitor_Statement_MATCH_STATEMENT_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_BEFORE == 3) {
                return visitor_Statement_MATCH_STATEMENT_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_BEFORE == 4) {
                return visitor_Statement_MATCH_STATEMENT_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_BEFORE == 5) {
                return visitor_Statement_MATCH_STATEMENT_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_BEFORE == 6) {
                return visitor_Statement_MATCH_STATEMENT_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_BEFORE < 7, "No suitable visitor hook found for Statement_MATCH_STATEMENT_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_MATCH_STATEMENT_after>> visitor_Statement_MATCH_STATEMENT_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_MATCH_STATEMENT_after>> visitor_Statement_MATCH_STATEMENT_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_MATCH_STATEMENT_after>> visitor_Statement_MATCH_STATEMENT_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_MATCH_STATEMENT_after>> visitor_Statement_MATCH_STATEMENT_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_MATCH_STATEMENT_after>> visitor_Statement_MATCH_STATEMENT_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_MATCH_STATEMENT_after>> visitor_Statement_MATCH_STATEMENT_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_MATCH_STATEMENT_after>> visitor_Statement_MATCH_STATEMENT_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_MATCH_STATEMENT_after(const Context_Statement_MATCH_STATEMENT_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_AFTER == 0) {
                return visitor_Statement_MATCH_STATEMENT_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_AFTER == 1) {
                return visitor_Statement_MATCH_STATEMENT_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_AFTER == 2) {
                return visitor_Statement_MATCH_STATEMENT_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_AFTER == 3) {
                return visitor_Statement_MATCH_STATEMENT_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_AFTER == 4) {
                return visitor_Statement_MATCH_STATEMENT_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_AFTER == 5) {
                return visitor_Statement_MATCH_STATEMENT_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_AFTER == 6) {
                return visitor_Statement_MATCH_STATEMENT_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_STATEMENT_AFTER < 7, "No suitable visitor hook found for Statement_MATCH_STATEMENT_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_MATCH_BRANCH>> visitor_Statement_MATCH_BRANCH_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_MATCH_BRANCH>> visitor_Statement_MATCH_BRANCH_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_MATCH_BRANCH>> visitor_Statement_MATCH_BRANCH_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_MATCH_BRANCH>> visitor_Statement_MATCH_BRANCH_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_MATCH_BRANCH>> visitor_Statement_MATCH_BRANCH_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_MATCH_BRANCH>> visitor_Statement_MATCH_BRANCH_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_MATCH_BRANCH>> visitor_Statement_MATCH_BRANCH_GeneratorDefaultHook;
        auto& get_visitor_Statement_MATCH_BRANCH(const Context_Statement_MATCH_BRANCH&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH == 0) {
                return visitor_Statement_MATCH_BRANCH_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH == 1) {
                return visitor_Statement_MATCH_BRANCH_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH == 2) {
                return visitor_Statement_MATCH_BRANCH_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH == 3) {
                return visitor_Statement_MATCH_BRANCH_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH == 4) {
                return visitor_Statement_MATCH_BRANCH_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH == 5) {
                return visitor_Statement_MATCH_BRANCH_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH == 6) {
                return visitor_Statement_MATCH_BRANCH_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH < 7, "No suitable visitor hook found for Statement_MATCH_BRANCH");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_MATCH_BRANCH_before>> visitor_Statement_MATCH_BRANCH_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_MATCH_BRANCH_before>> visitor_Statement_MATCH_BRANCH_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_MATCH_BRANCH_before>> visitor_Statement_MATCH_BRANCH_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_MATCH_BRANCH_before>> visitor_Statement_MATCH_BRANCH_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_MATCH_BRANCH_before>> visitor_Statement_MATCH_BRANCH_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_MATCH_BRANCH_before>> visitor_Statement_MATCH_BRANCH_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_MATCH_BRANCH_before>> visitor_Statement_MATCH_BRANCH_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_MATCH_BRANCH_before(const Context_Statement_MATCH_BRANCH_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_BEFORE == 0) {
                return visitor_Statement_MATCH_BRANCH_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_BEFORE == 1) {
                return visitor_Statement_MATCH_BRANCH_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_BEFORE == 2) {
                return visitor_Statement_MATCH_BRANCH_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_BEFORE == 3) {
                return visitor_Statement_MATCH_BRANCH_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_BEFORE == 4) {
                return visitor_Statement_MATCH_BRANCH_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_BEFORE == 5) {
                return visitor_Statement_MATCH_BRANCH_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_BEFORE == 6) {
                return visitor_Statement_MATCH_BRANCH_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_BEFORE < 7, "No suitable visitor hook found for Statement_MATCH_BRANCH_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_MATCH_BRANCH_after>> visitor_Statement_MATCH_BRANCH_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_MATCH_BRANCH_after>> visitor_Statement_MATCH_BRANCH_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_MATCH_BRANCH_after>> visitor_Statement_MATCH_BRANCH_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_MATCH_BRANCH_after>> visitor_Statement_MATCH_BRANCH_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_MATCH_BRANCH_after>> visitor_Statement_MATCH_BRANCH_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_MATCH_BRANCH_after>> visitor_Statement_MATCH_BRANCH_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_MATCH_BRANCH_after>> visitor_Statement_MATCH_BRANCH_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_MATCH_BRANCH_after(const Context_Statement_MATCH_BRANCH_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_AFTER == 0) {
                return visitor_Statement_MATCH_BRANCH_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_AFTER == 1) {
                return visitor_Statement_MATCH_BRANCH_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_AFTER == 2) {
                return visitor_Statement_MATCH_BRANCH_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_AFTER == 3) {
                return visitor_Statement_MATCH_BRANCH_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_AFTER == 4) {
                return visitor_Statement_MATCH_BRANCH_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_AFTER == 5) {
                return visitor_Statement_MATCH_BRANCH_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_AFTER == 6) {
                return visitor_Statement_MATCH_BRANCH_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_MATCH_BRANCH_AFTER < 7, "No suitable visitor hook found for Statement_MATCH_BRANCH_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_BREAK>> visitor_Statement_BREAK_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_BREAK>> visitor_Statement_BREAK_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_BREAK>> visitor_Statement_BREAK_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_BREAK>> visitor_Statement_BREAK_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_BREAK>> visitor_Statement_BREAK_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_BREAK>> visitor_Statement_BREAK_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_BREAK>> visitor_Statement_BREAK_GeneratorDefaultHook;
        auto& get_visitor_Statement_BREAK(const Context_Statement_BREAK&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK == 0) {
                return visitor_Statement_BREAK_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK == 1) {
                return visitor_Statement_BREAK_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK == 2) {
                return visitor_Statement_BREAK_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK == 3) {
                return visitor_Statement_BREAK_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK == 4) {
                return visitor_Statement_BREAK_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK == 5) {
                return visitor_Statement_BREAK_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK == 6) {
                return visitor_Statement_BREAK_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK < 7, "No suitable visitor hook found for Statement_BREAK");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_BREAK_before>> visitor_Statement_BREAK_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_BREAK_before>> visitor_Statement_BREAK_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_BREAK_before>> visitor_Statement_BREAK_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_BREAK_before>> visitor_Statement_BREAK_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_BREAK_before>> visitor_Statement_BREAK_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_BREAK_before>> visitor_Statement_BREAK_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_BREAK_before>> visitor_Statement_BREAK_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_BREAK_before(const Context_Statement_BREAK_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_BEFORE == 0) {
                return visitor_Statement_BREAK_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_BEFORE == 1) {
                return visitor_Statement_BREAK_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_BEFORE == 2) {
                return visitor_Statement_BREAK_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_BEFORE == 3) {
                return visitor_Statement_BREAK_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_BEFORE == 4) {
                return visitor_Statement_BREAK_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_BEFORE == 5) {
                return visitor_Statement_BREAK_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_BEFORE == 6) {
                return visitor_Statement_BREAK_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_BEFORE < 7, "No suitable visitor hook found for Statement_BREAK_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_BREAK_after>> visitor_Statement_BREAK_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_BREAK_after>> visitor_Statement_BREAK_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_BREAK_after>> visitor_Statement_BREAK_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_BREAK_after>> visitor_Statement_BREAK_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_BREAK_after>> visitor_Statement_BREAK_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_BREAK_after>> visitor_Statement_BREAK_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_BREAK_after>> visitor_Statement_BREAK_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_BREAK_after(const Context_Statement_BREAK_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_AFTER == 0) {
                return visitor_Statement_BREAK_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_AFTER == 1) {
                return visitor_Statement_BREAK_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_AFTER == 2) {
                return visitor_Statement_BREAK_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_AFTER == 3) {
                return visitor_Statement_BREAK_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_AFTER == 4) {
                return visitor_Statement_BREAK_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_AFTER == 5) {
                return visitor_Statement_BREAK_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_AFTER == 6) {
                return visitor_Statement_BREAK_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_BREAK_AFTER < 7, "No suitable visitor hook found for Statement_BREAK_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_CONTINUE>> visitor_Statement_CONTINUE_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_CONTINUE>> visitor_Statement_CONTINUE_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_CONTINUE>> visitor_Statement_CONTINUE_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_CONTINUE>> visitor_Statement_CONTINUE_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_CONTINUE>> visitor_Statement_CONTINUE_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_CONTINUE>> visitor_Statement_CONTINUE_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_CONTINUE>> visitor_Statement_CONTINUE_GeneratorDefaultHook;
        auto& get_visitor_Statement_CONTINUE(const Context_Statement_CONTINUE&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE == 0) {
                return visitor_Statement_CONTINUE_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE == 1) {
                return visitor_Statement_CONTINUE_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE == 2) {
                return visitor_Statement_CONTINUE_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE == 3) {
                return visitor_Statement_CONTINUE_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE == 4) {
                return visitor_Statement_CONTINUE_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE == 5) {
                return visitor_Statement_CONTINUE_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE == 6) {
                return visitor_Statement_CONTINUE_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE < 7, "No suitable visitor hook found for Statement_CONTINUE");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_CONTINUE_before>> visitor_Statement_CONTINUE_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_CONTINUE_before>> visitor_Statement_CONTINUE_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_CONTINUE_before>> visitor_Statement_CONTINUE_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_CONTINUE_before>> visitor_Statement_CONTINUE_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_CONTINUE_before>> visitor_Statement_CONTINUE_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_CONTINUE_before>> visitor_Statement_CONTINUE_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_CONTINUE_before>> visitor_Statement_CONTINUE_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_CONTINUE_before(const Context_Statement_CONTINUE_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_BEFORE == 0) {
                return visitor_Statement_CONTINUE_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_BEFORE == 1) {
                return visitor_Statement_CONTINUE_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_BEFORE == 2) {
                return visitor_Statement_CONTINUE_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_BEFORE == 3) {
                return visitor_Statement_CONTINUE_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_BEFORE == 4) {
                return visitor_Statement_CONTINUE_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_BEFORE == 5) {
                return visitor_Statement_CONTINUE_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_BEFORE == 6) {
                return visitor_Statement_CONTINUE_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_BEFORE < 7, "No suitable visitor hook found for Statement_CONTINUE_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_CONTINUE_after>> visitor_Statement_CONTINUE_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_CONTINUE_after>> visitor_Statement_CONTINUE_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_CONTINUE_after>> visitor_Statement_CONTINUE_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_CONTINUE_after>> visitor_Statement_CONTINUE_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_CONTINUE_after>> visitor_Statement_CONTINUE_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_CONTINUE_after>> visitor_Statement_CONTINUE_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_CONTINUE_after>> visitor_Statement_CONTINUE_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_CONTINUE_after(const Context_Statement_CONTINUE_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_AFTER == 0) {
                return visitor_Statement_CONTINUE_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_AFTER == 1) {
                return visitor_Statement_CONTINUE_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_AFTER == 2) {
                return visitor_Statement_CONTINUE_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_AFTER == 3) {
                return visitor_Statement_CONTINUE_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_AFTER == 4) {
                return visitor_Statement_CONTINUE_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_AFTER == 5) {
                return visitor_Statement_CONTINUE_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_AFTER == 6) {
                return visitor_Statement_CONTINUE_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_CONTINUE_AFTER < 7, "No suitable visitor hook found for Statement_CONTINUE_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_FUNCTION_DECL>> visitor_Statement_FUNCTION_DECL_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_FUNCTION_DECL>> visitor_Statement_FUNCTION_DECL_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_FUNCTION_DECL>> visitor_Statement_FUNCTION_DECL_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_FUNCTION_DECL>> visitor_Statement_FUNCTION_DECL_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_FUNCTION_DECL>> visitor_Statement_FUNCTION_DECL_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_FUNCTION_DECL>> visitor_Statement_FUNCTION_DECL_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_FUNCTION_DECL>> visitor_Statement_FUNCTION_DECL_GeneratorDefaultHook;
        auto& get_visitor_Statement_FUNCTION_DECL(const Context_Statement_FUNCTION_DECL&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL == 0) {
                return visitor_Statement_FUNCTION_DECL_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL == 1) {
                return visitor_Statement_FUNCTION_DECL_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL == 2) {
                return visitor_Statement_FUNCTION_DECL_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL == 3) {
                return visitor_Statement_FUNCTION_DECL_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL == 4) {
                return visitor_Statement_FUNCTION_DECL_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL == 5) {
                return visitor_Statement_FUNCTION_DECL_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL == 6) {
                return visitor_Statement_FUNCTION_DECL_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL < 7, "No suitable visitor hook found for Statement_FUNCTION_DECL");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_FUNCTION_DECL_before>> visitor_Statement_FUNCTION_DECL_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_FUNCTION_DECL_before>> visitor_Statement_FUNCTION_DECL_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_FUNCTION_DECL_before>> visitor_Statement_FUNCTION_DECL_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_FUNCTION_DECL_before>> visitor_Statement_FUNCTION_DECL_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_FUNCTION_DECL_before>> visitor_Statement_FUNCTION_DECL_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_FUNCTION_DECL_before>> visitor_Statement_FUNCTION_DECL_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_FUNCTION_DECL_before>> visitor_Statement_FUNCTION_DECL_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_FUNCTION_DECL_before(const Context_Statement_FUNCTION_DECL_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_BEFORE == 0) {
                return visitor_Statement_FUNCTION_DECL_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_BEFORE == 1) {
                return visitor_Statement_FUNCTION_DECL_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_BEFORE == 2) {
                return visitor_Statement_FUNCTION_DECL_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_BEFORE == 3) {
                return visitor_Statement_FUNCTION_DECL_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_BEFORE == 4) {
                return visitor_Statement_FUNCTION_DECL_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_BEFORE == 5) {
                return visitor_Statement_FUNCTION_DECL_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_BEFORE == 6) {
                return visitor_Statement_FUNCTION_DECL_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_BEFORE < 7, "No suitable visitor hook found for Statement_FUNCTION_DECL_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_FUNCTION_DECL_after>> visitor_Statement_FUNCTION_DECL_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_FUNCTION_DECL_after>> visitor_Statement_FUNCTION_DECL_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_FUNCTION_DECL_after>> visitor_Statement_FUNCTION_DECL_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_FUNCTION_DECL_after>> visitor_Statement_FUNCTION_DECL_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_FUNCTION_DECL_after>> visitor_Statement_FUNCTION_DECL_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_FUNCTION_DECL_after>> visitor_Statement_FUNCTION_DECL_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_FUNCTION_DECL_after>> visitor_Statement_FUNCTION_DECL_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_FUNCTION_DECL_after(const Context_Statement_FUNCTION_DECL_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_AFTER == 0) {
                return visitor_Statement_FUNCTION_DECL_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_AFTER == 1) {
                return visitor_Statement_FUNCTION_DECL_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_AFTER == 2) {
                return visitor_Statement_FUNCTION_DECL_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_AFTER == 3) {
                return visitor_Statement_FUNCTION_DECL_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_AFTER == 4) {
                return visitor_Statement_FUNCTION_DECL_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_AFTER == 5) {
                return visitor_Statement_FUNCTION_DECL_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_AFTER == 6) {
                return visitor_Statement_FUNCTION_DECL_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_FUNCTION_DECL_AFTER < 7, "No suitable visitor hook found for Statement_FUNCTION_DECL_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_VARIABLE_DECL>> visitor_Statement_VARIABLE_DECL_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_VARIABLE_DECL>> visitor_Statement_VARIABLE_DECL_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_VARIABLE_DECL>> visitor_Statement_VARIABLE_DECL_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_VARIABLE_DECL>> visitor_Statement_VARIABLE_DECL_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_VARIABLE_DECL>> visitor_Statement_VARIABLE_DECL_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_VARIABLE_DECL>> visitor_Statement_VARIABLE_DECL_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_VARIABLE_DECL>> visitor_Statement_VARIABLE_DECL_GeneratorDefaultHook;
        auto& get_visitor_Statement_VARIABLE_DECL(const Context_Statement_VARIABLE_DECL&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL == 0) {
                return visitor_Statement_VARIABLE_DECL_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL == 1) {
                return visitor_Statement_VARIABLE_DECL_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL == 2) {
                return visitor_Statement_VARIABLE_DECL_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL == 3) {
                return visitor_Statement_VARIABLE_DECL_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL == 4) {
                return visitor_Statement_VARIABLE_DECL_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL == 5) {
                return visitor_Statement_VARIABLE_DECL_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL == 6) {
                return visitor_Statement_VARIABLE_DECL_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL < 7, "No suitable visitor hook found for Statement_VARIABLE_DECL");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_VARIABLE_DECL_before>> visitor_Statement_VARIABLE_DECL_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_VARIABLE_DECL_before>> visitor_Statement_VARIABLE_DECL_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_VARIABLE_DECL_before>> visitor_Statement_VARIABLE_DECL_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_VARIABLE_DECL_before>> visitor_Statement_VARIABLE_DECL_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_VARIABLE_DECL_before>> visitor_Statement_VARIABLE_DECL_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_VARIABLE_DECL_before>> visitor_Statement_VARIABLE_DECL_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_VARIABLE_DECL_before>> visitor_Statement_VARIABLE_DECL_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_VARIABLE_DECL_before(const Context_Statement_VARIABLE_DECL_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_BEFORE == 0) {
                return visitor_Statement_VARIABLE_DECL_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_BEFORE == 1) {
                return visitor_Statement_VARIABLE_DECL_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_BEFORE == 2) {
                return visitor_Statement_VARIABLE_DECL_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_BEFORE == 3) {
                return visitor_Statement_VARIABLE_DECL_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_BEFORE == 4) {
                return visitor_Statement_VARIABLE_DECL_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_BEFORE == 5) {
                return visitor_Statement_VARIABLE_DECL_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_BEFORE == 6) {
                return visitor_Statement_VARIABLE_DECL_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_BEFORE < 7, "No suitable visitor hook found for Statement_VARIABLE_DECL_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_VARIABLE_DECL_after>> visitor_Statement_VARIABLE_DECL_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_VARIABLE_DECL_after>> visitor_Statement_VARIABLE_DECL_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_VARIABLE_DECL_after>> visitor_Statement_VARIABLE_DECL_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_VARIABLE_DECL_after>> visitor_Statement_VARIABLE_DECL_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_VARIABLE_DECL_after>> visitor_Statement_VARIABLE_DECL_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_VARIABLE_DECL_after>> visitor_Statement_VARIABLE_DECL_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_VARIABLE_DECL_after>> visitor_Statement_VARIABLE_DECL_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_VARIABLE_DECL_after(const Context_Statement_VARIABLE_DECL_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_AFTER == 0) {
                return visitor_Statement_VARIABLE_DECL_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_AFTER == 1) {
                return visitor_Statement_VARIABLE_DECL_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_AFTER == 2) {
                return visitor_Statement_VARIABLE_DECL_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_AFTER == 3) {
                return visitor_Statement_VARIABLE_DECL_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_AFTER == 4) {
                return visitor_Statement_VARIABLE_DECL_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_AFTER == 5) {
                return visitor_Statement_VARIABLE_DECL_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_AFTER == 6) {
                return visitor_Statement_VARIABLE_DECL_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_VARIABLE_DECL_AFTER < 7, "No suitable visitor hook found for Statement_VARIABLE_DECL_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_PARAMETER_DECL>> visitor_Statement_PARAMETER_DECL_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_PARAMETER_DECL>> visitor_Statement_PARAMETER_DECL_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_PARAMETER_DECL>> visitor_Statement_PARAMETER_DECL_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_PARAMETER_DECL>> visitor_Statement_PARAMETER_DECL_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_PARAMETER_DECL>> visitor_Statement_PARAMETER_DECL_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_PARAMETER_DECL>> visitor_Statement_PARAMETER_DECL_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_PARAMETER_DECL>> visitor_Statement_PARAMETER_DECL_GeneratorDefaultHook;
        auto& get_visitor_Statement_PARAMETER_DECL(const Context_Statement_PARAMETER_DECL&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL == 0) {
                return visitor_Statement_PARAMETER_DECL_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL == 1) {
                return visitor_Statement_PARAMETER_DECL_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL == 2) {
                return visitor_Statement_PARAMETER_DECL_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL == 3) {
                return visitor_Statement_PARAMETER_DECL_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL == 4) {
                return visitor_Statement_PARAMETER_DECL_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL == 5) {
                return visitor_Statement_PARAMETER_DECL_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL == 6) {
                return visitor_Statement_PARAMETER_DECL_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL < 7, "No suitable visitor hook found for Statement_PARAMETER_DECL");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_PARAMETER_DECL_before>> visitor_Statement_PARAMETER_DECL_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_PARAMETER_DECL_before>> visitor_Statement_PARAMETER_DECL_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_PARAMETER_DECL_before>> visitor_Statement_PARAMETER_DECL_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_PARAMETER_DECL_before>> visitor_Statement_PARAMETER_DECL_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_PARAMETER_DECL_before>> visitor_Statement_PARAMETER_DECL_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_PARAMETER_DECL_before>> visitor_Statement_PARAMETER_DECL_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_PARAMETER_DECL_before>> visitor_Statement_PARAMETER_DECL_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_PARAMETER_DECL_before(const Context_Statement_PARAMETER_DECL_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_BEFORE == 0) {
                return visitor_Statement_PARAMETER_DECL_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_BEFORE == 1) {
                return visitor_Statement_PARAMETER_DECL_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_BEFORE == 2) {
                return visitor_Statement_PARAMETER_DECL_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_BEFORE == 3) {
                return visitor_Statement_PARAMETER_DECL_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_BEFORE == 4) {
                return visitor_Statement_PARAMETER_DECL_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_BEFORE == 5) {
                return visitor_Statement_PARAMETER_DECL_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_BEFORE == 6) {
                return visitor_Statement_PARAMETER_DECL_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_BEFORE < 7, "No suitable visitor hook found for Statement_PARAMETER_DECL_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_PARAMETER_DECL_after>> visitor_Statement_PARAMETER_DECL_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_PARAMETER_DECL_after>> visitor_Statement_PARAMETER_DECL_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_PARAMETER_DECL_after>> visitor_Statement_PARAMETER_DECL_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_PARAMETER_DECL_after>> visitor_Statement_PARAMETER_DECL_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_PARAMETER_DECL_after>> visitor_Statement_PARAMETER_DECL_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_PARAMETER_DECL_after>> visitor_Statement_PARAMETER_DECL_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_PARAMETER_DECL_after>> visitor_Statement_PARAMETER_DECL_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_PARAMETER_DECL_after(const Context_Statement_PARAMETER_DECL_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_AFTER == 0) {
                return visitor_Statement_PARAMETER_DECL_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_AFTER == 1) {
                return visitor_Statement_PARAMETER_DECL_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_AFTER == 2) {
                return visitor_Statement_PARAMETER_DECL_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_AFTER == 3) {
                return visitor_Statement_PARAMETER_DECL_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_AFTER == 4) {
                return visitor_Statement_PARAMETER_DECL_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_AFTER == 5) {
                return visitor_Statement_PARAMETER_DECL_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_AFTER == 6) {
                return visitor_Statement_PARAMETER_DECL_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_PARAMETER_DECL_AFTER < 7, "No suitable visitor hook found for Statement_PARAMETER_DECL_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_FIELD_DECL>> visitor_Statement_FIELD_DECL_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_FIELD_DECL>> visitor_Statement_FIELD_DECL_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_FIELD_DECL>> visitor_Statement_FIELD_DECL_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_FIELD_DECL>> visitor_Statement_FIELD_DECL_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_FIELD_DECL>> visitor_Statement_FIELD_DECL_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_FIELD_DECL>> visitor_Statement_FIELD_DECL_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_FIELD_DECL>> visitor_Statement_FIELD_DECL_GeneratorDefaultHook;
        auto& get_visitor_Statement_FIELD_DECL(const Context_Statement_FIELD_DECL&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL == 0) {
                return visitor_Statement_FIELD_DECL_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL == 1) {
                return visitor_Statement_FIELD_DECL_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL == 2) {
                return visitor_Statement_FIELD_DECL_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL == 3) {
                return visitor_Statement_FIELD_DECL_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL == 4) {
                return visitor_Statement_FIELD_DECL_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL == 5) {
                return visitor_Statement_FIELD_DECL_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL == 6) {
                return visitor_Statement_FIELD_DECL_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL < 7, "No suitable visitor hook found for Statement_FIELD_DECL");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_FIELD_DECL_before>> visitor_Statement_FIELD_DECL_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_FIELD_DECL_before>> visitor_Statement_FIELD_DECL_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_FIELD_DECL_before>> visitor_Statement_FIELD_DECL_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_FIELD_DECL_before>> visitor_Statement_FIELD_DECL_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_FIELD_DECL_before>> visitor_Statement_FIELD_DECL_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_FIELD_DECL_before>> visitor_Statement_FIELD_DECL_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_FIELD_DECL_before>> visitor_Statement_FIELD_DECL_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_FIELD_DECL_before(const Context_Statement_FIELD_DECL_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_BEFORE == 0) {
                return visitor_Statement_FIELD_DECL_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_BEFORE == 1) {
                return visitor_Statement_FIELD_DECL_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_BEFORE == 2) {
                return visitor_Statement_FIELD_DECL_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_BEFORE == 3) {
                return visitor_Statement_FIELD_DECL_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_BEFORE == 4) {
                return visitor_Statement_FIELD_DECL_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_BEFORE == 5) {
                return visitor_Statement_FIELD_DECL_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_BEFORE == 6) {
                return visitor_Statement_FIELD_DECL_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_BEFORE < 7, "No suitable visitor hook found for Statement_FIELD_DECL_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_FIELD_DECL_after>> visitor_Statement_FIELD_DECL_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_FIELD_DECL_after>> visitor_Statement_FIELD_DECL_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_FIELD_DECL_after>> visitor_Statement_FIELD_DECL_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_FIELD_DECL_after>> visitor_Statement_FIELD_DECL_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_FIELD_DECL_after>> visitor_Statement_FIELD_DECL_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_FIELD_DECL_after>> visitor_Statement_FIELD_DECL_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_FIELD_DECL_after>> visitor_Statement_FIELD_DECL_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_FIELD_DECL_after(const Context_Statement_FIELD_DECL_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_AFTER == 0) {
                return visitor_Statement_FIELD_DECL_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_AFTER == 1) {
                return visitor_Statement_FIELD_DECL_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_AFTER == 2) {
                return visitor_Statement_FIELD_DECL_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_AFTER == 3) {
                return visitor_Statement_FIELD_DECL_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_AFTER == 4) {
                return visitor_Statement_FIELD_DECL_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_AFTER == 5) {
                return visitor_Statement_FIELD_DECL_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_AFTER == 6) {
                return visitor_Statement_FIELD_DECL_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_FIELD_DECL_AFTER < 7, "No suitable visitor hook found for Statement_FIELD_DECL_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_COMPOSITE_FIELD_DECL>> visitor_Statement_COMPOSITE_FIELD_DECL_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_COMPOSITE_FIELD_DECL>> visitor_Statement_COMPOSITE_FIELD_DECL_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_COMPOSITE_FIELD_DECL>> visitor_Statement_COMPOSITE_FIELD_DECL_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_COMPOSITE_FIELD_DECL>> visitor_Statement_COMPOSITE_FIELD_DECL_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_COMPOSITE_FIELD_DECL>> visitor_Statement_COMPOSITE_FIELD_DECL_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_COMPOSITE_FIELD_DECL>> visitor_Statement_COMPOSITE_FIELD_DECL_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_COMPOSITE_FIELD_DECL>> visitor_Statement_COMPOSITE_FIELD_DECL_GeneratorDefaultHook;
        auto& get_visitor_Statement_COMPOSITE_FIELD_DECL(const Context_Statement_COMPOSITE_FIELD_DECL&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL == 0) {
                return visitor_Statement_COMPOSITE_FIELD_DECL_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL == 1) {
                return visitor_Statement_COMPOSITE_FIELD_DECL_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL == 2) {
                return visitor_Statement_COMPOSITE_FIELD_DECL_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL == 3) {
                return visitor_Statement_COMPOSITE_FIELD_DECL_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL == 4) {
                return visitor_Statement_COMPOSITE_FIELD_DECL_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL == 5) {
                return visitor_Statement_COMPOSITE_FIELD_DECL_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL == 6) {
                return visitor_Statement_COMPOSITE_FIELD_DECL_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL < 7, "No suitable visitor hook found for Statement_COMPOSITE_FIELD_DECL");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>> visitor_Statement_COMPOSITE_FIELD_DECL_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>> visitor_Statement_COMPOSITE_FIELD_DECL_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>> visitor_Statement_COMPOSITE_FIELD_DECL_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>> visitor_Statement_COMPOSITE_FIELD_DECL_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>> visitor_Statement_COMPOSITE_FIELD_DECL_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>> visitor_Statement_COMPOSITE_FIELD_DECL_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>> visitor_Statement_COMPOSITE_FIELD_DECL_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_COMPOSITE_FIELD_DECL_before(const Context_Statement_COMPOSITE_FIELD_DECL_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE == 0) {
                return visitor_Statement_COMPOSITE_FIELD_DECL_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE == 1) {
                return visitor_Statement_COMPOSITE_FIELD_DECL_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE == 2) {
                return visitor_Statement_COMPOSITE_FIELD_DECL_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE == 3) {
                return visitor_Statement_COMPOSITE_FIELD_DECL_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE == 4) {
                return visitor_Statement_COMPOSITE_FIELD_DECL_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE == 5) {
                return visitor_Statement_COMPOSITE_FIELD_DECL_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE == 6) {
                return visitor_Statement_COMPOSITE_FIELD_DECL_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE < 7, "No suitable visitor hook found for Statement_COMPOSITE_FIELD_DECL_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>> visitor_Statement_COMPOSITE_FIELD_DECL_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>> visitor_Statement_COMPOSITE_FIELD_DECL_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>> visitor_Statement_COMPOSITE_FIELD_DECL_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>> visitor_Statement_COMPOSITE_FIELD_DECL_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>> visitor_Statement_COMPOSITE_FIELD_DECL_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>> visitor_Statement_COMPOSITE_FIELD_DECL_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>> visitor_Statement_COMPOSITE_FIELD_DECL_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_COMPOSITE_FIELD_DECL_after(const Context_Statement_COMPOSITE_FIELD_DECL_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_AFTER == 0) {
                return visitor_Statement_COMPOSITE_FIELD_DECL_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_AFTER == 1) {
                return visitor_Statement_COMPOSITE_FIELD_DECL_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_AFTER == 2) {
                return visitor_Statement_COMPOSITE_FIELD_DECL_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_AFTER == 3) {
                return visitor_Statement_COMPOSITE_FIELD_DECL_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_AFTER == 4) {
                return visitor_Statement_COMPOSITE_FIELD_DECL_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_AFTER == 5) {
                return visitor_Statement_COMPOSITE_FIELD_DECL_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_AFTER == 6) {
                return visitor_Statement_COMPOSITE_FIELD_DECL_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_COMPOSITE_FIELD_DECL_AFTER < 7, "No suitable visitor hook found for Statement_COMPOSITE_FIELD_DECL_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_ENUM_DECL>> visitor_Statement_ENUM_DECL_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_ENUM_DECL>> visitor_Statement_ENUM_DECL_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_ENUM_DECL>> visitor_Statement_ENUM_DECL_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_ENUM_DECL>> visitor_Statement_ENUM_DECL_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_ENUM_DECL>> visitor_Statement_ENUM_DECL_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_ENUM_DECL>> visitor_Statement_ENUM_DECL_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_ENUM_DECL>> visitor_Statement_ENUM_DECL_GeneratorDefaultHook;
        auto& get_visitor_Statement_ENUM_DECL(const Context_Statement_ENUM_DECL&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL == 0) {
                return visitor_Statement_ENUM_DECL_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL == 1) {
                return visitor_Statement_ENUM_DECL_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL == 2) {
                return visitor_Statement_ENUM_DECL_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL == 3) {
                return visitor_Statement_ENUM_DECL_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL == 4) {
                return visitor_Statement_ENUM_DECL_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL == 5) {
                return visitor_Statement_ENUM_DECL_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL == 6) {
                return visitor_Statement_ENUM_DECL_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL < 7, "No suitable visitor hook found for Statement_ENUM_DECL");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_ENUM_DECL_before>> visitor_Statement_ENUM_DECL_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_ENUM_DECL_before>> visitor_Statement_ENUM_DECL_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_ENUM_DECL_before>> visitor_Statement_ENUM_DECL_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_ENUM_DECL_before>> visitor_Statement_ENUM_DECL_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_ENUM_DECL_before>> visitor_Statement_ENUM_DECL_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_ENUM_DECL_before>> visitor_Statement_ENUM_DECL_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_ENUM_DECL_before>> visitor_Statement_ENUM_DECL_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_ENUM_DECL_before(const Context_Statement_ENUM_DECL_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_BEFORE == 0) {
                return visitor_Statement_ENUM_DECL_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_BEFORE == 1) {
                return visitor_Statement_ENUM_DECL_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_BEFORE == 2) {
                return visitor_Statement_ENUM_DECL_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_BEFORE == 3) {
                return visitor_Statement_ENUM_DECL_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_BEFORE == 4) {
                return visitor_Statement_ENUM_DECL_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_BEFORE == 5) {
                return visitor_Statement_ENUM_DECL_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_BEFORE == 6) {
                return visitor_Statement_ENUM_DECL_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_BEFORE < 7, "No suitable visitor hook found for Statement_ENUM_DECL_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_ENUM_DECL_after>> visitor_Statement_ENUM_DECL_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_ENUM_DECL_after>> visitor_Statement_ENUM_DECL_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_ENUM_DECL_after>> visitor_Statement_ENUM_DECL_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_ENUM_DECL_after>> visitor_Statement_ENUM_DECL_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_ENUM_DECL_after>> visitor_Statement_ENUM_DECL_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_ENUM_DECL_after>> visitor_Statement_ENUM_DECL_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_ENUM_DECL_after>> visitor_Statement_ENUM_DECL_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_ENUM_DECL_after(const Context_Statement_ENUM_DECL_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_AFTER == 0) {
                return visitor_Statement_ENUM_DECL_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_AFTER == 1) {
                return visitor_Statement_ENUM_DECL_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_AFTER == 2) {
                return visitor_Statement_ENUM_DECL_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_AFTER == 3) {
                return visitor_Statement_ENUM_DECL_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_AFTER == 4) {
                return visitor_Statement_ENUM_DECL_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_AFTER == 5) {
                return visitor_Statement_ENUM_DECL_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_AFTER == 6) {
                return visitor_Statement_ENUM_DECL_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_DECL_AFTER < 7, "No suitable visitor hook found for Statement_ENUM_DECL_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_ENUM_MEMBER_DECL>> visitor_Statement_ENUM_MEMBER_DECL_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_ENUM_MEMBER_DECL>> visitor_Statement_ENUM_MEMBER_DECL_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_ENUM_MEMBER_DECL>> visitor_Statement_ENUM_MEMBER_DECL_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_ENUM_MEMBER_DECL>> visitor_Statement_ENUM_MEMBER_DECL_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_ENUM_MEMBER_DECL>> visitor_Statement_ENUM_MEMBER_DECL_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_ENUM_MEMBER_DECL>> visitor_Statement_ENUM_MEMBER_DECL_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_ENUM_MEMBER_DECL>> visitor_Statement_ENUM_MEMBER_DECL_GeneratorDefaultHook;
        auto& get_visitor_Statement_ENUM_MEMBER_DECL(const Context_Statement_ENUM_MEMBER_DECL&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL == 0) {
                return visitor_Statement_ENUM_MEMBER_DECL_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL == 1) {
                return visitor_Statement_ENUM_MEMBER_DECL_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL == 2) {
                return visitor_Statement_ENUM_MEMBER_DECL_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL == 3) {
                return visitor_Statement_ENUM_MEMBER_DECL_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL == 4) {
                return visitor_Statement_ENUM_MEMBER_DECL_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL == 5) {
                return visitor_Statement_ENUM_MEMBER_DECL_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL == 6) {
                return visitor_Statement_ENUM_MEMBER_DECL_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL < 7, "No suitable visitor hook found for Statement_ENUM_MEMBER_DECL");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_ENUM_MEMBER_DECL_before>> visitor_Statement_ENUM_MEMBER_DECL_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_ENUM_MEMBER_DECL_before>> visitor_Statement_ENUM_MEMBER_DECL_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_ENUM_MEMBER_DECL_before>> visitor_Statement_ENUM_MEMBER_DECL_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_ENUM_MEMBER_DECL_before>> visitor_Statement_ENUM_MEMBER_DECL_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_ENUM_MEMBER_DECL_before>> visitor_Statement_ENUM_MEMBER_DECL_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_ENUM_MEMBER_DECL_before>> visitor_Statement_ENUM_MEMBER_DECL_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_ENUM_MEMBER_DECL_before>> visitor_Statement_ENUM_MEMBER_DECL_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_ENUM_MEMBER_DECL_before(const Context_Statement_ENUM_MEMBER_DECL_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_BEFORE == 0) {
                return visitor_Statement_ENUM_MEMBER_DECL_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_BEFORE == 1) {
                return visitor_Statement_ENUM_MEMBER_DECL_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_BEFORE == 2) {
                return visitor_Statement_ENUM_MEMBER_DECL_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_BEFORE == 3) {
                return visitor_Statement_ENUM_MEMBER_DECL_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_BEFORE == 4) {
                return visitor_Statement_ENUM_MEMBER_DECL_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_BEFORE == 5) {
                return visitor_Statement_ENUM_MEMBER_DECL_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_BEFORE == 6) {
                return visitor_Statement_ENUM_MEMBER_DECL_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_BEFORE < 7, "No suitable visitor hook found for Statement_ENUM_MEMBER_DECL_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_ENUM_MEMBER_DECL_after>> visitor_Statement_ENUM_MEMBER_DECL_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_ENUM_MEMBER_DECL_after>> visitor_Statement_ENUM_MEMBER_DECL_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_ENUM_MEMBER_DECL_after>> visitor_Statement_ENUM_MEMBER_DECL_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_ENUM_MEMBER_DECL_after>> visitor_Statement_ENUM_MEMBER_DECL_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_ENUM_MEMBER_DECL_after>> visitor_Statement_ENUM_MEMBER_DECL_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_ENUM_MEMBER_DECL_after>> visitor_Statement_ENUM_MEMBER_DECL_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_ENUM_MEMBER_DECL_after>> visitor_Statement_ENUM_MEMBER_DECL_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_ENUM_MEMBER_DECL_after(const Context_Statement_ENUM_MEMBER_DECL_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_AFTER == 0) {
                return visitor_Statement_ENUM_MEMBER_DECL_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_AFTER == 1) {
                return visitor_Statement_ENUM_MEMBER_DECL_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_AFTER == 2) {
                return visitor_Statement_ENUM_MEMBER_DECL_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_AFTER == 3) {
                return visitor_Statement_ENUM_MEMBER_DECL_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_AFTER == 4) {
                return visitor_Statement_ENUM_MEMBER_DECL_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_AFTER == 5) {
                return visitor_Statement_ENUM_MEMBER_DECL_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_AFTER == 6) {
                return visitor_Statement_ENUM_MEMBER_DECL_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENUM_MEMBER_DECL_AFTER < 7, "No suitable visitor hook found for Statement_ENUM_MEMBER_DECL_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_STRUCT_DECL>> visitor_Statement_STRUCT_DECL_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_STRUCT_DECL>> visitor_Statement_STRUCT_DECL_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_STRUCT_DECL>> visitor_Statement_STRUCT_DECL_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_STRUCT_DECL>> visitor_Statement_STRUCT_DECL_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_STRUCT_DECL>> visitor_Statement_STRUCT_DECL_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_STRUCT_DECL>> visitor_Statement_STRUCT_DECL_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_STRUCT_DECL>> visitor_Statement_STRUCT_DECL_GeneratorDefaultHook;
        auto& get_visitor_Statement_STRUCT_DECL(const Context_Statement_STRUCT_DECL&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL == 0) {
                return visitor_Statement_STRUCT_DECL_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL == 1) {
                return visitor_Statement_STRUCT_DECL_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL == 2) {
                return visitor_Statement_STRUCT_DECL_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL == 3) {
                return visitor_Statement_STRUCT_DECL_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL == 4) {
                return visitor_Statement_STRUCT_DECL_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL == 5) {
                return visitor_Statement_STRUCT_DECL_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL == 6) {
                return visitor_Statement_STRUCT_DECL_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL < 7, "No suitable visitor hook found for Statement_STRUCT_DECL");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_STRUCT_DECL_before>> visitor_Statement_STRUCT_DECL_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_STRUCT_DECL_before>> visitor_Statement_STRUCT_DECL_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_STRUCT_DECL_before>> visitor_Statement_STRUCT_DECL_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_STRUCT_DECL_before>> visitor_Statement_STRUCT_DECL_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_STRUCT_DECL_before>> visitor_Statement_STRUCT_DECL_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_STRUCT_DECL_before>> visitor_Statement_STRUCT_DECL_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_STRUCT_DECL_before>> visitor_Statement_STRUCT_DECL_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_STRUCT_DECL_before(const Context_Statement_STRUCT_DECL_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_BEFORE == 0) {
                return visitor_Statement_STRUCT_DECL_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_BEFORE == 1) {
                return visitor_Statement_STRUCT_DECL_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_BEFORE == 2) {
                return visitor_Statement_STRUCT_DECL_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_BEFORE == 3) {
                return visitor_Statement_STRUCT_DECL_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_BEFORE == 4) {
                return visitor_Statement_STRUCT_DECL_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_BEFORE == 5) {
                return visitor_Statement_STRUCT_DECL_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_BEFORE == 6) {
                return visitor_Statement_STRUCT_DECL_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_BEFORE < 7, "No suitable visitor hook found for Statement_STRUCT_DECL_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_STRUCT_DECL_after>> visitor_Statement_STRUCT_DECL_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_STRUCT_DECL_after>> visitor_Statement_STRUCT_DECL_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_STRUCT_DECL_after>> visitor_Statement_STRUCT_DECL_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_STRUCT_DECL_after>> visitor_Statement_STRUCT_DECL_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_STRUCT_DECL_after>> visitor_Statement_STRUCT_DECL_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_STRUCT_DECL_after>> visitor_Statement_STRUCT_DECL_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_STRUCT_DECL_after>> visitor_Statement_STRUCT_DECL_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_STRUCT_DECL_after(const Context_Statement_STRUCT_DECL_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_AFTER == 0) {
                return visitor_Statement_STRUCT_DECL_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_AFTER == 1) {
                return visitor_Statement_STRUCT_DECL_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_AFTER == 2) {
                return visitor_Statement_STRUCT_DECL_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_AFTER == 3) {
                return visitor_Statement_STRUCT_DECL_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_AFTER == 4) {
                return visitor_Statement_STRUCT_DECL_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_AFTER == 5) {
                return visitor_Statement_STRUCT_DECL_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_AFTER == 6) {
                return visitor_Statement_STRUCT_DECL_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_STRUCT_DECL_AFTER < 7, "No suitable visitor hook found for Statement_STRUCT_DECL_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_UNION_DECL>> visitor_Statement_UNION_DECL_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_UNION_DECL>> visitor_Statement_UNION_DECL_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_UNION_DECL>> visitor_Statement_UNION_DECL_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_UNION_DECL>> visitor_Statement_UNION_DECL_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_UNION_DECL>> visitor_Statement_UNION_DECL_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_UNION_DECL>> visitor_Statement_UNION_DECL_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_UNION_DECL>> visitor_Statement_UNION_DECL_GeneratorDefaultHook;
        auto& get_visitor_Statement_UNION_DECL(const Context_Statement_UNION_DECL&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL == 0) {
                return visitor_Statement_UNION_DECL_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL == 1) {
                return visitor_Statement_UNION_DECL_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL == 2) {
                return visitor_Statement_UNION_DECL_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL == 3) {
                return visitor_Statement_UNION_DECL_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL == 4) {
                return visitor_Statement_UNION_DECL_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL == 5) {
                return visitor_Statement_UNION_DECL_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL == 6) {
                return visitor_Statement_UNION_DECL_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL < 7, "No suitable visitor hook found for Statement_UNION_DECL");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_UNION_DECL_before>> visitor_Statement_UNION_DECL_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_UNION_DECL_before>> visitor_Statement_UNION_DECL_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_UNION_DECL_before>> visitor_Statement_UNION_DECL_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_UNION_DECL_before>> visitor_Statement_UNION_DECL_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_UNION_DECL_before>> visitor_Statement_UNION_DECL_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_UNION_DECL_before>> visitor_Statement_UNION_DECL_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_UNION_DECL_before>> visitor_Statement_UNION_DECL_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_UNION_DECL_before(const Context_Statement_UNION_DECL_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_BEFORE == 0) {
                return visitor_Statement_UNION_DECL_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_BEFORE == 1) {
                return visitor_Statement_UNION_DECL_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_BEFORE == 2) {
                return visitor_Statement_UNION_DECL_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_BEFORE == 3) {
                return visitor_Statement_UNION_DECL_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_BEFORE == 4) {
                return visitor_Statement_UNION_DECL_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_BEFORE == 5) {
                return visitor_Statement_UNION_DECL_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_BEFORE == 6) {
                return visitor_Statement_UNION_DECL_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_BEFORE < 7, "No suitable visitor hook found for Statement_UNION_DECL_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_UNION_DECL_after>> visitor_Statement_UNION_DECL_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_UNION_DECL_after>> visitor_Statement_UNION_DECL_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_UNION_DECL_after>> visitor_Statement_UNION_DECL_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_UNION_DECL_after>> visitor_Statement_UNION_DECL_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_UNION_DECL_after>> visitor_Statement_UNION_DECL_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_UNION_DECL_after>> visitor_Statement_UNION_DECL_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_UNION_DECL_after>> visitor_Statement_UNION_DECL_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_UNION_DECL_after(const Context_Statement_UNION_DECL_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_AFTER == 0) {
                return visitor_Statement_UNION_DECL_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_AFTER == 1) {
                return visitor_Statement_UNION_DECL_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_AFTER == 2) {
                return visitor_Statement_UNION_DECL_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_AFTER == 3) {
                return visitor_Statement_UNION_DECL_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_AFTER == 4) {
                return visitor_Statement_UNION_DECL_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_AFTER == 5) {
                return visitor_Statement_UNION_DECL_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_AFTER == 6) {
                return visitor_Statement_UNION_DECL_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_DECL_AFTER < 7, "No suitable visitor hook found for Statement_UNION_DECL_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_UNION_MEMBER_DECL>> visitor_Statement_UNION_MEMBER_DECL_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_UNION_MEMBER_DECL>> visitor_Statement_UNION_MEMBER_DECL_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_UNION_MEMBER_DECL>> visitor_Statement_UNION_MEMBER_DECL_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_UNION_MEMBER_DECL>> visitor_Statement_UNION_MEMBER_DECL_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_UNION_MEMBER_DECL>> visitor_Statement_UNION_MEMBER_DECL_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_UNION_MEMBER_DECL>> visitor_Statement_UNION_MEMBER_DECL_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_UNION_MEMBER_DECL>> visitor_Statement_UNION_MEMBER_DECL_GeneratorDefaultHook;
        auto& get_visitor_Statement_UNION_MEMBER_DECL(const Context_Statement_UNION_MEMBER_DECL&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL == 0) {
                return visitor_Statement_UNION_MEMBER_DECL_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL == 1) {
                return visitor_Statement_UNION_MEMBER_DECL_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL == 2) {
                return visitor_Statement_UNION_MEMBER_DECL_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL == 3) {
                return visitor_Statement_UNION_MEMBER_DECL_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL == 4) {
                return visitor_Statement_UNION_MEMBER_DECL_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL == 5) {
                return visitor_Statement_UNION_MEMBER_DECL_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL == 6) {
                return visitor_Statement_UNION_MEMBER_DECL_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL < 7, "No suitable visitor hook found for Statement_UNION_MEMBER_DECL");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_UNION_MEMBER_DECL_before>> visitor_Statement_UNION_MEMBER_DECL_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_UNION_MEMBER_DECL_before>> visitor_Statement_UNION_MEMBER_DECL_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_UNION_MEMBER_DECL_before>> visitor_Statement_UNION_MEMBER_DECL_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_UNION_MEMBER_DECL_before>> visitor_Statement_UNION_MEMBER_DECL_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_UNION_MEMBER_DECL_before>> visitor_Statement_UNION_MEMBER_DECL_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_UNION_MEMBER_DECL_before>> visitor_Statement_UNION_MEMBER_DECL_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_UNION_MEMBER_DECL_before>> visitor_Statement_UNION_MEMBER_DECL_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_UNION_MEMBER_DECL_before(const Context_Statement_UNION_MEMBER_DECL_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_BEFORE == 0) {
                return visitor_Statement_UNION_MEMBER_DECL_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_BEFORE == 1) {
                return visitor_Statement_UNION_MEMBER_DECL_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_BEFORE == 2) {
                return visitor_Statement_UNION_MEMBER_DECL_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_BEFORE == 3) {
                return visitor_Statement_UNION_MEMBER_DECL_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_BEFORE == 4) {
                return visitor_Statement_UNION_MEMBER_DECL_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_BEFORE == 5) {
                return visitor_Statement_UNION_MEMBER_DECL_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_BEFORE == 6) {
                return visitor_Statement_UNION_MEMBER_DECL_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_BEFORE < 7, "No suitable visitor hook found for Statement_UNION_MEMBER_DECL_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_UNION_MEMBER_DECL_after>> visitor_Statement_UNION_MEMBER_DECL_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_UNION_MEMBER_DECL_after>> visitor_Statement_UNION_MEMBER_DECL_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_UNION_MEMBER_DECL_after>> visitor_Statement_UNION_MEMBER_DECL_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_UNION_MEMBER_DECL_after>> visitor_Statement_UNION_MEMBER_DECL_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_UNION_MEMBER_DECL_after>> visitor_Statement_UNION_MEMBER_DECL_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_UNION_MEMBER_DECL_after>> visitor_Statement_UNION_MEMBER_DECL_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_UNION_MEMBER_DECL_after>> visitor_Statement_UNION_MEMBER_DECL_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_UNION_MEMBER_DECL_after(const Context_Statement_UNION_MEMBER_DECL_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_AFTER == 0) {
                return visitor_Statement_UNION_MEMBER_DECL_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_AFTER == 1) {
                return visitor_Statement_UNION_MEMBER_DECL_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_AFTER == 2) {
                return visitor_Statement_UNION_MEMBER_DECL_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_AFTER == 3) {
                return visitor_Statement_UNION_MEMBER_DECL_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_AFTER == 4) {
                return visitor_Statement_UNION_MEMBER_DECL_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_AFTER == 5) {
                return visitor_Statement_UNION_MEMBER_DECL_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_AFTER == 6) {
                return visitor_Statement_UNION_MEMBER_DECL_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_UNION_MEMBER_DECL_AFTER < 7, "No suitable visitor hook found for Statement_UNION_MEMBER_DECL_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_PROGRAM_DECL>> visitor_Statement_PROGRAM_DECL_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_PROGRAM_DECL>> visitor_Statement_PROGRAM_DECL_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_PROGRAM_DECL>> visitor_Statement_PROGRAM_DECL_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_PROGRAM_DECL>> visitor_Statement_PROGRAM_DECL_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_PROGRAM_DECL>> visitor_Statement_PROGRAM_DECL_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_PROGRAM_DECL>> visitor_Statement_PROGRAM_DECL_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_PROGRAM_DECL>> visitor_Statement_PROGRAM_DECL_GeneratorDefaultHook;
        auto& get_visitor_Statement_PROGRAM_DECL(const Context_Statement_PROGRAM_DECL&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL == 0) {
                return visitor_Statement_PROGRAM_DECL_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL == 1) {
                return visitor_Statement_PROGRAM_DECL_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL == 2) {
                return visitor_Statement_PROGRAM_DECL_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL == 3) {
                return visitor_Statement_PROGRAM_DECL_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL == 4) {
                return visitor_Statement_PROGRAM_DECL_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL == 5) {
                return visitor_Statement_PROGRAM_DECL_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL == 6) {
                return visitor_Statement_PROGRAM_DECL_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL < 7, "No suitable visitor hook found for Statement_PROGRAM_DECL");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_PROGRAM_DECL_before>> visitor_Statement_PROGRAM_DECL_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_PROGRAM_DECL_before>> visitor_Statement_PROGRAM_DECL_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_PROGRAM_DECL_before>> visitor_Statement_PROGRAM_DECL_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_PROGRAM_DECL_before>> visitor_Statement_PROGRAM_DECL_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_PROGRAM_DECL_before>> visitor_Statement_PROGRAM_DECL_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_PROGRAM_DECL_before>> visitor_Statement_PROGRAM_DECL_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_PROGRAM_DECL_before>> visitor_Statement_PROGRAM_DECL_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_PROGRAM_DECL_before(const Context_Statement_PROGRAM_DECL_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_BEFORE == 0) {
                return visitor_Statement_PROGRAM_DECL_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_BEFORE == 1) {
                return visitor_Statement_PROGRAM_DECL_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_BEFORE == 2) {
                return visitor_Statement_PROGRAM_DECL_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_BEFORE == 3) {
                return visitor_Statement_PROGRAM_DECL_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_BEFORE == 4) {
                return visitor_Statement_PROGRAM_DECL_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_BEFORE == 5) {
                return visitor_Statement_PROGRAM_DECL_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_BEFORE == 6) {
                return visitor_Statement_PROGRAM_DECL_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_BEFORE < 7, "No suitable visitor hook found for Statement_PROGRAM_DECL_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_PROGRAM_DECL_after>> visitor_Statement_PROGRAM_DECL_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_PROGRAM_DECL_after>> visitor_Statement_PROGRAM_DECL_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_PROGRAM_DECL_after>> visitor_Statement_PROGRAM_DECL_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_PROGRAM_DECL_after>> visitor_Statement_PROGRAM_DECL_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_PROGRAM_DECL_after>> visitor_Statement_PROGRAM_DECL_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_PROGRAM_DECL_after>> visitor_Statement_PROGRAM_DECL_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_PROGRAM_DECL_after>> visitor_Statement_PROGRAM_DECL_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_PROGRAM_DECL_after(const Context_Statement_PROGRAM_DECL_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_AFTER == 0) {
                return visitor_Statement_PROGRAM_DECL_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_AFTER == 1) {
                return visitor_Statement_PROGRAM_DECL_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_AFTER == 2) {
                return visitor_Statement_PROGRAM_DECL_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_AFTER == 3) {
                return visitor_Statement_PROGRAM_DECL_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_AFTER == 4) {
                return visitor_Statement_PROGRAM_DECL_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_AFTER == 5) {
                return visitor_Statement_PROGRAM_DECL_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_AFTER == 6) {
                return visitor_Statement_PROGRAM_DECL_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROGRAM_DECL_AFTER < 7, "No suitable visitor hook found for Statement_PROGRAM_DECL_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_PROPERTY_DECL>> visitor_Statement_PROPERTY_DECL_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_PROPERTY_DECL>> visitor_Statement_PROPERTY_DECL_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_PROPERTY_DECL>> visitor_Statement_PROPERTY_DECL_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_PROPERTY_DECL>> visitor_Statement_PROPERTY_DECL_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_PROPERTY_DECL>> visitor_Statement_PROPERTY_DECL_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_PROPERTY_DECL>> visitor_Statement_PROPERTY_DECL_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_PROPERTY_DECL>> visitor_Statement_PROPERTY_DECL_GeneratorDefaultHook;
        auto& get_visitor_Statement_PROPERTY_DECL(const Context_Statement_PROPERTY_DECL&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL == 0) {
                return visitor_Statement_PROPERTY_DECL_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL == 1) {
                return visitor_Statement_PROPERTY_DECL_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL == 2) {
                return visitor_Statement_PROPERTY_DECL_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL == 3) {
                return visitor_Statement_PROPERTY_DECL_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL == 4) {
                return visitor_Statement_PROPERTY_DECL_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL == 5) {
                return visitor_Statement_PROPERTY_DECL_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL == 6) {
                return visitor_Statement_PROPERTY_DECL_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL < 7, "No suitable visitor hook found for Statement_PROPERTY_DECL");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_PROPERTY_DECL_before>> visitor_Statement_PROPERTY_DECL_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_PROPERTY_DECL_before>> visitor_Statement_PROPERTY_DECL_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_PROPERTY_DECL_before>> visitor_Statement_PROPERTY_DECL_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_PROPERTY_DECL_before>> visitor_Statement_PROPERTY_DECL_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_PROPERTY_DECL_before>> visitor_Statement_PROPERTY_DECL_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_PROPERTY_DECL_before>> visitor_Statement_PROPERTY_DECL_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_PROPERTY_DECL_before>> visitor_Statement_PROPERTY_DECL_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_PROPERTY_DECL_before(const Context_Statement_PROPERTY_DECL_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_BEFORE == 0) {
                return visitor_Statement_PROPERTY_DECL_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_BEFORE == 1) {
                return visitor_Statement_PROPERTY_DECL_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_BEFORE == 2) {
                return visitor_Statement_PROPERTY_DECL_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_BEFORE == 3) {
                return visitor_Statement_PROPERTY_DECL_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_BEFORE == 4) {
                return visitor_Statement_PROPERTY_DECL_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_BEFORE == 5) {
                return visitor_Statement_PROPERTY_DECL_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_BEFORE == 6) {
                return visitor_Statement_PROPERTY_DECL_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_BEFORE < 7, "No suitable visitor hook found for Statement_PROPERTY_DECL_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_PROPERTY_DECL_after>> visitor_Statement_PROPERTY_DECL_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_PROPERTY_DECL_after>> visitor_Statement_PROPERTY_DECL_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_PROPERTY_DECL_after>> visitor_Statement_PROPERTY_DECL_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_PROPERTY_DECL_after>> visitor_Statement_PROPERTY_DECL_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_PROPERTY_DECL_after>> visitor_Statement_PROPERTY_DECL_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_PROPERTY_DECL_after>> visitor_Statement_PROPERTY_DECL_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_PROPERTY_DECL_after>> visitor_Statement_PROPERTY_DECL_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_PROPERTY_DECL_after(const Context_Statement_PROPERTY_DECL_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_AFTER == 0) {
                return visitor_Statement_PROPERTY_DECL_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_AFTER == 1) {
                return visitor_Statement_PROPERTY_DECL_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_AFTER == 2) {
                return visitor_Statement_PROPERTY_DECL_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_AFTER == 3) {
                return visitor_Statement_PROPERTY_DECL_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_AFTER == 4) {
                return visitor_Statement_PROPERTY_DECL_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_AFTER == 5) {
                return visitor_Statement_PROPERTY_DECL_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_AFTER == 6) {
                return visitor_Statement_PROPERTY_DECL_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_DECL_AFTER < 7, "No suitable visitor hook found for Statement_PROPERTY_DECL_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_PROPERTY_MEMBER_DECL>> visitor_Statement_PROPERTY_MEMBER_DECL_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_PROPERTY_MEMBER_DECL>> visitor_Statement_PROPERTY_MEMBER_DECL_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_PROPERTY_MEMBER_DECL>> visitor_Statement_PROPERTY_MEMBER_DECL_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_PROPERTY_MEMBER_DECL>> visitor_Statement_PROPERTY_MEMBER_DECL_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_PROPERTY_MEMBER_DECL>> visitor_Statement_PROPERTY_MEMBER_DECL_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_PROPERTY_MEMBER_DECL>> visitor_Statement_PROPERTY_MEMBER_DECL_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_PROPERTY_MEMBER_DECL>> visitor_Statement_PROPERTY_MEMBER_DECL_GeneratorDefaultHook;
        auto& get_visitor_Statement_PROPERTY_MEMBER_DECL(const Context_Statement_PROPERTY_MEMBER_DECL&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL == 0) {
                return visitor_Statement_PROPERTY_MEMBER_DECL_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL == 1) {
                return visitor_Statement_PROPERTY_MEMBER_DECL_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL == 2) {
                return visitor_Statement_PROPERTY_MEMBER_DECL_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL == 3) {
                return visitor_Statement_PROPERTY_MEMBER_DECL_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL == 4) {
                return visitor_Statement_PROPERTY_MEMBER_DECL_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL == 5) {
                return visitor_Statement_PROPERTY_MEMBER_DECL_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL == 6) {
                return visitor_Statement_PROPERTY_MEMBER_DECL_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL < 7, "No suitable visitor hook found for Statement_PROPERTY_MEMBER_DECL");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>> visitor_Statement_PROPERTY_MEMBER_DECL_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>> visitor_Statement_PROPERTY_MEMBER_DECL_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>> visitor_Statement_PROPERTY_MEMBER_DECL_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>> visitor_Statement_PROPERTY_MEMBER_DECL_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>> visitor_Statement_PROPERTY_MEMBER_DECL_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>> visitor_Statement_PROPERTY_MEMBER_DECL_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>> visitor_Statement_PROPERTY_MEMBER_DECL_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_PROPERTY_MEMBER_DECL_before(const Context_Statement_PROPERTY_MEMBER_DECL_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE == 0) {
                return visitor_Statement_PROPERTY_MEMBER_DECL_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE == 1) {
                return visitor_Statement_PROPERTY_MEMBER_DECL_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE == 2) {
                return visitor_Statement_PROPERTY_MEMBER_DECL_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE == 3) {
                return visitor_Statement_PROPERTY_MEMBER_DECL_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE == 4) {
                return visitor_Statement_PROPERTY_MEMBER_DECL_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE == 5) {
                return visitor_Statement_PROPERTY_MEMBER_DECL_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE == 6) {
                return visitor_Statement_PROPERTY_MEMBER_DECL_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE < 7, "No suitable visitor hook found for Statement_PROPERTY_MEMBER_DECL_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>> visitor_Statement_PROPERTY_MEMBER_DECL_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>> visitor_Statement_PROPERTY_MEMBER_DECL_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>> visitor_Statement_PROPERTY_MEMBER_DECL_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>> visitor_Statement_PROPERTY_MEMBER_DECL_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>> visitor_Statement_PROPERTY_MEMBER_DECL_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>> visitor_Statement_PROPERTY_MEMBER_DECL_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>> visitor_Statement_PROPERTY_MEMBER_DECL_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_PROPERTY_MEMBER_DECL_after(const Context_Statement_PROPERTY_MEMBER_DECL_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_AFTER == 0) {
                return visitor_Statement_PROPERTY_MEMBER_DECL_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_AFTER == 1) {
                return visitor_Statement_PROPERTY_MEMBER_DECL_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_AFTER == 2) {
                return visitor_Statement_PROPERTY_MEMBER_DECL_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_AFTER == 3) {
                return visitor_Statement_PROPERTY_MEMBER_DECL_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_AFTER == 4) {
                return visitor_Statement_PROPERTY_MEMBER_DECL_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_AFTER == 5) {
                return visitor_Statement_PROPERTY_MEMBER_DECL_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_AFTER == 6) {
                return visitor_Statement_PROPERTY_MEMBER_DECL_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_PROPERTY_MEMBER_DECL_AFTER < 7, "No suitable visitor hook found for Statement_PROPERTY_MEMBER_DECL_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_METADATA>> visitor_Statement_METADATA_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_METADATA>> visitor_Statement_METADATA_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_METADATA>> visitor_Statement_METADATA_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_METADATA>> visitor_Statement_METADATA_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_METADATA>> visitor_Statement_METADATA_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_METADATA>> visitor_Statement_METADATA_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_METADATA>> visitor_Statement_METADATA_GeneratorDefaultHook;
        auto& get_visitor_Statement_METADATA(const Context_Statement_METADATA&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA == 0) {
                return visitor_Statement_METADATA_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA == 1) {
                return visitor_Statement_METADATA_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA == 2) {
                return visitor_Statement_METADATA_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA == 3) {
                return visitor_Statement_METADATA_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA == 4) {
                return visitor_Statement_METADATA_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA == 5) {
                return visitor_Statement_METADATA_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA == 6) {
                return visitor_Statement_METADATA_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA < 7, "No suitable visitor hook found for Statement_METADATA");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_METADATA_before>> visitor_Statement_METADATA_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_METADATA_before>> visitor_Statement_METADATA_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_METADATA_before>> visitor_Statement_METADATA_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_METADATA_before>> visitor_Statement_METADATA_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_METADATA_before>> visitor_Statement_METADATA_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_METADATA_before>> visitor_Statement_METADATA_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_METADATA_before>> visitor_Statement_METADATA_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_METADATA_before(const Context_Statement_METADATA_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_BEFORE == 0) {
                return visitor_Statement_METADATA_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_BEFORE == 1) {
                return visitor_Statement_METADATA_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_BEFORE == 2) {
                return visitor_Statement_METADATA_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_BEFORE == 3) {
                return visitor_Statement_METADATA_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_BEFORE == 4) {
                return visitor_Statement_METADATA_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_BEFORE == 5) {
                return visitor_Statement_METADATA_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_BEFORE == 6) {
                return visitor_Statement_METADATA_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_BEFORE < 7, "No suitable visitor hook found for Statement_METADATA_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_METADATA_after>> visitor_Statement_METADATA_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_METADATA_after>> visitor_Statement_METADATA_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_METADATA_after>> visitor_Statement_METADATA_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_METADATA_after>> visitor_Statement_METADATA_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_METADATA_after>> visitor_Statement_METADATA_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_METADATA_after>> visitor_Statement_METADATA_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_METADATA_after>> visitor_Statement_METADATA_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_METADATA_after(const Context_Statement_METADATA_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_AFTER == 0) {
                return visitor_Statement_METADATA_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_AFTER == 1) {
                return visitor_Statement_METADATA_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_AFTER == 2) {
                return visitor_Statement_METADATA_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_AFTER == 3) {
                return visitor_Statement_METADATA_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_AFTER == 4) {
                return visitor_Statement_METADATA_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_AFTER == 5) {
                return visitor_Statement_METADATA_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_AFTER == 6) {
                return visitor_Statement_METADATA_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_METADATA_AFTER < 7, "No suitable visitor hook found for Statement_METADATA_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_IMPORT_MODULE>> visitor_Statement_IMPORT_MODULE_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_IMPORT_MODULE>> visitor_Statement_IMPORT_MODULE_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_IMPORT_MODULE>> visitor_Statement_IMPORT_MODULE_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_IMPORT_MODULE>> visitor_Statement_IMPORT_MODULE_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_IMPORT_MODULE>> visitor_Statement_IMPORT_MODULE_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_IMPORT_MODULE>> visitor_Statement_IMPORT_MODULE_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_IMPORT_MODULE>> visitor_Statement_IMPORT_MODULE_GeneratorDefaultHook;
        auto& get_visitor_Statement_IMPORT_MODULE(const Context_Statement_IMPORT_MODULE&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE == 0) {
                return visitor_Statement_IMPORT_MODULE_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE == 1) {
                return visitor_Statement_IMPORT_MODULE_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE == 2) {
                return visitor_Statement_IMPORT_MODULE_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE == 3) {
                return visitor_Statement_IMPORT_MODULE_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE == 4) {
                return visitor_Statement_IMPORT_MODULE_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE == 5) {
                return visitor_Statement_IMPORT_MODULE_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE == 6) {
                return visitor_Statement_IMPORT_MODULE_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE < 7, "No suitable visitor hook found for Statement_IMPORT_MODULE");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_IMPORT_MODULE_before>> visitor_Statement_IMPORT_MODULE_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_IMPORT_MODULE_before>> visitor_Statement_IMPORT_MODULE_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_IMPORT_MODULE_before>> visitor_Statement_IMPORT_MODULE_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_IMPORT_MODULE_before>> visitor_Statement_IMPORT_MODULE_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_IMPORT_MODULE_before>> visitor_Statement_IMPORT_MODULE_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_IMPORT_MODULE_before>> visitor_Statement_IMPORT_MODULE_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_IMPORT_MODULE_before>> visitor_Statement_IMPORT_MODULE_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_IMPORT_MODULE_before(const Context_Statement_IMPORT_MODULE_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_BEFORE == 0) {
                return visitor_Statement_IMPORT_MODULE_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_BEFORE == 1) {
                return visitor_Statement_IMPORT_MODULE_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_BEFORE == 2) {
                return visitor_Statement_IMPORT_MODULE_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_BEFORE == 3) {
                return visitor_Statement_IMPORT_MODULE_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_BEFORE == 4) {
                return visitor_Statement_IMPORT_MODULE_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_BEFORE == 5) {
                return visitor_Statement_IMPORT_MODULE_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_BEFORE == 6) {
                return visitor_Statement_IMPORT_MODULE_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_BEFORE < 7, "No suitable visitor hook found for Statement_IMPORT_MODULE_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_IMPORT_MODULE_after>> visitor_Statement_IMPORT_MODULE_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_IMPORT_MODULE_after>> visitor_Statement_IMPORT_MODULE_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_IMPORT_MODULE_after>> visitor_Statement_IMPORT_MODULE_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_IMPORT_MODULE_after>> visitor_Statement_IMPORT_MODULE_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_IMPORT_MODULE_after>> visitor_Statement_IMPORT_MODULE_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_IMPORT_MODULE_after>> visitor_Statement_IMPORT_MODULE_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_IMPORT_MODULE_after>> visitor_Statement_IMPORT_MODULE_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_IMPORT_MODULE_after(const Context_Statement_IMPORT_MODULE_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_AFTER == 0) {
                return visitor_Statement_IMPORT_MODULE_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_AFTER == 1) {
                return visitor_Statement_IMPORT_MODULE_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_AFTER == 2) {
                return visitor_Statement_IMPORT_MODULE_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_AFTER == 3) {
                return visitor_Statement_IMPORT_MODULE_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_AFTER == 4) {
                return visitor_Statement_IMPORT_MODULE_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_AFTER == 5) {
                return visitor_Statement_IMPORT_MODULE_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_AFTER == 6) {
                return visitor_Statement_IMPORT_MODULE_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_IMPORT_MODULE_AFTER < 7, "No suitable visitor hook found for Statement_IMPORT_MODULE_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_EXPRESSION>> visitor_Statement_EXPRESSION_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_EXPRESSION>> visitor_Statement_EXPRESSION_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_EXPRESSION>> visitor_Statement_EXPRESSION_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_EXPRESSION>> visitor_Statement_EXPRESSION_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_EXPRESSION>> visitor_Statement_EXPRESSION_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_EXPRESSION>> visitor_Statement_EXPRESSION_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_EXPRESSION>> visitor_Statement_EXPRESSION_GeneratorDefaultHook;
        auto& get_visitor_Statement_EXPRESSION(const Context_Statement_EXPRESSION&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION == 0) {
                return visitor_Statement_EXPRESSION_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION == 1) {
                return visitor_Statement_EXPRESSION_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION == 2) {
                return visitor_Statement_EXPRESSION_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION == 3) {
                return visitor_Statement_EXPRESSION_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION == 4) {
                return visitor_Statement_EXPRESSION_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION == 5) {
                return visitor_Statement_EXPRESSION_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION == 6) {
                return visitor_Statement_EXPRESSION_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION < 7, "No suitable visitor hook found for Statement_EXPRESSION");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_EXPRESSION_before>> visitor_Statement_EXPRESSION_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_EXPRESSION_before>> visitor_Statement_EXPRESSION_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_EXPRESSION_before>> visitor_Statement_EXPRESSION_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_EXPRESSION_before>> visitor_Statement_EXPRESSION_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_EXPRESSION_before>> visitor_Statement_EXPRESSION_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_EXPRESSION_before>> visitor_Statement_EXPRESSION_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_EXPRESSION_before>> visitor_Statement_EXPRESSION_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_EXPRESSION_before(const Context_Statement_EXPRESSION_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_BEFORE == 0) {
                return visitor_Statement_EXPRESSION_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_BEFORE == 1) {
                return visitor_Statement_EXPRESSION_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_BEFORE == 2) {
                return visitor_Statement_EXPRESSION_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_BEFORE == 3) {
                return visitor_Statement_EXPRESSION_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_BEFORE == 4) {
                return visitor_Statement_EXPRESSION_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_BEFORE == 5) {
                return visitor_Statement_EXPRESSION_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_BEFORE == 6) {
                return visitor_Statement_EXPRESSION_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_BEFORE < 7, "No suitable visitor hook found for Statement_EXPRESSION_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_EXPRESSION_after>> visitor_Statement_EXPRESSION_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_EXPRESSION_after>> visitor_Statement_EXPRESSION_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_EXPRESSION_after>> visitor_Statement_EXPRESSION_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_EXPRESSION_after>> visitor_Statement_EXPRESSION_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_EXPRESSION_after>> visitor_Statement_EXPRESSION_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_EXPRESSION_after>> visitor_Statement_EXPRESSION_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_EXPRESSION_after>> visitor_Statement_EXPRESSION_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_EXPRESSION_after(const Context_Statement_EXPRESSION_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_AFTER == 0) {
                return visitor_Statement_EXPRESSION_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_AFTER == 1) {
                return visitor_Statement_EXPRESSION_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_AFTER == 2) {
                return visitor_Statement_EXPRESSION_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_AFTER == 3) {
                return visitor_Statement_EXPRESSION_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_AFTER == 4) {
                return visitor_Statement_EXPRESSION_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_AFTER == 5) {
                return visitor_Statement_EXPRESSION_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_AFTER == 6) {
                return visitor_Statement_EXPRESSION_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_EXPRESSION_AFTER < 7, "No suitable visitor hook found for Statement_EXPRESSION_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_ERROR_REPORT>> visitor_Statement_ERROR_REPORT_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_ERROR_REPORT>> visitor_Statement_ERROR_REPORT_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_ERROR_REPORT>> visitor_Statement_ERROR_REPORT_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_ERROR_REPORT>> visitor_Statement_ERROR_REPORT_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_ERROR_REPORT>> visitor_Statement_ERROR_REPORT_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_ERROR_REPORT>> visitor_Statement_ERROR_REPORT_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_ERROR_REPORT>> visitor_Statement_ERROR_REPORT_GeneratorDefaultHook;
        auto& get_visitor_Statement_ERROR_REPORT(const Context_Statement_ERROR_REPORT&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT == 0) {
                return visitor_Statement_ERROR_REPORT_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT == 1) {
                return visitor_Statement_ERROR_REPORT_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT == 2) {
                return visitor_Statement_ERROR_REPORT_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT == 3) {
                return visitor_Statement_ERROR_REPORT_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT == 4) {
                return visitor_Statement_ERROR_REPORT_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT == 5) {
                return visitor_Statement_ERROR_REPORT_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT == 6) {
                return visitor_Statement_ERROR_REPORT_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT < 7, "No suitable visitor hook found for Statement_ERROR_REPORT");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_ERROR_REPORT_before>> visitor_Statement_ERROR_REPORT_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_ERROR_REPORT_before>> visitor_Statement_ERROR_REPORT_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_ERROR_REPORT_before>> visitor_Statement_ERROR_REPORT_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_ERROR_REPORT_before>> visitor_Statement_ERROR_REPORT_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_ERROR_REPORT_before>> visitor_Statement_ERROR_REPORT_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_ERROR_REPORT_before>> visitor_Statement_ERROR_REPORT_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_ERROR_REPORT_before>> visitor_Statement_ERROR_REPORT_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_ERROR_REPORT_before(const Context_Statement_ERROR_REPORT_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_BEFORE == 0) {
                return visitor_Statement_ERROR_REPORT_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_BEFORE == 1) {
                return visitor_Statement_ERROR_REPORT_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_BEFORE == 2) {
                return visitor_Statement_ERROR_REPORT_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_BEFORE == 3) {
                return visitor_Statement_ERROR_REPORT_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_BEFORE == 4) {
                return visitor_Statement_ERROR_REPORT_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_BEFORE == 5) {
                return visitor_Statement_ERROR_REPORT_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_BEFORE == 6) {
                return visitor_Statement_ERROR_REPORT_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_BEFORE < 7, "No suitable visitor hook found for Statement_ERROR_REPORT_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_ERROR_REPORT_after>> visitor_Statement_ERROR_REPORT_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_ERROR_REPORT_after>> visitor_Statement_ERROR_REPORT_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_ERROR_REPORT_after>> visitor_Statement_ERROR_REPORT_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_ERROR_REPORT_after>> visitor_Statement_ERROR_REPORT_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_ERROR_REPORT_after>> visitor_Statement_ERROR_REPORT_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_ERROR_REPORT_after>> visitor_Statement_ERROR_REPORT_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_ERROR_REPORT_after>> visitor_Statement_ERROR_REPORT_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_ERROR_REPORT_after(const Context_Statement_ERROR_REPORT_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_AFTER == 0) {
                return visitor_Statement_ERROR_REPORT_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_AFTER == 1) {
                return visitor_Statement_ERROR_REPORT_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_AFTER == 2) {
                return visitor_Statement_ERROR_REPORT_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_AFTER == 3) {
                return visitor_Statement_ERROR_REPORT_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_AFTER == 4) {
                return visitor_Statement_ERROR_REPORT_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_AFTER == 5) {
                return visitor_Statement_ERROR_REPORT_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_AFTER == 6) {
                return visitor_Statement_ERROR_REPORT_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_ERROR_REPORT_AFTER < 7, "No suitable visitor hook found for Statement_ERROR_REPORT_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_LOWERED_IO_STATEMENTS>> visitor_Statement_LOWERED_IO_STATEMENTS_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_LOWERED_IO_STATEMENTS>> visitor_Statement_LOWERED_IO_STATEMENTS_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_LOWERED_IO_STATEMENTS>> visitor_Statement_LOWERED_IO_STATEMENTS_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_LOWERED_IO_STATEMENTS>> visitor_Statement_LOWERED_IO_STATEMENTS_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_LOWERED_IO_STATEMENTS>> visitor_Statement_LOWERED_IO_STATEMENTS_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_LOWERED_IO_STATEMENTS>> visitor_Statement_LOWERED_IO_STATEMENTS_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_LOWERED_IO_STATEMENTS>> visitor_Statement_LOWERED_IO_STATEMENTS_GeneratorDefaultHook;
        auto& get_visitor_Statement_LOWERED_IO_STATEMENTS(const Context_Statement_LOWERED_IO_STATEMENTS&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS == 0) {
                return visitor_Statement_LOWERED_IO_STATEMENTS_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS == 1) {
                return visitor_Statement_LOWERED_IO_STATEMENTS_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS == 2) {
                return visitor_Statement_LOWERED_IO_STATEMENTS_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS == 3) {
                return visitor_Statement_LOWERED_IO_STATEMENTS_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS == 4) {
                return visitor_Statement_LOWERED_IO_STATEMENTS_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS == 5) {
                return visitor_Statement_LOWERED_IO_STATEMENTS_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS == 6) {
                return visitor_Statement_LOWERED_IO_STATEMENTS_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS < 7, "No suitable visitor hook found for Statement_LOWERED_IO_STATEMENTS");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>> visitor_Statement_LOWERED_IO_STATEMENTS_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>> visitor_Statement_LOWERED_IO_STATEMENTS_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>> visitor_Statement_LOWERED_IO_STATEMENTS_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>> visitor_Statement_LOWERED_IO_STATEMENTS_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>> visitor_Statement_LOWERED_IO_STATEMENTS_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>> visitor_Statement_LOWERED_IO_STATEMENTS_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>> visitor_Statement_LOWERED_IO_STATEMENTS_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_LOWERED_IO_STATEMENTS_before(const Context_Statement_LOWERED_IO_STATEMENTS_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE == 0) {
                return visitor_Statement_LOWERED_IO_STATEMENTS_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE == 1) {
                return visitor_Statement_LOWERED_IO_STATEMENTS_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE == 2) {
                return visitor_Statement_LOWERED_IO_STATEMENTS_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE == 3) {
                return visitor_Statement_LOWERED_IO_STATEMENTS_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE == 4) {
                return visitor_Statement_LOWERED_IO_STATEMENTS_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE == 5) {
                return visitor_Statement_LOWERED_IO_STATEMENTS_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE == 6) {
                return visitor_Statement_LOWERED_IO_STATEMENTS_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE < 7, "No suitable visitor hook found for Statement_LOWERED_IO_STATEMENTS_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>> visitor_Statement_LOWERED_IO_STATEMENTS_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>> visitor_Statement_LOWERED_IO_STATEMENTS_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>> visitor_Statement_LOWERED_IO_STATEMENTS_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>> visitor_Statement_LOWERED_IO_STATEMENTS_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>> visitor_Statement_LOWERED_IO_STATEMENTS_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>> visitor_Statement_LOWERED_IO_STATEMENTS_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>> visitor_Statement_LOWERED_IO_STATEMENTS_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_LOWERED_IO_STATEMENTS_after(const Context_Statement_LOWERED_IO_STATEMENTS_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_AFTER == 0) {
                return visitor_Statement_LOWERED_IO_STATEMENTS_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_AFTER == 1) {
                return visitor_Statement_LOWERED_IO_STATEMENTS_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_AFTER == 2) {
                return visitor_Statement_LOWERED_IO_STATEMENTS_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_AFTER == 3) {
                return visitor_Statement_LOWERED_IO_STATEMENTS_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_AFTER == 4) {
                return visitor_Statement_LOWERED_IO_STATEMENTS_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_AFTER == 5) {
                return visitor_Statement_LOWERED_IO_STATEMENTS_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_AFTER == 6) {
                return visitor_Statement_LOWERED_IO_STATEMENTS_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_LOWERED_IO_STATEMENTS_AFTER < 7, "No suitable visitor hook found for Statement_LOWERED_IO_STATEMENTS_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_SUB_BYTE_RANGE>> visitor_Statement_SUB_BYTE_RANGE_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_SUB_BYTE_RANGE>> visitor_Statement_SUB_BYTE_RANGE_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_SUB_BYTE_RANGE>> visitor_Statement_SUB_BYTE_RANGE_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_SUB_BYTE_RANGE>> visitor_Statement_SUB_BYTE_RANGE_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_SUB_BYTE_RANGE>> visitor_Statement_SUB_BYTE_RANGE_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_SUB_BYTE_RANGE>> visitor_Statement_SUB_BYTE_RANGE_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_SUB_BYTE_RANGE>> visitor_Statement_SUB_BYTE_RANGE_GeneratorDefaultHook;
        auto& get_visitor_Statement_SUB_BYTE_RANGE(const Context_Statement_SUB_BYTE_RANGE&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE == 0) {
                return visitor_Statement_SUB_BYTE_RANGE_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE == 1) {
                return visitor_Statement_SUB_BYTE_RANGE_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE == 2) {
                return visitor_Statement_SUB_BYTE_RANGE_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE == 3) {
                return visitor_Statement_SUB_BYTE_RANGE_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE == 4) {
                return visitor_Statement_SUB_BYTE_RANGE_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE == 5) {
                return visitor_Statement_SUB_BYTE_RANGE_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE == 6) {
                return visitor_Statement_SUB_BYTE_RANGE_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE < 7, "No suitable visitor hook found for Statement_SUB_BYTE_RANGE");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_SUB_BYTE_RANGE_before>> visitor_Statement_SUB_BYTE_RANGE_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_SUB_BYTE_RANGE_before>> visitor_Statement_SUB_BYTE_RANGE_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_SUB_BYTE_RANGE_before>> visitor_Statement_SUB_BYTE_RANGE_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_SUB_BYTE_RANGE_before>> visitor_Statement_SUB_BYTE_RANGE_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_SUB_BYTE_RANGE_before>> visitor_Statement_SUB_BYTE_RANGE_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_SUB_BYTE_RANGE_before>> visitor_Statement_SUB_BYTE_RANGE_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_SUB_BYTE_RANGE_before>> visitor_Statement_SUB_BYTE_RANGE_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_SUB_BYTE_RANGE_before(const Context_Statement_SUB_BYTE_RANGE_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_BEFORE == 0) {
                return visitor_Statement_SUB_BYTE_RANGE_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_BEFORE == 1) {
                return visitor_Statement_SUB_BYTE_RANGE_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_BEFORE == 2) {
                return visitor_Statement_SUB_BYTE_RANGE_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_BEFORE == 3) {
                return visitor_Statement_SUB_BYTE_RANGE_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_BEFORE == 4) {
                return visitor_Statement_SUB_BYTE_RANGE_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_BEFORE == 5) {
                return visitor_Statement_SUB_BYTE_RANGE_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_BEFORE == 6) {
                return visitor_Statement_SUB_BYTE_RANGE_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_BEFORE < 7, "No suitable visitor hook found for Statement_SUB_BYTE_RANGE_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_SUB_BYTE_RANGE_after>> visitor_Statement_SUB_BYTE_RANGE_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_SUB_BYTE_RANGE_after>> visitor_Statement_SUB_BYTE_RANGE_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_SUB_BYTE_RANGE_after>> visitor_Statement_SUB_BYTE_RANGE_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_SUB_BYTE_RANGE_after>> visitor_Statement_SUB_BYTE_RANGE_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_SUB_BYTE_RANGE_after>> visitor_Statement_SUB_BYTE_RANGE_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_SUB_BYTE_RANGE_after>> visitor_Statement_SUB_BYTE_RANGE_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_SUB_BYTE_RANGE_after>> visitor_Statement_SUB_BYTE_RANGE_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_SUB_BYTE_RANGE_after(const Context_Statement_SUB_BYTE_RANGE_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_AFTER == 0) {
                return visitor_Statement_SUB_BYTE_RANGE_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_AFTER == 1) {
                return visitor_Statement_SUB_BYTE_RANGE_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_AFTER == 2) {
                return visitor_Statement_SUB_BYTE_RANGE_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_AFTER == 3) {
                return visitor_Statement_SUB_BYTE_RANGE_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_AFTER == 4) {
                return visitor_Statement_SUB_BYTE_RANGE_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_AFTER == 5) {
                return visitor_Statement_SUB_BYTE_RANGE_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_AFTER == 6) {
                return visitor_Statement_SUB_BYTE_RANGE_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_SUB_BYTE_RANGE_AFTER < 7, "No suitable visitor hook found for Statement_SUB_BYTE_RANGE_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_INIT_CHECK>> visitor_Statement_INIT_CHECK_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_INIT_CHECK>> visitor_Statement_INIT_CHECK_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_INIT_CHECK>> visitor_Statement_INIT_CHECK_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_INIT_CHECK>> visitor_Statement_INIT_CHECK_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_INIT_CHECK>> visitor_Statement_INIT_CHECK_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_INIT_CHECK>> visitor_Statement_INIT_CHECK_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_INIT_CHECK>> visitor_Statement_INIT_CHECK_GeneratorDefaultHook;
        auto& get_visitor_Statement_INIT_CHECK(const Context_Statement_INIT_CHECK&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK == 0) {
                return visitor_Statement_INIT_CHECK_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK == 1) {
                return visitor_Statement_INIT_CHECK_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK == 2) {
                return visitor_Statement_INIT_CHECK_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK == 3) {
                return visitor_Statement_INIT_CHECK_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK == 4) {
                return visitor_Statement_INIT_CHECK_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK == 5) {
                return visitor_Statement_INIT_CHECK_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK == 6) {
                return visitor_Statement_INIT_CHECK_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK < 7, "No suitable visitor hook found for Statement_INIT_CHECK");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_INIT_CHECK_before>> visitor_Statement_INIT_CHECK_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_INIT_CHECK_before>> visitor_Statement_INIT_CHECK_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_INIT_CHECK_before>> visitor_Statement_INIT_CHECK_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_INIT_CHECK_before>> visitor_Statement_INIT_CHECK_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_INIT_CHECK_before>> visitor_Statement_INIT_CHECK_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_INIT_CHECK_before>> visitor_Statement_INIT_CHECK_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_INIT_CHECK_before>> visitor_Statement_INIT_CHECK_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_INIT_CHECK_before(const Context_Statement_INIT_CHECK_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_BEFORE == 0) {
                return visitor_Statement_INIT_CHECK_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_BEFORE == 1) {
                return visitor_Statement_INIT_CHECK_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_BEFORE == 2) {
                return visitor_Statement_INIT_CHECK_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_BEFORE == 3) {
                return visitor_Statement_INIT_CHECK_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_BEFORE == 4) {
                return visitor_Statement_INIT_CHECK_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_BEFORE == 5) {
                return visitor_Statement_INIT_CHECK_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_BEFORE == 6) {
                return visitor_Statement_INIT_CHECK_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_BEFORE < 7, "No suitable visitor hook found for Statement_INIT_CHECK_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_INIT_CHECK_after>> visitor_Statement_INIT_CHECK_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_INIT_CHECK_after>> visitor_Statement_INIT_CHECK_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_INIT_CHECK_after>> visitor_Statement_INIT_CHECK_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_INIT_CHECK_after>> visitor_Statement_INIT_CHECK_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_INIT_CHECK_after>> visitor_Statement_INIT_CHECK_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_INIT_CHECK_after>> visitor_Statement_INIT_CHECK_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_INIT_CHECK_after>> visitor_Statement_INIT_CHECK_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_INIT_CHECK_after(const Context_Statement_INIT_CHECK_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_AFTER == 0) {
                return visitor_Statement_INIT_CHECK_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_AFTER == 1) {
                return visitor_Statement_INIT_CHECK_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_AFTER == 2) {
                return visitor_Statement_INIT_CHECK_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_AFTER == 3) {
                return visitor_Statement_INIT_CHECK_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_AFTER == 4) {
                return visitor_Statement_INIT_CHECK_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_AFTER == 5) {
                return visitor_Statement_INIT_CHECK_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_AFTER == 6) {
                return visitor_Statement_INIT_CHECK_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_INIT_CHECK_AFTER < 7, "No suitable visitor hook found for Statement_INIT_CHECK_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_ENDIAN_VARIABLE>> visitor_Statement_ENDIAN_VARIABLE_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_ENDIAN_VARIABLE>> visitor_Statement_ENDIAN_VARIABLE_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_ENDIAN_VARIABLE>> visitor_Statement_ENDIAN_VARIABLE_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_ENDIAN_VARIABLE>> visitor_Statement_ENDIAN_VARIABLE_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_ENDIAN_VARIABLE>> visitor_Statement_ENDIAN_VARIABLE_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_ENDIAN_VARIABLE>> visitor_Statement_ENDIAN_VARIABLE_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_ENDIAN_VARIABLE>> visitor_Statement_ENDIAN_VARIABLE_GeneratorDefaultHook;
        auto& get_visitor_Statement_ENDIAN_VARIABLE(const Context_Statement_ENDIAN_VARIABLE&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE == 0) {
                return visitor_Statement_ENDIAN_VARIABLE_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE == 1) {
                return visitor_Statement_ENDIAN_VARIABLE_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE == 2) {
                return visitor_Statement_ENDIAN_VARIABLE_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE == 3) {
                return visitor_Statement_ENDIAN_VARIABLE_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE == 4) {
                return visitor_Statement_ENDIAN_VARIABLE_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE == 5) {
                return visitor_Statement_ENDIAN_VARIABLE_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE == 6) {
                return visitor_Statement_ENDIAN_VARIABLE_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE < 7, "No suitable visitor hook found for Statement_ENDIAN_VARIABLE");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_ENDIAN_VARIABLE_before>> visitor_Statement_ENDIAN_VARIABLE_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_ENDIAN_VARIABLE_before>> visitor_Statement_ENDIAN_VARIABLE_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_ENDIAN_VARIABLE_before>> visitor_Statement_ENDIAN_VARIABLE_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_ENDIAN_VARIABLE_before>> visitor_Statement_ENDIAN_VARIABLE_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_ENDIAN_VARIABLE_before>> visitor_Statement_ENDIAN_VARIABLE_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_ENDIAN_VARIABLE_before>> visitor_Statement_ENDIAN_VARIABLE_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_ENDIAN_VARIABLE_before>> visitor_Statement_ENDIAN_VARIABLE_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_ENDIAN_VARIABLE_before(const Context_Statement_ENDIAN_VARIABLE_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_BEFORE == 0) {
                return visitor_Statement_ENDIAN_VARIABLE_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_BEFORE == 1) {
                return visitor_Statement_ENDIAN_VARIABLE_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_BEFORE == 2) {
                return visitor_Statement_ENDIAN_VARIABLE_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_BEFORE == 3) {
                return visitor_Statement_ENDIAN_VARIABLE_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_BEFORE == 4) {
                return visitor_Statement_ENDIAN_VARIABLE_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_BEFORE == 5) {
                return visitor_Statement_ENDIAN_VARIABLE_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_BEFORE == 6) {
                return visitor_Statement_ENDIAN_VARIABLE_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_BEFORE < 7, "No suitable visitor hook found for Statement_ENDIAN_VARIABLE_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_ENDIAN_VARIABLE_after>> visitor_Statement_ENDIAN_VARIABLE_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_ENDIAN_VARIABLE_after>> visitor_Statement_ENDIAN_VARIABLE_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_ENDIAN_VARIABLE_after>> visitor_Statement_ENDIAN_VARIABLE_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_ENDIAN_VARIABLE_after>> visitor_Statement_ENDIAN_VARIABLE_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_ENDIAN_VARIABLE_after>> visitor_Statement_ENDIAN_VARIABLE_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_ENDIAN_VARIABLE_after>> visitor_Statement_ENDIAN_VARIABLE_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_ENDIAN_VARIABLE_after>> visitor_Statement_ENDIAN_VARIABLE_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_ENDIAN_VARIABLE_after(const Context_Statement_ENDIAN_VARIABLE_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_AFTER == 0) {
                return visitor_Statement_ENDIAN_VARIABLE_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_AFTER == 1) {
                return visitor_Statement_ENDIAN_VARIABLE_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_AFTER == 2) {
                return visitor_Statement_ENDIAN_VARIABLE_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_AFTER == 3) {
                return visitor_Statement_ENDIAN_VARIABLE_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_AFTER == 4) {
                return visitor_Statement_ENDIAN_VARIABLE_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_AFTER == 5) {
                return visitor_Statement_ENDIAN_VARIABLE_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_AFTER == 6) {
                return visitor_Statement_ENDIAN_VARIABLE_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_ENDIAN_VARIABLE_AFTER < 7, "No suitable visitor hook found for Statement_ENDIAN_VARIABLE_after");
            }
        }
        Visitor<UserHook<VisitorTag_Statement>> visitor_Statement_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement>> visitor_Statement_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement>> visitor_Statement_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement>> visitor_Statement_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement>> visitor_Statement_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement>> visitor_Statement_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement>> visitor_Statement_GeneratorDefaultHook;
        auto& get_visitor_Statement(const Context_Statement&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT == 0) {
                return visitor_Statement_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT == 1) {
                return visitor_Statement_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT == 2) {
                return visitor_Statement_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT == 3) {
                return visitor_Statement_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT == 4) {
                return visitor_Statement_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT == 5) {
                return visitor_Statement_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT == 6) {
                return visitor_Statement_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT < 7, "No suitable visitor hook found for Statement");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_before>> visitor_Statement_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_before>> visitor_Statement_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_before>> visitor_Statement_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_before>> visitor_Statement_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_before>> visitor_Statement_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_before>> visitor_Statement_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_before>> visitor_Statement_before_GeneratorDefaultHook;
        auto& get_visitor_Statement_before(const Context_Statement_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BEFORE == 0) {
                return visitor_Statement_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BEFORE == 1) {
                return visitor_Statement_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BEFORE == 2) {
                return visitor_Statement_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BEFORE == 3) {
                return visitor_Statement_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BEFORE == 4) {
                return visitor_Statement_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BEFORE == 5) {
                return visitor_Statement_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_BEFORE == 6) {
                return visitor_Statement_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_BEFORE < 7, "No suitable visitor hook found for Statement_before");
            }
        }
        Visitor<UserHook<VisitorTag_Statement_after>> visitor_Statement_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Statement_after>> visitor_Statement_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Statement_after>> visitor_Statement_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Statement_after>> visitor_Statement_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Statement_after>> visitor_Statement_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Statement_after>> visitor_Statement_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Statement_after>> visitor_Statement_after_GeneratorDefaultHook;
        auto& get_visitor_Statement_after(const Context_Statement_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_AFTER == 0) {
                return visitor_Statement_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_AFTER == 1) {
                return visitor_Statement_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_AFTER == 2) {
                return visitor_Statement_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_AFTER == 3) {
                return visitor_Statement_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_AFTER == 4) {
                return visitor_Statement_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_AFTER == 5) {
                return visitor_Statement_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_STATEMENT_AFTER == 6) {
                return visitor_Statement_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_STATEMENT_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_STATEMENT_AFTER < 7, "No suitable visitor hook found for Statement_after");
            }
        }
        Visitor<UserHook<VisitorTag_Block>> visitor_Block_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Block>> visitor_Block_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Block>> visitor_Block_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Block>> visitor_Block_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Block>> visitor_Block_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Block>> visitor_Block_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Block>> visitor_Block_GeneratorDefaultHook;
        auto& get_visitor_Block(const Context_Block&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_BLOCK == 0) {
                return visitor_Block_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_BLOCK == 1) {
                return visitor_Block_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_BLOCK == 2) {
                return visitor_Block_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_BLOCK == 3) {
                return visitor_Block_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_BLOCK == 4) {
                return visitor_Block_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_BLOCK == 5) {
                return visitor_Block_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_BLOCK == 6) {
                return visitor_Block_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_BLOCK>= 0 && CODEGEN_EXPECTED_PRIORITY_BLOCK < 7, "No suitable visitor hook found for Block");
            }
        }
        Visitor<UserHook<VisitorTag_Block_before>> visitor_Block_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Block_before>> visitor_Block_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Block_before>> visitor_Block_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Block_before>> visitor_Block_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Block_before>> visitor_Block_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Block_before>> visitor_Block_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Block_before>> visitor_Block_before_GeneratorDefaultHook;
        auto& get_visitor_Block_before(const Context_Block_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_BLOCK_BEFORE == 0) {
                return visitor_Block_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_BLOCK_BEFORE == 1) {
                return visitor_Block_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_BLOCK_BEFORE == 2) {
                return visitor_Block_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_BLOCK_BEFORE == 3) {
                return visitor_Block_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_BLOCK_BEFORE == 4) {
                return visitor_Block_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_BLOCK_BEFORE == 5) {
                return visitor_Block_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_BLOCK_BEFORE == 6) {
                return visitor_Block_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_BLOCK_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_BLOCK_BEFORE < 7, "No suitable visitor hook found for Block_before");
            }
        }
        Visitor<UserHook<VisitorTag_Block_after>> visitor_Block_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Block_after>> visitor_Block_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Block_after>> visitor_Block_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Block_after>> visitor_Block_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Block_after>> visitor_Block_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Block_after>> visitor_Block_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Block_after>> visitor_Block_after_GeneratorDefaultHook;
        auto& get_visitor_Block_after(const Context_Block_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_BLOCK_AFTER == 0) {
                return visitor_Block_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_BLOCK_AFTER == 1) {
                return visitor_Block_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_BLOCK_AFTER == 2) {
                return visitor_Block_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_BLOCK_AFTER == 3) {
                return visitor_Block_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_BLOCK_AFTER == 4) {
                return visitor_Block_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_BLOCK_AFTER == 5) {
                return visitor_Block_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_BLOCK_AFTER == 6) {
                return visitor_Block_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_BLOCK_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_BLOCK_AFTER < 7, "No suitable visitor hook found for Block_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_LITERAL_INT>> visitor_Expression_LITERAL_INT_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_LITERAL_INT>> visitor_Expression_LITERAL_INT_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_LITERAL_INT>> visitor_Expression_LITERAL_INT_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_LITERAL_INT>> visitor_Expression_LITERAL_INT_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_LITERAL_INT>> visitor_Expression_LITERAL_INT_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_LITERAL_INT>> visitor_Expression_LITERAL_INT_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_INT>> visitor_Expression_LITERAL_INT_GeneratorDefaultHook;
        auto& get_visitor_Expression_LITERAL_INT(const Context_Expression_LITERAL_INT&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT == 0) {
                return visitor_Expression_LITERAL_INT_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT == 1) {
                return visitor_Expression_LITERAL_INT_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT == 2) {
                return visitor_Expression_LITERAL_INT_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT == 3) {
                return visitor_Expression_LITERAL_INT_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT == 4) {
                return visitor_Expression_LITERAL_INT_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT == 5) {
                return visitor_Expression_LITERAL_INT_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT == 6) {
                return visitor_Expression_LITERAL_INT_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT < 7, "No suitable visitor hook found for Expression_LITERAL_INT");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_LITERAL_INT_before>> visitor_Expression_LITERAL_INT_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_LITERAL_INT_before>> visitor_Expression_LITERAL_INT_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_LITERAL_INT_before>> visitor_Expression_LITERAL_INT_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_LITERAL_INT_before>> visitor_Expression_LITERAL_INT_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_LITERAL_INT_before>> visitor_Expression_LITERAL_INT_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_LITERAL_INT_before>> visitor_Expression_LITERAL_INT_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_INT_before>> visitor_Expression_LITERAL_INT_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_LITERAL_INT_before(const Context_Expression_LITERAL_INT_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_BEFORE == 0) {
                return visitor_Expression_LITERAL_INT_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_BEFORE == 1) {
                return visitor_Expression_LITERAL_INT_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_BEFORE == 2) {
                return visitor_Expression_LITERAL_INT_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_BEFORE == 3) {
                return visitor_Expression_LITERAL_INT_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_BEFORE == 4) {
                return visitor_Expression_LITERAL_INT_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_BEFORE == 5) {
                return visitor_Expression_LITERAL_INT_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_BEFORE == 6) {
                return visitor_Expression_LITERAL_INT_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_BEFORE < 7, "No suitable visitor hook found for Expression_LITERAL_INT_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_LITERAL_INT_after>> visitor_Expression_LITERAL_INT_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_LITERAL_INT_after>> visitor_Expression_LITERAL_INT_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_LITERAL_INT_after>> visitor_Expression_LITERAL_INT_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_LITERAL_INT_after>> visitor_Expression_LITERAL_INT_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_LITERAL_INT_after>> visitor_Expression_LITERAL_INT_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_LITERAL_INT_after>> visitor_Expression_LITERAL_INT_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_INT_after>> visitor_Expression_LITERAL_INT_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_LITERAL_INT_after(const Context_Expression_LITERAL_INT_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_AFTER == 0) {
                return visitor_Expression_LITERAL_INT_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_AFTER == 1) {
                return visitor_Expression_LITERAL_INT_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_AFTER == 2) {
                return visitor_Expression_LITERAL_INT_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_AFTER == 3) {
                return visitor_Expression_LITERAL_INT_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_AFTER == 4) {
                return visitor_Expression_LITERAL_INT_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_AFTER == 5) {
                return visitor_Expression_LITERAL_INT_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_AFTER == 6) {
                return visitor_Expression_LITERAL_INT_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT_AFTER < 7, "No suitable visitor hook found for Expression_LITERAL_INT_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_LITERAL_INT64>> visitor_Expression_LITERAL_INT64_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_LITERAL_INT64>> visitor_Expression_LITERAL_INT64_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_LITERAL_INT64>> visitor_Expression_LITERAL_INT64_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_LITERAL_INT64>> visitor_Expression_LITERAL_INT64_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_LITERAL_INT64>> visitor_Expression_LITERAL_INT64_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_LITERAL_INT64>> visitor_Expression_LITERAL_INT64_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_INT64>> visitor_Expression_LITERAL_INT64_GeneratorDefaultHook;
        auto& get_visitor_Expression_LITERAL_INT64(const Context_Expression_LITERAL_INT64&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64 == 0) {
                return visitor_Expression_LITERAL_INT64_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64 == 1) {
                return visitor_Expression_LITERAL_INT64_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64 == 2) {
                return visitor_Expression_LITERAL_INT64_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64 == 3) {
                return visitor_Expression_LITERAL_INT64_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64 == 4) {
                return visitor_Expression_LITERAL_INT64_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64 == 5) {
                return visitor_Expression_LITERAL_INT64_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64 == 6) {
                return visitor_Expression_LITERAL_INT64_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64 < 7, "No suitable visitor hook found for Expression_LITERAL_INT64");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_LITERAL_INT64_before>> visitor_Expression_LITERAL_INT64_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_LITERAL_INT64_before>> visitor_Expression_LITERAL_INT64_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_LITERAL_INT64_before>> visitor_Expression_LITERAL_INT64_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_LITERAL_INT64_before>> visitor_Expression_LITERAL_INT64_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_LITERAL_INT64_before>> visitor_Expression_LITERAL_INT64_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_LITERAL_INT64_before>> visitor_Expression_LITERAL_INT64_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_INT64_before>> visitor_Expression_LITERAL_INT64_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_LITERAL_INT64_before(const Context_Expression_LITERAL_INT64_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_BEFORE == 0) {
                return visitor_Expression_LITERAL_INT64_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_BEFORE == 1) {
                return visitor_Expression_LITERAL_INT64_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_BEFORE == 2) {
                return visitor_Expression_LITERAL_INT64_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_BEFORE == 3) {
                return visitor_Expression_LITERAL_INT64_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_BEFORE == 4) {
                return visitor_Expression_LITERAL_INT64_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_BEFORE == 5) {
                return visitor_Expression_LITERAL_INT64_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_BEFORE == 6) {
                return visitor_Expression_LITERAL_INT64_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_BEFORE < 7, "No suitable visitor hook found for Expression_LITERAL_INT64_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_LITERAL_INT64_after>> visitor_Expression_LITERAL_INT64_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_LITERAL_INT64_after>> visitor_Expression_LITERAL_INT64_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_LITERAL_INT64_after>> visitor_Expression_LITERAL_INT64_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_LITERAL_INT64_after>> visitor_Expression_LITERAL_INT64_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_LITERAL_INT64_after>> visitor_Expression_LITERAL_INT64_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_LITERAL_INT64_after>> visitor_Expression_LITERAL_INT64_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_INT64_after>> visitor_Expression_LITERAL_INT64_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_LITERAL_INT64_after(const Context_Expression_LITERAL_INT64_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_AFTER == 0) {
                return visitor_Expression_LITERAL_INT64_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_AFTER == 1) {
                return visitor_Expression_LITERAL_INT64_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_AFTER == 2) {
                return visitor_Expression_LITERAL_INT64_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_AFTER == 3) {
                return visitor_Expression_LITERAL_INT64_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_AFTER == 4) {
                return visitor_Expression_LITERAL_INT64_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_AFTER == 5) {
                return visitor_Expression_LITERAL_INT64_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_AFTER == 6) {
                return visitor_Expression_LITERAL_INT64_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_INT64_AFTER < 7, "No suitable visitor hook found for Expression_LITERAL_INT64_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_LITERAL_BOOL>> visitor_Expression_LITERAL_BOOL_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_LITERAL_BOOL>> visitor_Expression_LITERAL_BOOL_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_LITERAL_BOOL>> visitor_Expression_LITERAL_BOOL_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_LITERAL_BOOL>> visitor_Expression_LITERAL_BOOL_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_LITERAL_BOOL>> visitor_Expression_LITERAL_BOOL_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_LITERAL_BOOL>> visitor_Expression_LITERAL_BOOL_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_BOOL>> visitor_Expression_LITERAL_BOOL_GeneratorDefaultHook;
        auto& get_visitor_Expression_LITERAL_BOOL(const Context_Expression_LITERAL_BOOL&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL == 0) {
                return visitor_Expression_LITERAL_BOOL_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL == 1) {
                return visitor_Expression_LITERAL_BOOL_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL == 2) {
                return visitor_Expression_LITERAL_BOOL_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL == 3) {
                return visitor_Expression_LITERAL_BOOL_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL == 4) {
                return visitor_Expression_LITERAL_BOOL_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL == 5) {
                return visitor_Expression_LITERAL_BOOL_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL == 6) {
                return visitor_Expression_LITERAL_BOOL_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL < 7, "No suitable visitor hook found for Expression_LITERAL_BOOL");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_LITERAL_BOOL_before>> visitor_Expression_LITERAL_BOOL_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_LITERAL_BOOL_before>> visitor_Expression_LITERAL_BOOL_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_LITERAL_BOOL_before>> visitor_Expression_LITERAL_BOOL_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_LITERAL_BOOL_before>> visitor_Expression_LITERAL_BOOL_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_LITERAL_BOOL_before>> visitor_Expression_LITERAL_BOOL_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_LITERAL_BOOL_before>> visitor_Expression_LITERAL_BOOL_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_BOOL_before>> visitor_Expression_LITERAL_BOOL_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_LITERAL_BOOL_before(const Context_Expression_LITERAL_BOOL_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_BEFORE == 0) {
                return visitor_Expression_LITERAL_BOOL_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_BEFORE == 1) {
                return visitor_Expression_LITERAL_BOOL_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_BEFORE == 2) {
                return visitor_Expression_LITERAL_BOOL_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_BEFORE == 3) {
                return visitor_Expression_LITERAL_BOOL_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_BEFORE == 4) {
                return visitor_Expression_LITERAL_BOOL_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_BEFORE == 5) {
                return visitor_Expression_LITERAL_BOOL_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_BEFORE == 6) {
                return visitor_Expression_LITERAL_BOOL_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_BEFORE < 7, "No suitable visitor hook found for Expression_LITERAL_BOOL_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_LITERAL_BOOL_after>> visitor_Expression_LITERAL_BOOL_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_LITERAL_BOOL_after>> visitor_Expression_LITERAL_BOOL_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_LITERAL_BOOL_after>> visitor_Expression_LITERAL_BOOL_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_LITERAL_BOOL_after>> visitor_Expression_LITERAL_BOOL_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_LITERAL_BOOL_after>> visitor_Expression_LITERAL_BOOL_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_LITERAL_BOOL_after>> visitor_Expression_LITERAL_BOOL_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_BOOL_after>> visitor_Expression_LITERAL_BOOL_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_LITERAL_BOOL_after(const Context_Expression_LITERAL_BOOL_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_AFTER == 0) {
                return visitor_Expression_LITERAL_BOOL_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_AFTER == 1) {
                return visitor_Expression_LITERAL_BOOL_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_AFTER == 2) {
                return visitor_Expression_LITERAL_BOOL_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_AFTER == 3) {
                return visitor_Expression_LITERAL_BOOL_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_AFTER == 4) {
                return visitor_Expression_LITERAL_BOOL_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_AFTER == 5) {
                return visitor_Expression_LITERAL_BOOL_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_AFTER == 6) {
                return visitor_Expression_LITERAL_BOOL_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_BOOL_AFTER < 7, "No suitable visitor hook found for Expression_LITERAL_BOOL_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_LITERAL_STRING>> visitor_Expression_LITERAL_STRING_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_LITERAL_STRING>> visitor_Expression_LITERAL_STRING_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_LITERAL_STRING>> visitor_Expression_LITERAL_STRING_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_LITERAL_STRING>> visitor_Expression_LITERAL_STRING_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_LITERAL_STRING>> visitor_Expression_LITERAL_STRING_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_LITERAL_STRING>> visitor_Expression_LITERAL_STRING_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_STRING>> visitor_Expression_LITERAL_STRING_GeneratorDefaultHook;
        auto& get_visitor_Expression_LITERAL_STRING(const Context_Expression_LITERAL_STRING&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING == 0) {
                return visitor_Expression_LITERAL_STRING_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING == 1) {
                return visitor_Expression_LITERAL_STRING_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING == 2) {
                return visitor_Expression_LITERAL_STRING_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING == 3) {
                return visitor_Expression_LITERAL_STRING_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING == 4) {
                return visitor_Expression_LITERAL_STRING_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING == 5) {
                return visitor_Expression_LITERAL_STRING_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING == 6) {
                return visitor_Expression_LITERAL_STRING_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING < 7, "No suitable visitor hook found for Expression_LITERAL_STRING");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_LITERAL_STRING_before>> visitor_Expression_LITERAL_STRING_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_LITERAL_STRING_before>> visitor_Expression_LITERAL_STRING_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_LITERAL_STRING_before>> visitor_Expression_LITERAL_STRING_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_LITERAL_STRING_before>> visitor_Expression_LITERAL_STRING_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_LITERAL_STRING_before>> visitor_Expression_LITERAL_STRING_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_LITERAL_STRING_before>> visitor_Expression_LITERAL_STRING_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_STRING_before>> visitor_Expression_LITERAL_STRING_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_LITERAL_STRING_before(const Context_Expression_LITERAL_STRING_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_BEFORE == 0) {
                return visitor_Expression_LITERAL_STRING_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_BEFORE == 1) {
                return visitor_Expression_LITERAL_STRING_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_BEFORE == 2) {
                return visitor_Expression_LITERAL_STRING_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_BEFORE == 3) {
                return visitor_Expression_LITERAL_STRING_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_BEFORE == 4) {
                return visitor_Expression_LITERAL_STRING_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_BEFORE == 5) {
                return visitor_Expression_LITERAL_STRING_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_BEFORE == 6) {
                return visitor_Expression_LITERAL_STRING_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_BEFORE < 7, "No suitable visitor hook found for Expression_LITERAL_STRING_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_LITERAL_STRING_after>> visitor_Expression_LITERAL_STRING_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_LITERAL_STRING_after>> visitor_Expression_LITERAL_STRING_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_LITERAL_STRING_after>> visitor_Expression_LITERAL_STRING_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_LITERAL_STRING_after>> visitor_Expression_LITERAL_STRING_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_LITERAL_STRING_after>> visitor_Expression_LITERAL_STRING_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_LITERAL_STRING_after>> visitor_Expression_LITERAL_STRING_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_STRING_after>> visitor_Expression_LITERAL_STRING_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_LITERAL_STRING_after(const Context_Expression_LITERAL_STRING_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_AFTER == 0) {
                return visitor_Expression_LITERAL_STRING_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_AFTER == 1) {
                return visitor_Expression_LITERAL_STRING_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_AFTER == 2) {
                return visitor_Expression_LITERAL_STRING_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_AFTER == 3) {
                return visitor_Expression_LITERAL_STRING_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_AFTER == 4) {
                return visitor_Expression_LITERAL_STRING_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_AFTER == 5) {
                return visitor_Expression_LITERAL_STRING_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_AFTER == 6) {
                return visitor_Expression_LITERAL_STRING_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_STRING_AFTER < 7, "No suitable visitor hook found for Expression_LITERAL_STRING_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_LITERAL_TYPE>> visitor_Expression_LITERAL_TYPE_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_LITERAL_TYPE>> visitor_Expression_LITERAL_TYPE_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_LITERAL_TYPE>> visitor_Expression_LITERAL_TYPE_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_LITERAL_TYPE>> visitor_Expression_LITERAL_TYPE_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_LITERAL_TYPE>> visitor_Expression_LITERAL_TYPE_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_LITERAL_TYPE>> visitor_Expression_LITERAL_TYPE_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_TYPE>> visitor_Expression_LITERAL_TYPE_GeneratorDefaultHook;
        auto& get_visitor_Expression_LITERAL_TYPE(const Context_Expression_LITERAL_TYPE&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE == 0) {
                return visitor_Expression_LITERAL_TYPE_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE == 1) {
                return visitor_Expression_LITERAL_TYPE_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE == 2) {
                return visitor_Expression_LITERAL_TYPE_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE == 3) {
                return visitor_Expression_LITERAL_TYPE_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE == 4) {
                return visitor_Expression_LITERAL_TYPE_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE == 5) {
                return visitor_Expression_LITERAL_TYPE_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE == 6) {
                return visitor_Expression_LITERAL_TYPE_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE < 7, "No suitable visitor hook found for Expression_LITERAL_TYPE");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_LITERAL_TYPE_before>> visitor_Expression_LITERAL_TYPE_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_LITERAL_TYPE_before>> visitor_Expression_LITERAL_TYPE_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_LITERAL_TYPE_before>> visitor_Expression_LITERAL_TYPE_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_LITERAL_TYPE_before>> visitor_Expression_LITERAL_TYPE_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_LITERAL_TYPE_before>> visitor_Expression_LITERAL_TYPE_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_LITERAL_TYPE_before>> visitor_Expression_LITERAL_TYPE_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_TYPE_before>> visitor_Expression_LITERAL_TYPE_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_LITERAL_TYPE_before(const Context_Expression_LITERAL_TYPE_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_BEFORE == 0) {
                return visitor_Expression_LITERAL_TYPE_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_BEFORE == 1) {
                return visitor_Expression_LITERAL_TYPE_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_BEFORE == 2) {
                return visitor_Expression_LITERAL_TYPE_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_BEFORE == 3) {
                return visitor_Expression_LITERAL_TYPE_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_BEFORE == 4) {
                return visitor_Expression_LITERAL_TYPE_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_BEFORE == 5) {
                return visitor_Expression_LITERAL_TYPE_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_BEFORE == 6) {
                return visitor_Expression_LITERAL_TYPE_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_BEFORE < 7, "No suitable visitor hook found for Expression_LITERAL_TYPE_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_LITERAL_TYPE_after>> visitor_Expression_LITERAL_TYPE_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_LITERAL_TYPE_after>> visitor_Expression_LITERAL_TYPE_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_LITERAL_TYPE_after>> visitor_Expression_LITERAL_TYPE_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_LITERAL_TYPE_after>> visitor_Expression_LITERAL_TYPE_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_LITERAL_TYPE_after>> visitor_Expression_LITERAL_TYPE_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_LITERAL_TYPE_after>> visitor_Expression_LITERAL_TYPE_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_TYPE_after>> visitor_Expression_LITERAL_TYPE_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_LITERAL_TYPE_after(const Context_Expression_LITERAL_TYPE_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_AFTER == 0) {
                return visitor_Expression_LITERAL_TYPE_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_AFTER == 1) {
                return visitor_Expression_LITERAL_TYPE_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_AFTER == 2) {
                return visitor_Expression_LITERAL_TYPE_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_AFTER == 3) {
                return visitor_Expression_LITERAL_TYPE_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_AFTER == 4) {
                return visitor_Expression_LITERAL_TYPE_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_AFTER == 5) {
                return visitor_Expression_LITERAL_TYPE_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_AFTER == 6) {
                return visitor_Expression_LITERAL_TYPE_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_TYPE_AFTER < 7, "No suitable visitor hook found for Expression_LITERAL_TYPE_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_LITERAL_CHAR>> visitor_Expression_LITERAL_CHAR_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_LITERAL_CHAR>> visitor_Expression_LITERAL_CHAR_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_LITERAL_CHAR>> visitor_Expression_LITERAL_CHAR_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_LITERAL_CHAR>> visitor_Expression_LITERAL_CHAR_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_LITERAL_CHAR>> visitor_Expression_LITERAL_CHAR_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_LITERAL_CHAR>> visitor_Expression_LITERAL_CHAR_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_CHAR>> visitor_Expression_LITERAL_CHAR_GeneratorDefaultHook;
        auto& get_visitor_Expression_LITERAL_CHAR(const Context_Expression_LITERAL_CHAR&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR == 0) {
                return visitor_Expression_LITERAL_CHAR_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR == 1) {
                return visitor_Expression_LITERAL_CHAR_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR == 2) {
                return visitor_Expression_LITERAL_CHAR_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR == 3) {
                return visitor_Expression_LITERAL_CHAR_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR == 4) {
                return visitor_Expression_LITERAL_CHAR_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR == 5) {
                return visitor_Expression_LITERAL_CHAR_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR == 6) {
                return visitor_Expression_LITERAL_CHAR_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR < 7, "No suitable visitor hook found for Expression_LITERAL_CHAR");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_LITERAL_CHAR_before>> visitor_Expression_LITERAL_CHAR_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_LITERAL_CHAR_before>> visitor_Expression_LITERAL_CHAR_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_LITERAL_CHAR_before>> visitor_Expression_LITERAL_CHAR_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_LITERAL_CHAR_before>> visitor_Expression_LITERAL_CHAR_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_LITERAL_CHAR_before>> visitor_Expression_LITERAL_CHAR_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_LITERAL_CHAR_before>> visitor_Expression_LITERAL_CHAR_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_CHAR_before>> visitor_Expression_LITERAL_CHAR_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_LITERAL_CHAR_before(const Context_Expression_LITERAL_CHAR_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_BEFORE == 0) {
                return visitor_Expression_LITERAL_CHAR_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_BEFORE == 1) {
                return visitor_Expression_LITERAL_CHAR_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_BEFORE == 2) {
                return visitor_Expression_LITERAL_CHAR_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_BEFORE == 3) {
                return visitor_Expression_LITERAL_CHAR_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_BEFORE == 4) {
                return visitor_Expression_LITERAL_CHAR_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_BEFORE == 5) {
                return visitor_Expression_LITERAL_CHAR_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_BEFORE == 6) {
                return visitor_Expression_LITERAL_CHAR_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_BEFORE < 7, "No suitable visitor hook found for Expression_LITERAL_CHAR_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_LITERAL_CHAR_after>> visitor_Expression_LITERAL_CHAR_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_LITERAL_CHAR_after>> visitor_Expression_LITERAL_CHAR_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_LITERAL_CHAR_after>> visitor_Expression_LITERAL_CHAR_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_LITERAL_CHAR_after>> visitor_Expression_LITERAL_CHAR_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_LITERAL_CHAR_after>> visitor_Expression_LITERAL_CHAR_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_LITERAL_CHAR_after>> visitor_Expression_LITERAL_CHAR_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_LITERAL_CHAR_after>> visitor_Expression_LITERAL_CHAR_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_LITERAL_CHAR_after(const Context_Expression_LITERAL_CHAR_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_AFTER == 0) {
                return visitor_Expression_LITERAL_CHAR_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_AFTER == 1) {
                return visitor_Expression_LITERAL_CHAR_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_AFTER == 2) {
                return visitor_Expression_LITERAL_CHAR_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_AFTER == 3) {
                return visitor_Expression_LITERAL_CHAR_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_AFTER == 4) {
                return visitor_Expression_LITERAL_CHAR_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_AFTER == 5) {
                return visitor_Expression_LITERAL_CHAR_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_AFTER == 6) {
                return visitor_Expression_LITERAL_CHAR_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_LITERAL_CHAR_AFTER < 7, "No suitable visitor hook found for Expression_LITERAL_CHAR_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_IDENTIFIER>> visitor_Expression_IDENTIFIER_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_IDENTIFIER>> visitor_Expression_IDENTIFIER_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_IDENTIFIER>> visitor_Expression_IDENTIFIER_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_IDENTIFIER>> visitor_Expression_IDENTIFIER_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_IDENTIFIER>> visitor_Expression_IDENTIFIER_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_IDENTIFIER>> visitor_Expression_IDENTIFIER_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_IDENTIFIER>> visitor_Expression_IDENTIFIER_GeneratorDefaultHook;
        auto& get_visitor_Expression_IDENTIFIER(const Context_Expression_IDENTIFIER&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER == 0) {
                return visitor_Expression_IDENTIFIER_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER == 1) {
                return visitor_Expression_IDENTIFIER_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER == 2) {
                return visitor_Expression_IDENTIFIER_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER == 3) {
                return visitor_Expression_IDENTIFIER_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER == 4) {
                return visitor_Expression_IDENTIFIER_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER == 5) {
                return visitor_Expression_IDENTIFIER_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER == 6) {
                return visitor_Expression_IDENTIFIER_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER < 7, "No suitable visitor hook found for Expression_IDENTIFIER");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_IDENTIFIER_before>> visitor_Expression_IDENTIFIER_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_IDENTIFIER_before>> visitor_Expression_IDENTIFIER_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_IDENTIFIER_before>> visitor_Expression_IDENTIFIER_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_IDENTIFIER_before>> visitor_Expression_IDENTIFIER_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_IDENTIFIER_before>> visitor_Expression_IDENTIFIER_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_IDENTIFIER_before>> visitor_Expression_IDENTIFIER_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_IDENTIFIER_before>> visitor_Expression_IDENTIFIER_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_IDENTIFIER_before(const Context_Expression_IDENTIFIER_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_BEFORE == 0) {
                return visitor_Expression_IDENTIFIER_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_BEFORE == 1) {
                return visitor_Expression_IDENTIFIER_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_BEFORE == 2) {
                return visitor_Expression_IDENTIFIER_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_BEFORE == 3) {
                return visitor_Expression_IDENTIFIER_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_BEFORE == 4) {
                return visitor_Expression_IDENTIFIER_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_BEFORE == 5) {
                return visitor_Expression_IDENTIFIER_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_BEFORE == 6) {
                return visitor_Expression_IDENTIFIER_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_BEFORE < 7, "No suitable visitor hook found for Expression_IDENTIFIER_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_IDENTIFIER_after>> visitor_Expression_IDENTIFIER_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_IDENTIFIER_after>> visitor_Expression_IDENTIFIER_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_IDENTIFIER_after>> visitor_Expression_IDENTIFIER_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_IDENTIFIER_after>> visitor_Expression_IDENTIFIER_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_IDENTIFIER_after>> visitor_Expression_IDENTIFIER_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_IDENTIFIER_after>> visitor_Expression_IDENTIFIER_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_IDENTIFIER_after>> visitor_Expression_IDENTIFIER_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_IDENTIFIER_after(const Context_Expression_IDENTIFIER_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_AFTER == 0) {
                return visitor_Expression_IDENTIFIER_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_AFTER == 1) {
                return visitor_Expression_IDENTIFIER_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_AFTER == 2) {
                return visitor_Expression_IDENTIFIER_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_AFTER == 3) {
                return visitor_Expression_IDENTIFIER_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_AFTER == 4) {
                return visitor_Expression_IDENTIFIER_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_AFTER == 5) {
                return visitor_Expression_IDENTIFIER_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_AFTER == 6) {
                return visitor_Expression_IDENTIFIER_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IDENTIFIER_AFTER < 7, "No suitable visitor hook found for Expression_IDENTIFIER_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_BINARY_OP>> visitor_Expression_BINARY_OP_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_BINARY_OP>> visitor_Expression_BINARY_OP_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_BINARY_OP>> visitor_Expression_BINARY_OP_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_BINARY_OP>> visitor_Expression_BINARY_OP_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_BINARY_OP>> visitor_Expression_BINARY_OP_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_BINARY_OP>> visitor_Expression_BINARY_OP_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_BINARY_OP>> visitor_Expression_BINARY_OP_GeneratorDefaultHook;
        auto& get_visitor_Expression_BINARY_OP(const Context_Expression_BINARY_OP&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP == 0) {
                return visitor_Expression_BINARY_OP_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP == 1) {
                return visitor_Expression_BINARY_OP_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP == 2) {
                return visitor_Expression_BINARY_OP_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP == 3) {
                return visitor_Expression_BINARY_OP_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP == 4) {
                return visitor_Expression_BINARY_OP_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP == 5) {
                return visitor_Expression_BINARY_OP_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP == 6) {
                return visitor_Expression_BINARY_OP_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP < 7, "No suitable visitor hook found for Expression_BINARY_OP");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_BINARY_OP_before>> visitor_Expression_BINARY_OP_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_BINARY_OP_before>> visitor_Expression_BINARY_OP_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_BINARY_OP_before>> visitor_Expression_BINARY_OP_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_BINARY_OP_before>> visitor_Expression_BINARY_OP_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_BINARY_OP_before>> visitor_Expression_BINARY_OP_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_BINARY_OP_before>> visitor_Expression_BINARY_OP_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_BINARY_OP_before>> visitor_Expression_BINARY_OP_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_BINARY_OP_before(const Context_Expression_BINARY_OP_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_BEFORE == 0) {
                return visitor_Expression_BINARY_OP_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_BEFORE == 1) {
                return visitor_Expression_BINARY_OP_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_BEFORE == 2) {
                return visitor_Expression_BINARY_OP_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_BEFORE == 3) {
                return visitor_Expression_BINARY_OP_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_BEFORE == 4) {
                return visitor_Expression_BINARY_OP_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_BEFORE == 5) {
                return visitor_Expression_BINARY_OP_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_BEFORE == 6) {
                return visitor_Expression_BINARY_OP_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_BEFORE < 7, "No suitable visitor hook found for Expression_BINARY_OP_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_BINARY_OP_after>> visitor_Expression_BINARY_OP_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_BINARY_OP_after>> visitor_Expression_BINARY_OP_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_BINARY_OP_after>> visitor_Expression_BINARY_OP_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_BINARY_OP_after>> visitor_Expression_BINARY_OP_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_BINARY_OP_after>> visitor_Expression_BINARY_OP_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_BINARY_OP_after>> visitor_Expression_BINARY_OP_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_BINARY_OP_after>> visitor_Expression_BINARY_OP_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_BINARY_OP_after(const Context_Expression_BINARY_OP_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_AFTER == 0) {
                return visitor_Expression_BINARY_OP_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_AFTER == 1) {
                return visitor_Expression_BINARY_OP_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_AFTER == 2) {
                return visitor_Expression_BINARY_OP_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_AFTER == 3) {
                return visitor_Expression_BINARY_OP_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_AFTER == 4) {
                return visitor_Expression_BINARY_OP_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_AFTER == 5) {
                return visitor_Expression_BINARY_OP_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_AFTER == 6) {
                return visitor_Expression_BINARY_OP_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BINARY_OP_AFTER < 7, "No suitable visitor hook found for Expression_BINARY_OP_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_UNARY_OP>> visitor_Expression_UNARY_OP_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_UNARY_OP>> visitor_Expression_UNARY_OP_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_UNARY_OP>> visitor_Expression_UNARY_OP_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_UNARY_OP>> visitor_Expression_UNARY_OP_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_UNARY_OP>> visitor_Expression_UNARY_OP_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_UNARY_OP>> visitor_Expression_UNARY_OP_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_UNARY_OP>> visitor_Expression_UNARY_OP_GeneratorDefaultHook;
        auto& get_visitor_Expression_UNARY_OP(const Context_Expression_UNARY_OP&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP == 0) {
                return visitor_Expression_UNARY_OP_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP == 1) {
                return visitor_Expression_UNARY_OP_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP == 2) {
                return visitor_Expression_UNARY_OP_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP == 3) {
                return visitor_Expression_UNARY_OP_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP == 4) {
                return visitor_Expression_UNARY_OP_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP == 5) {
                return visitor_Expression_UNARY_OP_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP == 6) {
                return visitor_Expression_UNARY_OP_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP < 7, "No suitable visitor hook found for Expression_UNARY_OP");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_UNARY_OP_before>> visitor_Expression_UNARY_OP_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_UNARY_OP_before>> visitor_Expression_UNARY_OP_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_UNARY_OP_before>> visitor_Expression_UNARY_OP_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_UNARY_OP_before>> visitor_Expression_UNARY_OP_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_UNARY_OP_before>> visitor_Expression_UNARY_OP_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_UNARY_OP_before>> visitor_Expression_UNARY_OP_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_UNARY_OP_before>> visitor_Expression_UNARY_OP_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_UNARY_OP_before(const Context_Expression_UNARY_OP_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_BEFORE == 0) {
                return visitor_Expression_UNARY_OP_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_BEFORE == 1) {
                return visitor_Expression_UNARY_OP_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_BEFORE == 2) {
                return visitor_Expression_UNARY_OP_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_BEFORE == 3) {
                return visitor_Expression_UNARY_OP_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_BEFORE == 4) {
                return visitor_Expression_UNARY_OP_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_BEFORE == 5) {
                return visitor_Expression_UNARY_OP_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_BEFORE == 6) {
                return visitor_Expression_UNARY_OP_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_BEFORE < 7, "No suitable visitor hook found for Expression_UNARY_OP_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_UNARY_OP_after>> visitor_Expression_UNARY_OP_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_UNARY_OP_after>> visitor_Expression_UNARY_OP_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_UNARY_OP_after>> visitor_Expression_UNARY_OP_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_UNARY_OP_after>> visitor_Expression_UNARY_OP_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_UNARY_OP_after>> visitor_Expression_UNARY_OP_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_UNARY_OP_after>> visitor_Expression_UNARY_OP_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_UNARY_OP_after>> visitor_Expression_UNARY_OP_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_UNARY_OP_after(const Context_Expression_UNARY_OP_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_AFTER == 0) {
                return visitor_Expression_UNARY_OP_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_AFTER == 1) {
                return visitor_Expression_UNARY_OP_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_AFTER == 2) {
                return visitor_Expression_UNARY_OP_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_AFTER == 3) {
                return visitor_Expression_UNARY_OP_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_AFTER == 4) {
                return visitor_Expression_UNARY_OP_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_AFTER == 5) {
                return visitor_Expression_UNARY_OP_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_AFTER == 6) {
                return visitor_Expression_UNARY_OP_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_UNARY_OP_AFTER < 7, "No suitable visitor hook found for Expression_UNARY_OP_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_CALL>> visitor_Expression_CALL_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_CALL>> visitor_Expression_CALL_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_CALL>> visitor_Expression_CALL_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_CALL>> visitor_Expression_CALL_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_CALL>> visitor_Expression_CALL_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_CALL>> visitor_Expression_CALL_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_CALL>> visitor_Expression_CALL_GeneratorDefaultHook;
        auto& get_visitor_Expression_CALL(const Context_Expression_CALL&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL == 0) {
                return visitor_Expression_CALL_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL == 1) {
                return visitor_Expression_CALL_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL == 2) {
                return visitor_Expression_CALL_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL == 3) {
                return visitor_Expression_CALL_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL == 4) {
                return visitor_Expression_CALL_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL == 5) {
                return visitor_Expression_CALL_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL == 6) {
                return visitor_Expression_CALL_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL < 7, "No suitable visitor hook found for Expression_CALL");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_CALL_before>> visitor_Expression_CALL_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_CALL_before>> visitor_Expression_CALL_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_CALL_before>> visitor_Expression_CALL_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_CALL_before>> visitor_Expression_CALL_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_CALL_before>> visitor_Expression_CALL_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_CALL_before>> visitor_Expression_CALL_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_CALL_before>> visitor_Expression_CALL_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_CALL_before(const Context_Expression_CALL_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_BEFORE == 0) {
                return visitor_Expression_CALL_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_BEFORE == 1) {
                return visitor_Expression_CALL_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_BEFORE == 2) {
                return visitor_Expression_CALL_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_BEFORE == 3) {
                return visitor_Expression_CALL_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_BEFORE == 4) {
                return visitor_Expression_CALL_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_BEFORE == 5) {
                return visitor_Expression_CALL_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_BEFORE == 6) {
                return visitor_Expression_CALL_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_BEFORE < 7, "No suitable visitor hook found for Expression_CALL_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_CALL_after>> visitor_Expression_CALL_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_CALL_after>> visitor_Expression_CALL_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_CALL_after>> visitor_Expression_CALL_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_CALL_after>> visitor_Expression_CALL_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_CALL_after>> visitor_Expression_CALL_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_CALL_after>> visitor_Expression_CALL_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_CALL_after>> visitor_Expression_CALL_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_CALL_after(const Context_Expression_CALL_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_AFTER == 0) {
                return visitor_Expression_CALL_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_AFTER == 1) {
                return visitor_Expression_CALL_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_AFTER == 2) {
                return visitor_Expression_CALL_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_AFTER == 3) {
                return visitor_Expression_CALL_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_AFTER == 4) {
                return visitor_Expression_CALL_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_AFTER == 5) {
                return visitor_Expression_CALL_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_AFTER == 6) {
                return visitor_Expression_CALL_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CALL_AFTER < 7, "No suitable visitor hook found for Expression_CALL_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_INDEX_ACCESS>> visitor_Expression_INDEX_ACCESS_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_INDEX_ACCESS>> visitor_Expression_INDEX_ACCESS_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_INDEX_ACCESS>> visitor_Expression_INDEX_ACCESS_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_INDEX_ACCESS>> visitor_Expression_INDEX_ACCESS_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_INDEX_ACCESS>> visitor_Expression_INDEX_ACCESS_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_INDEX_ACCESS>> visitor_Expression_INDEX_ACCESS_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_INDEX_ACCESS>> visitor_Expression_INDEX_ACCESS_GeneratorDefaultHook;
        auto& get_visitor_Expression_INDEX_ACCESS(const Context_Expression_INDEX_ACCESS&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS == 0) {
                return visitor_Expression_INDEX_ACCESS_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS == 1) {
                return visitor_Expression_INDEX_ACCESS_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS == 2) {
                return visitor_Expression_INDEX_ACCESS_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS == 3) {
                return visitor_Expression_INDEX_ACCESS_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS == 4) {
                return visitor_Expression_INDEX_ACCESS_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS == 5) {
                return visitor_Expression_INDEX_ACCESS_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS == 6) {
                return visitor_Expression_INDEX_ACCESS_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS < 7, "No suitable visitor hook found for Expression_INDEX_ACCESS");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_INDEX_ACCESS_before>> visitor_Expression_INDEX_ACCESS_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_INDEX_ACCESS_before>> visitor_Expression_INDEX_ACCESS_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_INDEX_ACCESS_before>> visitor_Expression_INDEX_ACCESS_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_INDEX_ACCESS_before>> visitor_Expression_INDEX_ACCESS_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_INDEX_ACCESS_before>> visitor_Expression_INDEX_ACCESS_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_INDEX_ACCESS_before>> visitor_Expression_INDEX_ACCESS_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_INDEX_ACCESS_before>> visitor_Expression_INDEX_ACCESS_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_INDEX_ACCESS_before(const Context_Expression_INDEX_ACCESS_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_BEFORE == 0) {
                return visitor_Expression_INDEX_ACCESS_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_BEFORE == 1) {
                return visitor_Expression_INDEX_ACCESS_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_BEFORE == 2) {
                return visitor_Expression_INDEX_ACCESS_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_BEFORE == 3) {
                return visitor_Expression_INDEX_ACCESS_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_BEFORE == 4) {
                return visitor_Expression_INDEX_ACCESS_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_BEFORE == 5) {
                return visitor_Expression_INDEX_ACCESS_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_BEFORE == 6) {
                return visitor_Expression_INDEX_ACCESS_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_BEFORE < 7, "No suitable visitor hook found for Expression_INDEX_ACCESS_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_INDEX_ACCESS_after>> visitor_Expression_INDEX_ACCESS_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_INDEX_ACCESS_after>> visitor_Expression_INDEX_ACCESS_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_INDEX_ACCESS_after>> visitor_Expression_INDEX_ACCESS_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_INDEX_ACCESS_after>> visitor_Expression_INDEX_ACCESS_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_INDEX_ACCESS_after>> visitor_Expression_INDEX_ACCESS_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_INDEX_ACCESS_after>> visitor_Expression_INDEX_ACCESS_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_INDEX_ACCESS_after>> visitor_Expression_INDEX_ACCESS_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_INDEX_ACCESS_after(const Context_Expression_INDEX_ACCESS_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_AFTER == 0) {
                return visitor_Expression_INDEX_ACCESS_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_AFTER == 1) {
                return visitor_Expression_INDEX_ACCESS_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_AFTER == 2) {
                return visitor_Expression_INDEX_ACCESS_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_AFTER == 3) {
                return visitor_Expression_INDEX_ACCESS_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_AFTER == 4) {
                return visitor_Expression_INDEX_ACCESS_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_AFTER == 5) {
                return visitor_Expression_INDEX_ACCESS_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_AFTER == 6) {
                return visitor_Expression_INDEX_ACCESS_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_INDEX_ACCESS_AFTER < 7, "No suitable visitor hook found for Expression_INDEX_ACCESS_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_MEMBER_ACCESS>> visitor_Expression_MEMBER_ACCESS_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_MEMBER_ACCESS>> visitor_Expression_MEMBER_ACCESS_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_MEMBER_ACCESS>> visitor_Expression_MEMBER_ACCESS_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_MEMBER_ACCESS>> visitor_Expression_MEMBER_ACCESS_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_MEMBER_ACCESS>> visitor_Expression_MEMBER_ACCESS_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_MEMBER_ACCESS>> visitor_Expression_MEMBER_ACCESS_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_MEMBER_ACCESS>> visitor_Expression_MEMBER_ACCESS_GeneratorDefaultHook;
        auto& get_visitor_Expression_MEMBER_ACCESS(const Context_Expression_MEMBER_ACCESS&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS == 0) {
                return visitor_Expression_MEMBER_ACCESS_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS == 1) {
                return visitor_Expression_MEMBER_ACCESS_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS == 2) {
                return visitor_Expression_MEMBER_ACCESS_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS == 3) {
                return visitor_Expression_MEMBER_ACCESS_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS == 4) {
                return visitor_Expression_MEMBER_ACCESS_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS == 5) {
                return visitor_Expression_MEMBER_ACCESS_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS == 6) {
                return visitor_Expression_MEMBER_ACCESS_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS < 7, "No suitable visitor hook found for Expression_MEMBER_ACCESS");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_MEMBER_ACCESS_before>> visitor_Expression_MEMBER_ACCESS_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_MEMBER_ACCESS_before>> visitor_Expression_MEMBER_ACCESS_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_MEMBER_ACCESS_before>> visitor_Expression_MEMBER_ACCESS_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_MEMBER_ACCESS_before>> visitor_Expression_MEMBER_ACCESS_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_MEMBER_ACCESS_before>> visitor_Expression_MEMBER_ACCESS_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_MEMBER_ACCESS_before>> visitor_Expression_MEMBER_ACCESS_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_MEMBER_ACCESS_before>> visitor_Expression_MEMBER_ACCESS_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_MEMBER_ACCESS_before(const Context_Expression_MEMBER_ACCESS_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_BEFORE == 0) {
                return visitor_Expression_MEMBER_ACCESS_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_BEFORE == 1) {
                return visitor_Expression_MEMBER_ACCESS_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_BEFORE == 2) {
                return visitor_Expression_MEMBER_ACCESS_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_BEFORE == 3) {
                return visitor_Expression_MEMBER_ACCESS_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_BEFORE == 4) {
                return visitor_Expression_MEMBER_ACCESS_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_BEFORE == 5) {
                return visitor_Expression_MEMBER_ACCESS_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_BEFORE == 6) {
                return visitor_Expression_MEMBER_ACCESS_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_BEFORE < 7, "No suitable visitor hook found for Expression_MEMBER_ACCESS_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_MEMBER_ACCESS_after>> visitor_Expression_MEMBER_ACCESS_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_MEMBER_ACCESS_after>> visitor_Expression_MEMBER_ACCESS_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_MEMBER_ACCESS_after>> visitor_Expression_MEMBER_ACCESS_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_MEMBER_ACCESS_after>> visitor_Expression_MEMBER_ACCESS_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_MEMBER_ACCESS_after>> visitor_Expression_MEMBER_ACCESS_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_MEMBER_ACCESS_after>> visitor_Expression_MEMBER_ACCESS_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_MEMBER_ACCESS_after>> visitor_Expression_MEMBER_ACCESS_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_MEMBER_ACCESS_after(const Context_Expression_MEMBER_ACCESS_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_AFTER == 0) {
                return visitor_Expression_MEMBER_ACCESS_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_AFTER == 1) {
                return visitor_Expression_MEMBER_ACCESS_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_AFTER == 2) {
                return visitor_Expression_MEMBER_ACCESS_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_AFTER == 3) {
                return visitor_Expression_MEMBER_ACCESS_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_AFTER == 4) {
                return visitor_Expression_MEMBER_ACCESS_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_AFTER == 5) {
                return visitor_Expression_MEMBER_ACCESS_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_AFTER == 6) {
                return visitor_Expression_MEMBER_ACCESS_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MEMBER_ACCESS_AFTER < 7, "No suitable visitor hook found for Expression_MEMBER_ACCESS_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_ENUM_MEMBER>> visitor_Expression_ENUM_MEMBER_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_ENUM_MEMBER>> visitor_Expression_ENUM_MEMBER_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_ENUM_MEMBER>> visitor_Expression_ENUM_MEMBER_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_ENUM_MEMBER>> visitor_Expression_ENUM_MEMBER_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_ENUM_MEMBER>> visitor_Expression_ENUM_MEMBER_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_ENUM_MEMBER>> visitor_Expression_ENUM_MEMBER_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_ENUM_MEMBER>> visitor_Expression_ENUM_MEMBER_GeneratorDefaultHook;
        auto& get_visitor_Expression_ENUM_MEMBER(const Context_Expression_ENUM_MEMBER&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER == 0) {
                return visitor_Expression_ENUM_MEMBER_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER == 1) {
                return visitor_Expression_ENUM_MEMBER_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER == 2) {
                return visitor_Expression_ENUM_MEMBER_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER == 3) {
                return visitor_Expression_ENUM_MEMBER_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER == 4) {
                return visitor_Expression_ENUM_MEMBER_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER == 5) {
                return visitor_Expression_ENUM_MEMBER_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER == 6) {
                return visitor_Expression_ENUM_MEMBER_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER < 7, "No suitable visitor hook found for Expression_ENUM_MEMBER");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_ENUM_MEMBER_before>> visitor_Expression_ENUM_MEMBER_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_ENUM_MEMBER_before>> visitor_Expression_ENUM_MEMBER_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_ENUM_MEMBER_before>> visitor_Expression_ENUM_MEMBER_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_ENUM_MEMBER_before>> visitor_Expression_ENUM_MEMBER_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_ENUM_MEMBER_before>> visitor_Expression_ENUM_MEMBER_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_ENUM_MEMBER_before>> visitor_Expression_ENUM_MEMBER_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_ENUM_MEMBER_before>> visitor_Expression_ENUM_MEMBER_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_ENUM_MEMBER_before(const Context_Expression_ENUM_MEMBER_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_BEFORE == 0) {
                return visitor_Expression_ENUM_MEMBER_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_BEFORE == 1) {
                return visitor_Expression_ENUM_MEMBER_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_BEFORE == 2) {
                return visitor_Expression_ENUM_MEMBER_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_BEFORE == 3) {
                return visitor_Expression_ENUM_MEMBER_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_BEFORE == 4) {
                return visitor_Expression_ENUM_MEMBER_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_BEFORE == 5) {
                return visitor_Expression_ENUM_MEMBER_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_BEFORE == 6) {
                return visitor_Expression_ENUM_MEMBER_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_BEFORE < 7, "No suitable visitor hook found for Expression_ENUM_MEMBER_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_ENUM_MEMBER_after>> visitor_Expression_ENUM_MEMBER_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_ENUM_MEMBER_after>> visitor_Expression_ENUM_MEMBER_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_ENUM_MEMBER_after>> visitor_Expression_ENUM_MEMBER_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_ENUM_MEMBER_after>> visitor_Expression_ENUM_MEMBER_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_ENUM_MEMBER_after>> visitor_Expression_ENUM_MEMBER_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_ENUM_MEMBER_after>> visitor_Expression_ENUM_MEMBER_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_ENUM_MEMBER_after>> visitor_Expression_ENUM_MEMBER_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_ENUM_MEMBER_after(const Context_Expression_ENUM_MEMBER_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_AFTER == 0) {
                return visitor_Expression_ENUM_MEMBER_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_AFTER == 1) {
                return visitor_Expression_ENUM_MEMBER_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_AFTER == 2) {
                return visitor_Expression_ENUM_MEMBER_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_AFTER == 3) {
                return visitor_Expression_ENUM_MEMBER_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_AFTER == 4) {
                return visitor_Expression_ENUM_MEMBER_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_AFTER == 5) {
                return visitor_Expression_ENUM_MEMBER_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_AFTER == 6) {
                return visitor_Expression_ENUM_MEMBER_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_MEMBER_AFTER < 7, "No suitable visitor hook found for Expression_ENUM_MEMBER_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_TYPE_CAST>> visitor_Expression_TYPE_CAST_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_TYPE_CAST>> visitor_Expression_TYPE_CAST_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_TYPE_CAST>> visitor_Expression_TYPE_CAST_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_TYPE_CAST>> visitor_Expression_TYPE_CAST_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_TYPE_CAST>> visitor_Expression_TYPE_CAST_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_TYPE_CAST>> visitor_Expression_TYPE_CAST_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_TYPE_CAST>> visitor_Expression_TYPE_CAST_GeneratorDefaultHook;
        auto& get_visitor_Expression_TYPE_CAST(const Context_Expression_TYPE_CAST&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST == 0) {
                return visitor_Expression_TYPE_CAST_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST == 1) {
                return visitor_Expression_TYPE_CAST_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST == 2) {
                return visitor_Expression_TYPE_CAST_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST == 3) {
                return visitor_Expression_TYPE_CAST_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST == 4) {
                return visitor_Expression_TYPE_CAST_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST == 5) {
                return visitor_Expression_TYPE_CAST_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST == 6) {
                return visitor_Expression_TYPE_CAST_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST < 7, "No suitable visitor hook found for Expression_TYPE_CAST");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_TYPE_CAST_before>> visitor_Expression_TYPE_CAST_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_TYPE_CAST_before>> visitor_Expression_TYPE_CAST_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_TYPE_CAST_before>> visitor_Expression_TYPE_CAST_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_TYPE_CAST_before>> visitor_Expression_TYPE_CAST_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_TYPE_CAST_before>> visitor_Expression_TYPE_CAST_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_TYPE_CAST_before>> visitor_Expression_TYPE_CAST_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_TYPE_CAST_before>> visitor_Expression_TYPE_CAST_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_TYPE_CAST_before(const Context_Expression_TYPE_CAST_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_BEFORE == 0) {
                return visitor_Expression_TYPE_CAST_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_BEFORE == 1) {
                return visitor_Expression_TYPE_CAST_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_BEFORE == 2) {
                return visitor_Expression_TYPE_CAST_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_BEFORE == 3) {
                return visitor_Expression_TYPE_CAST_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_BEFORE == 4) {
                return visitor_Expression_TYPE_CAST_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_BEFORE == 5) {
                return visitor_Expression_TYPE_CAST_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_BEFORE == 6) {
                return visitor_Expression_TYPE_CAST_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_BEFORE < 7, "No suitable visitor hook found for Expression_TYPE_CAST_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_TYPE_CAST_after>> visitor_Expression_TYPE_CAST_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_TYPE_CAST_after>> visitor_Expression_TYPE_CAST_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_TYPE_CAST_after>> visitor_Expression_TYPE_CAST_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_TYPE_CAST_after>> visitor_Expression_TYPE_CAST_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_TYPE_CAST_after>> visitor_Expression_TYPE_CAST_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_TYPE_CAST_after>> visitor_Expression_TYPE_CAST_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_TYPE_CAST_after>> visitor_Expression_TYPE_CAST_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_TYPE_CAST_after(const Context_Expression_TYPE_CAST_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_AFTER == 0) {
                return visitor_Expression_TYPE_CAST_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_AFTER == 1) {
                return visitor_Expression_TYPE_CAST_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_AFTER == 2) {
                return visitor_Expression_TYPE_CAST_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_AFTER == 3) {
                return visitor_Expression_TYPE_CAST_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_AFTER == 4) {
                return visitor_Expression_TYPE_CAST_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_AFTER == 5) {
                return visitor_Expression_TYPE_CAST_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_AFTER == 6) {
                return visitor_Expression_TYPE_CAST_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_TYPE_CAST_AFTER < 7, "No suitable visitor hook found for Expression_TYPE_CAST_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_RANGE>> visitor_Expression_RANGE_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_RANGE>> visitor_Expression_RANGE_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_RANGE>> visitor_Expression_RANGE_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_RANGE>> visitor_Expression_RANGE_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_RANGE>> visitor_Expression_RANGE_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_RANGE>> visitor_Expression_RANGE_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_RANGE>> visitor_Expression_RANGE_GeneratorDefaultHook;
        auto& get_visitor_Expression_RANGE(const Context_Expression_RANGE&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE == 0) {
                return visitor_Expression_RANGE_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE == 1) {
                return visitor_Expression_RANGE_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE == 2) {
                return visitor_Expression_RANGE_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE == 3) {
                return visitor_Expression_RANGE_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE == 4) {
                return visitor_Expression_RANGE_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE == 5) {
                return visitor_Expression_RANGE_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE == 6) {
                return visitor_Expression_RANGE_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE < 7, "No suitable visitor hook found for Expression_RANGE");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_RANGE_before>> visitor_Expression_RANGE_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_RANGE_before>> visitor_Expression_RANGE_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_RANGE_before>> visitor_Expression_RANGE_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_RANGE_before>> visitor_Expression_RANGE_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_RANGE_before>> visitor_Expression_RANGE_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_RANGE_before>> visitor_Expression_RANGE_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_RANGE_before>> visitor_Expression_RANGE_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_RANGE_before(const Context_Expression_RANGE_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_BEFORE == 0) {
                return visitor_Expression_RANGE_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_BEFORE == 1) {
                return visitor_Expression_RANGE_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_BEFORE == 2) {
                return visitor_Expression_RANGE_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_BEFORE == 3) {
                return visitor_Expression_RANGE_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_BEFORE == 4) {
                return visitor_Expression_RANGE_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_BEFORE == 5) {
                return visitor_Expression_RANGE_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_BEFORE == 6) {
                return visitor_Expression_RANGE_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_BEFORE < 7, "No suitable visitor hook found for Expression_RANGE_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_RANGE_after>> visitor_Expression_RANGE_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_RANGE_after>> visitor_Expression_RANGE_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_RANGE_after>> visitor_Expression_RANGE_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_RANGE_after>> visitor_Expression_RANGE_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_RANGE_after>> visitor_Expression_RANGE_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_RANGE_after>> visitor_Expression_RANGE_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_RANGE_after>> visitor_Expression_RANGE_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_RANGE_after(const Context_Expression_RANGE_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_AFTER == 0) {
                return visitor_Expression_RANGE_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_AFTER == 1) {
                return visitor_Expression_RANGE_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_AFTER == 2) {
                return visitor_Expression_RANGE_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_AFTER == 3) {
                return visitor_Expression_RANGE_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_AFTER == 4) {
                return visitor_Expression_RANGE_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_AFTER == 5) {
                return visitor_Expression_RANGE_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_AFTER == 6) {
                return visitor_Expression_RANGE_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_RANGE_AFTER < 7, "No suitable visitor hook found for Expression_RANGE_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_DEFAULT_VALUE>> visitor_Expression_DEFAULT_VALUE_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_DEFAULT_VALUE>> visitor_Expression_DEFAULT_VALUE_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_DEFAULT_VALUE>> visitor_Expression_DEFAULT_VALUE_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_DEFAULT_VALUE>> visitor_Expression_DEFAULT_VALUE_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_DEFAULT_VALUE>> visitor_Expression_DEFAULT_VALUE_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_DEFAULT_VALUE>> visitor_Expression_DEFAULT_VALUE_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_DEFAULT_VALUE>> visitor_Expression_DEFAULT_VALUE_GeneratorDefaultHook;
        auto& get_visitor_Expression_DEFAULT_VALUE(const Context_Expression_DEFAULT_VALUE&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE == 0) {
                return visitor_Expression_DEFAULT_VALUE_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE == 1) {
                return visitor_Expression_DEFAULT_VALUE_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE == 2) {
                return visitor_Expression_DEFAULT_VALUE_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE == 3) {
                return visitor_Expression_DEFAULT_VALUE_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE == 4) {
                return visitor_Expression_DEFAULT_VALUE_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE == 5) {
                return visitor_Expression_DEFAULT_VALUE_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE == 6) {
                return visitor_Expression_DEFAULT_VALUE_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE < 7, "No suitable visitor hook found for Expression_DEFAULT_VALUE");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_DEFAULT_VALUE_before>> visitor_Expression_DEFAULT_VALUE_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_DEFAULT_VALUE_before>> visitor_Expression_DEFAULT_VALUE_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_DEFAULT_VALUE_before>> visitor_Expression_DEFAULT_VALUE_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_DEFAULT_VALUE_before>> visitor_Expression_DEFAULT_VALUE_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_DEFAULT_VALUE_before>> visitor_Expression_DEFAULT_VALUE_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_DEFAULT_VALUE_before>> visitor_Expression_DEFAULT_VALUE_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_DEFAULT_VALUE_before>> visitor_Expression_DEFAULT_VALUE_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_DEFAULT_VALUE_before(const Context_Expression_DEFAULT_VALUE_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_BEFORE == 0) {
                return visitor_Expression_DEFAULT_VALUE_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_BEFORE == 1) {
                return visitor_Expression_DEFAULT_VALUE_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_BEFORE == 2) {
                return visitor_Expression_DEFAULT_VALUE_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_BEFORE == 3) {
                return visitor_Expression_DEFAULT_VALUE_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_BEFORE == 4) {
                return visitor_Expression_DEFAULT_VALUE_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_BEFORE == 5) {
                return visitor_Expression_DEFAULT_VALUE_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_BEFORE == 6) {
                return visitor_Expression_DEFAULT_VALUE_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_BEFORE < 7, "No suitable visitor hook found for Expression_DEFAULT_VALUE_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_DEFAULT_VALUE_after>> visitor_Expression_DEFAULT_VALUE_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_DEFAULT_VALUE_after>> visitor_Expression_DEFAULT_VALUE_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_DEFAULT_VALUE_after>> visitor_Expression_DEFAULT_VALUE_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_DEFAULT_VALUE_after>> visitor_Expression_DEFAULT_VALUE_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_DEFAULT_VALUE_after>> visitor_Expression_DEFAULT_VALUE_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_DEFAULT_VALUE_after>> visitor_Expression_DEFAULT_VALUE_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_DEFAULT_VALUE_after>> visitor_Expression_DEFAULT_VALUE_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_DEFAULT_VALUE_after(const Context_Expression_DEFAULT_VALUE_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_AFTER == 0) {
                return visitor_Expression_DEFAULT_VALUE_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_AFTER == 1) {
                return visitor_Expression_DEFAULT_VALUE_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_AFTER == 2) {
                return visitor_Expression_DEFAULT_VALUE_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_AFTER == 3) {
                return visitor_Expression_DEFAULT_VALUE_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_AFTER == 4) {
                return visitor_Expression_DEFAULT_VALUE_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_AFTER == 5) {
                return visitor_Expression_DEFAULT_VALUE_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_AFTER == 6) {
                return visitor_Expression_DEFAULT_VALUE_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_DEFAULT_VALUE_AFTER < 7, "No suitable visitor hook found for Expression_DEFAULT_VALUE_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_IS_LITTLE_ENDIAN>> visitor_Expression_IS_LITTLE_ENDIAN_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_IS_LITTLE_ENDIAN>> visitor_Expression_IS_LITTLE_ENDIAN_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_IS_LITTLE_ENDIAN>> visitor_Expression_IS_LITTLE_ENDIAN_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_IS_LITTLE_ENDIAN>> visitor_Expression_IS_LITTLE_ENDIAN_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_IS_LITTLE_ENDIAN>> visitor_Expression_IS_LITTLE_ENDIAN_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_IS_LITTLE_ENDIAN>> visitor_Expression_IS_LITTLE_ENDIAN_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_IS_LITTLE_ENDIAN>> visitor_Expression_IS_LITTLE_ENDIAN_GeneratorDefaultHook;
        auto& get_visitor_Expression_IS_LITTLE_ENDIAN(const Context_Expression_IS_LITTLE_ENDIAN&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN == 0) {
                return visitor_Expression_IS_LITTLE_ENDIAN_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN == 1) {
                return visitor_Expression_IS_LITTLE_ENDIAN_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN == 2) {
                return visitor_Expression_IS_LITTLE_ENDIAN_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN == 3) {
                return visitor_Expression_IS_LITTLE_ENDIAN_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN == 4) {
                return visitor_Expression_IS_LITTLE_ENDIAN_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN == 5) {
                return visitor_Expression_IS_LITTLE_ENDIAN_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN == 6) {
                return visitor_Expression_IS_LITTLE_ENDIAN_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN < 7, "No suitable visitor hook found for Expression_IS_LITTLE_ENDIAN");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_IS_LITTLE_ENDIAN_before>> visitor_Expression_IS_LITTLE_ENDIAN_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_IS_LITTLE_ENDIAN_before>> visitor_Expression_IS_LITTLE_ENDIAN_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_IS_LITTLE_ENDIAN_before>> visitor_Expression_IS_LITTLE_ENDIAN_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_IS_LITTLE_ENDIAN_before>> visitor_Expression_IS_LITTLE_ENDIAN_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_IS_LITTLE_ENDIAN_before>> visitor_Expression_IS_LITTLE_ENDIAN_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_IS_LITTLE_ENDIAN_before>> visitor_Expression_IS_LITTLE_ENDIAN_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_IS_LITTLE_ENDIAN_before>> visitor_Expression_IS_LITTLE_ENDIAN_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_IS_LITTLE_ENDIAN_before(const Context_Expression_IS_LITTLE_ENDIAN_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE == 0) {
                return visitor_Expression_IS_LITTLE_ENDIAN_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE == 1) {
                return visitor_Expression_IS_LITTLE_ENDIAN_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE == 2) {
                return visitor_Expression_IS_LITTLE_ENDIAN_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE == 3) {
                return visitor_Expression_IS_LITTLE_ENDIAN_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE == 4) {
                return visitor_Expression_IS_LITTLE_ENDIAN_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE == 5) {
                return visitor_Expression_IS_LITTLE_ENDIAN_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE == 6) {
                return visitor_Expression_IS_LITTLE_ENDIAN_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE < 7, "No suitable visitor hook found for Expression_IS_LITTLE_ENDIAN_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_IS_LITTLE_ENDIAN_after>> visitor_Expression_IS_LITTLE_ENDIAN_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_IS_LITTLE_ENDIAN_after>> visitor_Expression_IS_LITTLE_ENDIAN_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_IS_LITTLE_ENDIAN_after>> visitor_Expression_IS_LITTLE_ENDIAN_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_IS_LITTLE_ENDIAN_after>> visitor_Expression_IS_LITTLE_ENDIAN_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_IS_LITTLE_ENDIAN_after>> visitor_Expression_IS_LITTLE_ENDIAN_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_IS_LITTLE_ENDIAN_after>> visitor_Expression_IS_LITTLE_ENDIAN_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_IS_LITTLE_ENDIAN_after>> visitor_Expression_IS_LITTLE_ENDIAN_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_IS_LITTLE_ENDIAN_after(const Context_Expression_IS_LITTLE_ENDIAN_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_AFTER == 0) {
                return visitor_Expression_IS_LITTLE_ENDIAN_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_AFTER == 1) {
                return visitor_Expression_IS_LITTLE_ENDIAN_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_AFTER == 2) {
                return visitor_Expression_IS_LITTLE_ENDIAN_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_AFTER == 3) {
                return visitor_Expression_IS_LITTLE_ENDIAN_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_AFTER == 4) {
                return visitor_Expression_IS_LITTLE_ENDIAN_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_AFTER == 5) {
                return visitor_Expression_IS_LITTLE_ENDIAN_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_AFTER == 6) {
                return visitor_Expression_IS_LITTLE_ENDIAN_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_LITTLE_ENDIAN_AFTER < 7, "No suitable visitor hook found for Expression_IS_LITTLE_ENDIAN_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_GET_STREAM_OFFSET>> visitor_Expression_GET_STREAM_OFFSET_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_GET_STREAM_OFFSET>> visitor_Expression_GET_STREAM_OFFSET_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_GET_STREAM_OFFSET>> visitor_Expression_GET_STREAM_OFFSET_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_GET_STREAM_OFFSET>> visitor_Expression_GET_STREAM_OFFSET_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_GET_STREAM_OFFSET>> visitor_Expression_GET_STREAM_OFFSET_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_GET_STREAM_OFFSET>> visitor_Expression_GET_STREAM_OFFSET_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_GET_STREAM_OFFSET>> visitor_Expression_GET_STREAM_OFFSET_GeneratorDefaultHook;
        auto& get_visitor_Expression_GET_STREAM_OFFSET(const Context_Expression_GET_STREAM_OFFSET&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET == 0) {
                return visitor_Expression_GET_STREAM_OFFSET_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET == 1) {
                return visitor_Expression_GET_STREAM_OFFSET_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET == 2) {
                return visitor_Expression_GET_STREAM_OFFSET_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET == 3) {
                return visitor_Expression_GET_STREAM_OFFSET_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET == 4) {
                return visitor_Expression_GET_STREAM_OFFSET_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET == 5) {
                return visitor_Expression_GET_STREAM_OFFSET_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET == 6) {
                return visitor_Expression_GET_STREAM_OFFSET_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET < 7, "No suitable visitor hook found for Expression_GET_STREAM_OFFSET");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_GET_STREAM_OFFSET_before>> visitor_Expression_GET_STREAM_OFFSET_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_GET_STREAM_OFFSET_before>> visitor_Expression_GET_STREAM_OFFSET_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_GET_STREAM_OFFSET_before>> visitor_Expression_GET_STREAM_OFFSET_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_GET_STREAM_OFFSET_before>> visitor_Expression_GET_STREAM_OFFSET_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_GET_STREAM_OFFSET_before>> visitor_Expression_GET_STREAM_OFFSET_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_GET_STREAM_OFFSET_before>> visitor_Expression_GET_STREAM_OFFSET_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_GET_STREAM_OFFSET_before>> visitor_Expression_GET_STREAM_OFFSET_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_GET_STREAM_OFFSET_before(const Context_Expression_GET_STREAM_OFFSET_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_BEFORE == 0) {
                return visitor_Expression_GET_STREAM_OFFSET_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_BEFORE == 1) {
                return visitor_Expression_GET_STREAM_OFFSET_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_BEFORE == 2) {
                return visitor_Expression_GET_STREAM_OFFSET_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_BEFORE == 3) {
                return visitor_Expression_GET_STREAM_OFFSET_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_BEFORE == 4) {
                return visitor_Expression_GET_STREAM_OFFSET_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_BEFORE == 5) {
                return visitor_Expression_GET_STREAM_OFFSET_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_BEFORE == 6) {
                return visitor_Expression_GET_STREAM_OFFSET_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_BEFORE < 7, "No suitable visitor hook found for Expression_GET_STREAM_OFFSET_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_GET_STREAM_OFFSET_after>> visitor_Expression_GET_STREAM_OFFSET_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_GET_STREAM_OFFSET_after>> visitor_Expression_GET_STREAM_OFFSET_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_GET_STREAM_OFFSET_after>> visitor_Expression_GET_STREAM_OFFSET_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_GET_STREAM_OFFSET_after>> visitor_Expression_GET_STREAM_OFFSET_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_GET_STREAM_OFFSET_after>> visitor_Expression_GET_STREAM_OFFSET_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_GET_STREAM_OFFSET_after>> visitor_Expression_GET_STREAM_OFFSET_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_GET_STREAM_OFFSET_after>> visitor_Expression_GET_STREAM_OFFSET_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_GET_STREAM_OFFSET_after(const Context_Expression_GET_STREAM_OFFSET_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_AFTER == 0) {
                return visitor_Expression_GET_STREAM_OFFSET_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_AFTER == 1) {
                return visitor_Expression_GET_STREAM_OFFSET_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_AFTER == 2) {
                return visitor_Expression_GET_STREAM_OFFSET_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_AFTER == 3) {
                return visitor_Expression_GET_STREAM_OFFSET_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_AFTER == 4) {
                return visitor_Expression_GET_STREAM_OFFSET_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_AFTER == 5) {
                return visitor_Expression_GET_STREAM_OFFSET_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_AFTER == 6) {
                return visitor_Expression_GET_STREAM_OFFSET_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_STREAM_OFFSET_AFTER < 7, "No suitable visitor hook found for Expression_GET_STREAM_OFFSET_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_GET_REMAINING_BYTES>> visitor_Expression_GET_REMAINING_BYTES_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_GET_REMAINING_BYTES>> visitor_Expression_GET_REMAINING_BYTES_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_GET_REMAINING_BYTES>> visitor_Expression_GET_REMAINING_BYTES_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_GET_REMAINING_BYTES>> visitor_Expression_GET_REMAINING_BYTES_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_GET_REMAINING_BYTES>> visitor_Expression_GET_REMAINING_BYTES_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_GET_REMAINING_BYTES>> visitor_Expression_GET_REMAINING_BYTES_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_GET_REMAINING_BYTES>> visitor_Expression_GET_REMAINING_BYTES_GeneratorDefaultHook;
        auto& get_visitor_Expression_GET_REMAINING_BYTES(const Context_Expression_GET_REMAINING_BYTES&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES == 0) {
                return visitor_Expression_GET_REMAINING_BYTES_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES == 1) {
                return visitor_Expression_GET_REMAINING_BYTES_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES == 2) {
                return visitor_Expression_GET_REMAINING_BYTES_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES == 3) {
                return visitor_Expression_GET_REMAINING_BYTES_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES == 4) {
                return visitor_Expression_GET_REMAINING_BYTES_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES == 5) {
                return visitor_Expression_GET_REMAINING_BYTES_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES == 6) {
                return visitor_Expression_GET_REMAINING_BYTES_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES < 7, "No suitable visitor hook found for Expression_GET_REMAINING_BYTES");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_GET_REMAINING_BYTES_before>> visitor_Expression_GET_REMAINING_BYTES_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_GET_REMAINING_BYTES_before>> visitor_Expression_GET_REMAINING_BYTES_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_GET_REMAINING_BYTES_before>> visitor_Expression_GET_REMAINING_BYTES_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_GET_REMAINING_BYTES_before>> visitor_Expression_GET_REMAINING_BYTES_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_GET_REMAINING_BYTES_before>> visitor_Expression_GET_REMAINING_BYTES_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_GET_REMAINING_BYTES_before>> visitor_Expression_GET_REMAINING_BYTES_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_GET_REMAINING_BYTES_before>> visitor_Expression_GET_REMAINING_BYTES_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_GET_REMAINING_BYTES_before(const Context_Expression_GET_REMAINING_BYTES_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_BEFORE == 0) {
                return visitor_Expression_GET_REMAINING_BYTES_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_BEFORE == 1) {
                return visitor_Expression_GET_REMAINING_BYTES_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_BEFORE == 2) {
                return visitor_Expression_GET_REMAINING_BYTES_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_BEFORE == 3) {
                return visitor_Expression_GET_REMAINING_BYTES_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_BEFORE == 4) {
                return visitor_Expression_GET_REMAINING_BYTES_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_BEFORE == 5) {
                return visitor_Expression_GET_REMAINING_BYTES_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_BEFORE == 6) {
                return visitor_Expression_GET_REMAINING_BYTES_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_BEFORE < 7, "No suitable visitor hook found for Expression_GET_REMAINING_BYTES_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_GET_REMAINING_BYTES_after>> visitor_Expression_GET_REMAINING_BYTES_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_GET_REMAINING_BYTES_after>> visitor_Expression_GET_REMAINING_BYTES_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_GET_REMAINING_BYTES_after>> visitor_Expression_GET_REMAINING_BYTES_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_GET_REMAINING_BYTES_after>> visitor_Expression_GET_REMAINING_BYTES_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_GET_REMAINING_BYTES_after>> visitor_Expression_GET_REMAINING_BYTES_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_GET_REMAINING_BYTES_after>> visitor_Expression_GET_REMAINING_BYTES_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_GET_REMAINING_BYTES_after>> visitor_Expression_GET_REMAINING_BYTES_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_GET_REMAINING_BYTES_after(const Context_Expression_GET_REMAINING_BYTES_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_AFTER == 0) {
                return visitor_Expression_GET_REMAINING_BYTES_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_AFTER == 1) {
                return visitor_Expression_GET_REMAINING_BYTES_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_AFTER == 2) {
                return visitor_Expression_GET_REMAINING_BYTES_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_AFTER == 3) {
                return visitor_Expression_GET_REMAINING_BYTES_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_AFTER == 4) {
                return visitor_Expression_GET_REMAINING_BYTES_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_AFTER == 5) {
                return visitor_Expression_GET_REMAINING_BYTES_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_AFTER == 6) {
                return visitor_Expression_GET_REMAINING_BYTES_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_GET_REMAINING_BYTES_AFTER < 7, "No suitable visitor hook found for Expression_GET_REMAINING_BYTES_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_CAN_READ_STREAM>> visitor_Expression_CAN_READ_STREAM_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_CAN_READ_STREAM>> visitor_Expression_CAN_READ_STREAM_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_CAN_READ_STREAM>> visitor_Expression_CAN_READ_STREAM_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_CAN_READ_STREAM>> visitor_Expression_CAN_READ_STREAM_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_CAN_READ_STREAM>> visitor_Expression_CAN_READ_STREAM_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_CAN_READ_STREAM>> visitor_Expression_CAN_READ_STREAM_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_CAN_READ_STREAM>> visitor_Expression_CAN_READ_STREAM_GeneratorDefaultHook;
        auto& get_visitor_Expression_CAN_READ_STREAM(const Context_Expression_CAN_READ_STREAM&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM == 0) {
                return visitor_Expression_CAN_READ_STREAM_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM == 1) {
                return visitor_Expression_CAN_READ_STREAM_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM == 2) {
                return visitor_Expression_CAN_READ_STREAM_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM == 3) {
                return visitor_Expression_CAN_READ_STREAM_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM == 4) {
                return visitor_Expression_CAN_READ_STREAM_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM == 5) {
                return visitor_Expression_CAN_READ_STREAM_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM == 6) {
                return visitor_Expression_CAN_READ_STREAM_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM < 7, "No suitable visitor hook found for Expression_CAN_READ_STREAM");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_CAN_READ_STREAM_before>> visitor_Expression_CAN_READ_STREAM_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_CAN_READ_STREAM_before>> visitor_Expression_CAN_READ_STREAM_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_CAN_READ_STREAM_before>> visitor_Expression_CAN_READ_STREAM_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_CAN_READ_STREAM_before>> visitor_Expression_CAN_READ_STREAM_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_CAN_READ_STREAM_before>> visitor_Expression_CAN_READ_STREAM_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_CAN_READ_STREAM_before>> visitor_Expression_CAN_READ_STREAM_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_CAN_READ_STREAM_before>> visitor_Expression_CAN_READ_STREAM_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_CAN_READ_STREAM_before(const Context_Expression_CAN_READ_STREAM_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_BEFORE == 0) {
                return visitor_Expression_CAN_READ_STREAM_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_BEFORE == 1) {
                return visitor_Expression_CAN_READ_STREAM_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_BEFORE == 2) {
                return visitor_Expression_CAN_READ_STREAM_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_BEFORE == 3) {
                return visitor_Expression_CAN_READ_STREAM_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_BEFORE == 4) {
                return visitor_Expression_CAN_READ_STREAM_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_BEFORE == 5) {
                return visitor_Expression_CAN_READ_STREAM_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_BEFORE == 6) {
                return visitor_Expression_CAN_READ_STREAM_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_BEFORE < 7, "No suitable visitor hook found for Expression_CAN_READ_STREAM_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_CAN_READ_STREAM_after>> visitor_Expression_CAN_READ_STREAM_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_CAN_READ_STREAM_after>> visitor_Expression_CAN_READ_STREAM_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_CAN_READ_STREAM_after>> visitor_Expression_CAN_READ_STREAM_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_CAN_READ_STREAM_after>> visitor_Expression_CAN_READ_STREAM_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_CAN_READ_STREAM_after>> visitor_Expression_CAN_READ_STREAM_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_CAN_READ_STREAM_after>> visitor_Expression_CAN_READ_STREAM_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_CAN_READ_STREAM_after>> visitor_Expression_CAN_READ_STREAM_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_CAN_READ_STREAM_after(const Context_Expression_CAN_READ_STREAM_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_AFTER == 0) {
                return visitor_Expression_CAN_READ_STREAM_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_AFTER == 1) {
                return visitor_Expression_CAN_READ_STREAM_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_AFTER == 2) {
                return visitor_Expression_CAN_READ_STREAM_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_AFTER == 3) {
                return visitor_Expression_CAN_READ_STREAM_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_AFTER == 4) {
                return visitor_Expression_CAN_READ_STREAM_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_AFTER == 5) {
                return visitor_Expression_CAN_READ_STREAM_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_AFTER == 6) {
                return visitor_Expression_CAN_READ_STREAM_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CAN_READ_STREAM_AFTER < 7, "No suitable visitor hook found for Expression_CAN_READ_STREAM_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_ARRAY_SIZE>> visitor_Expression_ARRAY_SIZE_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_ARRAY_SIZE>> visitor_Expression_ARRAY_SIZE_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_ARRAY_SIZE>> visitor_Expression_ARRAY_SIZE_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_ARRAY_SIZE>> visitor_Expression_ARRAY_SIZE_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_ARRAY_SIZE>> visitor_Expression_ARRAY_SIZE_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_ARRAY_SIZE>> visitor_Expression_ARRAY_SIZE_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_ARRAY_SIZE>> visitor_Expression_ARRAY_SIZE_GeneratorDefaultHook;
        auto& get_visitor_Expression_ARRAY_SIZE(const Context_Expression_ARRAY_SIZE&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE == 0) {
                return visitor_Expression_ARRAY_SIZE_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE == 1) {
                return visitor_Expression_ARRAY_SIZE_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE == 2) {
                return visitor_Expression_ARRAY_SIZE_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE == 3) {
                return visitor_Expression_ARRAY_SIZE_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE == 4) {
                return visitor_Expression_ARRAY_SIZE_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE == 5) {
                return visitor_Expression_ARRAY_SIZE_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE == 6) {
                return visitor_Expression_ARRAY_SIZE_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE < 7, "No suitable visitor hook found for Expression_ARRAY_SIZE");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_ARRAY_SIZE_before>> visitor_Expression_ARRAY_SIZE_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_ARRAY_SIZE_before>> visitor_Expression_ARRAY_SIZE_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_ARRAY_SIZE_before>> visitor_Expression_ARRAY_SIZE_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_ARRAY_SIZE_before>> visitor_Expression_ARRAY_SIZE_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_ARRAY_SIZE_before>> visitor_Expression_ARRAY_SIZE_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_ARRAY_SIZE_before>> visitor_Expression_ARRAY_SIZE_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_ARRAY_SIZE_before>> visitor_Expression_ARRAY_SIZE_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_ARRAY_SIZE_before(const Context_Expression_ARRAY_SIZE_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_BEFORE == 0) {
                return visitor_Expression_ARRAY_SIZE_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_BEFORE == 1) {
                return visitor_Expression_ARRAY_SIZE_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_BEFORE == 2) {
                return visitor_Expression_ARRAY_SIZE_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_BEFORE == 3) {
                return visitor_Expression_ARRAY_SIZE_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_BEFORE == 4) {
                return visitor_Expression_ARRAY_SIZE_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_BEFORE == 5) {
                return visitor_Expression_ARRAY_SIZE_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_BEFORE == 6) {
                return visitor_Expression_ARRAY_SIZE_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_BEFORE < 7, "No suitable visitor hook found for Expression_ARRAY_SIZE_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_ARRAY_SIZE_after>> visitor_Expression_ARRAY_SIZE_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_ARRAY_SIZE_after>> visitor_Expression_ARRAY_SIZE_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_ARRAY_SIZE_after>> visitor_Expression_ARRAY_SIZE_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_ARRAY_SIZE_after>> visitor_Expression_ARRAY_SIZE_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_ARRAY_SIZE_after>> visitor_Expression_ARRAY_SIZE_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_ARRAY_SIZE_after>> visitor_Expression_ARRAY_SIZE_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_ARRAY_SIZE_after>> visitor_Expression_ARRAY_SIZE_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_ARRAY_SIZE_after(const Context_Expression_ARRAY_SIZE_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_AFTER == 0) {
                return visitor_Expression_ARRAY_SIZE_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_AFTER == 1) {
                return visitor_Expression_ARRAY_SIZE_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_AFTER == 2) {
                return visitor_Expression_ARRAY_SIZE_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_AFTER == 3) {
                return visitor_Expression_ARRAY_SIZE_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_AFTER == 4) {
                return visitor_Expression_ARRAY_SIZE_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_AFTER == 5) {
                return visitor_Expression_ARRAY_SIZE_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_AFTER == 6) {
                return visitor_Expression_ARRAY_SIZE_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ARRAY_SIZE_AFTER < 7, "No suitable visitor hook found for Expression_ARRAY_SIZE_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_ENUM_IS_DEFINED>> visitor_Expression_ENUM_IS_DEFINED_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_ENUM_IS_DEFINED>> visitor_Expression_ENUM_IS_DEFINED_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_ENUM_IS_DEFINED>> visitor_Expression_ENUM_IS_DEFINED_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_ENUM_IS_DEFINED>> visitor_Expression_ENUM_IS_DEFINED_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_ENUM_IS_DEFINED>> visitor_Expression_ENUM_IS_DEFINED_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_ENUM_IS_DEFINED>> visitor_Expression_ENUM_IS_DEFINED_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_ENUM_IS_DEFINED>> visitor_Expression_ENUM_IS_DEFINED_GeneratorDefaultHook;
        auto& get_visitor_Expression_ENUM_IS_DEFINED(const Context_Expression_ENUM_IS_DEFINED&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED == 0) {
                return visitor_Expression_ENUM_IS_DEFINED_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED == 1) {
                return visitor_Expression_ENUM_IS_DEFINED_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED == 2) {
                return visitor_Expression_ENUM_IS_DEFINED_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED == 3) {
                return visitor_Expression_ENUM_IS_DEFINED_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED == 4) {
                return visitor_Expression_ENUM_IS_DEFINED_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED == 5) {
                return visitor_Expression_ENUM_IS_DEFINED_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED == 6) {
                return visitor_Expression_ENUM_IS_DEFINED_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED < 7, "No suitable visitor hook found for Expression_ENUM_IS_DEFINED");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_ENUM_IS_DEFINED_before>> visitor_Expression_ENUM_IS_DEFINED_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_ENUM_IS_DEFINED_before>> visitor_Expression_ENUM_IS_DEFINED_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_ENUM_IS_DEFINED_before>> visitor_Expression_ENUM_IS_DEFINED_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_ENUM_IS_DEFINED_before>> visitor_Expression_ENUM_IS_DEFINED_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_ENUM_IS_DEFINED_before>> visitor_Expression_ENUM_IS_DEFINED_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_ENUM_IS_DEFINED_before>> visitor_Expression_ENUM_IS_DEFINED_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_ENUM_IS_DEFINED_before>> visitor_Expression_ENUM_IS_DEFINED_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_ENUM_IS_DEFINED_before(const Context_Expression_ENUM_IS_DEFINED_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_BEFORE == 0) {
                return visitor_Expression_ENUM_IS_DEFINED_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_BEFORE == 1) {
                return visitor_Expression_ENUM_IS_DEFINED_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_BEFORE == 2) {
                return visitor_Expression_ENUM_IS_DEFINED_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_BEFORE == 3) {
                return visitor_Expression_ENUM_IS_DEFINED_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_BEFORE == 4) {
                return visitor_Expression_ENUM_IS_DEFINED_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_BEFORE == 5) {
                return visitor_Expression_ENUM_IS_DEFINED_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_BEFORE == 6) {
                return visitor_Expression_ENUM_IS_DEFINED_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_BEFORE < 7, "No suitable visitor hook found for Expression_ENUM_IS_DEFINED_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_ENUM_IS_DEFINED_after>> visitor_Expression_ENUM_IS_DEFINED_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_ENUM_IS_DEFINED_after>> visitor_Expression_ENUM_IS_DEFINED_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_ENUM_IS_DEFINED_after>> visitor_Expression_ENUM_IS_DEFINED_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_ENUM_IS_DEFINED_after>> visitor_Expression_ENUM_IS_DEFINED_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_ENUM_IS_DEFINED_after>> visitor_Expression_ENUM_IS_DEFINED_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_ENUM_IS_DEFINED_after>> visitor_Expression_ENUM_IS_DEFINED_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_ENUM_IS_DEFINED_after>> visitor_Expression_ENUM_IS_DEFINED_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_ENUM_IS_DEFINED_after(const Context_Expression_ENUM_IS_DEFINED_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_AFTER == 0) {
                return visitor_Expression_ENUM_IS_DEFINED_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_AFTER == 1) {
                return visitor_Expression_ENUM_IS_DEFINED_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_AFTER == 2) {
                return visitor_Expression_ENUM_IS_DEFINED_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_AFTER == 3) {
                return visitor_Expression_ENUM_IS_DEFINED_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_AFTER == 4) {
                return visitor_Expression_ENUM_IS_DEFINED_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_AFTER == 5) {
                return visitor_Expression_ENUM_IS_DEFINED_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_AFTER == 6) {
                return visitor_Expression_ENUM_IS_DEFINED_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ENUM_IS_DEFINED_AFTER < 7, "No suitable visitor hook found for Expression_ENUM_IS_DEFINED_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_IS_ERROR>> visitor_Expression_IS_ERROR_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_IS_ERROR>> visitor_Expression_IS_ERROR_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_IS_ERROR>> visitor_Expression_IS_ERROR_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_IS_ERROR>> visitor_Expression_IS_ERROR_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_IS_ERROR>> visitor_Expression_IS_ERROR_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_IS_ERROR>> visitor_Expression_IS_ERROR_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_IS_ERROR>> visitor_Expression_IS_ERROR_GeneratorDefaultHook;
        auto& get_visitor_Expression_IS_ERROR(const Context_Expression_IS_ERROR&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR == 0) {
                return visitor_Expression_IS_ERROR_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR == 1) {
                return visitor_Expression_IS_ERROR_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR == 2) {
                return visitor_Expression_IS_ERROR_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR == 3) {
                return visitor_Expression_IS_ERROR_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR == 4) {
                return visitor_Expression_IS_ERROR_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR == 5) {
                return visitor_Expression_IS_ERROR_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR == 6) {
                return visitor_Expression_IS_ERROR_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR < 7, "No suitable visitor hook found for Expression_IS_ERROR");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_IS_ERROR_before>> visitor_Expression_IS_ERROR_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_IS_ERROR_before>> visitor_Expression_IS_ERROR_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_IS_ERROR_before>> visitor_Expression_IS_ERROR_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_IS_ERROR_before>> visitor_Expression_IS_ERROR_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_IS_ERROR_before>> visitor_Expression_IS_ERROR_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_IS_ERROR_before>> visitor_Expression_IS_ERROR_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_IS_ERROR_before>> visitor_Expression_IS_ERROR_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_IS_ERROR_before(const Context_Expression_IS_ERROR_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_BEFORE == 0) {
                return visitor_Expression_IS_ERROR_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_BEFORE == 1) {
                return visitor_Expression_IS_ERROR_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_BEFORE == 2) {
                return visitor_Expression_IS_ERROR_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_BEFORE == 3) {
                return visitor_Expression_IS_ERROR_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_BEFORE == 4) {
                return visitor_Expression_IS_ERROR_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_BEFORE == 5) {
                return visitor_Expression_IS_ERROR_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_BEFORE == 6) {
                return visitor_Expression_IS_ERROR_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_BEFORE < 7, "No suitable visitor hook found for Expression_IS_ERROR_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_IS_ERROR_after>> visitor_Expression_IS_ERROR_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_IS_ERROR_after>> visitor_Expression_IS_ERROR_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_IS_ERROR_after>> visitor_Expression_IS_ERROR_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_IS_ERROR_after>> visitor_Expression_IS_ERROR_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_IS_ERROR_after>> visitor_Expression_IS_ERROR_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_IS_ERROR_after>> visitor_Expression_IS_ERROR_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_IS_ERROR_after>> visitor_Expression_IS_ERROR_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_IS_ERROR_after(const Context_Expression_IS_ERROR_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_AFTER == 0) {
                return visitor_Expression_IS_ERROR_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_AFTER == 1) {
                return visitor_Expression_IS_ERROR_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_AFTER == 2) {
                return visitor_Expression_IS_ERROR_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_AFTER == 3) {
                return visitor_Expression_IS_ERROR_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_AFTER == 4) {
                return visitor_Expression_IS_ERROR_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_AFTER == 5) {
                return visitor_Expression_IS_ERROR_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_AFTER == 6) {
                return visitor_Expression_IS_ERROR_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_IS_ERROR_AFTER < 7, "No suitable visitor hook found for Expression_IS_ERROR_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_MAX_VALUE>> visitor_Expression_MAX_VALUE_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_MAX_VALUE>> visitor_Expression_MAX_VALUE_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_MAX_VALUE>> visitor_Expression_MAX_VALUE_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_MAX_VALUE>> visitor_Expression_MAX_VALUE_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_MAX_VALUE>> visitor_Expression_MAX_VALUE_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_MAX_VALUE>> visitor_Expression_MAX_VALUE_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_MAX_VALUE>> visitor_Expression_MAX_VALUE_GeneratorDefaultHook;
        auto& get_visitor_Expression_MAX_VALUE(const Context_Expression_MAX_VALUE&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE == 0) {
                return visitor_Expression_MAX_VALUE_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE == 1) {
                return visitor_Expression_MAX_VALUE_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE == 2) {
                return visitor_Expression_MAX_VALUE_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE == 3) {
                return visitor_Expression_MAX_VALUE_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE == 4) {
                return visitor_Expression_MAX_VALUE_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE == 5) {
                return visitor_Expression_MAX_VALUE_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE == 6) {
                return visitor_Expression_MAX_VALUE_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE < 7, "No suitable visitor hook found for Expression_MAX_VALUE");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_MAX_VALUE_before>> visitor_Expression_MAX_VALUE_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_MAX_VALUE_before>> visitor_Expression_MAX_VALUE_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_MAX_VALUE_before>> visitor_Expression_MAX_VALUE_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_MAX_VALUE_before>> visitor_Expression_MAX_VALUE_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_MAX_VALUE_before>> visitor_Expression_MAX_VALUE_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_MAX_VALUE_before>> visitor_Expression_MAX_VALUE_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_MAX_VALUE_before>> visitor_Expression_MAX_VALUE_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_MAX_VALUE_before(const Context_Expression_MAX_VALUE_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_BEFORE == 0) {
                return visitor_Expression_MAX_VALUE_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_BEFORE == 1) {
                return visitor_Expression_MAX_VALUE_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_BEFORE == 2) {
                return visitor_Expression_MAX_VALUE_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_BEFORE == 3) {
                return visitor_Expression_MAX_VALUE_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_BEFORE == 4) {
                return visitor_Expression_MAX_VALUE_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_BEFORE == 5) {
                return visitor_Expression_MAX_VALUE_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_BEFORE == 6) {
                return visitor_Expression_MAX_VALUE_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_BEFORE < 7, "No suitable visitor hook found for Expression_MAX_VALUE_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_MAX_VALUE_after>> visitor_Expression_MAX_VALUE_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_MAX_VALUE_after>> visitor_Expression_MAX_VALUE_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_MAX_VALUE_after>> visitor_Expression_MAX_VALUE_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_MAX_VALUE_after>> visitor_Expression_MAX_VALUE_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_MAX_VALUE_after>> visitor_Expression_MAX_VALUE_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_MAX_VALUE_after>> visitor_Expression_MAX_VALUE_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_MAX_VALUE_after>> visitor_Expression_MAX_VALUE_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_MAX_VALUE_after(const Context_Expression_MAX_VALUE_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_AFTER == 0) {
                return visitor_Expression_MAX_VALUE_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_AFTER == 1) {
                return visitor_Expression_MAX_VALUE_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_AFTER == 2) {
                return visitor_Expression_MAX_VALUE_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_AFTER == 3) {
                return visitor_Expression_MAX_VALUE_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_AFTER == 4) {
                return visitor_Expression_MAX_VALUE_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_AFTER == 5) {
                return visitor_Expression_MAX_VALUE_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_AFTER == 6) {
                return visitor_Expression_MAX_VALUE_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_MAX_VALUE_AFTER < 7, "No suitable visitor hook found for Expression_MAX_VALUE_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_READ_DATA>> visitor_Expression_READ_DATA_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_READ_DATA>> visitor_Expression_READ_DATA_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_READ_DATA>> visitor_Expression_READ_DATA_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_READ_DATA>> visitor_Expression_READ_DATA_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_READ_DATA>> visitor_Expression_READ_DATA_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_READ_DATA>> visitor_Expression_READ_DATA_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_READ_DATA>> visitor_Expression_READ_DATA_GeneratorDefaultHook;
        auto& get_visitor_Expression_READ_DATA(const Context_Expression_READ_DATA&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA == 0) {
                return visitor_Expression_READ_DATA_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA == 1) {
                return visitor_Expression_READ_DATA_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA == 2) {
                return visitor_Expression_READ_DATA_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA == 3) {
                return visitor_Expression_READ_DATA_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA == 4) {
                return visitor_Expression_READ_DATA_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA == 5) {
                return visitor_Expression_READ_DATA_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA == 6) {
                return visitor_Expression_READ_DATA_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA < 7, "No suitable visitor hook found for Expression_READ_DATA");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_READ_DATA_before>> visitor_Expression_READ_DATA_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_READ_DATA_before>> visitor_Expression_READ_DATA_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_READ_DATA_before>> visitor_Expression_READ_DATA_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_READ_DATA_before>> visitor_Expression_READ_DATA_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_READ_DATA_before>> visitor_Expression_READ_DATA_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_READ_DATA_before>> visitor_Expression_READ_DATA_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_READ_DATA_before>> visitor_Expression_READ_DATA_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_READ_DATA_before(const Context_Expression_READ_DATA_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_BEFORE == 0) {
                return visitor_Expression_READ_DATA_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_BEFORE == 1) {
                return visitor_Expression_READ_DATA_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_BEFORE == 2) {
                return visitor_Expression_READ_DATA_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_BEFORE == 3) {
                return visitor_Expression_READ_DATA_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_BEFORE == 4) {
                return visitor_Expression_READ_DATA_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_BEFORE == 5) {
                return visitor_Expression_READ_DATA_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_BEFORE == 6) {
                return visitor_Expression_READ_DATA_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_BEFORE < 7, "No suitable visitor hook found for Expression_READ_DATA_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_READ_DATA_after>> visitor_Expression_READ_DATA_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_READ_DATA_after>> visitor_Expression_READ_DATA_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_READ_DATA_after>> visitor_Expression_READ_DATA_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_READ_DATA_after>> visitor_Expression_READ_DATA_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_READ_DATA_after>> visitor_Expression_READ_DATA_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_READ_DATA_after>> visitor_Expression_READ_DATA_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_READ_DATA_after>> visitor_Expression_READ_DATA_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_READ_DATA_after(const Context_Expression_READ_DATA_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_AFTER == 0) {
                return visitor_Expression_READ_DATA_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_AFTER == 1) {
                return visitor_Expression_READ_DATA_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_AFTER == 2) {
                return visitor_Expression_READ_DATA_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_AFTER == 3) {
                return visitor_Expression_READ_DATA_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_AFTER == 4) {
                return visitor_Expression_READ_DATA_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_AFTER == 5) {
                return visitor_Expression_READ_DATA_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_AFTER == 6) {
                return visitor_Expression_READ_DATA_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_READ_DATA_AFTER < 7, "No suitable visitor hook found for Expression_READ_DATA_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_WRITE_DATA>> visitor_Expression_WRITE_DATA_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_WRITE_DATA>> visitor_Expression_WRITE_DATA_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_WRITE_DATA>> visitor_Expression_WRITE_DATA_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_WRITE_DATA>> visitor_Expression_WRITE_DATA_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_WRITE_DATA>> visitor_Expression_WRITE_DATA_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_WRITE_DATA>> visitor_Expression_WRITE_DATA_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_WRITE_DATA>> visitor_Expression_WRITE_DATA_GeneratorDefaultHook;
        auto& get_visitor_Expression_WRITE_DATA(const Context_Expression_WRITE_DATA&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA == 0) {
                return visitor_Expression_WRITE_DATA_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA == 1) {
                return visitor_Expression_WRITE_DATA_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA == 2) {
                return visitor_Expression_WRITE_DATA_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA == 3) {
                return visitor_Expression_WRITE_DATA_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA == 4) {
                return visitor_Expression_WRITE_DATA_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA == 5) {
                return visitor_Expression_WRITE_DATA_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA == 6) {
                return visitor_Expression_WRITE_DATA_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA < 7, "No suitable visitor hook found for Expression_WRITE_DATA");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_WRITE_DATA_before>> visitor_Expression_WRITE_DATA_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_WRITE_DATA_before>> visitor_Expression_WRITE_DATA_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_WRITE_DATA_before>> visitor_Expression_WRITE_DATA_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_WRITE_DATA_before>> visitor_Expression_WRITE_DATA_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_WRITE_DATA_before>> visitor_Expression_WRITE_DATA_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_WRITE_DATA_before>> visitor_Expression_WRITE_DATA_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_WRITE_DATA_before>> visitor_Expression_WRITE_DATA_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_WRITE_DATA_before(const Context_Expression_WRITE_DATA_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_BEFORE == 0) {
                return visitor_Expression_WRITE_DATA_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_BEFORE == 1) {
                return visitor_Expression_WRITE_DATA_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_BEFORE == 2) {
                return visitor_Expression_WRITE_DATA_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_BEFORE == 3) {
                return visitor_Expression_WRITE_DATA_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_BEFORE == 4) {
                return visitor_Expression_WRITE_DATA_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_BEFORE == 5) {
                return visitor_Expression_WRITE_DATA_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_BEFORE == 6) {
                return visitor_Expression_WRITE_DATA_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_BEFORE < 7, "No suitable visitor hook found for Expression_WRITE_DATA_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_WRITE_DATA_after>> visitor_Expression_WRITE_DATA_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_WRITE_DATA_after>> visitor_Expression_WRITE_DATA_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_WRITE_DATA_after>> visitor_Expression_WRITE_DATA_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_WRITE_DATA_after>> visitor_Expression_WRITE_DATA_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_WRITE_DATA_after>> visitor_Expression_WRITE_DATA_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_WRITE_DATA_after>> visitor_Expression_WRITE_DATA_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_WRITE_DATA_after>> visitor_Expression_WRITE_DATA_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_WRITE_DATA_after(const Context_Expression_WRITE_DATA_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_AFTER == 0) {
                return visitor_Expression_WRITE_DATA_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_AFTER == 1) {
                return visitor_Expression_WRITE_DATA_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_AFTER == 2) {
                return visitor_Expression_WRITE_DATA_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_AFTER == 3) {
                return visitor_Expression_WRITE_DATA_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_AFTER == 4) {
                return visitor_Expression_WRITE_DATA_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_AFTER == 5) {
                return visitor_Expression_WRITE_DATA_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_AFTER == 6) {
                return visitor_Expression_WRITE_DATA_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_WRITE_DATA_AFTER < 7, "No suitable visitor hook found for Expression_WRITE_DATA_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_CONDITIONAL_STATEMENT>> visitor_Expression_CONDITIONAL_STATEMENT_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_CONDITIONAL_STATEMENT>> visitor_Expression_CONDITIONAL_STATEMENT_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_CONDITIONAL_STATEMENT>> visitor_Expression_CONDITIONAL_STATEMENT_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_CONDITIONAL_STATEMENT>> visitor_Expression_CONDITIONAL_STATEMENT_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_CONDITIONAL_STATEMENT>> visitor_Expression_CONDITIONAL_STATEMENT_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_CONDITIONAL_STATEMENT>> visitor_Expression_CONDITIONAL_STATEMENT_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_CONDITIONAL_STATEMENT>> visitor_Expression_CONDITIONAL_STATEMENT_GeneratorDefaultHook;
        auto& get_visitor_Expression_CONDITIONAL_STATEMENT(const Context_Expression_CONDITIONAL_STATEMENT&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT == 0) {
                return visitor_Expression_CONDITIONAL_STATEMENT_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT == 1) {
                return visitor_Expression_CONDITIONAL_STATEMENT_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT == 2) {
                return visitor_Expression_CONDITIONAL_STATEMENT_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT == 3) {
                return visitor_Expression_CONDITIONAL_STATEMENT_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT == 4) {
                return visitor_Expression_CONDITIONAL_STATEMENT_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT == 5) {
                return visitor_Expression_CONDITIONAL_STATEMENT_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT == 6) {
                return visitor_Expression_CONDITIONAL_STATEMENT_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT < 7, "No suitable visitor hook found for Expression_CONDITIONAL_STATEMENT");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_CONDITIONAL_STATEMENT_before>> visitor_Expression_CONDITIONAL_STATEMENT_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_CONDITIONAL_STATEMENT_before>> visitor_Expression_CONDITIONAL_STATEMENT_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_CONDITIONAL_STATEMENT_before>> visitor_Expression_CONDITIONAL_STATEMENT_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_CONDITIONAL_STATEMENT_before>> visitor_Expression_CONDITIONAL_STATEMENT_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_CONDITIONAL_STATEMENT_before>> visitor_Expression_CONDITIONAL_STATEMENT_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_CONDITIONAL_STATEMENT_before>> visitor_Expression_CONDITIONAL_STATEMENT_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_CONDITIONAL_STATEMENT_before>> visitor_Expression_CONDITIONAL_STATEMENT_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_CONDITIONAL_STATEMENT_before(const Context_Expression_CONDITIONAL_STATEMENT_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE == 0) {
                return visitor_Expression_CONDITIONAL_STATEMENT_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE == 1) {
                return visitor_Expression_CONDITIONAL_STATEMENT_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE == 2) {
                return visitor_Expression_CONDITIONAL_STATEMENT_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE == 3) {
                return visitor_Expression_CONDITIONAL_STATEMENT_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE == 4) {
                return visitor_Expression_CONDITIONAL_STATEMENT_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE == 5) {
                return visitor_Expression_CONDITIONAL_STATEMENT_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE == 6) {
                return visitor_Expression_CONDITIONAL_STATEMENT_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE < 7, "No suitable visitor hook found for Expression_CONDITIONAL_STATEMENT_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_CONDITIONAL_STATEMENT_after>> visitor_Expression_CONDITIONAL_STATEMENT_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_CONDITIONAL_STATEMENT_after>> visitor_Expression_CONDITIONAL_STATEMENT_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_CONDITIONAL_STATEMENT_after>> visitor_Expression_CONDITIONAL_STATEMENT_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_CONDITIONAL_STATEMENT_after>> visitor_Expression_CONDITIONAL_STATEMENT_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_CONDITIONAL_STATEMENT_after>> visitor_Expression_CONDITIONAL_STATEMENT_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_CONDITIONAL_STATEMENT_after>> visitor_Expression_CONDITIONAL_STATEMENT_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_CONDITIONAL_STATEMENT_after>> visitor_Expression_CONDITIONAL_STATEMENT_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_CONDITIONAL_STATEMENT_after(const Context_Expression_CONDITIONAL_STATEMENT_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_AFTER == 0) {
                return visitor_Expression_CONDITIONAL_STATEMENT_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_AFTER == 1) {
                return visitor_Expression_CONDITIONAL_STATEMENT_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_AFTER == 2) {
                return visitor_Expression_CONDITIONAL_STATEMENT_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_AFTER == 3) {
                return visitor_Expression_CONDITIONAL_STATEMENT_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_AFTER == 4) {
                return visitor_Expression_CONDITIONAL_STATEMENT_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_AFTER == 5) {
                return visitor_Expression_CONDITIONAL_STATEMENT_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_AFTER == 6) {
                return visitor_Expression_CONDITIONAL_STATEMENT_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_STATEMENT_AFTER < 7, "No suitable visitor hook found for Expression_CONDITIONAL_STATEMENT_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_CONDITIONAL>> visitor_Expression_CONDITIONAL_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_CONDITIONAL>> visitor_Expression_CONDITIONAL_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_CONDITIONAL>> visitor_Expression_CONDITIONAL_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_CONDITIONAL>> visitor_Expression_CONDITIONAL_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_CONDITIONAL>> visitor_Expression_CONDITIONAL_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_CONDITIONAL>> visitor_Expression_CONDITIONAL_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_CONDITIONAL>> visitor_Expression_CONDITIONAL_GeneratorDefaultHook;
        auto& get_visitor_Expression_CONDITIONAL(const Context_Expression_CONDITIONAL&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL == 0) {
                return visitor_Expression_CONDITIONAL_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL == 1) {
                return visitor_Expression_CONDITIONAL_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL == 2) {
                return visitor_Expression_CONDITIONAL_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL == 3) {
                return visitor_Expression_CONDITIONAL_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL == 4) {
                return visitor_Expression_CONDITIONAL_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL == 5) {
                return visitor_Expression_CONDITIONAL_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL == 6) {
                return visitor_Expression_CONDITIONAL_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL < 7, "No suitable visitor hook found for Expression_CONDITIONAL");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_CONDITIONAL_before>> visitor_Expression_CONDITIONAL_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_CONDITIONAL_before>> visitor_Expression_CONDITIONAL_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_CONDITIONAL_before>> visitor_Expression_CONDITIONAL_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_CONDITIONAL_before>> visitor_Expression_CONDITIONAL_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_CONDITIONAL_before>> visitor_Expression_CONDITIONAL_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_CONDITIONAL_before>> visitor_Expression_CONDITIONAL_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_CONDITIONAL_before>> visitor_Expression_CONDITIONAL_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_CONDITIONAL_before(const Context_Expression_CONDITIONAL_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_BEFORE == 0) {
                return visitor_Expression_CONDITIONAL_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_BEFORE == 1) {
                return visitor_Expression_CONDITIONAL_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_BEFORE == 2) {
                return visitor_Expression_CONDITIONAL_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_BEFORE == 3) {
                return visitor_Expression_CONDITIONAL_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_BEFORE == 4) {
                return visitor_Expression_CONDITIONAL_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_BEFORE == 5) {
                return visitor_Expression_CONDITIONAL_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_BEFORE == 6) {
                return visitor_Expression_CONDITIONAL_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_BEFORE < 7, "No suitable visitor hook found for Expression_CONDITIONAL_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_CONDITIONAL_after>> visitor_Expression_CONDITIONAL_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_CONDITIONAL_after>> visitor_Expression_CONDITIONAL_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_CONDITIONAL_after>> visitor_Expression_CONDITIONAL_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_CONDITIONAL_after>> visitor_Expression_CONDITIONAL_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_CONDITIONAL_after>> visitor_Expression_CONDITIONAL_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_CONDITIONAL_after>> visitor_Expression_CONDITIONAL_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_CONDITIONAL_after>> visitor_Expression_CONDITIONAL_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_CONDITIONAL_after(const Context_Expression_CONDITIONAL_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_AFTER == 0) {
                return visitor_Expression_CONDITIONAL_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_AFTER == 1) {
                return visitor_Expression_CONDITIONAL_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_AFTER == 2) {
                return visitor_Expression_CONDITIONAL_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_AFTER == 3) {
                return visitor_Expression_CONDITIONAL_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_AFTER == 4) {
                return visitor_Expression_CONDITIONAL_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_AFTER == 5) {
                return visitor_Expression_CONDITIONAL_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_AFTER == 6) {
                return visitor_Expression_CONDITIONAL_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_CONDITIONAL_AFTER < 7, "No suitable visitor hook found for Expression_CONDITIONAL_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_AVAILABLE>> visitor_Expression_AVAILABLE_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_AVAILABLE>> visitor_Expression_AVAILABLE_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_AVAILABLE>> visitor_Expression_AVAILABLE_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_AVAILABLE>> visitor_Expression_AVAILABLE_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_AVAILABLE>> visitor_Expression_AVAILABLE_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_AVAILABLE>> visitor_Expression_AVAILABLE_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_AVAILABLE>> visitor_Expression_AVAILABLE_GeneratorDefaultHook;
        auto& get_visitor_Expression_AVAILABLE(const Context_Expression_AVAILABLE&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE == 0) {
                return visitor_Expression_AVAILABLE_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE == 1) {
                return visitor_Expression_AVAILABLE_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE == 2) {
                return visitor_Expression_AVAILABLE_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE == 3) {
                return visitor_Expression_AVAILABLE_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE == 4) {
                return visitor_Expression_AVAILABLE_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE == 5) {
                return visitor_Expression_AVAILABLE_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE == 6) {
                return visitor_Expression_AVAILABLE_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE < 7, "No suitable visitor hook found for Expression_AVAILABLE");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_AVAILABLE_before>> visitor_Expression_AVAILABLE_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_AVAILABLE_before>> visitor_Expression_AVAILABLE_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_AVAILABLE_before>> visitor_Expression_AVAILABLE_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_AVAILABLE_before>> visitor_Expression_AVAILABLE_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_AVAILABLE_before>> visitor_Expression_AVAILABLE_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_AVAILABLE_before>> visitor_Expression_AVAILABLE_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_AVAILABLE_before>> visitor_Expression_AVAILABLE_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_AVAILABLE_before(const Context_Expression_AVAILABLE_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_BEFORE == 0) {
                return visitor_Expression_AVAILABLE_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_BEFORE == 1) {
                return visitor_Expression_AVAILABLE_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_BEFORE == 2) {
                return visitor_Expression_AVAILABLE_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_BEFORE == 3) {
                return visitor_Expression_AVAILABLE_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_BEFORE == 4) {
                return visitor_Expression_AVAILABLE_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_BEFORE == 5) {
                return visitor_Expression_AVAILABLE_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_BEFORE == 6) {
                return visitor_Expression_AVAILABLE_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_BEFORE < 7, "No suitable visitor hook found for Expression_AVAILABLE_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_AVAILABLE_after>> visitor_Expression_AVAILABLE_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_AVAILABLE_after>> visitor_Expression_AVAILABLE_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_AVAILABLE_after>> visitor_Expression_AVAILABLE_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_AVAILABLE_after>> visitor_Expression_AVAILABLE_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_AVAILABLE_after>> visitor_Expression_AVAILABLE_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_AVAILABLE_after>> visitor_Expression_AVAILABLE_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_AVAILABLE_after>> visitor_Expression_AVAILABLE_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_AVAILABLE_after(const Context_Expression_AVAILABLE_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_AFTER == 0) {
                return visitor_Expression_AVAILABLE_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_AFTER == 1) {
                return visitor_Expression_AVAILABLE_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_AFTER == 2) {
                return visitor_Expression_AVAILABLE_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_AFTER == 3) {
                return visitor_Expression_AVAILABLE_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_AFTER == 4) {
                return visitor_Expression_AVAILABLE_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_AFTER == 5) {
                return visitor_Expression_AVAILABLE_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_AFTER == 6) {
                return visitor_Expression_AVAILABLE_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AVAILABLE_AFTER < 7, "No suitable visitor hook found for Expression_AVAILABLE_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_SIZEOF>> visitor_Expression_SIZEOF_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_SIZEOF>> visitor_Expression_SIZEOF_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_SIZEOF>> visitor_Expression_SIZEOF_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_SIZEOF>> visitor_Expression_SIZEOF_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_SIZEOF>> visitor_Expression_SIZEOF_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_SIZEOF>> visitor_Expression_SIZEOF_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_SIZEOF>> visitor_Expression_SIZEOF_GeneratorDefaultHook;
        auto& get_visitor_Expression_SIZEOF(const Context_Expression_SIZEOF&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF == 0) {
                return visitor_Expression_SIZEOF_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF == 1) {
                return visitor_Expression_SIZEOF_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF == 2) {
                return visitor_Expression_SIZEOF_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF == 3) {
                return visitor_Expression_SIZEOF_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF == 4) {
                return visitor_Expression_SIZEOF_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF == 5) {
                return visitor_Expression_SIZEOF_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF == 6) {
                return visitor_Expression_SIZEOF_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF < 7, "No suitable visitor hook found for Expression_SIZEOF");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_SIZEOF_before>> visitor_Expression_SIZEOF_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_SIZEOF_before>> visitor_Expression_SIZEOF_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_SIZEOF_before>> visitor_Expression_SIZEOF_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_SIZEOF_before>> visitor_Expression_SIZEOF_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_SIZEOF_before>> visitor_Expression_SIZEOF_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_SIZEOF_before>> visitor_Expression_SIZEOF_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_SIZEOF_before>> visitor_Expression_SIZEOF_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_SIZEOF_before(const Context_Expression_SIZEOF_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_BEFORE == 0) {
                return visitor_Expression_SIZEOF_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_BEFORE == 1) {
                return visitor_Expression_SIZEOF_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_BEFORE == 2) {
                return visitor_Expression_SIZEOF_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_BEFORE == 3) {
                return visitor_Expression_SIZEOF_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_BEFORE == 4) {
                return visitor_Expression_SIZEOF_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_BEFORE == 5) {
                return visitor_Expression_SIZEOF_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_BEFORE == 6) {
                return visitor_Expression_SIZEOF_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_BEFORE < 7, "No suitable visitor hook found for Expression_SIZEOF_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_SIZEOF_after>> visitor_Expression_SIZEOF_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_SIZEOF_after>> visitor_Expression_SIZEOF_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_SIZEOF_after>> visitor_Expression_SIZEOF_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_SIZEOF_after>> visitor_Expression_SIZEOF_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_SIZEOF_after>> visitor_Expression_SIZEOF_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_SIZEOF_after>> visitor_Expression_SIZEOF_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_SIZEOF_after>> visitor_Expression_SIZEOF_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_SIZEOF_after(const Context_Expression_SIZEOF_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_AFTER == 0) {
                return visitor_Expression_SIZEOF_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_AFTER == 1) {
                return visitor_Expression_SIZEOF_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_AFTER == 2) {
                return visitor_Expression_SIZEOF_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_AFTER == 3) {
                return visitor_Expression_SIZEOF_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_AFTER == 4) {
                return visitor_Expression_SIZEOF_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_AFTER == 5) {
                return visitor_Expression_SIZEOF_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_AFTER == 6) {
                return visitor_Expression_SIZEOF_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SIZEOF_AFTER < 7, "No suitable visitor hook found for Expression_SIZEOF_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_SUB_RANGE_INIT>> visitor_Expression_SUB_RANGE_INIT_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_SUB_RANGE_INIT>> visitor_Expression_SUB_RANGE_INIT_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_SUB_RANGE_INIT>> visitor_Expression_SUB_RANGE_INIT_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_SUB_RANGE_INIT>> visitor_Expression_SUB_RANGE_INIT_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_SUB_RANGE_INIT>> visitor_Expression_SUB_RANGE_INIT_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_SUB_RANGE_INIT>> visitor_Expression_SUB_RANGE_INIT_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_SUB_RANGE_INIT>> visitor_Expression_SUB_RANGE_INIT_GeneratorDefaultHook;
        auto& get_visitor_Expression_SUB_RANGE_INIT(const Context_Expression_SUB_RANGE_INIT&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT == 0) {
                return visitor_Expression_SUB_RANGE_INIT_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT == 1) {
                return visitor_Expression_SUB_RANGE_INIT_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT == 2) {
                return visitor_Expression_SUB_RANGE_INIT_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT == 3) {
                return visitor_Expression_SUB_RANGE_INIT_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT == 4) {
                return visitor_Expression_SUB_RANGE_INIT_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT == 5) {
                return visitor_Expression_SUB_RANGE_INIT_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT == 6) {
                return visitor_Expression_SUB_RANGE_INIT_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT < 7, "No suitable visitor hook found for Expression_SUB_RANGE_INIT");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_SUB_RANGE_INIT_before>> visitor_Expression_SUB_RANGE_INIT_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_SUB_RANGE_INIT_before>> visitor_Expression_SUB_RANGE_INIT_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_SUB_RANGE_INIT_before>> visitor_Expression_SUB_RANGE_INIT_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_SUB_RANGE_INIT_before>> visitor_Expression_SUB_RANGE_INIT_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_SUB_RANGE_INIT_before>> visitor_Expression_SUB_RANGE_INIT_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_SUB_RANGE_INIT_before>> visitor_Expression_SUB_RANGE_INIT_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_SUB_RANGE_INIT_before>> visitor_Expression_SUB_RANGE_INIT_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_SUB_RANGE_INIT_before(const Context_Expression_SUB_RANGE_INIT_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_BEFORE == 0) {
                return visitor_Expression_SUB_RANGE_INIT_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_BEFORE == 1) {
                return visitor_Expression_SUB_RANGE_INIT_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_BEFORE == 2) {
                return visitor_Expression_SUB_RANGE_INIT_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_BEFORE == 3) {
                return visitor_Expression_SUB_RANGE_INIT_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_BEFORE == 4) {
                return visitor_Expression_SUB_RANGE_INIT_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_BEFORE == 5) {
                return visitor_Expression_SUB_RANGE_INIT_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_BEFORE == 6) {
                return visitor_Expression_SUB_RANGE_INIT_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_BEFORE < 7, "No suitable visitor hook found for Expression_SUB_RANGE_INIT_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_SUB_RANGE_INIT_after>> visitor_Expression_SUB_RANGE_INIT_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_SUB_RANGE_INIT_after>> visitor_Expression_SUB_RANGE_INIT_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_SUB_RANGE_INIT_after>> visitor_Expression_SUB_RANGE_INIT_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_SUB_RANGE_INIT_after>> visitor_Expression_SUB_RANGE_INIT_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_SUB_RANGE_INIT_after>> visitor_Expression_SUB_RANGE_INIT_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_SUB_RANGE_INIT_after>> visitor_Expression_SUB_RANGE_INIT_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_SUB_RANGE_INIT_after>> visitor_Expression_SUB_RANGE_INIT_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_SUB_RANGE_INIT_after(const Context_Expression_SUB_RANGE_INIT_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_AFTER == 0) {
                return visitor_Expression_SUB_RANGE_INIT_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_AFTER == 1) {
                return visitor_Expression_SUB_RANGE_INIT_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_AFTER == 2) {
                return visitor_Expression_SUB_RANGE_INIT_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_AFTER == 3) {
                return visitor_Expression_SUB_RANGE_INIT_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_AFTER == 4) {
                return visitor_Expression_SUB_RANGE_INIT_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_AFTER == 5) {
                return visitor_Expression_SUB_RANGE_INIT_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_AFTER == 6) {
                return visitor_Expression_SUB_RANGE_INIT_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SUB_RANGE_INIT_AFTER < 7, "No suitable visitor hook found for Expression_SUB_RANGE_INIT_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_OR_COND>> visitor_Expression_OR_COND_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_OR_COND>> visitor_Expression_OR_COND_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_OR_COND>> visitor_Expression_OR_COND_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_OR_COND>> visitor_Expression_OR_COND_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_OR_COND>> visitor_Expression_OR_COND_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_OR_COND>> visitor_Expression_OR_COND_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_OR_COND>> visitor_Expression_OR_COND_GeneratorDefaultHook;
        auto& get_visitor_Expression_OR_COND(const Context_Expression_OR_COND&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND == 0) {
                return visitor_Expression_OR_COND_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND == 1) {
                return visitor_Expression_OR_COND_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND == 2) {
                return visitor_Expression_OR_COND_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND == 3) {
                return visitor_Expression_OR_COND_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND == 4) {
                return visitor_Expression_OR_COND_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND == 5) {
                return visitor_Expression_OR_COND_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND == 6) {
                return visitor_Expression_OR_COND_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND < 7, "No suitable visitor hook found for Expression_OR_COND");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_OR_COND_before>> visitor_Expression_OR_COND_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_OR_COND_before>> visitor_Expression_OR_COND_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_OR_COND_before>> visitor_Expression_OR_COND_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_OR_COND_before>> visitor_Expression_OR_COND_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_OR_COND_before>> visitor_Expression_OR_COND_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_OR_COND_before>> visitor_Expression_OR_COND_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_OR_COND_before>> visitor_Expression_OR_COND_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_OR_COND_before(const Context_Expression_OR_COND_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_BEFORE == 0) {
                return visitor_Expression_OR_COND_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_BEFORE == 1) {
                return visitor_Expression_OR_COND_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_BEFORE == 2) {
                return visitor_Expression_OR_COND_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_BEFORE == 3) {
                return visitor_Expression_OR_COND_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_BEFORE == 4) {
                return visitor_Expression_OR_COND_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_BEFORE == 5) {
                return visitor_Expression_OR_COND_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_BEFORE == 6) {
                return visitor_Expression_OR_COND_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_BEFORE < 7, "No suitable visitor hook found for Expression_OR_COND_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_OR_COND_after>> visitor_Expression_OR_COND_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_OR_COND_after>> visitor_Expression_OR_COND_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_OR_COND_after>> visitor_Expression_OR_COND_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_OR_COND_after>> visitor_Expression_OR_COND_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_OR_COND_after>> visitor_Expression_OR_COND_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_OR_COND_after>> visitor_Expression_OR_COND_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_OR_COND_after>> visitor_Expression_OR_COND_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_OR_COND_after(const Context_Expression_OR_COND_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_AFTER == 0) {
                return visitor_Expression_OR_COND_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_AFTER == 1) {
                return visitor_Expression_OR_COND_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_AFTER == 2) {
                return visitor_Expression_OR_COND_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_AFTER == 3) {
                return visitor_Expression_OR_COND_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_AFTER == 4) {
                return visitor_Expression_OR_COND_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_AFTER == 5) {
                return visitor_Expression_OR_COND_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_AFTER == 6) {
                return visitor_Expression_OR_COND_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OR_COND_AFTER < 7, "No suitable visitor hook found for Expression_OR_COND_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_ADDRESS_OF>> visitor_Expression_ADDRESS_OF_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_ADDRESS_OF>> visitor_Expression_ADDRESS_OF_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_ADDRESS_OF>> visitor_Expression_ADDRESS_OF_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_ADDRESS_OF>> visitor_Expression_ADDRESS_OF_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_ADDRESS_OF>> visitor_Expression_ADDRESS_OF_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_ADDRESS_OF>> visitor_Expression_ADDRESS_OF_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_ADDRESS_OF>> visitor_Expression_ADDRESS_OF_GeneratorDefaultHook;
        auto& get_visitor_Expression_ADDRESS_OF(const Context_Expression_ADDRESS_OF&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF == 0) {
                return visitor_Expression_ADDRESS_OF_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF == 1) {
                return visitor_Expression_ADDRESS_OF_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF == 2) {
                return visitor_Expression_ADDRESS_OF_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF == 3) {
                return visitor_Expression_ADDRESS_OF_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF == 4) {
                return visitor_Expression_ADDRESS_OF_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF == 5) {
                return visitor_Expression_ADDRESS_OF_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF == 6) {
                return visitor_Expression_ADDRESS_OF_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF < 7, "No suitable visitor hook found for Expression_ADDRESS_OF");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_ADDRESS_OF_before>> visitor_Expression_ADDRESS_OF_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_ADDRESS_OF_before>> visitor_Expression_ADDRESS_OF_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_ADDRESS_OF_before>> visitor_Expression_ADDRESS_OF_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_ADDRESS_OF_before>> visitor_Expression_ADDRESS_OF_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_ADDRESS_OF_before>> visitor_Expression_ADDRESS_OF_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_ADDRESS_OF_before>> visitor_Expression_ADDRESS_OF_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_ADDRESS_OF_before>> visitor_Expression_ADDRESS_OF_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_ADDRESS_OF_before(const Context_Expression_ADDRESS_OF_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_BEFORE == 0) {
                return visitor_Expression_ADDRESS_OF_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_BEFORE == 1) {
                return visitor_Expression_ADDRESS_OF_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_BEFORE == 2) {
                return visitor_Expression_ADDRESS_OF_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_BEFORE == 3) {
                return visitor_Expression_ADDRESS_OF_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_BEFORE == 4) {
                return visitor_Expression_ADDRESS_OF_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_BEFORE == 5) {
                return visitor_Expression_ADDRESS_OF_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_BEFORE == 6) {
                return visitor_Expression_ADDRESS_OF_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_BEFORE < 7, "No suitable visitor hook found for Expression_ADDRESS_OF_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_ADDRESS_OF_after>> visitor_Expression_ADDRESS_OF_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_ADDRESS_OF_after>> visitor_Expression_ADDRESS_OF_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_ADDRESS_OF_after>> visitor_Expression_ADDRESS_OF_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_ADDRESS_OF_after>> visitor_Expression_ADDRESS_OF_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_ADDRESS_OF_after>> visitor_Expression_ADDRESS_OF_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_ADDRESS_OF_after>> visitor_Expression_ADDRESS_OF_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_ADDRESS_OF_after>> visitor_Expression_ADDRESS_OF_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_ADDRESS_OF_after(const Context_Expression_ADDRESS_OF_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_AFTER == 0) {
                return visitor_Expression_ADDRESS_OF_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_AFTER == 1) {
                return visitor_Expression_ADDRESS_OF_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_AFTER == 2) {
                return visitor_Expression_ADDRESS_OF_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_AFTER == 3) {
                return visitor_Expression_ADDRESS_OF_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_AFTER == 4) {
                return visitor_Expression_ADDRESS_OF_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_AFTER == 5) {
                return visitor_Expression_ADDRESS_OF_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_AFTER == 6) {
                return visitor_Expression_ADDRESS_OF_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_ADDRESS_OF_AFTER < 7, "No suitable visitor hook found for Expression_ADDRESS_OF_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_OPTIONAL_OF>> visitor_Expression_OPTIONAL_OF_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_OPTIONAL_OF>> visitor_Expression_OPTIONAL_OF_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_OPTIONAL_OF>> visitor_Expression_OPTIONAL_OF_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_OPTIONAL_OF>> visitor_Expression_OPTIONAL_OF_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_OPTIONAL_OF>> visitor_Expression_OPTIONAL_OF_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_OPTIONAL_OF>> visitor_Expression_OPTIONAL_OF_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_OPTIONAL_OF>> visitor_Expression_OPTIONAL_OF_GeneratorDefaultHook;
        auto& get_visitor_Expression_OPTIONAL_OF(const Context_Expression_OPTIONAL_OF&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF == 0) {
                return visitor_Expression_OPTIONAL_OF_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF == 1) {
                return visitor_Expression_OPTIONAL_OF_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF == 2) {
                return visitor_Expression_OPTIONAL_OF_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF == 3) {
                return visitor_Expression_OPTIONAL_OF_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF == 4) {
                return visitor_Expression_OPTIONAL_OF_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF == 5) {
                return visitor_Expression_OPTIONAL_OF_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF == 6) {
                return visitor_Expression_OPTIONAL_OF_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF < 7, "No suitable visitor hook found for Expression_OPTIONAL_OF");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_OPTIONAL_OF_before>> visitor_Expression_OPTIONAL_OF_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_OPTIONAL_OF_before>> visitor_Expression_OPTIONAL_OF_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_OPTIONAL_OF_before>> visitor_Expression_OPTIONAL_OF_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_OPTIONAL_OF_before>> visitor_Expression_OPTIONAL_OF_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_OPTIONAL_OF_before>> visitor_Expression_OPTIONAL_OF_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_OPTIONAL_OF_before>> visitor_Expression_OPTIONAL_OF_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_OPTIONAL_OF_before>> visitor_Expression_OPTIONAL_OF_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_OPTIONAL_OF_before(const Context_Expression_OPTIONAL_OF_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_BEFORE == 0) {
                return visitor_Expression_OPTIONAL_OF_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_BEFORE == 1) {
                return visitor_Expression_OPTIONAL_OF_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_BEFORE == 2) {
                return visitor_Expression_OPTIONAL_OF_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_BEFORE == 3) {
                return visitor_Expression_OPTIONAL_OF_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_BEFORE == 4) {
                return visitor_Expression_OPTIONAL_OF_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_BEFORE == 5) {
                return visitor_Expression_OPTIONAL_OF_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_BEFORE == 6) {
                return visitor_Expression_OPTIONAL_OF_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_BEFORE < 7, "No suitable visitor hook found for Expression_OPTIONAL_OF_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_OPTIONAL_OF_after>> visitor_Expression_OPTIONAL_OF_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_OPTIONAL_OF_after>> visitor_Expression_OPTIONAL_OF_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_OPTIONAL_OF_after>> visitor_Expression_OPTIONAL_OF_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_OPTIONAL_OF_after>> visitor_Expression_OPTIONAL_OF_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_OPTIONAL_OF_after>> visitor_Expression_OPTIONAL_OF_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_OPTIONAL_OF_after>> visitor_Expression_OPTIONAL_OF_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_OPTIONAL_OF_after>> visitor_Expression_OPTIONAL_OF_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_OPTIONAL_OF_after(const Context_Expression_OPTIONAL_OF_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_AFTER == 0) {
                return visitor_Expression_OPTIONAL_OF_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_AFTER == 1) {
                return visitor_Expression_OPTIONAL_OF_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_AFTER == 2) {
                return visitor_Expression_OPTIONAL_OF_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_AFTER == 3) {
                return visitor_Expression_OPTIONAL_OF_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_AFTER == 4) {
                return visitor_Expression_OPTIONAL_OF_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_AFTER == 5) {
                return visitor_Expression_OPTIONAL_OF_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_AFTER == 6) {
                return visitor_Expression_OPTIONAL_OF_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_OPTIONAL_OF_AFTER < 7, "No suitable visitor hook found for Expression_OPTIONAL_OF_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_SETTER_STATUS>> visitor_Expression_SETTER_STATUS_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_SETTER_STATUS>> visitor_Expression_SETTER_STATUS_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_SETTER_STATUS>> visitor_Expression_SETTER_STATUS_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_SETTER_STATUS>> visitor_Expression_SETTER_STATUS_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_SETTER_STATUS>> visitor_Expression_SETTER_STATUS_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_SETTER_STATUS>> visitor_Expression_SETTER_STATUS_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_SETTER_STATUS>> visitor_Expression_SETTER_STATUS_GeneratorDefaultHook;
        auto& get_visitor_Expression_SETTER_STATUS(const Context_Expression_SETTER_STATUS&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS == 0) {
                return visitor_Expression_SETTER_STATUS_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS == 1) {
                return visitor_Expression_SETTER_STATUS_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS == 2) {
                return visitor_Expression_SETTER_STATUS_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS == 3) {
                return visitor_Expression_SETTER_STATUS_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS == 4) {
                return visitor_Expression_SETTER_STATUS_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS == 5) {
                return visitor_Expression_SETTER_STATUS_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS == 6) {
                return visitor_Expression_SETTER_STATUS_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS < 7, "No suitable visitor hook found for Expression_SETTER_STATUS");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_SETTER_STATUS_before>> visitor_Expression_SETTER_STATUS_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_SETTER_STATUS_before>> visitor_Expression_SETTER_STATUS_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_SETTER_STATUS_before>> visitor_Expression_SETTER_STATUS_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_SETTER_STATUS_before>> visitor_Expression_SETTER_STATUS_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_SETTER_STATUS_before>> visitor_Expression_SETTER_STATUS_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_SETTER_STATUS_before>> visitor_Expression_SETTER_STATUS_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_SETTER_STATUS_before>> visitor_Expression_SETTER_STATUS_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_SETTER_STATUS_before(const Context_Expression_SETTER_STATUS_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_BEFORE == 0) {
                return visitor_Expression_SETTER_STATUS_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_BEFORE == 1) {
                return visitor_Expression_SETTER_STATUS_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_BEFORE == 2) {
                return visitor_Expression_SETTER_STATUS_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_BEFORE == 3) {
                return visitor_Expression_SETTER_STATUS_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_BEFORE == 4) {
                return visitor_Expression_SETTER_STATUS_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_BEFORE == 5) {
                return visitor_Expression_SETTER_STATUS_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_BEFORE == 6) {
                return visitor_Expression_SETTER_STATUS_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_BEFORE < 7, "No suitable visitor hook found for Expression_SETTER_STATUS_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_SETTER_STATUS_after>> visitor_Expression_SETTER_STATUS_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_SETTER_STATUS_after>> visitor_Expression_SETTER_STATUS_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_SETTER_STATUS_after>> visitor_Expression_SETTER_STATUS_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_SETTER_STATUS_after>> visitor_Expression_SETTER_STATUS_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_SETTER_STATUS_after>> visitor_Expression_SETTER_STATUS_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_SETTER_STATUS_after>> visitor_Expression_SETTER_STATUS_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_SETTER_STATUS_after>> visitor_Expression_SETTER_STATUS_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_SETTER_STATUS_after(const Context_Expression_SETTER_STATUS_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_AFTER == 0) {
                return visitor_Expression_SETTER_STATUS_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_AFTER == 1) {
                return visitor_Expression_SETTER_STATUS_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_AFTER == 2) {
                return visitor_Expression_SETTER_STATUS_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_AFTER == 3) {
                return visitor_Expression_SETTER_STATUS_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_AFTER == 4) {
                return visitor_Expression_SETTER_STATUS_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_AFTER == 5) {
                return visitor_Expression_SETTER_STATUS_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_AFTER == 6) {
                return visitor_Expression_SETTER_STATUS_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SETTER_STATUS_AFTER < 7, "No suitable visitor hook found for Expression_SETTER_STATUS_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_SELF>> visitor_Expression_SELF_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_SELF>> visitor_Expression_SELF_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_SELF>> visitor_Expression_SELF_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_SELF>> visitor_Expression_SELF_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_SELF>> visitor_Expression_SELF_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_SELF>> visitor_Expression_SELF_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_SELF>> visitor_Expression_SELF_GeneratorDefaultHook;
        auto& get_visitor_Expression_SELF(const Context_Expression_SELF&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF == 0) {
                return visitor_Expression_SELF_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF == 1) {
                return visitor_Expression_SELF_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF == 2) {
                return visitor_Expression_SELF_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF == 3) {
                return visitor_Expression_SELF_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF == 4) {
                return visitor_Expression_SELF_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF == 5) {
                return visitor_Expression_SELF_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF == 6) {
                return visitor_Expression_SELF_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF < 7, "No suitable visitor hook found for Expression_SELF");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_SELF_before>> visitor_Expression_SELF_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_SELF_before>> visitor_Expression_SELF_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_SELF_before>> visitor_Expression_SELF_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_SELF_before>> visitor_Expression_SELF_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_SELF_before>> visitor_Expression_SELF_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_SELF_before>> visitor_Expression_SELF_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_SELF_before>> visitor_Expression_SELF_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_SELF_before(const Context_Expression_SELF_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_BEFORE == 0) {
                return visitor_Expression_SELF_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_BEFORE == 1) {
                return visitor_Expression_SELF_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_BEFORE == 2) {
                return visitor_Expression_SELF_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_BEFORE == 3) {
                return visitor_Expression_SELF_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_BEFORE == 4) {
                return visitor_Expression_SELF_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_BEFORE == 5) {
                return visitor_Expression_SELF_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_BEFORE == 6) {
                return visitor_Expression_SELF_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_BEFORE < 7, "No suitable visitor hook found for Expression_SELF_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_SELF_after>> visitor_Expression_SELF_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_SELF_after>> visitor_Expression_SELF_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_SELF_after>> visitor_Expression_SELF_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_SELF_after>> visitor_Expression_SELF_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_SELF_after>> visitor_Expression_SELF_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_SELF_after>> visitor_Expression_SELF_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_SELF_after>> visitor_Expression_SELF_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_SELF_after(const Context_Expression_SELF_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_AFTER == 0) {
                return visitor_Expression_SELF_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_AFTER == 1) {
                return visitor_Expression_SELF_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_AFTER == 2) {
                return visitor_Expression_SELF_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_AFTER == 3) {
                return visitor_Expression_SELF_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_AFTER == 4) {
                return visitor_Expression_SELF_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_AFTER == 5) {
                return visitor_Expression_SELF_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_AFTER == 6) {
                return visitor_Expression_SELF_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_SELF_AFTER < 7, "No suitable visitor hook found for Expression_SELF_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_AS_ARG>> visitor_Expression_AS_ARG_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_AS_ARG>> visitor_Expression_AS_ARG_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_AS_ARG>> visitor_Expression_AS_ARG_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_AS_ARG>> visitor_Expression_AS_ARG_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_AS_ARG>> visitor_Expression_AS_ARG_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_AS_ARG>> visitor_Expression_AS_ARG_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_AS_ARG>> visitor_Expression_AS_ARG_GeneratorDefaultHook;
        auto& get_visitor_Expression_AS_ARG(const Context_Expression_AS_ARG&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG == 0) {
                return visitor_Expression_AS_ARG_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG == 1) {
                return visitor_Expression_AS_ARG_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG == 2) {
                return visitor_Expression_AS_ARG_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG == 3) {
                return visitor_Expression_AS_ARG_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG == 4) {
                return visitor_Expression_AS_ARG_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG == 5) {
                return visitor_Expression_AS_ARG_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG == 6) {
                return visitor_Expression_AS_ARG_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG < 7, "No suitable visitor hook found for Expression_AS_ARG");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_AS_ARG_before>> visitor_Expression_AS_ARG_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_AS_ARG_before>> visitor_Expression_AS_ARG_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_AS_ARG_before>> visitor_Expression_AS_ARG_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_AS_ARG_before>> visitor_Expression_AS_ARG_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_AS_ARG_before>> visitor_Expression_AS_ARG_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_AS_ARG_before>> visitor_Expression_AS_ARG_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_AS_ARG_before>> visitor_Expression_AS_ARG_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_AS_ARG_before(const Context_Expression_AS_ARG_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_BEFORE == 0) {
                return visitor_Expression_AS_ARG_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_BEFORE == 1) {
                return visitor_Expression_AS_ARG_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_BEFORE == 2) {
                return visitor_Expression_AS_ARG_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_BEFORE == 3) {
                return visitor_Expression_AS_ARG_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_BEFORE == 4) {
                return visitor_Expression_AS_ARG_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_BEFORE == 5) {
                return visitor_Expression_AS_ARG_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_BEFORE == 6) {
                return visitor_Expression_AS_ARG_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_BEFORE < 7, "No suitable visitor hook found for Expression_AS_ARG_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_AS_ARG_after>> visitor_Expression_AS_ARG_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_AS_ARG_after>> visitor_Expression_AS_ARG_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_AS_ARG_after>> visitor_Expression_AS_ARG_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_AS_ARG_after>> visitor_Expression_AS_ARG_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_AS_ARG_after>> visitor_Expression_AS_ARG_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_AS_ARG_after>> visitor_Expression_AS_ARG_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_AS_ARG_after>> visitor_Expression_AS_ARG_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_AS_ARG_after(const Context_Expression_AS_ARG_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_AFTER == 0) {
                return visitor_Expression_AS_ARG_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_AFTER == 1) {
                return visitor_Expression_AS_ARG_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_AFTER == 2) {
                return visitor_Expression_AS_ARG_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_AFTER == 3) {
                return visitor_Expression_AS_ARG_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_AFTER == 4) {
                return visitor_Expression_AS_ARG_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_AFTER == 5) {
                return visitor_Expression_AS_ARG_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_AFTER == 6) {
                return visitor_Expression_AS_ARG_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AS_ARG_AFTER < 7, "No suitable visitor hook found for Expression_AS_ARG_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expression>> visitor_Expression_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression>> visitor_Expression_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression>> visitor_Expression_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression>> visitor_Expression_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression>> visitor_Expression_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression>> visitor_Expression_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression>> visitor_Expression_GeneratorDefaultHook;
        auto& get_visitor_Expression(const Context_Expression&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION == 0) {
                return visitor_Expression_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION == 1) {
                return visitor_Expression_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION == 2) {
                return visitor_Expression_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION == 3) {
                return visitor_Expression_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION == 4) {
                return visitor_Expression_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION == 5) {
                return visitor_Expression_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION == 6) {
                return visitor_Expression_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION < 7, "No suitable visitor hook found for Expression");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_before>> visitor_Expression_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_before>> visitor_Expression_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_before>> visitor_Expression_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_before>> visitor_Expression_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_before>> visitor_Expression_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_before>> visitor_Expression_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_before>> visitor_Expression_before_GeneratorDefaultHook;
        auto& get_visitor_Expression_before(const Context_Expression_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BEFORE == 0) {
                return visitor_Expression_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BEFORE == 1) {
                return visitor_Expression_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BEFORE == 2) {
                return visitor_Expression_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BEFORE == 3) {
                return visitor_Expression_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BEFORE == 4) {
                return visitor_Expression_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BEFORE == 5) {
                return visitor_Expression_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BEFORE == 6) {
                return visitor_Expression_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_BEFORE < 7, "No suitable visitor hook found for Expression_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expression_after>> visitor_Expression_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expression_after>> visitor_Expression_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expression_after>> visitor_Expression_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expression_after>> visitor_Expression_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expression_after>> visitor_Expression_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expression_after>> visitor_Expression_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expression_after>> visitor_Expression_after_GeneratorDefaultHook;
        auto& get_visitor_Expression_after(const Context_Expression_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AFTER == 0) {
                return visitor_Expression_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AFTER == 1) {
                return visitor_Expression_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AFTER == 2) {
                return visitor_Expression_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AFTER == 3) {
                return visitor_Expression_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AFTER == 4) {
                return visitor_Expression_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AFTER == 5) {
                return visitor_Expression_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AFTER == 6) {
                return visitor_Expression_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSION_AFTER < 7, "No suitable visitor hook found for Expression_after");
            }
        }
        Visitor<UserHook<VisitorTag_Expressions>> visitor_Expressions_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expressions>> visitor_Expressions_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expressions>> visitor_Expressions_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expressions>> visitor_Expressions_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expressions>> visitor_Expressions_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expressions>> visitor_Expressions_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expressions>> visitor_Expressions_GeneratorDefaultHook;
        auto& get_visitor_Expressions(const Context_Expressions&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS == 0) {
                return visitor_Expressions_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS == 1) {
                return visitor_Expressions_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS == 2) {
                return visitor_Expressions_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS == 3) {
                return visitor_Expressions_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS == 4) {
                return visitor_Expressions_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS == 5) {
                return visitor_Expressions_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS == 6) {
                return visitor_Expressions_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS < 7, "No suitable visitor hook found for Expressions");
            }
        }
        Visitor<UserHook<VisitorTag_Expressions_before>> visitor_Expressions_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expressions_before>> visitor_Expressions_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expressions_before>> visitor_Expressions_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expressions_before>> visitor_Expressions_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expressions_before>> visitor_Expressions_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expressions_before>> visitor_Expressions_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expressions_before>> visitor_Expressions_before_GeneratorDefaultHook;
        auto& get_visitor_Expressions_before(const Context_Expressions_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_BEFORE == 0) {
                return visitor_Expressions_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_BEFORE == 1) {
                return visitor_Expressions_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_BEFORE == 2) {
                return visitor_Expressions_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_BEFORE == 3) {
                return visitor_Expressions_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_BEFORE == 4) {
                return visitor_Expressions_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_BEFORE == 5) {
                return visitor_Expressions_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_BEFORE == 6) {
                return visitor_Expressions_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_BEFORE < 7, "No suitable visitor hook found for Expressions_before");
            }
        }
        Visitor<UserHook<VisitorTag_Expressions_after>> visitor_Expressions_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Expressions_after>> visitor_Expressions_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Expressions_after>> visitor_Expressions_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Expressions_after>> visitor_Expressions_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Expressions_after>> visitor_Expressions_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Expressions_after>> visitor_Expressions_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Expressions_after>> visitor_Expressions_after_GeneratorDefaultHook;
        auto& get_visitor_Expressions_after(const Context_Expressions_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_AFTER == 0) {
                return visitor_Expressions_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_AFTER == 1) {
                return visitor_Expressions_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_AFTER == 2) {
                return visitor_Expressions_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_AFTER == 3) {
                return visitor_Expressions_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_AFTER == 4) {
                return visitor_Expressions_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_AFTER == 5) {
                return visitor_Expressions_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_AFTER == 6) {
                return visitor_Expressions_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_EXPRESSIONS_AFTER < 7, "No suitable visitor hook found for Expressions_after");
            }
        }
        Visitor<UserHook<VisitorTag_Type_INT>> visitor_Type_INT_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_INT>> visitor_Type_INT_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_INT>> visitor_Type_INT_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_INT>> visitor_Type_INT_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_INT>> visitor_Type_INT_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_INT>> visitor_Type_INT_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_INT>> visitor_Type_INT_GeneratorDefaultHook;
        auto& get_visitor_Type_INT(const Context_Type_INT&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_INT == 0) {
                return visitor_Type_INT_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_INT == 1) {
                return visitor_Type_INT_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_INT == 2) {
                return visitor_Type_INT_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_INT == 3) {
                return visitor_Type_INT_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_INT == 4) {
                return visitor_Type_INT_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_INT == 5) {
                return visitor_Type_INT_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_INT == 6) {
                return visitor_Type_INT_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_INT>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_INT < 7, "No suitable visitor hook found for Type_INT");
            }
        }
        Visitor<UserHook<VisitorTag_Type_INT_before>> visitor_Type_INT_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_INT_before>> visitor_Type_INT_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_INT_before>> visitor_Type_INT_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_INT_before>> visitor_Type_INT_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_INT_before>> visitor_Type_INT_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_INT_before>> visitor_Type_INT_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_INT_before>> visitor_Type_INT_before_GeneratorDefaultHook;
        auto& get_visitor_Type_INT_before(const Context_Type_INT_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_INT_BEFORE == 0) {
                return visitor_Type_INT_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_INT_BEFORE == 1) {
                return visitor_Type_INT_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_INT_BEFORE == 2) {
                return visitor_Type_INT_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_INT_BEFORE == 3) {
                return visitor_Type_INT_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_INT_BEFORE == 4) {
                return visitor_Type_INT_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_INT_BEFORE == 5) {
                return visitor_Type_INT_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_INT_BEFORE == 6) {
                return visitor_Type_INT_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_INT_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_INT_BEFORE < 7, "No suitable visitor hook found for Type_INT_before");
            }
        }
        Visitor<UserHook<VisitorTag_Type_INT_after>> visitor_Type_INT_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_INT_after>> visitor_Type_INT_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_INT_after>> visitor_Type_INT_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_INT_after>> visitor_Type_INT_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_INT_after>> visitor_Type_INT_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_INT_after>> visitor_Type_INT_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_INT_after>> visitor_Type_INT_after_GeneratorDefaultHook;
        auto& get_visitor_Type_INT_after(const Context_Type_INT_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_INT_AFTER == 0) {
                return visitor_Type_INT_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_INT_AFTER == 1) {
                return visitor_Type_INT_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_INT_AFTER == 2) {
                return visitor_Type_INT_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_INT_AFTER == 3) {
                return visitor_Type_INT_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_INT_AFTER == 4) {
                return visitor_Type_INT_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_INT_AFTER == 5) {
                return visitor_Type_INT_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_INT_AFTER == 6) {
                return visitor_Type_INT_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_INT_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_INT_AFTER < 7, "No suitable visitor hook found for Type_INT_after");
            }
        }
        Visitor<UserHook<VisitorTag_Type_UINT>> visitor_Type_UINT_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_UINT>> visitor_Type_UINT_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_UINT>> visitor_Type_UINT_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_UINT>> visitor_Type_UINT_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_UINT>> visitor_Type_UINT_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_UINT>> visitor_Type_UINT_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_UINT>> visitor_Type_UINT_GeneratorDefaultHook;
        auto& get_visitor_Type_UINT(const Context_Type_UINT&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_UINT == 0) {
                return visitor_Type_UINT_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_UINT == 1) {
                return visitor_Type_UINT_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_UINT == 2) {
                return visitor_Type_UINT_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_UINT == 3) {
                return visitor_Type_UINT_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_UINT == 4) {
                return visitor_Type_UINT_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_UINT == 5) {
                return visitor_Type_UINT_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_UINT == 6) {
                return visitor_Type_UINT_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_UINT>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_UINT < 7, "No suitable visitor hook found for Type_UINT");
            }
        }
        Visitor<UserHook<VisitorTag_Type_UINT_before>> visitor_Type_UINT_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_UINT_before>> visitor_Type_UINT_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_UINT_before>> visitor_Type_UINT_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_UINT_before>> visitor_Type_UINT_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_UINT_before>> visitor_Type_UINT_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_UINT_before>> visitor_Type_UINT_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_UINT_before>> visitor_Type_UINT_before_GeneratorDefaultHook;
        auto& get_visitor_Type_UINT_before(const Context_Type_UINT_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_BEFORE == 0) {
                return visitor_Type_UINT_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_BEFORE == 1) {
                return visitor_Type_UINT_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_BEFORE == 2) {
                return visitor_Type_UINT_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_BEFORE == 3) {
                return visitor_Type_UINT_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_BEFORE == 4) {
                return visitor_Type_UINT_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_BEFORE == 5) {
                return visitor_Type_UINT_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_BEFORE == 6) {
                return visitor_Type_UINT_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_BEFORE < 7, "No suitable visitor hook found for Type_UINT_before");
            }
        }
        Visitor<UserHook<VisitorTag_Type_UINT_after>> visitor_Type_UINT_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_UINT_after>> visitor_Type_UINT_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_UINT_after>> visitor_Type_UINT_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_UINT_after>> visitor_Type_UINT_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_UINT_after>> visitor_Type_UINT_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_UINT_after>> visitor_Type_UINT_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_UINT_after>> visitor_Type_UINT_after_GeneratorDefaultHook;
        auto& get_visitor_Type_UINT_after(const Context_Type_UINT_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_AFTER == 0) {
                return visitor_Type_UINT_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_AFTER == 1) {
                return visitor_Type_UINT_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_AFTER == 2) {
                return visitor_Type_UINT_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_AFTER == 3) {
                return visitor_Type_UINT_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_AFTER == 4) {
                return visitor_Type_UINT_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_AFTER == 5) {
                return visitor_Type_UINT_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_AFTER == 6) {
                return visitor_Type_UINT_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_UINT_AFTER < 7, "No suitable visitor hook found for Type_UINT_after");
            }
        }
        Visitor<UserHook<VisitorTag_Type_USIZE>> visitor_Type_USIZE_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_USIZE>> visitor_Type_USIZE_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_USIZE>> visitor_Type_USIZE_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_USIZE>> visitor_Type_USIZE_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_USIZE>> visitor_Type_USIZE_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_USIZE>> visitor_Type_USIZE_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_USIZE>> visitor_Type_USIZE_GeneratorDefaultHook;
        auto& get_visitor_Type_USIZE(const Context_Type_USIZE&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE == 0) {
                return visitor_Type_USIZE_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE == 1) {
                return visitor_Type_USIZE_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE == 2) {
                return visitor_Type_USIZE_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE == 3) {
                return visitor_Type_USIZE_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE == 4) {
                return visitor_Type_USIZE_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE == 5) {
                return visitor_Type_USIZE_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE == 6) {
                return visitor_Type_USIZE_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE < 7, "No suitable visitor hook found for Type_USIZE");
            }
        }
        Visitor<UserHook<VisitorTag_Type_USIZE_before>> visitor_Type_USIZE_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_USIZE_before>> visitor_Type_USIZE_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_USIZE_before>> visitor_Type_USIZE_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_USIZE_before>> visitor_Type_USIZE_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_USIZE_before>> visitor_Type_USIZE_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_USIZE_before>> visitor_Type_USIZE_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_USIZE_before>> visitor_Type_USIZE_before_GeneratorDefaultHook;
        auto& get_visitor_Type_USIZE_before(const Context_Type_USIZE_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_BEFORE == 0) {
                return visitor_Type_USIZE_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_BEFORE == 1) {
                return visitor_Type_USIZE_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_BEFORE == 2) {
                return visitor_Type_USIZE_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_BEFORE == 3) {
                return visitor_Type_USIZE_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_BEFORE == 4) {
                return visitor_Type_USIZE_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_BEFORE == 5) {
                return visitor_Type_USIZE_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_BEFORE == 6) {
                return visitor_Type_USIZE_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_BEFORE < 7, "No suitable visitor hook found for Type_USIZE_before");
            }
        }
        Visitor<UserHook<VisitorTag_Type_USIZE_after>> visitor_Type_USIZE_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_USIZE_after>> visitor_Type_USIZE_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_USIZE_after>> visitor_Type_USIZE_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_USIZE_after>> visitor_Type_USIZE_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_USIZE_after>> visitor_Type_USIZE_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_USIZE_after>> visitor_Type_USIZE_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_USIZE_after>> visitor_Type_USIZE_after_GeneratorDefaultHook;
        auto& get_visitor_Type_USIZE_after(const Context_Type_USIZE_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_AFTER == 0) {
                return visitor_Type_USIZE_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_AFTER == 1) {
                return visitor_Type_USIZE_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_AFTER == 2) {
                return visitor_Type_USIZE_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_AFTER == 3) {
                return visitor_Type_USIZE_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_AFTER == 4) {
                return visitor_Type_USIZE_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_AFTER == 5) {
                return visitor_Type_USIZE_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_AFTER == 6) {
                return visitor_Type_USIZE_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_USIZE_AFTER < 7, "No suitable visitor hook found for Type_USIZE_after");
            }
        }
        Visitor<UserHook<VisitorTag_Type_FLOAT>> visitor_Type_FLOAT_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_FLOAT>> visitor_Type_FLOAT_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_FLOAT>> visitor_Type_FLOAT_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_FLOAT>> visitor_Type_FLOAT_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_FLOAT>> visitor_Type_FLOAT_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_FLOAT>> visitor_Type_FLOAT_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_FLOAT>> visitor_Type_FLOAT_GeneratorDefaultHook;
        auto& get_visitor_Type_FLOAT(const Context_Type_FLOAT&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT == 0) {
                return visitor_Type_FLOAT_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT == 1) {
                return visitor_Type_FLOAT_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT == 2) {
                return visitor_Type_FLOAT_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT == 3) {
                return visitor_Type_FLOAT_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT == 4) {
                return visitor_Type_FLOAT_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT == 5) {
                return visitor_Type_FLOAT_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT == 6) {
                return visitor_Type_FLOAT_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT < 7, "No suitable visitor hook found for Type_FLOAT");
            }
        }
        Visitor<UserHook<VisitorTag_Type_FLOAT_before>> visitor_Type_FLOAT_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_FLOAT_before>> visitor_Type_FLOAT_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_FLOAT_before>> visitor_Type_FLOAT_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_FLOAT_before>> visitor_Type_FLOAT_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_FLOAT_before>> visitor_Type_FLOAT_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_FLOAT_before>> visitor_Type_FLOAT_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_FLOAT_before>> visitor_Type_FLOAT_before_GeneratorDefaultHook;
        auto& get_visitor_Type_FLOAT_before(const Context_Type_FLOAT_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_BEFORE == 0) {
                return visitor_Type_FLOAT_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_BEFORE == 1) {
                return visitor_Type_FLOAT_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_BEFORE == 2) {
                return visitor_Type_FLOAT_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_BEFORE == 3) {
                return visitor_Type_FLOAT_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_BEFORE == 4) {
                return visitor_Type_FLOAT_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_BEFORE == 5) {
                return visitor_Type_FLOAT_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_BEFORE == 6) {
                return visitor_Type_FLOAT_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_BEFORE < 7, "No suitable visitor hook found for Type_FLOAT_before");
            }
        }
        Visitor<UserHook<VisitorTag_Type_FLOAT_after>> visitor_Type_FLOAT_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_FLOAT_after>> visitor_Type_FLOAT_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_FLOAT_after>> visitor_Type_FLOAT_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_FLOAT_after>> visitor_Type_FLOAT_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_FLOAT_after>> visitor_Type_FLOAT_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_FLOAT_after>> visitor_Type_FLOAT_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_FLOAT_after>> visitor_Type_FLOAT_after_GeneratorDefaultHook;
        auto& get_visitor_Type_FLOAT_after(const Context_Type_FLOAT_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_AFTER == 0) {
                return visitor_Type_FLOAT_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_AFTER == 1) {
                return visitor_Type_FLOAT_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_AFTER == 2) {
                return visitor_Type_FLOAT_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_AFTER == 3) {
                return visitor_Type_FLOAT_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_AFTER == 4) {
                return visitor_Type_FLOAT_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_AFTER == 5) {
                return visitor_Type_FLOAT_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_AFTER == 6) {
                return visitor_Type_FLOAT_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_FLOAT_AFTER < 7, "No suitable visitor hook found for Type_FLOAT_after");
            }
        }
        Visitor<UserHook<VisitorTag_Type_STRUCT>> visitor_Type_STRUCT_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_STRUCT>> visitor_Type_STRUCT_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_STRUCT>> visitor_Type_STRUCT_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_STRUCT>> visitor_Type_STRUCT_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_STRUCT>> visitor_Type_STRUCT_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_STRUCT>> visitor_Type_STRUCT_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_STRUCT>> visitor_Type_STRUCT_GeneratorDefaultHook;
        auto& get_visitor_Type_STRUCT(const Context_Type_STRUCT&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT == 0) {
                return visitor_Type_STRUCT_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT == 1) {
                return visitor_Type_STRUCT_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT == 2) {
                return visitor_Type_STRUCT_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT == 3) {
                return visitor_Type_STRUCT_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT == 4) {
                return visitor_Type_STRUCT_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT == 5) {
                return visitor_Type_STRUCT_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT == 6) {
                return visitor_Type_STRUCT_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT < 7, "No suitable visitor hook found for Type_STRUCT");
            }
        }
        Visitor<UserHook<VisitorTag_Type_STRUCT_before>> visitor_Type_STRUCT_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_STRUCT_before>> visitor_Type_STRUCT_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_STRUCT_before>> visitor_Type_STRUCT_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_STRUCT_before>> visitor_Type_STRUCT_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_STRUCT_before>> visitor_Type_STRUCT_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_STRUCT_before>> visitor_Type_STRUCT_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_STRUCT_before>> visitor_Type_STRUCT_before_GeneratorDefaultHook;
        auto& get_visitor_Type_STRUCT_before(const Context_Type_STRUCT_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_BEFORE == 0) {
                return visitor_Type_STRUCT_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_BEFORE == 1) {
                return visitor_Type_STRUCT_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_BEFORE == 2) {
                return visitor_Type_STRUCT_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_BEFORE == 3) {
                return visitor_Type_STRUCT_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_BEFORE == 4) {
                return visitor_Type_STRUCT_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_BEFORE == 5) {
                return visitor_Type_STRUCT_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_BEFORE == 6) {
                return visitor_Type_STRUCT_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_BEFORE < 7, "No suitable visitor hook found for Type_STRUCT_before");
            }
        }
        Visitor<UserHook<VisitorTag_Type_STRUCT_after>> visitor_Type_STRUCT_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_STRUCT_after>> visitor_Type_STRUCT_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_STRUCT_after>> visitor_Type_STRUCT_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_STRUCT_after>> visitor_Type_STRUCT_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_STRUCT_after>> visitor_Type_STRUCT_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_STRUCT_after>> visitor_Type_STRUCT_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_STRUCT_after>> visitor_Type_STRUCT_after_GeneratorDefaultHook;
        auto& get_visitor_Type_STRUCT_after(const Context_Type_STRUCT_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_AFTER == 0) {
                return visitor_Type_STRUCT_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_AFTER == 1) {
                return visitor_Type_STRUCT_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_AFTER == 2) {
                return visitor_Type_STRUCT_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_AFTER == 3) {
                return visitor_Type_STRUCT_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_AFTER == 4) {
                return visitor_Type_STRUCT_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_AFTER == 5) {
                return visitor_Type_STRUCT_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_AFTER == 6) {
                return visitor_Type_STRUCT_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_STRUCT_AFTER < 7, "No suitable visitor hook found for Type_STRUCT_after");
            }
        }
        Visitor<UserHook<VisitorTag_Type_RECURSIVE_STRUCT>> visitor_Type_RECURSIVE_STRUCT_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_RECURSIVE_STRUCT>> visitor_Type_RECURSIVE_STRUCT_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_RECURSIVE_STRUCT>> visitor_Type_RECURSIVE_STRUCT_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_RECURSIVE_STRUCT>> visitor_Type_RECURSIVE_STRUCT_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_RECURSIVE_STRUCT>> visitor_Type_RECURSIVE_STRUCT_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_RECURSIVE_STRUCT>> visitor_Type_RECURSIVE_STRUCT_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_RECURSIVE_STRUCT>> visitor_Type_RECURSIVE_STRUCT_GeneratorDefaultHook;
        auto& get_visitor_Type_RECURSIVE_STRUCT(const Context_Type_RECURSIVE_STRUCT&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT == 0) {
                return visitor_Type_RECURSIVE_STRUCT_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT == 1) {
                return visitor_Type_RECURSIVE_STRUCT_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT == 2) {
                return visitor_Type_RECURSIVE_STRUCT_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT == 3) {
                return visitor_Type_RECURSIVE_STRUCT_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT == 4) {
                return visitor_Type_RECURSIVE_STRUCT_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT == 5) {
                return visitor_Type_RECURSIVE_STRUCT_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT == 6) {
                return visitor_Type_RECURSIVE_STRUCT_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT < 7, "No suitable visitor hook found for Type_RECURSIVE_STRUCT");
            }
        }
        Visitor<UserHook<VisitorTag_Type_RECURSIVE_STRUCT_before>> visitor_Type_RECURSIVE_STRUCT_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_RECURSIVE_STRUCT_before>> visitor_Type_RECURSIVE_STRUCT_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_RECURSIVE_STRUCT_before>> visitor_Type_RECURSIVE_STRUCT_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_RECURSIVE_STRUCT_before>> visitor_Type_RECURSIVE_STRUCT_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_RECURSIVE_STRUCT_before>> visitor_Type_RECURSIVE_STRUCT_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_RECURSIVE_STRUCT_before>> visitor_Type_RECURSIVE_STRUCT_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_RECURSIVE_STRUCT_before>> visitor_Type_RECURSIVE_STRUCT_before_GeneratorDefaultHook;
        auto& get_visitor_Type_RECURSIVE_STRUCT_before(const Context_Type_RECURSIVE_STRUCT_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_BEFORE == 0) {
                return visitor_Type_RECURSIVE_STRUCT_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_BEFORE == 1) {
                return visitor_Type_RECURSIVE_STRUCT_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_BEFORE == 2) {
                return visitor_Type_RECURSIVE_STRUCT_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_BEFORE == 3) {
                return visitor_Type_RECURSIVE_STRUCT_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_BEFORE == 4) {
                return visitor_Type_RECURSIVE_STRUCT_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_BEFORE == 5) {
                return visitor_Type_RECURSIVE_STRUCT_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_BEFORE == 6) {
                return visitor_Type_RECURSIVE_STRUCT_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_BEFORE < 7, "No suitable visitor hook found for Type_RECURSIVE_STRUCT_before");
            }
        }
        Visitor<UserHook<VisitorTag_Type_RECURSIVE_STRUCT_after>> visitor_Type_RECURSIVE_STRUCT_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_RECURSIVE_STRUCT_after>> visitor_Type_RECURSIVE_STRUCT_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_RECURSIVE_STRUCT_after>> visitor_Type_RECURSIVE_STRUCT_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_RECURSIVE_STRUCT_after>> visitor_Type_RECURSIVE_STRUCT_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_RECURSIVE_STRUCT_after>> visitor_Type_RECURSIVE_STRUCT_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_RECURSIVE_STRUCT_after>> visitor_Type_RECURSIVE_STRUCT_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_RECURSIVE_STRUCT_after>> visitor_Type_RECURSIVE_STRUCT_after_GeneratorDefaultHook;
        auto& get_visitor_Type_RECURSIVE_STRUCT_after(const Context_Type_RECURSIVE_STRUCT_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_AFTER == 0) {
                return visitor_Type_RECURSIVE_STRUCT_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_AFTER == 1) {
                return visitor_Type_RECURSIVE_STRUCT_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_AFTER == 2) {
                return visitor_Type_RECURSIVE_STRUCT_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_AFTER == 3) {
                return visitor_Type_RECURSIVE_STRUCT_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_AFTER == 4) {
                return visitor_Type_RECURSIVE_STRUCT_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_AFTER == 5) {
                return visitor_Type_RECURSIVE_STRUCT_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_AFTER == 6) {
                return visitor_Type_RECURSIVE_STRUCT_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_RECURSIVE_STRUCT_AFTER < 7, "No suitable visitor hook found for Type_RECURSIVE_STRUCT_after");
            }
        }
        Visitor<UserHook<VisitorTag_Type_BOOL>> visitor_Type_BOOL_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_BOOL>> visitor_Type_BOOL_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_BOOL>> visitor_Type_BOOL_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_BOOL>> visitor_Type_BOOL_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_BOOL>> visitor_Type_BOOL_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_BOOL>> visitor_Type_BOOL_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_BOOL>> visitor_Type_BOOL_GeneratorDefaultHook;
        auto& get_visitor_Type_BOOL(const Context_Type_BOOL&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL == 0) {
                return visitor_Type_BOOL_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL == 1) {
                return visitor_Type_BOOL_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL == 2) {
                return visitor_Type_BOOL_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL == 3) {
                return visitor_Type_BOOL_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL == 4) {
                return visitor_Type_BOOL_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL == 5) {
                return visitor_Type_BOOL_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL == 6) {
                return visitor_Type_BOOL_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL < 7, "No suitable visitor hook found for Type_BOOL");
            }
        }
        Visitor<UserHook<VisitorTag_Type_BOOL_before>> visitor_Type_BOOL_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_BOOL_before>> visitor_Type_BOOL_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_BOOL_before>> visitor_Type_BOOL_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_BOOL_before>> visitor_Type_BOOL_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_BOOL_before>> visitor_Type_BOOL_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_BOOL_before>> visitor_Type_BOOL_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_BOOL_before>> visitor_Type_BOOL_before_GeneratorDefaultHook;
        auto& get_visitor_Type_BOOL_before(const Context_Type_BOOL_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_BEFORE == 0) {
                return visitor_Type_BOOL_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_BEFORE == 1) {
                return visitor_Type_BOOL_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_BEFORE == 2) {
                return visitor_Type_BOOL_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_BEFORE == 3) {
                return visitor_Type_BOOL_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_BEFORE == 4) {
                return visitor_Type_BOOL_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_BEFORE == 5) {
                return visitor_Type_BOOL_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_BEFORE == 6) {
                return visitor_Type_BOOL_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_BEFORE < 7, "No suitable visitor hook found for Type_BOOL_before");
            }
        }
        Visitor<UserHook<VisitorTag_Type_BOOL_after>> visitor_Type_BOOL_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_BOOL_after>> visitor_Type_BOOL_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_BOOL_after>> visitor_Type_BOOL_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_BOOL_after>> visitor_Type_BOOL_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_BOOL_after>> visitor_Type_BOOL_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_BOOL_after>> visitor_Type_BOOL_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_BOOL_after>> visitor_Type_BOOL_after_GeneratorDefaultHook;
        auto& get_visitor_Type_BOOL_after(const Context_Type_BOOL_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_AFTER == 0) {
                return visitor_Type_BOOL_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_AFTER == 1) {
                return visitor_Type_BOOL_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_AFTER == 2) {
                return visitor_Type_BOOL_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_AFTER == 3) {
                return visitor_Type_BOOL_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_AFTER == 4) {
                return visitor_Type_BOOL_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_AFTER == 5) {
                return visitor_Type_BOOL_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_AFTER == 6) {
                return visitor_Type_BOOL_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_BOOL_AFTER < 7, "No suitable visitor hook found for Type_BOOL_after");
            }
        }
        Visitor<UserHook<VisitorTag_Type_VOID>> visitor_Type_VOID_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_VOID>> visitor_Type_VOID_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_VOID>> visitor_Type_VOID_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_VOID>> visitor_Type_VOID_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_VOID>> visitor_Type_VOID_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_VOID>> visitor_Type_VOID_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_VOID>> visitor_Type_VOID_GeneratorDefaultHook;
        auto& get_visitor_Type_VOID(const Context_Type_VOID&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VOID == 0) {
                return visitor_Type_VOID_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VOID == 1) {
                return visitor_Type_VOID_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VOID == 2) {
                return visitor_Type_VOID_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VOID == 3) {
                return visitor_Type_VOID_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VOID == 4) {
                return visitor_Type_VOID_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VOID == 5) {
                return visitor_Type_VOID_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VOID == 6) {
                return visitor_Type_VOID_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_VOID>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_VOID < 7, "No suitable visitor hook found for Type_VOID");
            }
        }
        Visitor<UserHook<VisitorTag_Type_VOID_before>> visitor_Type_VOID_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_VOID_before>> visitor_Type_VOID_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_VOID_before>> visitor_Type_VOID_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_VOID_before>> visitor_Type_VOID_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_VOID_before>> visitor_Type_VOID_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_VOID_before>> visitor_Type_VOID_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_VOID_before>> visitor_Type_VOID_before_GeneratorDefaultHook;
        auto& get_visitor_Type_VOID_before(const Context_Type_VOID_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_BEFORE == 0) {
                return visitor_Type_VOID_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_BEFORE == 1) {
                return visitor_Type_VOID_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_BEFORE == 2) {
                return visitor_Type_VOID_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_BEFORE == 3) {
                return visitor_Type_VOID_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_BEFORE == 4) {
                return visitor_Type_VOID_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_BEFORE == 5) {
                return visitor_Type_VOID_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_BEFORE == 6) {
                return visitor_Type_VOID_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_BEFORE < 7, "No suitable visitor hook found for Type_VOID_before");
            }
        }
        Visitor<UserHook<VisitorTag_Type_VOID_after>> visitor_Type_VOID_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_VOID_after>> visitor_Type_VOID_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_VOID_after>> visitor_Type_VOID_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_VOID_after>> visitor_Type_VOID_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_VOID_after>> visitor_Type_VOID_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_VOID_after>> visitor_Type_VOID_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_VOID_after>> visitor_Type_VOID_after_GeneratorDefaultHook;
        auto& get_visitor_Type_VOID_after(const Context_Type_VOID_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_AFTER == 0) {
                return visitor_Type_VOID_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_AFTER == 1) {
                return visitor_Type_VOID_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_AFTER == 2) {
                return visitor_Type_VOID_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_AFTER == 3) {
                return visitor_Type_VOID_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_AFTER == 4) {
                return visitor_Type_VOID_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_AFTER == 5) {
                return visitor_Type_VOID_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_AFTER == 6) {
                return visitor_Type_VOID_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_VOID_AFTER < 7, "No suitable visitor hook found for Type_VOID_after");
            }
        }
        Visitor<UserHook<VisitorTag_Type_META>> visitor_Type_META_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_META>> visitor_Type_META_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_META>> visitor_Type_META_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_META>> visitor_Type_META_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_META>> visitor_Type_META_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_META>> visitor_Type_META_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_META>> visitor_Type_META_GeneratorDefaultHook;
        auto& get_visitor_Type_META(const Context_Type_META&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_META == 0) {
                return visitor_Type_META_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_META == 1) {
                return visitor_Type_META_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_META == 2) {
                return visitor_Type_META_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_META == 3) {
                return visitor_Type_META_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_META == 4) {
                return visitor_Type_META_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_META == 5) {
                return visitor_Type_META_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_META == 6) {
                return visitor_Type_META_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_META>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_META < 7, "No suitable visitor hook found for Type_META");
            }
        }
        Visitor<UserHook<VisitorTag_Type_META_before>> visitor_Type_META_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_META_before>> visitor_Type_META_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_META_before>> visitor_Type_META_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_META_before>> visitor_Type_META_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_META_before>> visitor_Type_META_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_META_before>> visitor_Type_META_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_META_before>> visitor_Type_META_before_GeneratorDefaultHook;
        auto& get_visitor_Type_META_before(const Context_Type_META_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_META_BEFORE == 0) {
                return visitor_Type_META_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_META_BEFORE == 1) {
                return visitor_Type_META_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_META_BEFORE == 2) {
                return visitor_Type_META_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_META_BEFORE == 3) {
                return visitor_Type_META_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_META_BEFORE == 4) {
                return visitor_Type_META_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_META_BEFORE == 5) {
                return visitor_Type_META_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_META_BEFORE == 6) {
                return visitor_Type_META_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_META_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_META_BEFORE < 7, "No suitable visitor hook found for Type_META_before");
            }
        }
        Visitor<UserHook<VisitorTag_Type_META_after>> visitor_Type_META_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_META_after>> visitor_Type_META_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_META_after>> visitor_Type_META_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_META_after>> visitor_Type_META_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_META_after>> visitor_Type_META_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_META_after>> visitor_Type_META_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_META_after>> visitor_Type_META_after_GeneratorDefaultHook;
        auto& get_visitor_Type_META_after(const Context_Type_META_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_META_AFTER == 0) {
                return visitor_Type_META_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_META_AFTER == 1) {
                return visitor_Type_META_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_META_AFTER == 2) {
                return visitor_Type_META_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_META_AFTER == 3) {
                return visitor_Type_META_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_META_AFTER == 4) {
                return visitor_Type_META_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_META_AFTER == 5) {
                return visitor_Type_META_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_META_AFTER == 6) {
                return visitor_Type_META_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_META_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_META_AFTER < 7, "No suitable visitor hook found for Type_META_after");
            }
        }
        Visitor<UserHook<VisitorTag_Type_ENUM>> visitor_Type_ENUM_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_ENUM>> visitor_Type_ENUM_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_ENUM>> visitor_Type_ENUM_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_ENUM>> visitor_Type_ENUM_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_ENUM>> visitor_Type_ENUM_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_ENUM>> visitor_Type_ENUM_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_ENUM>> visitor_Type_ENUM_GeneratorDefaultHook;
        auto& get_visitor_Type_ENUM(const Context_Type_ENUM&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM == 0) {
                return visitor_Type_ENUM_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM == 1) {
                return visitor_Type_ENUM_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM == 2) {
                return visitor_Type_ENUM_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM == 3) {
                return visitor_Type_ENUM_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM == 4) {
                return visitor_Type_ENUM_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM == 5) {
                return visitor_Type_ENUM_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM == 6) {
                return visitor_Type_ENUM_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM < 7, "No suitable visitor hook found for Type_ENUM");
            }
        }
        Visitor<UserHook<VisitorTag_Type_ENUM_before>> visitor_Type_ENUM_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_ENUM_before>> visitor_Type_ENUM_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_ENUM_before>> visitor_Type_ENUM_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_ENUM_before>> visitor_Type_ENUM_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_ENUM_before>> visitor_Type_ENUM_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_ENUM_before>> visitor_Type_ENUM_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_ENUM_before>> visitor_Type_ENUM_before_GeneratorDefaultHook;
        auto& get_visitor_Type_ENUM_before(const Context_Type_ENUM_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_BEFORE == 0) {
                return visitor_Type_ENUM_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_BEFORE == 1) {
                return visitor_Type_ENUM_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_BEFORE == 2) {
                return visitor_Type_ENUM_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_BEFORE == 3) {
                return visitor_Type_ENUM_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_BEFORE == 4) {
                return visitor_Type_ENUM_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_BEFORE == 5) {
                return visitor_Type_ENUM_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_BEFORE == 6) {
                return visitor_Type_ENUM_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_BEFORE < 7, "No suitable visitor hook found for Type_ENUM_before");
            }
        }
        Visitor<UserHook<VisitorTag_Type_ENUM_after>> visitor_Type_ENUM_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_ENUM_after>> visitor_Type_ENUM_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_ENUM_after>> visitor_Type_ENUM_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_ENUM_after>> visitor_Type_ENUM_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_ENUM_after>> visitor_Type_ENUM_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_ENUM_after>> visitor_Type_ENUM_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_ENUM_after>> visitor_Type_ENUM_after_GeneratorDefaultHook;
        auto& get_visitor_Type_ENUM_after(const Context_Type_ENUM_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_AFTER == 0) {
                return visitor_Type_ENUM_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_AFTER == 1) {
                return visitor_Type_ENUM_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_AFTER == 2) {
                return visitor_Type_ENUM_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_AFTER == 3) {
                return visitor_Type_ENUM_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_AFTER == 4) {
                return visitor_Type_ENUM_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_AFTER == 5) {
                return visitor_Type_ENUM_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_AFTER == 6) {
                return visitor_Type_ENUM_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_ENUM_AFTER < 7, "No suitable visitor hook found for Type_ENUM_after");
            }
        }
        Visitor<UserHook<VisitorTag_Type_ARRAY>> visitor_Type_ARRAY_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_ARRAY>> visitor_Type_ARRAY_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_ARRAY>> visitor_Type_ARRAY_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_ARRAY>> visitor_Type_ARRAY_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_ARRAY>> visitor_Type_ARRAY_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_ARRAY>> visitor_Type_ARRAY_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_ARRAY>> visitor_Type_ARRAY_GeneratorDefaultHook;
        auto& get_visitor_Type_ARRAY(const Context_Type_ARRAY&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY == 0) {
                return visitor_Type_ARRAY_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY == 1) {
                return visitor_Type_ARRAY_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY == 2) {
                return visitor_Type_ARRAY_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY == 3) {
                return visitor_Type_ARRAY_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY == 4) {
                return visitor_Type_ARRAY_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY == 5) {
                return visitor_Type_ARRAY_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY == 6) {
                return visitor_Type_ARRAY_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY < 7, "No suitable visitor hook found for Type_ARRAY");
            }
        }
        Visitor<UserHook<VisitorTag_Type_ARRAY_before>> visitor_Type_ARRAY_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_ARRAY_before>> visitor_Type_ARRAY_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_ARRAY_before>> visitor_Type_ARRAY_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_ARRAY_before>> visitor_Type_ARRAY_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_ARRAY_before>> visitor_Type_ARRAY_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_ARRAY_before>> visitor_Type_ARRAY_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_ARRAY_before>> visitor_Type_ARRAY_before_GeneratorDefaultHook;
        auto& get_visitor_Type_ARRAY_before(const Context_Type_ARRAY_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_BEFORE == 0) {
                return visitor_Type_ARRAY_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_BEFORE == 1) {
                return visitor_Type_ARRAY_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_BEFORE == 2) {
                return visitor_Type_ARRAY_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_BEFORE == 3) {
                return visitor_Type_ARRAY_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_BEFORE == 4) {
                return visitor_Type_ARRAY_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_BEFORE == 5) {
                return visitor_Type_ARRAY_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_BEFORE == 6) {
                return visitor_Type_ARRAY_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_BEFORE < 7, "No suitable visitor hook found for Type_ARRAY_before");
            }
        }
        Visitor<UserHook<VisitorTag_Type_ARRAY_after>> visitor_Type_ARRAY_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_ARRAY_after>> visitor_Type_ARRAY_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_ARRAY_after>> visitor_Type_ARRAY_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_ARRAY_after>> visitor_Type_ARRAY_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_ARRAY_after>> visitor_Type_ARRAY_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_ARRAY_after>> visitor_Type_ARRAY_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_ARRAY_after>> visitor_Type_ARRAY_after_GeneratorDefaultHook;
        auto& get_visitor_Type_ARRAY_after(const Context_Type_ARRAY_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_AFTER == 0) {
                return visitor_Type_ARRAY_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_AFTER == 1) {
                return visitor_Type_ARRAY_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_AFTER == 2) {
                return visitor_Type_ARRAY_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_AFTER == 3) {
                return visitor_Type_ARRAY_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_AFTER == 4) {
                return visitor_Type_ARRAY_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_AFTER == 5) {
                return visitor_Type_ARRAY_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_AFTER == 6) {
                return visitor_Type_ARRAY_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_ARRAY_AFTER < 7, "No suitable visitor hook found for Type_ARRAY_after");
            }
        }
        Visitor<UserHook<VisitorTag_Type_VECTOR>> visitor_Type_VECTOR_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_VECTOR>> visitor_Type_VECTOR_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_VECTOR>> visitor_Type_VECTOR_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_VECTOR>> visitor_Type_VECTOR_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_VECTOR>> visitor_Type_VECTOR_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_VECTOR>> visitor_Type_VECTOR_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_VECTOR>> visitor_Type_VECTOR_GeneratorDefaultHook;
        auto& get_visitor_Type_VECTOR(const Context_Type_VECTOR&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR == 0) {
                return visitor_Type_VECTOR_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR == 1) {
                return visitor_Type_VECTOR_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR == 2) {
                return visitor_Type_VECTOR_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR == 3) {
                return visitor_Type_VECTOR_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR == 4) {
                return visitor_Type_VECTOR_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR == 5) {
                return visitor_Type_VECTOR_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR == 6) {
                return visitor_Type_VECTOR_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR < 7, "No suitable visitor hook found for Type_VECTOR");
            }
        }
        Visitor<UserHook<VisitorTag_Type_VECTOR_before>> visitor_Type_VECTOR_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_VECTOR_before>> visitor_Type_VECTOR_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_VECTOR_before>> visitor_Type_VECTOR_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_VECTOR_before>> visitor_Type_VECTOR_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_VECTOR_before>> visitor_Type_VECTOR_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_VECTOR_before>> visitor_Type_VECTOR_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_VECTOR_before>> visitor_Type_VECTOR_before_GeneratorDefaultHook;
        auto& get_visitor_Type_VECTOR_before(const Context_Type_VECTOR_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_BEFORE == 0) {
                return visitor_Type_VECTOR_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_BEFORE == 1) {
                return visitor_Type_VECTOR_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_BEFORE == 2) {
                return visitor_Type_VECTOR_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_BEFORE == 3) {
                return visitor_Type_VECTOR_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_BEFORE == 4) {
                return visitor_Type_VECTOR_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_BEFORE == 5) {
                return visitor_Type_VECTOR_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_BEFORE == 6) {
                return visitor_Type_VECTOR_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_BEFORE < 7, "No suitable visitor hook found for Type_VECTOR_before");
            }
        }
        Visitor<UserHook<VisitorTag_Type_VECTOR_after>> visitor_Type_VECTOR_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_VECTOR_after>> visitor_Type_VECTOR_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_VECTOR_after>> visitor_Type_VECTOR_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_VECTOR_after>> visitor_Type_VECTOR_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_VECTOR_after>> visitor_Type_VECTOR_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_VECTOR_after>> visitor_Type_VECTOR_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_VECTOR_after>> visitor_Type_VECTOR_after_GeneratorDefaultHook;
        auto& get_visitor_Type_VECTOR_after(const Context_Type_VECTOR_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_AFTER == 0) {
                return visitor_Type_VECTOR_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_AFTER == 1) {
                return visitor_Type_VECTOR_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_AFTER == 2) {
                return visitor_Type_VECTOR_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_AFTER == 3) {
                return visitor_Type_VECTOR_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_AFTER == 4) {
                return visitor_Type_VECTOR_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_AFTER == 5) {
                return visitor_Type_VECTOR_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_AFTER == 6) {
                return visitor_Type_VECTOR_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_VECTOR_AFTER < 7, "No suitable visitor hook found for Type_VECTOR_after");
            }
        }
        Visitor<UserHook<VisitorTag_Type_VARIANT>> visitor_Type_VARIANT_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_VARIANT>> visitor_Type_VARIANT_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_VARIANT>> visitor_Type_VARIANT_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_VARIANT>> visitor_Type_VARIANT_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_VARIANT>> visitor_Type_VARIANT_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_VARIANT>> visitor_Type_VARIANT_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_VARIANT>> visitor_Type_VARIANT_GeneratorDefaultHook;
        auto& get_visitor_Type_VARIANT(const Context_Type_VARIANT&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT == 0) {
                return visitor_Type_VARIANT_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT == 1) {
                return visitor_Type_VARIANT_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT == 2) {
                return visitor_Type_VARIANT_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT == 3) {
                return visitor_Type_VARIANT_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT == 4) {
                return visitor_Type_VARIANT_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT == 5) {
                return visitor_Type_VARIANT_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT == 6) {
                return visitor_Type_VARIANT_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT < 7, "No suitable visitor hook found for Type_VARIANT");
            }
        }
        Visitor<UserHook<VisitorTag_Type_VARIANT_before>> visitor_Type_VARIANT_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_VARIANT_before>> visitor_Type_VARIANT_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_VARIANT_before>> visitor_Type_VARIANT_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_VARIANT_before>> visitor_Type_VARIANT_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_VARIANT_before>> visitor_Type_VARIANT_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_VARIANT_before>> visitor_Type_VARIANT_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_VARIANT_before>> visitor_Type_VARIANT_before_GeneratorDefaultHook;
        auto& get_visitor_Type_VARIANT_before(const Context_Type_VARIANT_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_BEFORE == 0) {
                return visitor_Type_VARIANT_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_BEFORE == 1) {
                return visitor_Type_VARIANT_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_BEFORE == 2) {
                return visitor_Type_VARIANT_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_BEFORE == 3) {
                return visitor_Type_VARIANT_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_BEFORE == 4) {
                return visitor_Type_VARIANT_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_BEFORE == 5) {
                return visitor_Type_VARIANT_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_BEFORE == 6) {
                return visitor_Type_VARIANT_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_BEFORE < 7, "No suitable visitor hook found for Type_VARIANT_before");
            }
        }
        Visitor<UserHook<VisitorTag_Type_VARIANT_after>> visitor_Type_VARIANT_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_VARIANT_after>> visitor_Type_VARIANT_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_VARIANT_after>> visitor_Type_VARIANT_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_VARIANT_after>> visitor_Type_VARIANT_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_VARIANT_after>> visitor_Type_VARIANT_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_VARIANT_after>> visitor_Type_VARIANT_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_VARIANT_after>> visitor_Type_VARIANT_after_GeneratorDefaultHook;
        auto& get_visitor_Type_VARIANT_after(const Context_Type_VARIANT_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_AFTER == 0) {
                return visitor_Type_VARIANT_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_AFTER == 1) {
                return visitor_Type_VARIANT_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_AFTER == 2) {
                return visitor_Type_VARIANT_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_AFTER == 3) {
                return visitor_Type_VARIANT_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_AFTER == 4) {
                return visitor_Type_VARIANT_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_AFTER == 5) {
                return visitor_Type_VARIANT_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_AFTER == 6) {
                return visitor_Type_VARIANT_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_VARIANT_AFTER < 7, "No suitable visitor hook found for Type_VARIANT_after");
            }
        }
        Visitor<UserHook<VisitorTag_Type_RANGE>> visitor_Type_RANGE_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_RANGE>> visitor_Type_RANGE_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_RANGE>> visitor_Type_RANGE_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_RANGE>> visitor_Type_RANGE_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_RANGE>> visitor_Type_RANGE_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_RANGE>> visitor_Type_RANGE_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_RANGE>> visitor_Type_RANGE_GeneratorDefaultHook;
        auto& get_visitor_Type_RANGE(const Context_Type_RANGE&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE == 0) {
                return visitor_Type_RANGE_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE == 1) {
                return visitor_Type_RANGE_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE == 2) {
                return visitor_Type_RANGE_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE == 3) {
                return visitor_Type_RANGE_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE == 4) {
                return visitor_Type_RANGE_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE == 5) {
                return visitor_Type_RANGE_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE == 6) {
                return visitor_Type_RANGE_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE < 7, "No suitable visitor hook found for Type_RANGE");
            }
        }
        Visitor<UserHook<VisitorTag_Type_RANGE_before>> visitor_Type_RANGE_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_RANGE_before>> visitor_Type_RANGE_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_RANGE_before>> visitor_Type_RANGE_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_RANGE_before>> visitor_Type_RANGE_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_RANGE_before>> visitor_Type_RANGE_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_RANGE_before>> visitor_Type_RANGE_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_RANGE_before>> visitor_Type_RANGE_before_GeneratorDefaultHook;
        auto& get_visitor_Type_RANGE_before(const Context_Type_RANGE_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_BEFORE == 0) {
                return visitor_Type_RANGE_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_BEFORE == 1) {
                return visitor_Type_RANGE_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_BEFORE == 2) {
                return visitor_Type_RANGE_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_BEFORE == 3) {
                return visitor_Type_RANGE_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_BEFORE == 4) {
                return visitor_Type_RANGE_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_BEFORE == 5) {
                return visitor_Type_RANGE_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_BEFORE == 6) {
                return visitor_Type_RANGE_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_BEFORE < 7, "No suitable visitor hook found for Type_RANGE_before");
            }
        }
        Visitor<UserHook<VisitorTag_Type_RANGE_after>> visitor_Type_RANGE_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_RANGE_after>> visitor_Type_RANGE_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_RANGE_after>> visitor_Type_RANGE_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_RANGE_after>> visitor_Type_RANGE_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_RANGE_after>> visitor_Type_RANGE_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_RANGE_after>> visitor_Type_RANGE_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_RANGE_after>> visitor_Type_RANGE_after_GeneratorDefaultHook;
        auto& get_visitor_Type_RANGE_after(const Context_Type_RANGE_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_AFTER == 0) {
                return visitor_Type_RANGE_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_AFTER == 1) {
                return visitor_Type_RANGE_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_AFTER == 2) {
                return visitor_Type_RANGE_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_AFTER == 3) {
                return visitor_Type_RANGE_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_AFTER == 4) {
                return visitor_Type_RANGE_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_AFTER == 5) {
                return visitor_Type_RANGE_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_AFTER == 6) {
                return visitor_Type_RANGE_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_RANGE_AFTER < 7, "No suitable visitor hook found for Type_RANGE_after");
            }
        }
        Visitor<UserHook<VisitorTag_Type_ENCODER_RETURN>> visitor_Type_ENCODER_RETURN_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_ENCODER_RETURN>> visitor_Type_ENCODER_RETURN_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_ENCODER_RETURN>> visitor_Type_ENCODER_RETURN_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_ENCODER_RETURN>> visitor_Type_ENCODER_RETURN_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_ENCODER_RETURN>> visitor_Type_ENCODER_RETURN_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_ENCODER_RETURN>> visitor_Type_ENCODER_RETURN_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_ENCODER_RETURN>> visitor_Type_ENCODER_RETURN_GeneratorDefaultHook;
        auto& get_visitor_Type_ENCODER_RETURN(const Context_Type_ENCODER_RETURN&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN == 0) {
                return visitor_Type_ENCODER_RETURN_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN == 1) {
                return visitor_Type_ENCODER_RETURN_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN == 2) {
                return visitor_Type_ENCODER_RETURN_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN == 3) {
                return visitor_Type_ENCODER_RETURN_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN == 4) {
                return visitor_Type_ENCODER_RETURN_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN == 5) {
                return visitor_Type_ENCODER_RETURN_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN == 6) {
                return visitor_Type_ENCODER_RETURN_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN < 7, "No suitable visitor hook found for Type_ENCODER_RETURN");
            }
        }
        Visitor<UserHook<VisitorTag_Type_ENCODER_RETURN_before>> visitor_Type_ENCODER_RETURN_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_ENCODER_RETURN_before>> visitor_Type_ENCODER_RETURN_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_ENCODER_RETURN_before>> visitor_Type_ENCODER_RETURN_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_ENCODER_RETURN_before>> visitor_Type_ENCODER_RETURN_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_ENCODER_RETURN_before>> visitor_Type_ENCODER_RETURN_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_ENCODER_RETURN_before>> visitor_Type_ENCODER_RETURN_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_ENCODER_RETURN_before>> visitor_Type_ENCODER_RETURN_before_GeneratorDefaultHook;
        auto& get_visitor_Type_ENCODER_RETURN_before(const Context_Type_ENCODER_RETURN_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_BEFORE == 0) {
                return visitor_Type_ENCODER_RETURN_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_BEFORE == 1) {
                return visitor_Type_ENCODER_RETURN_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_BEFORE == 2) {
                return visitor_Type_ENCODER_RETURN_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_BEFORE == 3) {
                return visitor_Type_ENCODER_RETURN_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_BEFORE == 4) {
                return visitor_Type_ENCODER_RETURN_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_BEFORE == 5) {
                return visitor_Type_ENCODER_RETURN_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_BEFORE == 6) {
                return visitor_Type_ENCODER_RETURN_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_BEFORE < 7, "No suitable visitor hook found for Type_ENCODER_RETURN_before");
            }
        }
        Visitor<UserHook<VisitorTag_Type_ENCODER_RETURN_after>> visitor_Type_ENCODER_RETURN_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_ENCODER_RETURN_after>> visitor_Type_ENCODER_RETURN_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_ENCODER_RETURN_after>> visitor_Type_ENCODER_RETURN_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_ENCODER_RETURN_after>> visitor_Type_ENCODER_RETURN_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_ENCODER_RETURN_after>> visitor_Type_ENCODER_RETURN_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_ENCODER_RETURN_after>> visitor_Type_ENCODER_RETURN_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_ENCODER_RETURN_after>> visitor_Type_ENCODER_RETURN_after_GeneratorDefaultHook;
        auto& get_visitor_Type_ENCODER_RETURN_after(const Context_Type_ENCODER_RETURN_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_AFTER == 0) {
                return visitor_Type_ENCODER_RETURN_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_AFTER == 1) {
                return visitor_Type_ENCODER_RETURN_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_AFTER == 2) {
                return visitor_Type_ENCODER_RETURN_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_AFTER == 3) {
                return visitor_Type_ENCODER_RETURN_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_AFTER == 4) {
                return visitor_Type_ENCODER_RETURN_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_AFTER == 5) {
                return visitor_Type_ENCODER_RETURN_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_AFTER == 6) {
                return visitor_Type_ENCODER_RETURN_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_RETURN_AFTER < 7, "No suitable visitor hook found for Type_ENCODER_RETURN_after");
            }
        }
        Visitor<UserHook<VisitorTag_Type_DECODER_RETURN>> visitor_Type_DECODER_RETURN_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_DECODER_RETURN>> visitor_Type_DECODER_RETURN_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_DECODER_RETURN>> visitor_Type_DECODER_RETURN_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_DECODER_RETURN>> visitor_Type_DECODER_RETURN_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_DECODER_RETURN>> visitor_Type_DECODER_RETURN_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_DECODER_RETURN>> visitor_Type_DECODER_RETURN_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_DECODER_RETURN>> visitor_Type_DECODER_RETURN_GeneratorDefaultHook;
        auto& get_visitor_Type_DECODER_RETURN(const Context_Type_DECODER_RETURN&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN == 0) {
                return visitor_Type_DECODER_RETURN_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN == 1) {
                return visitor_Type_DECODER_RETURN_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN == 2) {
                return visitor_Type_DECODER_RETURN_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN == 3) {
                return visitor_Type_DECODER_RETURN_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN == 4) {
                return visitor_Type_DECODER_RETURN_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN == 5) {
                return visitor_Type_DECODER_RETURN_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN == 6) {
                return visitor_Type_DECODER_RETURN_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN < 7, "No suitable visitor hook found for Type_DECODER_RETURN");
            }
        }
        Visitor<UserHook<VisitorTag_Type_DECODER_RETURN_before>> visitor_Type_DECODER_RETURN_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_DECODER_RETURN_before>> visitor_Type_DECODER_RETURN_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_DECODER_RETURN_before>> visitor_Type_DECODER_RETURN_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_DECODER_RETURN_before>> visitor_Type_DECODER_RETURN_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_DECODER_RETURN_before>> visitor_Type_DECODER_RETURN_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_DECODER_RETURN_before>> visitor_Type_DECODER_RETURN_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_DECODER_RETURN_before>> visitor_Type_DECODER_RETURN_before_GeneratorDefaultHook;
        auto& get_visitor_Type_DECODER_RETURN_before(const Context_Type_DECODER_RETURN_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_BEFORE == 0) {
                return visitor_Type_DECODER_RETURN_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_BEFORE == 1) {
                return visitor_Type_DECODER_RETURN_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_BEFORE == 2) {
                return visitor_Type_DECODER_RETURN_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_BEFORE == 3) {
                return visitor_Type_DECODER_RETURN_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_BEFORE == 4) {
                return visitor_Type_DECODER_RETURN_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_BEFORE == 5) {
                return visitor_Type_DECODER_RETURN_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_BEFORE == 6) {
                return visitor_Type_DECODER_RETURN_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_BEFORE < 7, "No suitable visitor hook found for Type_DECODER_RETURN_before");
            }
        }
        Visitor<UserHook<VisitorTag_Type_DECODER_RETURN_after>> visitor_Type_DECODER_RETURN_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_DECODER_RETURN_after>> visitor_Type_DECODER_RETURN_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_DECODER_RETURN_after>> visitor_Type_DECODER_RETURN_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_DECODER_RETURN_after>> visitor_Type_DECODER_RETURN_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_DECODER_RETURN_after>> visitor_Type_DECODER_RETURN_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_DECODER_RETURN_after>> visitor_Type_DECODER_RETURN_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_DECODER_RETURN_after>> visitor_Type_DECODER_RETURN_after_GeneratorDefaultHook;
        auto& get_visitor_Type_DECODER_RETURN_after(const Context_Type_DECODER_RETURN_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_AFTER == 0) {
                return visitor_Type_DECODER_RETURN_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_AFTER == 1) {
                return visitor_Type_DECODER_RETURN_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_AFTER == 2) {
                return visitor_Type_DECODER_RETURN_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_AFTER == 3) {
                return visitor_Type_DECODER_RETURN_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_AFTER == 4) {
                return visitor_Type_DECODER_RETURN_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_AFTER == 5) {
                return visitor_Type_DECODER_RETURN_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_AFTER == 6) {
                return visitor_Type_DECODER_RETURN_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_RETURN_AFTER < 7, "No suitable visitor hook found for Type_DECODER_RETURN_after");
            }
        }
        Visitor<UserHook<VisitorTag_Type_ENCODER_INPUT>> visitor_Type_ENCODER_INPUT_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_ENCODER_INPUT>> visitor_Type_ENCODER_INPUT_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_ENCODER_INPUT>> visitor_Type_ENCODER_INPUT_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_ENCODER_INPUT>> visitor_Type_ENCODER_INPUT_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_ENCODER_INPUT>> visitor_Type_ENCODER_INPUT_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_ENCODER_INPUT>> visitor_Type_ENCODER_INPUT_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_ENCODER_INPUT>> visitor_Type_ENCODER_INPUT_GeneratorDefaultHook;
        auto& get_visitor_Type_ENCODER_INPUT(const Context_Type_ENCODER_INPUT&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT == 0) {
                return visitor_Type_ENCODER_INPUT_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT == 1) {
                return visitor_Type_ENCODER_INPUT_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT == 2) {
                return visitor_Type_ENCODER_INPUT_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT == 3) {
                return visitor_Type_ENCODER_INPUT_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT == 4) {
                return visitor_Type_ENCODER_INPUT_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT == 5) {
                return visitor_Type_ENCODER_INPUT_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT == 6) {
                return visitor_Type_ENCODER_INPUT_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT < 7, "No suitable visitor hook found for Type_ENCODER_INPUT");
            }
        }
        Visitor<UserHook<VisitorTag_Type_ENCODER_INPUT_before>> visitor_Type_ENCODER_INPUT_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_ENCODER_INPUT_before>> visitor_Type_ENCODER_INPUT_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_ENCODER_INPUT_before>> visitor_Type_ENCODER_INPUT_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_ENCODER_INPUT_before>> visitor_Type_ENCODER_INPUT_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_ENCODER_INPUT_before>> visitor_Type_ENCODER_INPUT_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_ENCODER_INPUT_before>> visitor_Type_ENCODER_INPUT_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_ENCODER_INPUT_before>> visitor_Type_ENCODER_INPUT_before_GeneratorDefaultHook;
        auto& get_visitor_Type_ENCODER_INPUT_before(const Context_Type_ENCODER_INPUT_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_BEFORE == 0) {
                return visitor_Type_ENCODER_INPUT_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_BEFORE == 1) {
                return visitor_Type_ENCODER_INPUT_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_BEFORE == 2) {
                return visitor_Type_ENCODER_INPUT_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_BEFORE == 3) {
                return visitor_Type_ENCODER_INPUT_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_BEFORE == 4) {
                return visitor_Type_ENCODER_INPUT_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_BEFORE == 5) {
                return visitor_Type_ENCODER_INPUT_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_BEFORE == 6) {
                return visitor_Type_ENCODER_INPUT_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_BEFORE < 7, "No suitable visitor hook found for Type_ENCODER_INPUT_before");
            }
        }
        Visitor<UserHook<VisitorTag_Type_ENCODER_INPUT_after>> visitor_Type_ENCODER_INPUT_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_ENCODER_INPUT_after>> visitor_Type_ENCODER_INPUT_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_ENCODER_INPUT_after>> visitor_Type_ENCODER_INPUT_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_ENCODER_INPUT_after>> visitor_Type_ENCODER_INPUT_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_ENCODER_INPUT_after>> visitor_Type_ENCODER_INPUT_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_ENCODER_INPUT_after>> visitor_Type_ENCODER_INPUT_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_ENCODER_INPUT_after>> visitor_Type_ENCODER_INPUT_after_GeneratorDefaultHook;
        auto& get_visitor_Type_ENCODER_INPUT_after(const Context_Type_ENCODER_INPUT_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_AFTER == 0) {
                return visitor_Type_ENCODER_INPUT_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_AFTER == 1) {
                return visitor_Type_ENCODER_INPUT_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_AFTER == 2) {
                return visitor_Type_ENCODER_INPUT_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_AFTER == 3) {
                return visitor_Type_ENCODER_INPUT_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_AFTER == 4) {
                return visitor_Type_ENCODER_INPUT_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_AFTER == 5) {
                return visitor_Type_ENCODER_INPUT_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_AFTER == 6) {
                return visitor_Type_ENCODER_INPUT_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_ENCODER_INPUT_AFTER < 7, "No suitable visitor hook found for Type_ENCODER_INPUT_after");
            }
        }
        Visitor<UserHook<VisitorTag_Type_DECODER_INPUT>> visitor_Type_DECODER_INPUT_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_DECODER_INPUT>> visitor_Type_DECODER_INPUT_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_DECODER_INPUT>> visitor_Type_DECODER_INPUT_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_DECODER_INPUT>> visitor_Type_DECODER_INPUT_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_DECODER_INPUT>> visitor_Type_DECODER_INPUT_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_DECODER_INPUT>> visitor_Type_DECODER_INPUT_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_DECODER_INPUT>> visitor_Type_DECODER_INPUT_GeneratorDefaultHook;
        auto& get_visitor_Type_DECODER_INPUT(const Context_Type_DECODER_INPUT&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT == 0) {
                return visitor_Type_DECODER_INPUT_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT == 1) {
                return visitor_Type_DECODER_INPUT_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT == 2) {
                return visitor_Type_DECODER_INPUT_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT == 3) {
                return visitor_Type_DECODER_INPUT_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT == 4) {
                return visitor_Type_DECODER_INPUT_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT == 5) {
                return visitor_Type_DECODER_INPUT_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT == 6) {
                return visitor_Type_DECODER_INPUT_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT < 7, "No suitable visitor hook found for Type_DECODER_INPUT");
            }
        }
        Visitor<UserHook<VisitorTag_Type_DECODER_INPUT_before>> visitor_Type_DECODER_INPUT_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_DECODER_INPUT_before>> visitor_Type_DECODER_INPUT_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_DECODER_INPUT_before>> visitor_Type_DECODER_INPUT_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_DECODER_INPUT_before>> visitor_Type_DECODER_INPUT_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_DECODER_INPUT_before>> visitor_Type_DECODER_INPUT_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_DECODER_INPUT_before>> visitor_Type_DECODER_INPUT_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_DECODER_INPUT_before>> visitor_Type_DECODER_INPUT_before_GeneratorDefaultHook;
        auto& get_visitor_Type_DECODER_INPUT_before(const Context_Type_DECODER_INPUT_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_BEFORE == 0) {
                return visitor_Type_DECODER_INPUT_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_BEFORE == 1) {
                return visitor_Type_DECODER_INPUT_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_BEFORE == 2) {
                return visitor_Type_DECODER_INPUT_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_BEFORE == 3) {
                return visitor_Type_DECODER_INPUT_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_BEFORE == 4) {
                return visitor_Type_DECODER_INPUT_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_BEFORE == 5) {
                return visitor_Type_DECODER_INPUT_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_BEFORE == 6) {
                return visitor_Type_DECODER_INPUT_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_BEFORE < 7, "No suitable visitor hook found for Type_DECODER_INPUT_before");
            }
        }
        Visitor<UserHook<VisitorTag_Type_DECODER_INPUT_after>> visitor_Type_DECODER_INPUT_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_DECODER_INPUT_after>> visitor_Type_DECODER_INPUT_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_DECODER_INPUT_after>> visitor_Type_DECODER_INPUT_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_DECODER_INPUT_after>> visitor_Type_DECODER_INPUT_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_DECODER_INPUT_after>> visitor_Type_DECODER_INPUT_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_DECODER_INPUT_after>> visitor_Type_DECODER_INPUT_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_DECODER_INPUT_after>> visitor_Type_DECODER_INPUT_after_GeneratorDefaultHook;
        auto& get_visitor_Type_DECODER_INPUT_after(const Context_Type_DECODER_INPUT_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_AFTER == 0) {
                return visitor_Type_DECODER_INPUT_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_AFTER == 1) {
                return visitor_Type_DECODER_INPUT_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_AFTER == 2) {
                return visitor_Type_DECODER_INPUT_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_AFTER == 3) {
                return visitor_Type_DECODER_INPUT_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_AFTER == 4) {
                return visitor_Type_DECODER_INPUT_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_AFTER == 5) {
                return visitor_Type_DECODER_INPUT_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_AFTER == 6) {
                return visitor_Type_DECODER_INPUT_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_DECODER_INPUT_AFTER < 7, "No suitable visitor hook found for Type_DECODER_INPUT_after");
            }
        }
        Visitor<UserHook<VisitorTag_Type_PROPERTY_SETTER_RETURN>> visitor_Type_PROPERTY_SETTER_RETURN_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_PROPERTY_SETTER_RETURN>> visitor_Type_PROPERTY_SETTER_RETURN_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_PROPERTY_SETTER_RETURN>> visitor_Type_PROPERTY_SETTER_RETURN_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_PROPERTY_SETTER_RETURN>> visitor_Type_PROPERTY_SETTER_RETURN_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_PROPERTY_SETTER_RETURN>> visitor_Type_PROPERTY_SETTER_RETURN_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_PROPERTY_SETTER_RETURN>> visitor_Type_PROPERTY_SETTER_RETURN_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_PROPERTY_SETTER_RETURN>> visitor_Type_PROPERTY_SETTER_RETURN_GeneratorDefaultHook;
        auto& get_visitor_Type_PROPERTY_SETTER_RETURN(const Context_Type_PROPERTY_SETTER_RETURN&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN == 0) {
                return visitor_Type_PROPERTY_SETTER_RETURN_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN == 1) {
                return visitor_Type_PROPERTY_SETTER_RETURN_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN == 2) {
                return visitor_Type_PROPERTY_SETTER_RETURN_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN == 3) {
                return visitor_Type_PROPERTY_SETTER_RETURN_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN == 4) {
                return visitor_Type_PROPERTY_SETTER_RETURN_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN == 5) {
                return visitor_Type_PROPERTY_SETTER_RETURN_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN == 6) {
                return visitor_Type_PROPERTY_SETTER_RETURN_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN < 7, "No suitable visitor hook found for Type_PROPERTY_SETTER_RETURN");
            }
        }
        Visitor<UserHook<VisitorTag_Type_PROPERTY_SETTER_RETURN_before>> visitor_Type_PROPERTY_SETTER_RETURN_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_PROPERTY_SETTER_RETURN_before>> visitor_Type_PROPERTY_SETTER_RETURN_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_PROPERTY_SETTER_RETURN_before>> visitor_Type_PROPERTY_SETTER_RETURN_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_PROPERTY_SETTER_RETURN_before>> visitor_Type_PROPERTY_SETTER_RETURN_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_PROPERTY_SETTER_RETURN_before>> visitor_Type_PROPERTY_SETTER_RETURN_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_PROPERTY_SETTER_RETURN_before>> visitor_Type_PROPERTY_SETTER_RETURN_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_PROPERTY_SETTER_RETURN_before>> visitor_Type_PROPERTY_SETTER_RETURN_before_GeneratorDefaultHook;
        auto& get_visitor_Type_PROPERTY_SETTER_RETURN_before(const Context_Type_PROPERTY_SETTER_RETURN_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_BEFORE == 0) {
                return visitor_Type_PROPERTY_SETTER_RETURN_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_BEFORE == 1) {
                return visitor_Type_PROPERTY_SETTER_RETURN_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_BEFORE == 2) {
                return visitor_Type_PROPERTY_SETTER_RETURN_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_BEFORE == 3) {
                return visitor_Type_PROPERTY_SETTER_RETURN_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_BEFORE == 4) {
                return visitor_Type_PROPERTY_SETTER_RETURN_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_BEFORE == 5) {
                return visitor_Type_PROPERTY_SETTER_RETURN_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_BEFORE == 6) {
                return visitor_Type_PROPERTY_SETTER_RETURN_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_BEFORE < 7, "No suitable visitor hook found for Type_PROPERTY_SETTER_RETURN_before");
            }
        }
        Visitor<UserHook<VisitorTag_Type_PROPERTY_SETTER_RETURN_after>> visitor_Type_PROPERTY_SETTER_RETURN_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_PROPERTY_SETTER_RETURN_after>> visitor_Type_PROPERTY_SETTER_RETURN_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_PROPERTY_SETTER_RETURN_after>> visitor_Type_PROPERTY_SETTER_RETURN_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_PROPERTY_SETTER_RETURN_after>> visitor_Type_PROPERTY_SETTER_RETURN_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_PROPERTY_SETTER_RETURN_after>> visitor_Type_PROPERTY_SETTER_RETURN_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_PROPERTY_SETTER_RETURN_after>> visitor_Type_PROPERTY_SETTER_RETURN_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_PROPERTY_SETTER_RETURN_after>> visitor_Type_PROPERTY_SETTER_RETURN_after_GeneratorDefaultHook;
        auto& get_visitor_Type_PROPERTY_SETTER_RETURN_after(const Context_Type_PROPERTY_SETTER_RETURN_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_AFTER == 0) {
                return visitor_Type_PROPERTY_SETTER_RETURN_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_AFTER == 1) {
                return visitor_Type_PROPERTY_SETTER_RETURN_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_AFTER == 2) {
                return visitor_Type_PROPERTY_SETTER_RETURN_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_AFTER == 3) {
                return visitor_Type_PROPERTY_SETTER_RETURN_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_AFTER == 4) {
                return visitor_Type_PROPERTY_SETTER_RETURN_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_AFTER == 5) {
                return visitor_Type_PROPERTY_SETTER_RETURN_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_AFTER == 6) {
                return visitor_Type_PROPERTY_SETTER_RETURN_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_PROPERTY_SETTER_RETURN_AFTER < 7, "No suitable visitor hook found for Type_PROPERTY_SETTER_RETURN_after");
            }
        }
        Visitor<UserHook<VisitorTag_Type_OPTIONAL>> visitor_Type_OPTIONAL_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_OPTIONAL>> visitor_Type_OPTIONAL_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_OPTIONAL>> visitor_Type_OPTIONAL_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_OPTIONAL>> visitor_Type_OPTIONAL_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_OPTIONAL>> visitor_Type_OPTIONAL_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_OPTIONAL>> visitor_Type_OPTIONAL_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_OPTIONAL>> visitor_Type_OPTIONAL_GeneratorDefaultHook;
        auto& get_visitor_Type_OPTIONAL(const Context_Type_OPTIONAL&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL == 0) {
                return visitor_Type_OPTIONAL_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL == 1) {
                return visitor_Type_OPTIONAL_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL == 2) {
                return visitor_Type_OPTIONAL_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL == 3) {
                return visitor_Type_OPTIONAL_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL == 4) {
                return visitor_Type_OPTIONAL_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL == 5) {
                return visitor_Type_OPTIONAL_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL == 6) {
                return visitor_Type_OPTIONAL_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL < 7, "No suitable visitor hook found for Type_OPTIONAL");
            }
        }
        Visitor<UserHook<VisitorTag_Type_OPTIONAL_before>> visitor_Type_OPTIONAL_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_OPTIONAL_before>> visitor_Type_OPTIONAL_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_OPTIONAL_before>> visitor_Type_OPTIONAL_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_OPTIONAL_before>> visitor_Type_OPTIONAL_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_OPTIONAL_before>> visitor_Type_OPTIONAL_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_OPTIONAL_before>> visitor_Type_OPTIONAL_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_OPTIONAL_before>> visitor_Type_OPTIONAL_before_GeneratorDefaultHook;
        auto& get_visitor_Type_OPTIONAL_before(const Context_Type_OPTIONAL_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_BEFORE == 0) {
                return visitor_Type_OPTIONAL_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_BEFORE == 1) {
                return visitor_Type_OPTIONAL_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_BEFORE == 2) {
                return visitor_Type_OPTIONAL_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_BEFORE == 3) {
                return visitor_Type_OPTIONAL_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_BEFORE == 4) {
                return visitor_Type_OPTIONAL_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_BEFORE == 5) {
                return visitor_Type_OPTIONAL_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_BEFORE == 6) {
                return visitor_Type_OPTIONAL_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_BEFORE < 7, "No suitable visitor hook found for Type_OPTIONAL_before");
            }
        }
        Visitor<UserHook<VisitorTag_Type_OPTIONAL_after>> visitor_Type_OPTIONAL_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_OPTIONAL_after>> visitor_Type_OPTIONAL_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_OPTIONAL_after>> visitor_Type_OPTIONAL_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_OPTIONAL_after>> visitor_Type_OPTIONAL_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_OPTIONAL_after>> visitor_Type_OPTIONAL_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_OPTIONAL_after>> visitor_Type_OPTIONAL_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_OPTIONAL_after>> visitor_Type_OPTIONAL_after_GeneratorDefaultHook;
        auto& get_visitor_Type_OPTIONAL_after(const Context_Type_OPTIONAL_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_AFTER == 0) {
                return visitor_Type_OPTIONAL_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_AFTER == 1) {
                return visitor_Type_OPTIONAL_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_AFTER == 2) {
                return visitor_Type_OPTIONAL_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_AFTER == 3) {
                return visitor_Type_OPTIONAL_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_AFTER == 4) {
                return visitor_Type_OPTIONAL_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_AFTER == 5) {
                return visitor_Type_OPTIONAL_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_AFTER == 6) {
                return visitor_Type_OPTIONAL_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_OPTIONAL_AFTER < 7, "No suitable visitor hook found for Type_OPTIONAL_after");
            }
        }
        Visitor<UserHook<VisitorTag_Type_PTR>> visitor_Type_PTR_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_PTR>> visitor_Type_PTR_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_PTR>> visitor_Type_PTR_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_PTR>> visitor_Type_PTR_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_PTR>> visitor_Type_PTR_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_PTR>> visitor_Type_PTR_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_PTR>> visitor_Type_PTR_GeneratorDefaultHook;
        auto& get_visitor_Type_PTR(const Context_Type_PTR&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PTR == 0) {
                return visitor_Type_PTR_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PTR == 1) {
                return visitor_Type_PTR_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PTR == 2) {
                return visitor_Type_PTR_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PTR == 3) {
                return visitor_Type_PTR_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PTR == 4) {
                return visitor_Type_PTR_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PTR == 5) {
                return visitor_Type_PTR_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PTR == 6) {
                return visitor_Type_PTR_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_PTR>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_PTR < 7, "No suitable visitor hook found for Type_PTR");
            }
        }
        Visitor<UserHook<VisitorTag_Type_PTR_before>> visitor_Type_PTR_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_PTR_before>> visitor_Type_PTR_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_PTR_before>> visitor_Type_PTR_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_PTR_before>> visitor_Type_PTR_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_PTR_before>> visitor_Type_PTR_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_PTR_before>> visitor_Type_PTR_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_PTR_before>> visitor_Type_PTR_before_GeneratorDefaultHook;
        auto& get_visitor_Type_PTR_before(const Context_Type_PTR_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_BEFORE == 0) {
                return visitor_Type_PTR_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_BEFORE == 1) {
                return visitor_Type_PTR_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_BEFORE == 2) {
                return visitor_Type_PTR_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_BEFORE == 3) {
                return visitor_Type_PTR_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_BEFORE == 4) {
                return visitor_Type_PTR_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_BEFORE == 5) {
                return visitor_Type_PTR_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_BEFORE == 6) {
                return visitor_Type_PTR_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_BEFORE < 7, "No suitable visitor hook found for Type_PTR_before");
            }
        }
        Visitor<UserHook<VisitorTag_Type_PTR_after>> visitor_Type_PTR_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_PTR_after>> visitor_Type_PTR_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_PTR_after>> visitor_Type_PTR_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_PTR_after>> visitor_Type_PTR_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_PTR_after>> visitor_Type_PTR_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_PTR_after>> visitor_Type_PTR_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_PTR_after>> visitor_Type_PTR_after_GeneratorDefaultHook;
        auto& get_visitor_Type_PTR_after(const Context_Type_PTR_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_AFTER == 0) {
                return visitor_Type_PTR_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_AFTER == 1) {
                return visitor_Type_PTR_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_AFTER == 2) {
                return visitor_Type_PTR_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_AFTER == 3) {
                return visitor_Type_PTR_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_AFTER == 4) {
                return visitor_Type_PTR_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_AFTER == 5) {
                return visitor_Type_PTR_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_AFTER == 6) {
                return visitor_Type_PTR_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_PTR_AFTER < 7, "No suitable visitor hook found for Type_PTR_after");
            }
        }
        Visitor<UserHook<VisitorTag_Type_FUNCTION>> visitor_Type_FUNCTION_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_FUNCTION>> visitor_Type_FUNCTION_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_FUNCTION>> visitor_Type_FUNCTION_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_FUNCTION>> visitor_Type_FUNCTION_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_FUNCTION>> visitor_Type_FUNCTION_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_FUNCTION>> visitor_Type_FUNCTION_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_FUNCTION>> visitor_Type_FUNCTION_GeneratorDefaultHook;
        auto& get_visitor_Type_FUNCTION(const Context_Type_FUNCTION&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION == 0) {
                return visitor_Type_FUNCTION_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION == 1) {
                return visitor_Type_FUNCTION_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION == 2) {
                return visitor_Type_FUNCTION_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION == 3) {
                return visitor_Type_FUNCTION_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION == 4) {
                return visitor_Type_FUNCTION_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION == 5) {
                return visitor_Type_FUNCTION_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION == 6) {
                return visitor_Type_FUNCTION_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION < 7, "No suitable visitor hook found for Type_FUNCTION");
            }
        }
        Visitor<UserHook<VisitorTag_Type_FUNCTION_before>> visitor_Type_FUNCTION_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_FUNCTION_before>> visitor_Type_FUNCTION_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_FUNCTION_before>> visitor_Type_FUNCTION_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_FUNCTION_before>> visitor_Type_FUNCTION_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_FUNCTION_before>> visitor_Type_FUNCTION_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_FUNCTION_before>> visitor_Type_FUNCTION_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_FUNCTION_before>> visitor_Type_FUNCTION_before_GeneratorDefaultHook;
        auto& get_visitor_Type_FUNCTION_before(const Context_Type_FUNCTION_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_BEFORE == 0) {
                return visitor_Type_FUNCTION_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_BEFORE == 1) {
                return visitor_Type_FUNCTION_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_BEFORE == 2) {
                return visitor_Type_FUNCTION_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_BEFORE == 3) {
                return visitor_Type_FUNCTION_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_BEFORE == 4) {
                return visitor_Type_FUNCTION_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_BEFORE == 5) {
                return visitor_Type_FUNCTION_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_BEFORE == 6) {
                return visitor_Type_FUNCTION_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_BEFORE < 7, "No suitable visitor hook found for Type_FUNCTION_before");
            }
        }
        Visitor<UserHook<VisitorTag_Type_FUNCTION_after>> visitor_Type_FUNCTION_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_FUNCTION_after>> visitor_Type_FUNCTION_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_FUNCTION_after>> visitor_Type_FUNCTION_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_FUNCTION_after>> visitor_Type_FUNCTION_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_FUNCTION_after>> visitor_Type_FUNCTION_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_FUNCTION_after>> visitor_Type_FUNCTION_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_FUNCTION_after>> visitor_Type_FUNCTION_after_GeneratorDefaultHook;
        auto& get_visitor_Type_FUNCTION_after(const Context_Type_FUNCTION_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_AFTER == 0) {
                return visitor_Type_FUNCTION_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_AFTER == 1) {
                return visitor_Type_FUNCTION_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_AFTER == 2) {
                return visitor_Type_FUNCTION_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_AFTER == 3) {
                return visitor_Type_FUNCTION_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_AFTER == 4) {
                return visitor_Type_FUNCTION_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_AFTER == 5) {
                return visitor_Type_FUNCTION_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_AFTER == 6) {
                return visitor_Type_FUNCTION_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_FUNCTION_AFTER < 7, "No suitable visitor hook found for Type_FUNCTION_after");
            }
        }
        Visitor<UserHook<VisitorTag_Type>> visitor_Type_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type>> visitor_Type_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type>> visitor_Type_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type>> visitor_Type_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type>> visitor_Type_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type>> visitor_Type_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type>> visitor_Type_GeneratorDefaultHook;
        auto& get_visitor_Type(const Context_Type&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE == 0) {
                return visitor_Type_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE == 1) {
                return visitor_Type_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE == 2) {
                return visitor_Type_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE == 3) {
                return visitor_Type_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE == 4) {
                return visitor_Type_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE == 5) {
                return visitor_Type_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE == 6) {
                return visitor_Type_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE < 7, "No suitable visitor hook found for Type");
            }
        }
        Visitor<UserHook<VisitorTag_Type_before>> visitor_Type_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_before>> visitor_Type_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_before>> visitor_Type_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_before>> visitor_Type_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_before>> visitor_Type_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_before>> visitor_Type_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_before>> visitor_Type_before_GeneratorDefaultHook;
        auto& get_visitor_Type_before(const Context_Type_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BEFORE == 0) {
                return visitor_Type_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BEFORE == 1) {
                return visitor_Type_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BEFORE == 2) {
                return visitor_Type_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BEFORE == 3) {
                return visitor_Type_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BEFORE == 4) {
                return visitor_Type_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BEFORE == 5) {
                return visitor_Type_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_BEFORE == 6) {
                return visitor_Type_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_BEFORE < 7, "No suitable visitor hook found for Type_before");
            }
        }
        Visitor<UserHook<VisitorTag_Type_after>> visitor_Type_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Type_after>> visitor_Type_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Type_after>> visitor_Type_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Type_after>> visitor_Type_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Type_after>> visitor_Type_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Type_after>> visitor_Type_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Type_after>> visitor_Type_after_GeneratorDefaultHook;
        auto& get_visitor_Type_after(const Context_Type_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_AFTER == 0) {
                return visitor_Type_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_AFTER == 1) {
                return visitor_Type_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_AFTER == 2) {
                return visitor_Type_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_AFTER == 3) {
                return visitor_Type_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_AFTER == 4) {
                return visitor_Type_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_AFTER == 5) {
                return visitor_Type_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPE_AFTER == 6) {
                return visitor_Type_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPE_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPE_AFTER < 7, "No suitable visitor hook found for Type_after");
            }
        }
        Visitor<UserHook<VisitorTag_Types>> visitor_Types_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Types>> visitor_Types_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Types>> visitor_Types_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Types>> visitor_Types_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Types>> visitor_Types_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Types>> visitor_Types_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Types>> visitor_Types_GeneratorDefaultHook;
        auto& get_visitor_Types(const Context_Types&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPES == 0) {
                return visitor_Types_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPES == 1) {
                return visitor_Types_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPES == 2) {
                return visitor_Types_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPES == 3) {
                return visitor_Types_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPES == 4) {
                return visitor_Types_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPES == 5) {
                return visitor_Types_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPES == 6) {
                return visitor_Types_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPES>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPES < 7, "No suitable visitor hook found for Types");
            }
        }
        Visitor<UserHook<VisitorTag_Types_before>> visitor_Types_before_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Types_before>> visitor_Types_before_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Types_before>> visitor_Types_before_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Types_before>> visitor_Types_before_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Types_before>> visitor_Types_before_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Types_before>> visitor_Types_before_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Types_before>> visitor_Types_before_GeneratorDefaultHook;
        auto& get_visitor_Types_before(const Context_Types_before<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPES_BEFORE == 0) {
                return visitor_Types_before_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPES_BEFORE == 1) {
                return visitor_Types_before_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPES_BEFORE == 2) {
                return visitor_Types_before_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPES_BEFORE == 3) {
                return visitor_Types_before_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPES_BEFORE == 4) {
                return visitor_Types_before_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPES_BEFORE == 5) {
                return visitor_Types_before_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPES_BEFORE == 6) {
                return visitor_Types_before_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPES_BEFORE>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPES_BEFORE < 7, "No suitable visitor hook found for Types_before");
            }
        }
        Visitor<UserHook<VisitorTag_Types_after>> visitor_Types_after_UserHook;
        Visitor<UserInlinedHook<VisitorTag_Types_after>> visitor_Types_after_UserInlinedHook;
        Visitor<UserDSLHook<VisitorTag_Types_after>> visitor_Types_after_UserDSLHook;
        Visitor<UserInlinedDSLHook<VisitorTag_Types_after>> visitor_Types_after_UserInlinedDSLHook;
        Visitor<DefaultCodegenVisitorHook<VisitorTag_Types_after>> visitor_Types_after_DefaultCodegenVisitorHook;
        Visitor<DefaultCodegenVisitorInlinedHook<VisitorTag_Types_after>> visitor_Types_after_DefaultCodegenVisitorInlinedHook;
        Visitor<GeneratorDefaultHook<VisitorTag_Types_after>> visitor_Types_after_GeneratorDefaultHook;
        auto& get_visitor_Types_after(const Context_Types_after<Result>&) {
            if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPES_AFTER == 0) {
                return visitor_Types_after_UserHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPES_AFTER == 1) {
                return visitor_Types_after_UserInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPES_AFTER == 2) {
                return visitor_Types_after_UserDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPES_AFTER == 3) {
                return visitor_Types_after_UserInlinedDSLHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPES_AFTER == 4) {
                return visitor_Types_after_DefaultCodegenVisitorHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPES_AFTER == 5) {
                return visitor_Types_after_DefaultCodegenVisitorInlinedHook;
            }
            else if constexpr (CODEGEN_EXPECTED_PRIORITY_TYPES_AFTER == 6) {
                return visitor_Types_after_GeneratorDefaultHook;
            }
            else {
                static_assert(CODEGEN_EXPECTED_PRIORITY_TYPES_AFTER>= 0 && CODEGEN_EXPECTED_PRIORITY_TYPES_AFTER < 7, "No suitable visitor hook found for Types_after");
            }
        }
    };
    struct MergedVisitor : BaseVisitor {
        MergedVisitor(ebmgen::EBMProxy module_,Flags& flags,Output& output,futils::binary::writer& wm,VisitorsImpl& impl) :BaseVisitor(this, module_, flags, output, wm),impl(impl){}
    
        VisitorsImpl& impl;
        expected<Result> visit(Context_entry& ctx) {
            auto visitor = impl.get_visitor_entry(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_entry_before<Result>& ctx) {
            auto visitor = impl.get_visitor_entry_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_entry_after<Result>& ctx) {
            auto visitor = impl.get_visitor_entry_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_pre_visitor& ctx) {
            auto visitor = impl.get_visitor_pre_visitor(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_pre_visitor_before<Result>& ctx) {
            auto visitor = impl.get_visitor_pre_visitor_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_pre_visitor_after<Result>& ctx) {
            auto visitor = impl.get_visitor_pre_visitor_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_post_entry<Result>& ctx) {
            auto visitor = impl.get_visitor_post_entry(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_post_entry_before<Result>& ctx) {
            auto visitor = impl.get_visitor_post_entry_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_post_entry_after<Result>& ctx) {
            auto visitor = impl.get_visitor_post_entry_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_BLOCK& ctx) {
            auto visitor = impl.get_visitor_Statement_BLOCK(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_BLOCK_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_BLOCK_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_BLOCK_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_BLOCK_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_ASSIGNMENT& ctx) {
            auto visitor = impl.get_visitor_Statement_ASSIGNMENT(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_ASSIGNMENT_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_ASSIGNMENT_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_ASSIGNMENT_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_ASSIGNMENT_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_YIELD& ctx) {
            auto visitor = impl.get_visitor_Statement_YIELD(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_YIELD_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_YIELD_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_YIELD_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_YIELD_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_APPEND& ctx) {
            auto visitor = impl.get_visitor_Statement_APPEND(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_APPEND_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_APPEND_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_APPEND_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_APPEND_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_RETURN& ctx) {
            auto visitor = impl.get_visitor_Statement_RETURN(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_RETURN_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_RETURN_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_RETURN_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_RETURN_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_ERROR_RETURN& ctx) {
            auto visitor = impl.get_visitor_Statement_ERROR_RETURN(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_ERROR_RETURN_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_ERROR_RETURN_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_ERROR_RETURN_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_ERROR_RETURN_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_ASSERT& ctx) {
            auto visitor = impl.get_visitor_Statement_ASSERT(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_ASSERT_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_ASSERT_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_ASSERT_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_ASSERT_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_READ_DATA& ctx) {
            auto visitor = impl.get_visitor_Statement_READ_DATA(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_READ_DATA_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_READ_DATA_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_READ_DATA_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_READ_DATA_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_WRITE_DATA& ctx) {
            auto visitor = impl.get_visitor_Statement_WRITE_DATA(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_WRITE_DATA_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_WRITE_DATA_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_WRITE_DATA_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_WRITE_DATA_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_RESERVE_DATA& ctx) {
            auto visitor = impl.get_visitor_Statement_RESERVE_DATA(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_RESERVE_DATA_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_RESERVE_DATA_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_RESERVE_DATA_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_RESERVE_DATA_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_IF_STATEMENT& ctx) {
            auto visitor = impl.get_visitor_Statement_IF_STATEMENT(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_IF_STATEMENT_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_IF_STATEMENT_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_IF_STATEMENT_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_IF_STATEMENT_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_LOOP_STATEMENT& ctx) {
            auto visitor = impl.get_visitor_Statement_LOOP_STATEMENT(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_LOOP_STATEMENT_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_LOOP_STATEMENT_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_LOOP_STATEMENT_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_LOOP_STATEMENT_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_MATCH_STATEMENT& ctx) {
            auto visitor = impl.get_visitor_Statement_MATCH_STATEMENT(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_MATCH_STATEMENT_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_MATCH_STATEMENT_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_MATCH_STATEMENT_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_MATCH_STATEMENT_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_MATCH_BRANCH& ctx) {
            auto visitor = impl.get_visitor_Statement_MATCH_BRANCH(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_MATCH_BRANCH_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_MATCH_BRANCH_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_MATCH_BRANCH_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_MATCH_BRANCH_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_BREAK& ctx) {
            auto visitor = impl.get_visitor_Statement_BREAK(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_BREAK_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_BREAK_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_BREAK_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_BREAK_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_CONTINUE& ctx) {
            auto visitor = impl.get_visitor_Statement_CONTINUE(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_CONTINUE_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_CONTINUE_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_CONTINUE_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_CONTINUE_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_FUNCTION_DECL& ctx) {
            auto visitor = impl.get_visitor_Statement_FUNCTION_DECL(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_FUNCTION_DECL_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_FUNCTION_DECL_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_FUNCTION_DECL_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_FUNCTION_DECL_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_VARIABLE_DECL& ctx) {
            auto visitor = impl.get_visitor_Statement_VARIABLE_DECL(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_VARIABLE_DECL_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_VARIABLE_DECL_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_VARIABLE_DECL_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_VARIABLE_DECL_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_PARAMETER_DECL& ctx) {
            auto visitor = impl.get_visitor_Statement_PARAMETER_DECL(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_PARAMETER_DECL_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_PARAMETER_DECL_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_PARAMETER_DECL_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_PARAMETER_DECL_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_FIELD_DECL& ctx) {
            auto visitor = impl.get_visitor_Statement_FIELD_DECL(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_FIELD_DECL_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_FIELD_DECL_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_FIELD_DECL_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_FIELD_DECL_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_COMPOSITE_FIELD_DECL& ctx) {
            auto visitor = impl.get_visitor_Statement_COMPOSITE_FIELD_DECL(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_COMPOSITE_FIELD_DECL_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_COMPOSITE_FIELD_DECL_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_COMPOSITE_FIELD_DECL_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_COMPOSITE_FIELD_DECL_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_ENUM_DECL& ctx) {
            auto visitor = impl.get_visitor_Statement_ENUM_DECL(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_ENUM_DECL_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_ENUM_DECL_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_ENUM_DECL_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_ENUM_DECL_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_ENUM_MEMBER_DECL& ctx) {
            auto visitor = impl.get_visitor_Statement_ENUM_MEMBER_DECL(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_ENUM_MEMBER_DECL_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_ENUM_MEMBER_DECL_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_ENUM_MEMBER_DECL_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_ENUM_MEMBER_DECL_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_STRUCT_DECL& ctx) {
            auto visitor = impl.get_visitor_Statement_STRUCT_DECL(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_STRUCT_DECL_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_STRUCT_DECL_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_STRUCT_DECL_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_STRUCT_DECL_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_UNION_DECL& ctx) {
            auto visitor = impl.get_visitor_Statement_UNION_DECL(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_UNION_DECL_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_UNION_DECL_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_UNION_DECL_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_UNION_DECL_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_UNION_MEMBER_DECL& ctx) {
            auto visitor = impl.get_visitor_Statement_UNION_MEMBER_DECL(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_UNION_MEMBER_DECL_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_UNION_MEMBER_DECL_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_UNION_MEMBER_DECL_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_UNION_MEMBER_DECL_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_PROGRAM_DECL& ctx) {
            auto visitor = impl.get_visitor_Statement_PROGRAM_DECL(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_PROGRAM_DECL_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_PROGRAM_DECL_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_PROGRAM_DECL_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_PROGRAM_DECL_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_PROPERTY_DECL& ctx) {
            auto visitor = impl.get_visitor_Statement_PROPERTY_DECL(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_PROPERTY_DECL_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_PROPERTY_DECL_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_PROPERTY_DECL_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_PROPERTY_DECL_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_PROPERTY_MEMBER_DECL& ctx) {
            auto visitor = impl.get_visitor_Statement_PROPERTY_MEMBER_DECL(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_PROPERTY_MEMBER_DECL_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_PROPERTY_MEMBER_DECL_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_PROPERTY_MEMBER_DECL_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_PROPERTY_MEMBER_DECL_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_METADATA& ctx) {
            auto visitor = impl.get_visitor_Statement_METADATA(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_METADATA_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_METADATA_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_METADATA_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_METADATA_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_IMPORT_MODULE& ctx) {
            auto visitor = impl.get_visitor_Statement_IMPORT_MODULE(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_IMPORT_MODULE_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_IMPORT_MODULE_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_IMPORT_MODULE_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_IMPORT_MODULE_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_EXPRESSION& ctx) {
            auto visitor = impl.get_visitor_Statement_EXPRESSION(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_EXPRESSION_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_EXPRESSION_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_EXPRESSION_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_EXPRESSION_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_ERROR_REPORT& ctx) {
            auto visitor = impl.get_visitor_Statement_ERROR_REPORT(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_ERROR_REPORT_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_ERROR_REPORT_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_ERROR_REPORT_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_ERROR_REPORT_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_LOWERED_IO_STATEMENTS& ctx) {
            auto visitor = impl.get_visitor_Statement_LOWERED_IO_STATEMENTS(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_LOWERED_IO_STATEMENTS_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_LOWERED_IO_STATEMENTS_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_LOWERED_IO_STATEMENTS_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_LOWERED_IO_STATEMENTS_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_SUB_BYTE_RANGE& ctx) {
            auto visitor = impl.get_visitor_Statement_SUB_BYTE_RANGE(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_SUB_BYTE_RANGE_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_SUB_BYTE_RANGE_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_SUB_BYTE_RANGE_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_SUB_BYTE_RANGE_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_INIT_CHECK& ctx) {
            auto visitor = impl.get_visitor_Statement_INIT_CHECK(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_INIT_CHECK_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_INIT_CHECK_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_INIT_CHECK_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_INIT_CHECK_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_ENDIAN_VARIABLE& ctx) {
            auto visitor = impl.get_visitor_Statement_ENDIAN_VARIABLE(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_ENDIAN_VARIABLE_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_ENDIAN_VARIABLE_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_ENDIAN_VARIABLE_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_ENDIAN_VARIABLE_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement& ctx) {
            auto visitor = impl.get_visitor_Statement(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Statement_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Statement_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Block& ctx) {
            auto visitor = impl.get_visitor_Block(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Block_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Block_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Block_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Block_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_LITERAL_INT& ctx) {
            auto visitor = impl.get_visitor_Expression_LITERAL_INT(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_LITERAL_INT_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_LITERAL_INT_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_LITERAL_INT_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_LITERAL_INT_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_LITERAL_INT64& ctx) {
            auto visitor = impl.get_visitor_Expression_LITERAL_INT64(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_LITERAL_INT64_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_LITERAL_INT64_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_LITERAL_INT64_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_LITERAL_INT64_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_LITERAL_BOOL& ctx) {
            auto visitor = impl.get_visitor_Expression_LITERAL_BOOL(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_LITERAL_BOOL_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_LITERAL_BOOL_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_LITERAL_BOOL_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_LITERAL_BOOL_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_LITERAL_STRING& ctx) {
            auto visitor = impl.get_visitor_Expression_LITERAL_STRING(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_LITERAL_STRING_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_LITERAL_STRING_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_LITERAL_STRING_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_LITERAL_STRING_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_LITERAL_TYPE& ctx) {
            auto visitor = impl.get_visitor_Expression_LITERAL_TYPE(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_LITERAL_TYPE_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_LITERAL_TYPE_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_LITERAL_TYPE_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_LITERAL_TYPE_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_LITERAL_CHAR& ctx) {
            auto visitor = impl.get_visitor_Expression_LITERAL_CHAR(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_LITERAL_CHAR_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_LITERAL_CHAR_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_LITERAL_CHAR_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_LITERAL_CHAR_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_IDENTIFIER& ctx) {
            auto visitor = impl.get_visitor_Expression_IDENTIFIER(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_IDENTIFIER_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_IDENTIFIER_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_IDENTIFIER_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_IDENTIFIER_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_BINARY_OP& ctx) {
            auto visitor = impl.get_visitor_Expression_BINARY_OP(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_BINARY_OP_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_BINARY_OP_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_BINARY_OP_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_BINARY_OP_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_UNARY_OP& ctx) {
            auto visitor = impl.get_visitor_Expression_UNARY_OP(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_UNARY_OP_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_UNARY_OP_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_UNARY_OP_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_UNARY_OP_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_CALL& ctx) {
            auto visitor = impl.get_visitor_Expression_CALL(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_CALL_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_CALL_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_CALL_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_CALL_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_INDEX_ACCESS& ctx) {
            auto visitor = impl.get_visitor_Expression_INDEX_ACCESS(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_INDEX_ACCESS_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_INDEX_ACCESS_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_INDEX_ACCESS_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_INDEX_ACCESS_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_MEMBER_ACCESS& ctx) {
            auto visitor = impl.get_visitor_Expression_MEMBER_ACCESS(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_MEMBER_ACCESS_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_MEMBER_ACCESS_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_MEMBER_ACCESS_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_MEMBER_ACCESS_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_ENUM_MEMBER& ctx) {
            auto visitor = impl.get_visitor_Expression_ENUM_MEMBER(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_ENUM_MEMBER_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_ENUM_MEMBER_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_ENUM_MEMBER_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_ENUM_MEMBER_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_TYPE_CAST& ctx) {
            auto visitor = impl.get_visitor_Expression_TYPE_CAST(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_TYPE_CAST_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_TYPE_CAST_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_TYPE_CAST_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_TYPE_CAST_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_RANGE& ctx) {
            auto visitor = impl.get_visitor_Expression_RANGE(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_RANGE_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_RANGE_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_RANGE_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_RANGE_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_DEFAULT_VALUE& ctx) {
            auto visitor = impl.get_visitor_Expression_DEFAULT_VALUE(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_DEFAULT_VALUE_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_DEFAULT_VALUE_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_DEFAULT_VALUE_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_DEFAULT_VALUE_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_IS_LITTLE_ENDIAN& ctx) {
            auto visitor = impl.get_visitor_Expression_IS_LITTLE_ENDIAN(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_IS_LITTLE_ENDIAN_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_IS_LITTLE_ENDIAN_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_IS_LITTLE_ENDIAN_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_IS_LITTLE_ENDIAN_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_GET_STREAM_OFFSET& ctx) {
            auto visitor = impl.get_visitor_Expression_GET_STREAM_OFFSET(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_GET_STREAM_OFFSET_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_GET_STREAM_OFFSET_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_GET_STREAM_OFFSET_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_GET_STREAM_OFFSET_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_GET_REMAINING_BYTES& ctx) {
            auto visitor = impl.get_visitor_Expression_GET_REMAINING_BYTES(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_GET_REMAINING_BYTES_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_GET_REMAINING_BYTES_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_GET_REMAINING_BYTES_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_GET_REMAINING_BYTES_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_CAN_READ_STREAM& ctx) {
            auto visitor = impl.get_visitor_Expression_CAN_READ_STREAM(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_CAN_READ_STREAM_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_CAN_READ_STREAM_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_CAN_READ_STREAM_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_CAN_READ_STREAM_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_ARRAY_SIZE& ctx) {
            auto visitor = impl.get_visitor_Expression_ARRAY_SIZE(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_ARRAY_SIZE_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_ARRAY_SIZE_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_ARRAY_SIZE_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_ARRAY_SIZE_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_ENUM_IS_DEFINED& ctx) {
            auto visitor = impl.get_visitor_Expression_ENUM_IS_DEFINED(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_ENUM_IS_DEFINED_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_ENUM_IS_DEFINED_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_ENUM_IS_DEFINED_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_ENUM_IS_DEFINED_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_IS_ERROR& ctx) {
            auto visitor = impl.get_visitor_Expression_IS_ERROR(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_IS_ERROR_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_IS_ERROR_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_IS_ERROR_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_IS_ERROR_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_MAX_VALUE& ctx) {
            auto visitor = impl.get_visitor_Expression_MAX_VALUE(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_MAX_VALUE_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_MAX_VALUE_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_MAX_VALUE_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_MAX_VALUE_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_READ_DATA& ctx) {
            auto visitor = impl.get_visitor_Expression_READ_DATA(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_READ_DATA_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_READ_DATA_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_READ_DATA_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_READ_DATA_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_WRITE_DATA& ctx) {
            auto visitor = impl.get_visitor_Expression_WRITE_DATA(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_WRITE_DATA_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_WRITE_DATA_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_WRITE_DATA_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_WRITE_DATA_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_CONDITIONAL_STATEMENT& ctx) {
            auto visitor = impl.get_visitor_Expression_CONDITIONAL_STATEMENT(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_CONDITIONAL_STATEMENT_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_CONDITIONAL_STATEMENT_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_CONDITIONAL_STATEMENT_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_CONDITIONAL_STATEMENT_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_CONDITIONAL& ctx) {
            auto visitor = impl.get_visitor_Expression_CONDITIONAL(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_CONDITIONAL_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_CONDITIONAL_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_CONDITIONAL_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_CONDITIONAL_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_AVAILABLE& ctx) {
            auto visitor = impl.get_visitor_Expression_AVAILABLE(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_AVAILABLE_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_AVAILABLE_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_AVAILABLE_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_AVAILABLE_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_SIZEOF& ctx) {
            auto visitor = impl.get_visitor_Expression_SIZEOF(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_SIZEOF_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_SIZEOF_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_SIZEOF_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_SIZEOF_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_SUB_RANGE_INIT& ctx) {
            auto visitor = impl.get_visitor_Expression_SUB_RANGE_INIT(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_SUB_RANGE_INIT_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_SUB_RANGE_INIT_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_SUB_RANGE_INIT_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_SUB_RANGE_INIT_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_OR_COND& ctx) {
            auto visitor = impl.get_visitor_Expression_OR_COND(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_OR_COND_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_OR_COND_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_OR_COND_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_OR_COND_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_ADDRESS_OF& ctx) {
            auto visitor = impl.get_visitor_Expression_ADDRESS_OF(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_ADDRESS_OF_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_ADDRESS_OF_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_ADDRESS_OF_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_ADDRESS_OF_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_OPTIONAL_OF& ctx) {
            auto visitor = impl.get_visitor_Expression_OPTIONAL_OF(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_OPTIONAL_OF_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_OPTIONAL_OF_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_OPTIONAL_OF_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_OPTIONAL_OF_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_SETTER_STATUS& ctx) {
            auto visitor = impl.get_visitor_Expression_SETTER_STATUS(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_SETTER_STATUS_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_SETTER_STATUS_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_SETTER_STATUS_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_SETTER_STATUS_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_SELF& ctx) {
            auto visitor = impl.get_visitor_Expression_SELF(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_SELF_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_SELF_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_SELF_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_SELF_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_AS_ARG& ctx) {
            auto visitor = impl.get_visitor_Expression_AS_ARG(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_AS_ARG_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_AS_ARG_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_AS_ARG_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_AS_ARG_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression& ctx) {
            auto visitor = impl.get_visitor_Expression(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expression_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expression_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expressions& ctx) {
            auto visitor = impl.get_visitor_Expressions(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expressions_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Expressions_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Expressions_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Expressions_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_INT& ctx) {
            auto visitor = impl.get_visitor_Type_INT(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_INT_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_INT_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_INT_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_INT_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_UINT& ctx) {
            auto visitor = impl.get_visitor_Type_UINT(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_UINT_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_UINT_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_UINT_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_UINT_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_USIZE& ctx) {
            auto visitor = impl.get_visitor_Type_USIZE(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_USIZE_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_USIZE_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_USIZE_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_USIZE_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_FLOAT& ctx) {
            auto visitor = impl.get_visitor_Type_FLOAT(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_FLOAT_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_FLOAT_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_FLOAT_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_FLOAT_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_STRUCT& ctx) {
            auto visitor = impl.get_visitor_Type_STRUCT(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_STRUCT_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_STRUCT_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_STRUCT_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_STRUCT_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_RECURSIVE_STRUCT& ctx) {
            auto visitor = impl.get_visitor_Type_RECURSIVE_STRUCT(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_RECURSIVE_STRUCT_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_RECURSIVE_STRUCT_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_RECURSIVE_STRUCT_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_RECURSIVE_STRUCT_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_BOOL& ctx) {
            auto visitor = impl.get_visitor_Type_BOOL(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_BOOL_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_BOOL_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_BOOL_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_BOOL_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_VOID& ctx) {
            auto visitor = impl.get_visitor_Type_VOID(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_VOID_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_VOID_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_VOID_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_VOID_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_META& ctx) {
            auto visitor = impl.get_visitor_Type_META(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_META_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_META_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_META_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_META_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_ENUM& ctx) {
            auto visitor = impl.get_visitor_Type_ENUM(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_ENUM_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_ENUM_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_ENUM_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_ENUM_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_ARRAY& ctx) {
            auto visitor = impl.get_visitor_Type_ARRAY(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_ARRAY_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_ARRAY_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_ARRAY_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_ARRAY_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_VECTOR& ctx) {
            auto visitor = impl.get_visitor_Type_VECTOR(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_VECTOR_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_VECTOR_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_VECTOR_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_VECTOR_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_VARIANT& ctx) {
            auto visitor = impl.get_visitor_Type_VARIANT(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_VARIANT_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_VARIANT_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_VARIANT_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_VARIANT_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_RANGE& ctx) {
            auto visitor = impl.get_visitor_Type_RANGE(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_RANGE_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_RANGE_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_RANGE_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_RANGE_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_ENCODER_RETURN& ctx) {
            auto visitor = impl.get_visitor_Type_ENCODER_RETURN(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_ENCODER_RETURN_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_ENCODER_RETURN_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_ENCODER_RETURN_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_ENCODER_RETURN_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_DECODER_RETURN& ctx) {
            auto visitor = impl.get_visitor_Type_DECODER_RETURN(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_DECODER_RETURN_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_DECODER_RETURN_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_DECODER_RETURN_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_DECODER_RETURN_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_ENCODER_INPUT& ctx) {
            auto visitor = impl.get_visitor_Type_ENCODER_INPUT(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_ENCODER_INPUT_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_ENCODER_INPUT_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_ENCODER_INPUT_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_ENCODER_INPUT_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_DECODER_INPUT& ctx) {
            auto visitor = impl.get_visitor_Type_DECODER_INPUT(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_DECODER_INPUT_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_DECODER_INPUT_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_DECODER_INPUT_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_DECODER_INPUT_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_PROPERTY_SETTER_RETURN& ctx) {
            auto visitor = impl.get_visitor_Type_PROPERTY_SETTER_RETURN(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_PROPERTY_SETTER_RETURN_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_PROPERTY_SETTER_RETURN_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_PROPERTY_SETTER_RETURN_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_PROPERTY_SETTER_RETURN_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_OPTIONAL& ctx) {
            auto visitor = impl.get_visitor_Type_OPTIONAL(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_OPTIONAL_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_OPTIONAL_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_OPTIONAL_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_OPTIONAL_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_PTR& ctx) {
            auto visitor = impl.get_visitor_Type_PTR(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_PTR_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_PTR_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_PTR_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_PTR_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_FUNCTION& ctx) {
            auto visitor = impl.get_visitor_Type_FUNCTION(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_FUNCTION_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_FUNCTION_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_FUNCTION_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_FUNCTION_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type& ctx) {
            auto visitor = impl.get_visitor_Type(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Type_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Type_after(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Types& ctx) {
            auto visitor = impl.get_visitor_Types(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Types_before<Result>& ctx) {
            auto visitor = impl.get_visitor_Types_before(ctx);
            return visitor.visit(ctx);
        }
        expected<Result> visit(Context_Types_after<Result>& ctx) {
            auto visitor = impl.get_visitor_Types_after(ctx);
            return visitor.visit(ctx);
        }
    };
    template<class R, typename Context,typename Callback>
    R get_visitor_impl(Context&& ctx,Callback&& cb) {
        return cb(ctx.visitor.__legacy_compat_ptr->impl);
    }
    expected<Result> visit_unimplemented(MergedVisitor& visitor,std::string_view kind,std::uint64_t item_id) {
        if (visitor.flags.debug_unimplemented) {
            return std::format("{{{{Unimplemented {} {}}}}}", kind, item_id);
            }
            return expected<Result>{}; // Unimplemented
    }
}  // namespace ebm2python
DEFINE_ENTRY(ebm2python::Flags, ebm2python::Output) {
    ebm2python::VisitorsImpl visitors_impl;
    ebm2python::MergedVisitor visitor{ebm,flags,output,w,visitors_impl};
    auto entry_function = [&]() -> ebmgen::expected<ebm2python::Result> {
        ebm2python::InitialContext initial_ctx{.visitor = visitor};
        auto pre_visit_result = ebm2python::dispatch_pre_visitor(initial_ctx,ebm);
        if (!pre_visit_result) {
            if(!ebmcodegen::util::is_pass_error(pre_visit_result.error())) {
                return ebmgen::unexpect_error(std::move(pre_visit_result.error())); // for trace
            }
        }
        else { // if hijacked
            return pre_visit_result;
        }
        if(!visitor.module_.valid()) {
            visitor.module_.build_maps(); // initialize mapping tables if not yet
        }
        auto entry_result = ebm2python::dispatch_entry(initial_ctx);
        auto post_visit_result = ebm2python::dispatch_post_entry(initial_ctx,entry_result);
        if (!post_visit_result) {
            if(!ebmcodegen::util::is_pass_error(post_visit_result.error())) {
                return ebmgen::unexpect_error(std::move(post_visit_result.error())); // for trace
            }
        }
        else { // if hijacked
            return post_visit_result;
        }
        return entry_result;
    };
    auto result = entry_function();
    if (!result) {
        futils::wrap::cerr_wrap() << visitor.program_name << ": error: " << result.error().error();
        return 1;
    }
    return 0;
}
