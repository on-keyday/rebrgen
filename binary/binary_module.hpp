// Code generated by json2cpp2
#pragma once
#include <cstdint>
#include <vector>
#include <array>
#include <optional>
#include <variant>

#include <binary/flags.h>
#include <binary/float.h>
#include <view/iovec.h>
#include <binary/number.h>
#include <string>
namespace rebgn {
    enum class AbstractOp : std::uint8_t {
        NOP = 0,
        METADATA = 1,
        IMPORT = 2,
        SPECIFY_ENDIAN = 3,
        SPECIFY_BIT_ORDER = 4,
        SPECIFY_ALIGNMENT = 5,
        SPECIFY_LENGTH = 6,
        EXPLICIT_ERROR = 7,
        MAP_TYPE = 8,
        DEFINE_FORMAT = 9,
        END_FORMAT = 10,
        DEFINE_FIELD = 11,
        END_FIELD = 12,
        DEFINE_FUNCTION = 13,
        END_FUNCTION = 14,
        DEFINE_ENUM = 15,
        END_ENUM = 16,
        DEFINE_ENUM_MEMBER = 17,
        END_ENUM_MEMBER = 18,
        DEFINE_UNION = 19,
        END_UNION = 20,
        ENCODE_INT = 21,
        DECODE_INT = 22,
        ENCODE_FLOAT = 23,
        DECODE_FLOAT = 24,
        CALL_ENCODE = 25,
        CALL_DECODE = 26,
        LOOP = 27,
        END_LOOP = 28,
        IF = 29,
        ELIF = 30,
        ELSE = 31,
        END_IF = 32,
        MATCH = 33,
        CASE = 34,
        END_MATCH = 35,
        DEFINE_VARIABLE = 36,
        END_VARIABLE = 37,
        ASSIGN = 38,
        ACCESS = 39,
        ENUM_MEMBER = 40,
        INDEX = 41,
        APPEND = 42,
        ADD = 43,
        SUB = 44,
        MUL = 45,
        DIV = 46,
        MOD = 47,
        AND = 48,
        OR = 49,
        XOR = 50,
        NOT = 51,
        SHL = 52,
        SHR = 53,
        INC = 54,
        DEC = 55,
        NEG = 56,
        CALL = 57,
        RET = 58,
    };
    struct Varint;
    struct Code;
    struct String;
    struct StringRef;
    struct BinaryModule;
    struct Varint {
        ::futils::binary::flags_t<std::uint64_t, 2, 62> flags_1_;
        bits_flag_alias_method(flags_1_, 0, prefix);
        bits_flag_alias_method(flags_1_, 1, value);
        bool encode(::futils::binary::writer& w) const;
        bool decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 0;
    };
    struct Code {
        AbstractOp op{};
        bool encode(::futils::binary::writer& w) const;
        bool decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
    };
    struct String {
        Varint length;
        std::string data;
        bool encode(::futils::binary::writer& w) const;
        bool decode(::futils::binary::reader& r);
    };
    struct StringRef {
        Varint code;
        String string;
        bool encode(::futils::binary::writer& w) const;
        bool decode(::futils::binary::reader& r);
    };
    struct BinaryModule {
        Varint string_refs_length;
        std::vector<StringRef> string_refs;
        Varint code_length;
        std::vector<Code> code;
        bool encode(::futils::binary::writer& w) const;
        bool decode(::futils::binary::reader& r);
    };
    inline bool Varint::encode(::futils::binary::writer& w) const {
        if ((*this).prefix() == 0) {
            std::uint8_t tmp2 = 0;
            tmp2 = (*this).value();
            tmp2 |= std::uint8_t(0) << 6;
            if (!::futils::binary::write_num(w, tmp2, true)) {
                return false;
            }
        }
        else if ((*this).prefix() == 1) {
            std::uint16_t tmp2 = 0;
            tmp2 = (*this).value();
            tmp2 |= std::uint16_t(1) << 14;
            if (!::futils::binary::write_num(w, tmp2, true)) {
                return false;
            }
        }
        else if ((*this).prefix() == 2) {
            std::uint32_t tmp2 = 0;
            tmp2 = (*this).value();
            tmp2 |= std::uint32_t(2) << 30;
            if (!::futils::binary::write_num(w, tmp2, true)) {
                return false;
            }
        }
        else if ((*this).prefix() == 3) {
            std::uint64_t tmp2 = 0;
            tmp2 = (*this).value();
            tmp2 |= std::uint64_t(3) << 62;
            if (!::futils::binary::write_num(w, tmp2, true)) {
                return false;
            }
        }
        return true;
    }
    inline bool Varint::decode(::futils::binary::reader& r) {
        if (!r.load_stream(1)) {
            return false;
        }
        std::uint8_t tmp3 = (r.top() >> 6) & 0x3;
        (*this).prefix(tmp3);
        if ((*this).prefix() == 0) {
            std::uint8_t tmp4 = 0;
            if (!::futils::binary::read_num(r, tmp4, true)) {
                return false;
            }
            tmp4 &= ~(std::uint8_t(0x3) << 6);
            (*this).value(tmp4);
        }
        else if ((*this).prefix() == 1) {
            std::uint16_t tmp5 = 0;
            if (!::futils::binary::read_num(r, tmp5, true)) {
                return false;
            }
            tmp5 &= ~(std::uint16_t(0x3) << 14);
            (*this).value(tmp5);
        }
        else if ((*this).prefix() == 2) {
            std::uint32_t tmp6 = 0;
            if (!::futils::binary::read_num(r, tmp6, true)) {
                return false;
            }
            tmp6 &= ~(std::uint32_t(0x3) << 30);
            (*this).value(tmp6);
        }
        else if ((*this).prefix() == 3) {
            std::uint64_t tmp7 = 0;
            if (!::futils::binary::read_num(r, tmp7, true)) {
                return false;
            }
            tmp7 &= ~(std::uint64_t(0x3) << 62);
            (*this).value(tmp7);
        }
        return true;
    }
    inline bool Code::encode(::futils::binary::writer& w) const {
        auto tmp_8_ = static_cast<std::uint8_t>((*this).op);
        if (!::futils::binary::write_num(w, static_cast<std::uint8_t>(tmp_8_), true)) {
            return false;
        }
        return true;
    }
    inline bool Code::decode(::futils::binary::reader& r) {
        std::uint8_t tmp_9_ = 0;
        if (!::futils::binary::read_num(r, tmp_9_, true)) {
            return false;
        }
        (*this).op = static_cast<AbstractOp>(tmp_9_);
        return true;
    }
    inline bool String::encode(::futils::binary::writer& w) const {
        if (!(*this).length.encode(w)) {
            return false;
        }
        auto tmp_10_ = (*this).length.value();
        if (tmp_10_ != (*this).data.size()) {
            return false;
        }
        if (!w.write((*this).data)) {
            return false;
        }
        return true;
    }
    inline bool String::decode(::futils::binary::reader& r) {
        if (!(*this).length.decode(r)) {
            return false;
        }
        auto tmp_11_ = (*this).length.value();
        if (!r.read((*this).data, tmp_11_)) {
            return false;
        }
        return true;
    }
    inline bool StringRef::encode(::futils::binary::writer& w) const {
        if (!(*this).code.encode(w)) {
            return false;
        }
        if (!(*this).string.encode(w)) {
            return false;
        }
        return true;
    }
    inline bool StringRef::decode(::futils::binary::reader& r) {
        if (!(*this).code.decode(r)) {
            return false;
        }
        if (!(*this).string.decode(r)) {
            return false;
        }
        return true;
    }
    inline bool BinaryModule::encode(::futils::binary::writer& w) const {
        if (!(*this).string_refs_length.encode(w)) {
            return false;
        }
        auto tmp_12_ = (*this).string_refs_length.value();
        if (tmp_12_ != (*this).string_refs.size()) {
            return false;
        }
        for (auto& tmp_13_ : (*this).string_refs) {
            if (!tmp_13_.encode(w)) {
                return false;
            }
        }
        if (!(*this).code_length.encode(w)) {
            return false;
        }
        auto tmp_14_ = (*this).code_length.value();
        if (tmp_14_ != (*this).code.size()) {
            return false;
        }
        for (auto& tmp_15_ : (*this).code) {
            if (!tmp_15_.encode(w)) {
                return false;
            }
        }
        return true;
    }
    inline bool BinaryModule::decode(::futils::binary::reader& r) {
        if (!(*this).string_refs_length.decode(r)) {
            return false;
        }
        auto tmp_16_ = (*this).string_refs_length.value();
        (*this).string_refs.clear();
        for (size_t tmp_18_ = 0; tmp_18_ < tmp_16_; ++tmp_18_) {
            StringRef tmp_17_;
            if (!tmp_17_.decode(r)) {
                return false;
            }
            (*this).string_refs.push_back(std::move(tmp_17_));
        }
        if (!(*this).code_length.decode(r)) {
            return false;
        }
        auto tmp_19_ = (*this).code_length.value();
        (*this).code.clear();
        for (size_t tmp_21_ = 0; tmp_21_ < tmp_19_; ++tmp_21_) {
            Code tmp_20_;
            if (!tmp_20_.decode(r)) {
                return false;
            }
            (*this).code.push_back(std::move(tmp_20_));
        }
        return true;
    }
}  // namespace rebgn
