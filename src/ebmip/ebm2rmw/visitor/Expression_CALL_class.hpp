/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Expression_CALL_class
  Available Variables:
    ctx: Context_Expression_CALL
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
        module_: ebmgen::MappingTable
      item_id: ebm::ExpressionRef
      type: const ebm::TypeRef&
      kind: const ebm::ExpressionKind&
      call_desc: const ebm::CallDesc&
        callee: ExpressionRef
        arguments: Expressions
          len: Varint
          container: std::vector<ExpressionRef>
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include "../codegen.hpp"
DEFINE_VISITOR(Expression_CALL) {
    using namespace CODEGEN_NAMESPACE;
    /*here to write the hook*/
    // if member function, also push base at first
    if (auto base = ctx.get_field<"base">(ctx.call_desc.callee)) {
        MAYBE(base_res, ctx.visit(*base));
    }
    std::vector<std::string> arg_strs;
    for (auto& arg : ctx.call_desc.arguments.container | std::views::reverse) {
        MAYBE(arg_res, ctx.visit(arg));
        arg_strs.push_back(arg_res.str_repr);
    }
    MAYBE(callee, ctx.visit(ctx.call_desc.callee));
    auto str_repr = std::format("{}({})", callee.str_repr, join(", ", arg_strs));
    ebm::Instruction instr;
    instr.op = ebm::OpCode::CALL;
    instr.arg_num(*varint(static_cast<std::uint64_t>(ctx.call_desc.arguments.container.size())));
    ctx.config().env.add_instruction(instr, str_repr);
    return Result{.str_repr = str_repr};
}
