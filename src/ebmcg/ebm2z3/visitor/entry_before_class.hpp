/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: entry_before_class
  Available Variables:
    ctx: Context_entry_before<Result>
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        module_: ebmgen::MappingTable
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
      main_logic: ebmcodegen::util::MainLogicWrapper<Result>
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include "../codegen.hpp"
#include "ebm/extended_binary_module.hpp"
#include "ebmcodegen/stub/url.hpp"
namespace ebm2z3 {

    expected<CodeWriter> init_variable(auto&& ctx, const std::string& var_name, ebm::TypeRef typ) {
        CodeWriter w;
        MAYBE(type, ctx.get(typ));
        if (type.body.kind == ebm::TypeKind::ARRAY || type.body.kind == ebm::TypeKind::VECTOR) {
            auto size = ctx.template get_field<"body.size">(type.body.element_type());
            if (size) {
                w.writeln(var_name, " = z3.Array('", var_name, "', z3.BitVecSort(64), z3.BitVecSort(", std::to_string(size->value()), "))");
            }
        }
        else {
            auto size = type.body.size();
            if (size) {
                w.writeln(var_name, " = z3.BitVec('", var_name, "',", std::to_string(size->value()), " )");
            }
        }
        return w;
    }
}  // namespace ebm2z3

DEFINE_VISITOR(entry_before) {
    using namespace CODEGEN_NAMESPACE;
    /*here to write the hook*/
    ctx.config().solver_name = "solver";
    ctx.config().begin_block = ":";
    ctx.config().end_block = "";
    ctx.config().program_decl_start_wrapper = [](Context_Statement_PROGRAM_DECL& ctx) {
        CodeWriter w;
        w.writeln("// Code generated by ebm2z3 at ", repo_url, ". Work in progress");
        w.writeln("import z3");
        return w;
    };
    ctx.config().param_visitor = [](Context_Statement_PARAMETER_DECL& ctx, Result) -> expected<Result> {
        return init_variable(ctx, ctx.config().current_ident(ctx, ctx.item_id), ctx.param_decl.param_type);
    };
    ctx.config().binary_op_custom = [](Context_Expression_BINARY_OP& ctx, Result& left_str, Result& right_str) -> expected<Result> {
        CodeWriter w;
        switch (ctx.bop) {
            case ebm::BinaryOp::right_shift:
                w.write("z3.LShR(", left_str.to_writer(), ", ", right_str.to_writer(), ")");
                return w;
            case ebm::BinaryOp::logical_and:
                w.write("z3.And(", left_str.to_writer(), ", ", right_str.to_writer(), ")");
                return w;
            case ebm::BinaryOp::logical_or:
                w.write("z3.Or(", left_str.to_writer(), ", ", right_str.to_writer(), ")");
                return w;
            case ebm::BinaryOp::less_or_eq:
                w.write("z3.ULE(", left_str.to_writer(), ", ", right_str.to_writer(), ")");
                return w;
            case ebm::BinaryOp::greater_or_eq:
                w.write("z3.UGE(", left_str.to_writer(), ", ", right_str.to_writer(), ")");
                return w;
            case ebm::BinaryOp::div:
                w.write("z3.UDiv(", left_str.to_writer(), ", ", right_str.to_writer(), ")");
                return w;
            case ebm::BinaryOp::mod:
                w.write("z3.URem(", left_str.to_writer(), ", ", right_str.to_writer(), ")");
                return w;
            default:
                return pass;
        }
    };
    ctx.config().unary_op_custom = [](Context_Expression_UNARY_OP& ctx, Result& operand_str) -> expected<Result> {
        CodeWriter w;
        switch (ctx.uop) {
            case ebm::UnaryOp::minus_sign:
                w.write("z3.Neg(", operand_str.to_writer(), ")");
                return w;
            case ebm::UnaryOp::logical_not:
                w.write("z3.Not(", operand_str.to_writer(), ")");
                return w;
            default:
                return pass;
        }
    };
    ctx.config().if_statement_custom = [](Context_Statement_IF_STATEMENT& ctx) -> expected<Result> {
        MAYBE(branches, flatten_if_then(ctx, ctx.item_id));
        MAYBE(w, ctx.get_writer());
        // それまでに失敗した条件を累積する（else if 用）
        CodeWriter accumulated_not_cond;

        for (const auto& branch : branches) {
            CodeWriter current_branch_cond;

            if (branch.condition) {
                MAYBE(cond_str, ctx.visit(*branch.condition));  // Z3式に変換
                if (accumulated_not_cond.empty()) {
                    current_branch_cond = cond_str.to_writer();
                    accumulated_not_cond = CODE("z3.Not(", cond_str.to_writer(), ")");
                }
                else {
                    current_branch_cond = CODE("z3.And(", accumulated_not_cond, ", ", cond_str.to_writer(), ")");
                    accumulated_not_cond = CODE("z3.And(", accumulated_not_cond, ", z3.Not(", cond_str.to_writer(), "))");
                }
            }
            else {
                // 最後の else ブロック
                current_branch_cond = accumulated_not_cond;
            }

            // パス条件をスタックに積む
            ctx.config().condition_stack.push_back(std::move(current_branch_cond));

            // そのブランチの Statement(s) を visit
            // ここで各 Assignment 等が z3.If(current_branch_cond, ...) を吐き出す
            MAYBE(branch_code, ctx.visit(branch.then_branch));
            w.get().write(branch_code.to_writer());

            ctx.config().condition_stack.pop_back();
        }
        return "";
    };
    ctx.config().init_check_visitor = [](Context_Statement_INIT_CHECK& ctx) -> expected<Result> {
        CodeWriter w;
        return w;
    };
    ctx.config().write_data_visitor = [](Context_Statement_WRITE_DATA& ctx) -> expected<Result> {
        if (auto ref = ctx.write_data.lowered_statement()) {
            return ctx.visit(ref->io_statement.id);
        }
        CodeWriter w;
        return w;
    };
    ctx.config().read_data_visitor = [](Context_Statement_READ_DATA& ctx) -> expected<Result> {
        CodeWriter w;
        return w;
    };
    ctx.config().return_visitor = [](Context_Statement_RETURN& ctx) -> expected<Result> {
        CodeWriter w;
        return w;
    };
    ctx.config().error_return_visitor = [](Context_Statement_ERROR_RETURN& ctx) -> expected<Result> {
        CodeWriter w;
        return w;
    };
    ctx.config().assignment_custom = [](Context_Statement_ASSIGNMENT& ctx) -> expected<Result> {
        CodeWriter w;
        MAYBE(target, ctx.get(ctx.target));
        if (target.body.kind == ebm::ExpressionKind::INDEX_ACCESS) {
            MAYBE(base_expr_ref, target.body.base());
            MAYBE(index, target.body.index());
            MAYBE(base_expr, ctx.get(base_expr_ref));
            if (base_expr.body.kind != ebm::ExpressionKind::IDENTIFIER) {
                return w;
            }
            MAYBE(ident, base_expr.body.id());
            auto current_ident = ctx.config().current_ident(ctx, from_weak(ident));
            MAYBE(condition_related, ctx.visit(ctx.value));
            MAYBE(index_str, ctx.visit(index));
            ctx.config().update_version(from_weak(ident));
            auto result_ident = ctx.config().current_ident(ctx, from_weak(ident));
            MAYBE(init, init_variable(ctx, result_ident, base_expr.body.type));
            w.write(std::move(init));
            auto updated_array = ctx.config().wrap_condition(current_ident, CODE("z3.Store(", current_ident, ", ", index_str.to_writer(), ", ", condition_related.to_writer(), ")"));
            w.writeln(ctx.config().solver_name, ".add(", result_ident, " == ", std::move(updated_array), ")");
            return w;
        }
        auto ident = ctx.get_field<"body.id.id">(ctx.target);
        if (!ident) {
            return w;
        }
        MAYBE(type, ctx.get_field<"type">(ctx.target));
        auto old_name = ctx.config().current_ident(ctx, *ident);
        MAYBE(condition_related, ctx.visit(ctx.value));
        ctx.config().update_version(*ident);
        auto result_name = ctx.config().current_ident(ctx, *ident);
        MAYBE(init, init_variable(ctx, result_name, type));
        w.write(std::move(init));
        w.writeln(ctx.config().solver_name, ".add(", result_name, " == ", ctx.config().wrap_condition(old_name, CODE(condition_related.to_writer())), ")");
        return w;
    };
    ctx.config().identifier_custom = [](Context_Expression_IDENTIFIER& ctx) -> expected<Result> {
        // 変数名を識別子から取得
        return ctx.config().current_ident(ctx, from_weak(ctx.id));
    };
    ctx.config().variable_decl_custom = [](Context_Statement_VARIABLE_DECL& ctx) -> expected<Result> {
        CodeWriter w;
        auto name = ctx.config().current_ident(ctx, ctx.item_id);
        MAYBE(init, init_variable(ctx, name, ctx.var_decl.var_type));
        w.write(std::move(init));
        return w;
    };
    ctx.config().error_report_visitor = [](Context_Statement_ERROR_REPORT& ctx) -> expected<Result> {
        CodeWriter w;
        return w;
    };

    ctx.config().function_definition_start_wrapper = [](Result, std::string_view func_name, CodeWriter, Context_Statement_FUNCTION_DECL& ctx) -> expected<Result> {
        CodeWriter out;

        // 関数名を識別子から取得
        std::string parent;
        if (!is_nil(ctx.func_decl.parent_format)) {
            parent = ctx.identifier(ctx.func_decl.parent_format) + "_";
        }

        out.writeln("");
        out.writeln("# Verification for function: ", func_name);
        out.writeln("def verify_", parent, func_name, "(", ctx.config().solver_name, " :z3.Solver):");
        auto scope = out.indent_scope();

        // パラメータを Z3 変数として宣言 (バージョン0)
        // ここで ctx.func_decl.params.container を走査して BitVec を宣言
        for (auto& param_ref : ctx.func_decl.params.container) {
            // パラメータの型情報から BitVec(name, size) を出力
            MAYBE(param, ctx.visit(param_ref));
            out.write(std::move(param.to_writer()));
        }
        auto returend = ctx.config().current_ident(ctx, ctx.item_id) + "_returned";
        out.writeln(returend, " = z3.Bool('", returend, "')");

        return out;
    };
    return pass;
}
