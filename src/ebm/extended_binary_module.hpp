//Code generated by json2cpp2
#pragma once
#include <cstdint>
#include <vector>
#include <array>
#include <optional>
#include <variant>
#include <string_view>

#include <binary/flags.h>
#include <binary/float.h>
#include <view/iovec.h>
#include <binary/number.h>
#include <memory>
#include <error/error.h>
#include <string>
#ifndef EBM_API
#ifdef _WIN32
#define EBM_API __declspec(dllimport)
#else
#define EBM_API
#endif
#endif
namespace ebm {
    enum class GenerateType {
        Normal = 0,
        Encode = 1,
        Decode = 2,
    };
    constexpr const char* to_string(GenerateType e) {
        switch(e) {
            case GenerateType::Normal: return "Normal";
            case GenerateType::Encode: return "Encode";
            case GenerateType::Decode: return "Decode";
        }
        return "";
    }
    
    constexpr std::optional<GenerateType> GenerateType_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "Normal") {
            return GenerateType::Normal;
        }
        if (str == "Encode") {
            return GenerateType::Encode;
        }
        if (str == "Decode") {
            return GenerateType::Decode;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(GenerateType) {
        return "GenerateType";
    }
    enum class BinaryOp : std::uint8_t {
        mul = 0,
        div = 1,
        mod = 2,
        left_shift = 3,
        right_shift = 4,
        bit_and = 5,
        add = 6,
        sub = 7,
        bit_or = 8,
        bit_xor = 9,
        equal = 10,
        not_equal = 11,
        less = 12,
        less_or_eq = 13,
        greater = 14,
        greater_or_eq = 15,
        logical_and = 16,
        logical_or = 17,
    };
    constexpr const char* to_string(BinaryOp e) {
        switch(e) {
            case BinaryOp::mul: return "*";
            case BinaryOp::div: return "/";
            case BinaryOp::mod: return "%";
            case BinaryOp::left_shift: return "<<";
            case BinaryOp::right_shift: return ">>";
            case BinaryOp::bit_and: return "&";
            case BinaryOp::add: return "+";
            case BinaryOp::sub: return "-";
            case BinaryOp::bit_or: return "|";
            case BinaryOp::bit_xor: return "^";
            case BinaryOp::equal: return "==";
            case BinaryOp::not_equal: return "!=";
            case BinaryOp::less: return "<";
            case BinaryOp::less_or_eq: return "<=";
            case BinaryOp::greater: return ">";
            case BinaryOp::greater_or_eq: return ">=";
            case BinaryOp::logical_and: return "&&";
            case BinaryOp::logical_or: return "||";
        }
        return "";
    }
    
    constexpr std::optional<BinaryOp> BinaryOp_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "*") {
            return BinaryOp::mul;
        }
        if (str == "/") {
            return BinaryOp::div;
        }
        if (str == "%") {
            return BinaryOp::mod;
        }
        if (str == "<<") {
            return BinaryOp::left_shift;
        }
        if (str == ">>") {
            return BinaryOp::right_shift;
        }
        if (str == "&") {
            return BinaryOp::bit_and;
        }
        if (str == "+") {
            return BinaryOp::add;
        }
        if (str == "-") {
            return BinaryOp::sub;
        }
        if (str == "|") {
            return BinaryOp::bit_or;
        }
        if (str == "^") {
            return BinaryOp::bit_xor;
        }
        if (str == "==") {
            return BinaryOp::equal;
        }
        if (str == "!=") {
            return BinaryOp::not_equal;
        }
        if (str == "<") {
            return BinaryOp::less;
        }
        if (str == "<=") {
            return BinaryOp::less_or_eq;
        }
        if (str == ">") {
            return BinaryOp::greater;
        }
        if (str == ">=") {
            return BinaryOp::greater_or_eq;
        }
        if (str == "&&") {
            return BinaryOp::logical_and;
        }
        if (str == "||") {
            return BinaryOp::logical_or;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(BinaryOp) {
        return "BinaryOp";
    }
    enum class UnaryOp : std::uint8_t {
        logical_not = 0,
        minus_sign = 1,
        bit_not = 2,
    };
    constexpr const char* to_string(UnaryOp e) {
        switch(e) {
            case UnaryOp::logical_not: return "!";
            case UnaryOp::minus_sign: return "-";
            case UnaryOp::bit_not: return "~";
        }
        return "";
    }
    
    constexpr std::optional<UnaryOp> UnaryOp_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "!") {
            return UnaryOp::logical_not;
        }
        if (str == "-") {
            return UnaryOp::minus_sign;
        }
        if (str == "~") {
            return UnaryOp::bit_not;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(UnaryOp) {
        return "UnaryOp";
    }
    enum class Endian : std::uint8_t {
        unspec = 0,
        big = 1,
        little = 2,
        dynamic = 3,
        native = 4,
    };
    constexpr const char* to_string(Endian e) {
        switch(e) {
            case Endian::unspec: return "unspec";
            case Endian::big: return "big";
            case Endian::little: return "little";
            case Endian::dynamic: return "dynamic";
            case Endian::native: return "native";
        }
        return "";
    }
    
    constexpr std::optional<Endian> Endian_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "unspec") {
            return Endian::unspec;
        }
        if (str == "big") {
            return Endian::big;
        }
        if (str == "little") {
            return Endian::little;
        }
        if (str == "dynamic") {
            return Endian::dynamic;
        }
        if (str == "native") {
            return Endian::native;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(Endian) {
        return "Endian";
    }
    enum class ExpressionOp : std::uint8_t {
        LITERAL_INT = 0,
        LITERAL_INT64 = 1,
        LITERAL_BOOL = 2,
        LITERAL_STRING = 3,
        LITERAL_TYPE = 4,
        LITERAL_CHAR = 5,
        IDENTIFIER = 6,
        BINARY_OP = 7,
        UNARY_OP = 8,
        CALL = 9,
        INDEX_ACCESS = 10,
        MEMBER_ACCESS = 11,
        TYPE_CAST = 12,
        RANGE = 13,
        DEFAULT_VALUE = 14,
        IS_LITTLE_ENDIAN = 15,
        GET_STREAM_OFFSET = 16,
        GET_REMAINING_BYTES = 17,
        CAN_READ_STREAM = 18,
        ARRAY_SIZE = 19,
        IS_ERROR = 20,
        MAX_VALUE = 21,
        READ_DATA = 22,
        WRITE_DATA = 23,
        CONDITIONAL_STATEMENT = 24,
    };
    constexpr const char* to_string(ExpressionOp e) {
        switch(e) {
            case ExpressionOp::LITERAL_INT: return "LITERAL_INT";
            case ExpressionOp::LITERAL_INT64: return "LITERAL_INT64";
            case ExpressionOp::LITERAL_BOOL: return "LITERAL_BOOL";
            case ExpressionOp::LITERAL_STRING: return "LITERAL_STRING";
            case ExpressionOp::LITERAL_TYPE: return "LITERAL_TYPE";
            case ExpressionOp::LITERAL_CHAR: return "LITERAL_CHAR";
            case ExpressionOp::IDENTIFIER: return "IDENTIFIER";
            case ExpressionOp::BINARY_OP: return "BINARY_OP";
            case ExpressionOp::UNARY_OP: return "UNARY_OP";
            case ExpressionOp::CALL: return "CALL";
            case ExpressionOp::INDEX_ACCESS: return "INDEX_ACCESS";
            case ExpressionOp::MEMBER_ACCESS: return "MEMBER_ACCESS";
            case ExpressionOp::TYPE_CAST: return "TYPE_CAST";
            case ExpressionOp::RANGE: return "RANGE";
            case ExpressionOp::DEFAULT_VALUE: return "DEFAULT_VALUE";
            case ExpressionOp::IS_LITTLE_ENDIAN: return "IS_LITTLE_ENDIAN";
            case ExpressionOp::GET_STREAM_OFFSET: return "GET_STREAM_OFFSET";
            case ExpressionOp::GET_REMAINING_BYTES: return "GET_REMAINING_BYTES";
            case ExpressionOp::CAN_READ_STREAM: return "CAN_READ_STREAM";
            case ExpressionOp::ARRAY_SIZE: return "ARRAY_SIZE";
            case ExpressionOp::IS_ERROR: return "IS_ERROR";
            case ExpressionOp::MAX_VALUE: return "MAX_VALUE";
            case ExpressionOp::READ_DATA: return "READ_DATA";
            case ExpressionOp::WRITE_DATA: return "WRITE_DATA";
            case ExpressionOp::CONDITIONAL_STATEMENT: return "CONDITIONAL_STATEMENT";
        }
        return "";
    }
    
    constexpr std::optional<ExpressionOp> ExpressionOp_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "LITERAL_INT") {
            return ExpressionOp::LITERAL_INT;
        }
        if (str == "LITERAL_INT64") {
            return ExpressionOp::LITERAL_INT64;
        }
        if (str == "LITERAL_BOOL") {
            return ExpressionOp::LITERAL_BOOL;
        }
        if (str == "LITERAL_STRING") {
            return ExpressionOp::LITERAL_STRING;
        }
        if (str == "LITERAL_TYPE") {
            return ExpressionOp::LITERAL_TYPE;
        }
        if (str == "LITERAL_CHAR") {
            return ExpressionOp::LITERAL_CHAR;
        }
        if (str == "IDENTIFIER") {
            return ExpressionOp::IDENTIFIER;
        }
        if (str == "BINARY_OP") {
            return ExpressionOp::BINARY_OP;
        }
        if (str == "UNARY_OP") {
            return ExpressionOp::UNARY_OP;
        }
        if (str == "CALL") {
            return ExpressionOp::CALL;
        }
        if (str == "INDEX_ACCESS") {
            return ExpressionOp::INDEX_ACCESS;
        }
        if (str == "MEMBER_ACCESS") {
            return ExpressionOp::MEMBER_ACCESS;
        }
        if (str == "TYPE_CAST") {
            return ExpressionOp::TYPE_CAST;
        }
        if (str == "RANGE") {
            return ExpressionOp::RANGE;
        }
        if (str == "DEFAULT_VALUE") {
            return ExpressionOp::DEFAULT_VALUE;
        }
        if (str == "IS_LITTLE_ENDIAN") {
            return ExpressionOp::IS_LITTLE_ENDIAN;
        }
        if (str == "GET_STREAM_OFFSET") {
            return ExpressionOp::GET_STREAM_OFFSET;
        }
        if (str == "GET_REMAINING_BYTES") {
            return ExpressionOp::GET_REMAINING_BYTES;
        }
        if (str == "CAN_READ_STREAM") {
            return ExpressionOp::CAN_READ_STREAM;
        }
        if (str == "ARRAY_SIZE") {
            return ExpressionOp::ARRAY_SIZE;
        }
        if (str == "IS_ERROR") {
            return ExpressionOp::IS_ERROR;
        }
        if (str == "MAX_VALUE") {
            return ExpressionOp::MAX_VALUE;
        }
        if (str == "READ_DATA") {
            return ExpressionOp::READ_DATA;
        }
        if (str == "WRITE_DATA") {
            return ExpressionOp::WRITE_DATA;
        }
        if (str == "CONDITIONAL_STATEMENT") {
            return ExpressionOp::CONDITIONAL_STATEMENT;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(ExpressionOp) {
        return "ExpressionOp";
    }
    enum class LoopType : std::uint8_t {
        INFINITE = 0,
        WHILE = 1,
        FOR_EACH = 2,
        FOR = 3,
    };
    constexpr const char* to_string(LoopType e) {
        switch(e) {
            case LoopType::INFINITE: return "INFINITE";
            case LoopType::WHILE: return "WHILE";
            case LoopType::FOR_EACH: return "FOR_EACH";
            case LoopType::FOR: return "FOR";
        }
        return "";
    }
    
    constexpr std::optional<LoopType> LoopType_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "INFINITE") {
            return LoopType::INFINITE;
        }
        if (str == "WHILE") {
            return LoopType::WHILE;
        }
        if (str == "FOR_EACH") {
            return LoopType::FOR_EACH;
        }
        if (str == "FOR") {
            return LoopType::FOR;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(LoopType) {
        return "LoopType";
    }
    enum class PackedOpType : std::uint8_t {
        FIXED = 0,
        VARIABLE = 1,
    };
    constexpr const char* to_string(PackedOpType e) {
        switch(e) {
            case PackedOpType::FIXED: return "FIXED";
            case PackedOpType::VARIABLE: return "VARIABLE";
        }
        return "";
    }
    
    constexpr std::optional<PackedOpType> PackedOpType_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "FIXED") {
            return PackedOpType::FIXED;
        }
        if (str == "VARIABLE") {
            return PackedOpType::VARIABLE;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(PackedOpType) {
        return "PackedOpType";
    }
    enum class LoweringType : std::uint8_t {
        NAIVE = 0,
        C_LIKE = 1,
        BIT_STREAM = 2,
        ASSEMBLY = 3,
    };
    constexpr const char* to_string(LoweringType e) {
        switch(e) {
            case LoweringType::NAIVE: return "NAIVE";
            case LoweringType::C_LIKE: return "C_LIKE";
            case LoweringType::BIT_STREAM: return "BIT_STREAM";
            case LoweringType::ASSEMBLY: return "ASSEMBLY";
        }
        return "";
    }
    
    constexpr std::optional<LoweringType> LoweringType_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "NAIVE") {
            return LoweringType::NAIVE;
        }
        if (str == "C_LIKE") {
            return LoweringType::C_LIKE;
        }
        if (str == "BIT_STREAM") {
            return LoweringType::BIT_STREAM;
        }
        if (str == "ASSEMBLY") {
            return LoweringType::ASSEMBLY;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(LoweringType) {
        return "LoweringType";
    }
    enum class StatementOp : std::uint8_t {
        BLOCK = 0,
        ASSIGNMENT = 1,
        APPEND = 2,
        RETURN = 3,
        ERROR_RETURN = 4,
        ASSERT = 5,
        READ_DATA = 6,
        WRITE_DATA = 7,
        SEEK_STREAM = 8,
        IF_STATEMENT = 9,
        LOOP_STATEMENT = 10,
        MATCH_STATEMENT = 11,
        MATCH_BRANCH = 12,
        BREAK = 13,
        CONTINUE = 14,
        FUNCTION_DECL = 15,
        VARIABLE_DECL = 16,
        FIELD_DECL = 17,
        ENUM_DECL = 18,
        ENUM_MEMBER_DECL = 19,
        STRUCT_DECL = 20,
        UNION_DECL = 21,
        UNION_MEMBER_DECL = 22,
        PROGRAM_DECL = 23,
        PROPERTY_DECL = 24,
        METADATA = 25,
        IMPORT_MODULE = 26,
        EXPRESSION = 27,
        PHI_NODE = 28,
        ERROR_REPORT = 29,
        LOWERED_STATEMENTS = 30,
    };
    constexpr const char* to_string(StatementOp e) {
        switch(e) {
            case StatementOp::BLOCK: return "BLOCK";
            case StatementOp::ASSIGNMENT: return "ASSIGNMENT";
            case StatementOp::APPEND: return "APPEND";
            case StatementOp::RETURN: return "RETURN";
            case StatementOp::ERROR_RETURN: return "ERROR_RETURN";
            case StatementOp::ASSERT: return "ASSERT";
            case StatementOp::READ_DATA: return "READ_DATA";
            case StatementOp::WRITE_DATA: return "WRITE_DATA";
            case StatementOp::SEEK_STREAM: return "SEEK_STREAM";
            case StatementOp::IF_STATEMENT: return "IF_STATEMENT";
            case StatementOp::LOOP_STATEMENT: return "LOOP_STATEMENT";
            case StatementOp::MATCH_STATEMENT: return "MATCH_STATEMENT";
            case StatementOp::MATCH_BRANCH: return "MATCH_BRANCH";
            case StatementOp::BREAK: return "BREAK";
            case StatementOp::CONTINUE: return "CONTINUE";
            case StatementOp::FUNCTION_DECL: return "FUNCTION_DECL";
            case StatementOp::VARIABLE_DECL: return "VARIABLE_DECL";
            case StatementOp::FIELD_DECL: return "FIELD_DECL";
            case StatementOp::ENUM_DECL: return "ENUM_DECL";
            case StatementOp::ENUM_MEMBER_DECL: return "ENUM_MEMBER_DECL";
            case StatementOp::STRUCT_DECL: return "STRUCT_DECL";
            case StatementOp::UNION_DECL: return "UNION_DECL";
            case StatementOp::UNION_MEMBER_DECL: return "UNION_MEMBER_DECL";
            case StatementOp::PROGRAM_DECL: return "PROGRAM_DECL";
            case StatementOp::PROPERTY_DECL: return "PROPERTY_DECL";
            case StatementOp::METADATA: return "METADATA";
            case StatementOp::IMPORT_MODULE: return "IMPORT_MODULE";
            case StatementOp::EXPRESSION: return "EXPRESSION";
            case StatementOp::PHI_NODE: return "PHI_NODE";
            case StatementOp::ERROR_REPORT: return "ERROR_REPORT";
            case StatementOp::LOWERED_STATEMENTS: return "LOWERED_STATEMENTS";
        }
        return "";
    }
    
    constexpr std::optional<StatementOp> StatementOp_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "BLOCK") {
            return StatementOp::BLOCK;
        }
        if (str == "ASSIGNMENT") {
            return StatementOp::ASSIGNMENT;
        }
        if (str == "APPEND") {
            return StatementOp::APPEND;
        }
        if (str == "RETURN") {
            return StatementOp::RETURN;
        }
        if (str == "ERROR_RETURN") {
            return StatementOp::ERROR_RETURN;
        }
        if (str == "ASSERT") {
            return StatementOp::ASSERT;
        }
        if (str == "READ_DATA") {
            return StatementOp::READ_DATA;
        }
        if (str == "WRITE_DATA") {
            return StatementOp::WRITE_DATA;
        }
        if (str == "SEEK_STREAM") {
            return StatementOp::SEEK_STREAM;
        }
        if (str == "IF_STATEMENT") {
            return StatementOp::IF_STATEMENT;
        }
        if (str == "LOOP_STATEMENT") {
            return StatementOp::LOOP_STATEMENT;
        }
        if (str == "MATCH_STATEMENT") {
            return StatementOp::MATCH_STATEMENT;
        }
        if (str == "MATCH_BRANCH") {
            return StatementOp::MATCH_BRANCH;
        }
        if (str == "BREAK") {
            return StatementOp::BREAK;
        }
        if (str == "CONTINUE") {
            return StatementOp::CONTINUE;
        }
        if (str == "FUNCTION_DECL") {
            return StatementOp::FUNCTION_DECL;
        }
        if (str == "VARIABLE_DECL") {
            return StatementOp::VARIABLE_DECL;
        }
        if (str == "FIELD_DECL") {
            return StatementOp::FIELD_DECL;
        }
        if (str == "ENUM_DECL") {
            return StatementOp::ENUM_DECL;
        }
        if (str == "ENUM_MEMBER_DECL") {
            return StatementOp::ENUM_MEMBER_DECL;
        }
        if (str == "STRUCT_DECL") {
            return StatementOp::STRUCT_DECL;
        }
        if (str == "UNION_DECL") {
            return StatementOp::UNION_DECL;
        }
        if (str == "UNION_MEMBER_DECL") {
            return StatementOp::UNION_MEMBER_DECL;
        }
        if (str == "PROGRAM_DECL") {
            return StatementOp::PROGRAM_DECL;
        }
        if (str == "PROPERTY_DECL") {
            return StatementOp::PROPERTY_DECL;
        }
        if (str == "METADATA") {
            return StatementOp::METADATA;
        }
        if (str == "IMPORT_MODULE") {
            return StatementOp::IMPORT_MODULE;
        }
        if (str == "EXPRESSION") {
            return StatementOp::EXPRESSION;
        }
        if (str == "PHI_NODE") {
            return StatementOp::PHI_NODE;
        }
        if (str == "ERROR_REPORT") {
            return StatementOp::ERROR_REPORT;
        }
        if (str == "LOWERED_STATEMENTS") {
            return StatementOp::LOWERED_STATEMENTS;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(StatementOp) {
        return "StatementOp";
    }
    enum class StreamType : std::uint8_t {
        INPUT = 0,
        OUTPUT = 1,
    };
    constexpr const char* to_string(StreamType e) {
        switch(e) {
            case StreamType::INPUT: return "INPUT";
            case StreamType::OUTPUT: return "OUTPUT";
        }
        return "";
    }
    
    constexpr std::optional<StreamType> StreamType_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "INPUT") {
            return StreamType::INPUT;
        }
        if (str == "OUTPUT") {
            return StreamType::OUTPUT;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(StreamType) {
        return "StreamType";
    }
    enum class SizeUnit : std::uint8_t {
        UNKNOWN = 0,
        BIT_FIXED = 1,
        BYTE_FIXED = 2,
        ELEMENT_FIXED = 3,
        BIT_DYNAMIC = 4,
        BYTE_DYNAMIC = 5,
        ELEMENT_DYNAMIC = 6,
        DYNAMIC = 7,
    };
    constexpr const char* to_string(SizeUnit e) {
        switch(e) {
            case SizeUnit::UNKNOWN: return "UNKNOWN";
            case SizeUnit::BIT_FIXED: return "BIT_FIXED";
            case SizeUnit::BYTE_FIXED: return "BYTE_FIXED";
            case SizeUnit::ELEMENT_FIXED: return "ELEMENT_FIXED";
            case SizeUnit::BIT_DYNAMIC: return "BIT_DYNAMIC";
            case SizeUnit::BYTE_DYNAMIC: return "BYTE_DYNAMIC";
            case SizeUnit::ELEMENT_DYNAMIC: return "ELEMENT_DYNAMIC";
            case SizeUnit::DYNAMIC: return "DYNAMIC";
        }
        return "";
    }
    
    constexpr std::optional<SizeUnit> SizeUnit_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "UNKNOWN") {
            return SizeUnit::UNKNOWN;
        }
        if (str == "BIT_FIXED") {
            return SizeUnit::BIT_FIXED;
        }
        if (str == "BYTE_FIXED") {
            return SizeUnit::BYTE_FIXED;
        }
        if (str == "ELEMENT_FIXED") {
            return SizeUnit::ELEMENT_FIXED;
        }
        if (str == "BIT_DYNAMIC") {
            return SizeUnit::BIT_DYNAMIC;
        }
        if (str == "BYTE_DYNAMIC") {
            return SizeUnit::BYTE_DYNAMIC;
        }
        if (str == "ELEMENT_DYNAMIC") {
            return SizeUnit::ELEMENT_DYNAMIC;
        }
        if (str == "DYNAMIC") {
            return SizeUnit::DYNAMIC;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(SizeUnit) {
        return "SizeUnit";
    }
    enum class CastType : std::uint8_t {
        ENUM_TO_INT = 0,
        INT_TO_ENUM = 1,
        FLOAT_TO_INT_BIT = 2,
        INT_TO_FLOAT_BIT = 3,
        VECTOR_TO_ARRAY = 4,
        ARRAY_TO_VECTOR = 5,
        INT_TO_VECTOR = 6,
        INT_TO_ARRAY = 7,
        SMALL_INT_TO_LARGE_INT = 8,
        LARGE_INT_TO_SMALL_INT = 9,
        SIGNED_TO_UNSIGNED = 10,
        UNSIGNED_TO_SIGNED = 11,
        BOOL_TO_INT = 12,
        INT_TO_BOOL = 13,
        STRUCT_TO_RECURSIVE_STRUCT = 14,
        RECURSIVE_STRUCT_TO_STRUCT = 15,
        OTHER = 16,
    };
    constexpr const char* to_string(CastType e) {
        switch(e) {
            case CastType::ENUM_TO_INT: return "ENUM_TO_INT";
            case CastType::INT_TO_ENUM: return "INT_TO_ENUM";
            case CastType::FLOAT_TO_INT_BIT: return "FLOAT_TO_INT_BIT";
            case CastType::INT_TO_FLOAT_BIT: return "INT_TO_FLOAT_BIT";
            case CastType::VECTOR_TO_ARRAY: return "VECTOR_TO_ARRAY";
            case CastType::ARRAY_TO_VECTOR: return "ARRAY_TO_VECTOR";
            case CastType::INT_TO_VECTOR: return "INT_TO_VECTOR";
            case CastType::INT_TO_ARRAY: return "INT_TO_ARRAY";
            case CastType::SMALL_INT_TO_LARGE_INT: return "SMALL_INT_TO_LARGE_INT";
            case CastType::LARGE_INT_TO_SMALL_INT: return "LARGE_INT_TO_SMALL_INT";
            case CastType::SIGNED_TO_UNSIGNED: return "SIGNED_TO_UNSIGNED";
            case CastType::UNSIGNED_TO_SIGNED: return "UNSIGNED_TO_SIGNED";
            case CastType::BOOL_TO_INT: return "BOOL_TO_INT";
            case CastType::INT_TO_BOOL: return "INT_TO_BOOL";
            case CastType::STRUCT_TO_RECURSIVE_STRUCT: return "STRUCT_TO_RECURSIVE_STRUCT";
            case CastType::RECURSIVE_STRUCT_TO_STRUCT: return "RECURSIVE_STRUCT_TO_STRUCT";
            case CastType::OTHER: return "OTHER";
        }
        return "";
    }
    
    constexpr std::optional<CastType> CastType_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "ENUM_TO_INT") {
            return CastType::ENUM_TO_INT;
        }
        if (str == "INT_TO_ENUM") {
            return CastType::INT_TO_ENUM;
        }
        if (str == "FLOAT_TO_INT_BIT") {
            return CastType::FLOAT_TO_INT_BIT;
        }
        if (str == "INT_TO_FLOAT_BIT") {
            return CastType::INT_TO_FLOAT_BIT;
        }
        if (str == "VECTOR_TO_ARRAY") {
            return CastType::VECTOR_TO_ARRAY;
        }
        if (str == "ARRAY_TO_VECTOR") {
            return CastType::ARRAY_TO_VECTOR;
        }
        if (str == "INT_TO_VECTOR") {
            return CastType::INT_TO_VECTOR;
        }
        if (str == "INT_TO_ARRAY") {
            return CastType::INT_TO_ARRAY;
        }
        if (str == "SMALL_INT_TO_LARGE_INT") {
            return CastType::SMALL_INT_TO_LARGE_INT;
        }
        if (str == "LARGE_INT_TO_SMALL_INT") {
            return CastType::LARGE_INT_TO_SMALL_INT;
        }
        if (str == "SIGNED_TO_UNSIGNED") {
            return CastType::SIGNED_TO_UNSIGNED;
        }
        if (str == "UNSIGNED_TO_SIGNED") {
            return CastType::UNSIGNED_TO_SIGNED;
        }
        if (str == "BOOL_TO_INT") {
            return CastType::BOOL_TO_INT;
        }
        if (str == "INT_TO_BOOL") {
            return CastType::INT_TO_BOOL;
        }
        if (str == "STRUCT_TO_RECURSIVE_STRUCT") {
            return CastType::STRUCT_TO_RECURSIVE_STRUCT;
        }
        if (str == "RECURSIVE_STRUCT_TO_STRUCT") {
            return CastType::RECURSIVE_STRUCT_TO_STRUCT;
        }
        if (str == "OTHER") {
            return CastType::OTHER;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(CastType) {
        return "CastType";
    }
    enum class MergeMode : std::uint8_t {
        COMMON_TYPE = 0,
        STRICT_TYPE = 1,
        STRICT_COMMON_TYPE = 2,
    };
    constexpr const char* to_string(MergeMode e) {
        switch(e) {
            case MergeMode::COMMON_TYPE: return "COMMON_TYPE";
            case MergeMode::STRICT_TYPE: return "STRICT_TYPE";
            case MergeMode::STRICT_COMMON_TYPE: return "STRICT_COMMON_TYPE";
        }
        return "";
    }
    
    constexpr std::optional<MergeMode> MergeMode_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "COMMON_TYPE") {
            return MergeMode::COMMON_TYPE;
        }
        if (str == "STRICT_TYPE") {
            return MergeMode::STRICT_TYPE;
        }
        if (str == "STRICT_COMMON_TYPE") {
            return MergeMode::STRICT_COMMON_TYPE;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(MergeMode) {
        return "MergeMode";
    }
    enum class TypeKind : std::uint8_t {
        INT = 0,
        UINT = 1,
        FLOAT = 2,
        STRUCT = 3,
        RECURSIVE_STRUCT = 4,
        BOOL = 5,
        VOID = 6,
        META = 7,
        ENUM = 8,
        ARRAY = 9,
        VECTOR = 10,
        VARIANT = 11,
        RANGE = 12,
        ENCODER_RETURN = 13,
        DECODER_RETURN = 14,
        ENCODER_INPUT = 15,
        DECODER_INPUT = 16,
        PROPERTY_SETTER_RETURN = 17,
        OPTIONAL = 18,
        PTR = 19,
        FUNCTION = 20,
    };
    constexpr const char* to_string(TypeKind e) {
        switch(e) {
            case TypeKind::INT: return "INT";
            case TypeKind::UINT: return "UINT";
            case TypeKind::FLOAT: return "FLOAT";
            case TypeKind::STRUCT: return "STRUCT";
            case TypeKind::RECURSIVE_STRUCT: return "RECURSIVE_STRUCT";
            case TypeKind::BOOL: return "BOOL";
            case TypeKind::VOID: return "VOID";
            case TypeKind::META: return "META";
            case TypeKind::ENUM: return "ENUM";
            case TypeKind::ARRAY: return "ARRAY";
            case TypeKind::VECTOR: return "VECTOR";
            case TypeKind::VARIANT: return "VARIANT";
            case TypeKind::RANGE: return "RANGE";
            case TypeKind::ENCODER_RETURN: return "ENCODER_RETURN";
            case TypeKind::DECODER_RETURN: return "DECODER_RETURN";
            case TypeKind::ENCODER_INPUT: return "ENCODER_INPUT";
            case TypeKind::DECODER_INPUT: return "DECODER_INPUT";
            case TypeKind::PROPERTY_SETTER_RETURN: return "PROPERTY_SETTER_RETURN";
            case TypeKind::OPTIONAL: return "OPTIONAL";
            case TypeKind::PTR: return "PTR";
            case TypeKind::FUNCTION: return "FUNCTION";
        }
        return "";
    }
    
    constexpr std::optional<TypeKind> TypeKind_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "INT") {
            return TypeKind::INT;
        }
        if (str == "UINT") {
            return TypeKind::UINT;
        }
        if (str == "FLOAT") {
            return TypeKind::FLOAT;
        }
        if (str == "STRUCT") {
            return TypeKind::STRUCT;
        }
        if (str == "RECURSIVE_STRUCT") {
            return TypeKind::RECURSIVE_STRUCT;
        }
        if (str == "BOOL") {
            return TypeKind::BOOL;
        }
        if (str == "VOID") {
            return TypeKind::VOID;
        }
        if (str == "META") {
            return TypeKind::META;
        }
        if (str == "ENUM") {
            return TypeKind::ENUM;
        }
        if (str == "ARRAY") {
            return TypeKind::ARRAY;
        }
        if (str == "VECTOR") {
            return TypeKind::VECTOR;
        }
        if (str == "VARIANT") {
            return TypeKind::VARIANT;
        }
        if (str == "RANGE") {
            return TypeKind::RANGE;
        }
        if (str == "ENCODER_RETURN") {
            return TypeKind::ENCODER_RETURN;
        }
        if (str == "DECODER_RETURN") {
            return TypeKind::DECODER_RETURN;
        }
        if (str == "ENCODER_INPUT") {
            return TypeKind::ENCODER_INPUT;
        }
        if (str == "DECODER_INPUT") {
            return TypeKind::DECODER_INPUT;
        }
        if (str == "PROPERTY_SETTER_RETURN") {
            return TypeKind::PROPERTY_SETTER_RETURN;
        }
        if (str == "OPTIONAL") {
            return TypeKind::OPTIONAL;
        }
        if (str == "PTR") {
            return TypeKind::PTR;
        }
        if (str == "FUNCTION") {
            return TypeKind::FUNCTION;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(TypeKind) {
        return "TypeKind";
    }
    enum class AliasHint : std::uint8_t {
        IDENTIFIER = 0,
        STRING = 1,
        TYPE = 2,
        EXPRESSION = 3,
        STATEMENT = 4,
        ALIAS = 5,
    };
    constexpr const char* to_string(AliasHint e) {
        switch(e) {
            case AliasHint::IDENTIFIER: return "IDENTIFIER";
            case AliasHint::STRING: return "STRING";
            case AliasHint::TYPE: return "TYPE";
            case AliasHint::EXPRESSION: return "EXPRESSION";
            case AliasHint::STATEMENT: return "STATEMENT";
            case AliasHint::ALIAS: return "ALIAS";
        }
        return "";
    }
    
    constexpr std::optional<AliasHint> AliasHint_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "IDENTIFIER") {
            return AliasHint::IDENTIFIER;
        }
        if (str == "STRING") {
            return AliasHint::STRING;
        }
        if (str == "TYPE") {
            return AliasHint::TYPE;
        }
        if (str == "EXPRESSION") {
            return AliasHint::EXPRESSION;
        }
        if (str == "STATEMENT") {
            return AliasHint::STATEMENT;
        }
        if (str == "ALIAS") {
            return AliasHint::ALIAS;
        }
        return std::nullopt;
    }
    constexpr const char* visit_enum(AliasHint) {
        return "AliasHint";
    }
    struct Varint;
    struct StatementRef;
    struct IOAttribute;
    struct String;
    struct IdentifierRef;
    struct TypeRef;
    struct ExpressionRef;
    struct StringRef;
    struct LoweredStatement;
    struct LoweredExpression;
    struct LoopFlowControl;
    struct AnyRef;
    struct RefAlias;
    struct Expressions;
    struct CallDesc;
    struct Size;
    struct ExpressionBody;
    struct Expression;
    struct Condition;
    struct IfStatement;
    struct Metadata;
    struct LoweredStatements;
    struct LoweredExpressions;
    struct Block;
    struct AssertDesc;
    struct IOData;
    struct LoopStatement;
    struct MatchStatement;
    struct MatchBranch;
    struct FunctionDecl;
    struct VariableDecl;
    struct FieldDecl;
    struct EnumDecl;
    struct EnumMemberDecl;
    struct StructDecl;
    struct UnionDecl;
    struct UnionMemberDecl;
    struct PropertyDecl;
    struct PhiParam;
    struct ErrorReport;
    struct StatementBody;
    struct Statement;
    struct Types;
    struct TypeBody;
    struct Type;
    struct Loc;
    struct Identifier;
    struct StringLiteral;
    struct DebugInfo;
    struct ExtendedBinaryModule;
    struct EBM_API Varint{
        ::futils::binary::flags_t<std::uint64_t,2,62> flags_1_;
        bits_flag_alias_method(flags_1_,0,prefix);
        bits_flag_alias_method(flags_1_,1,value);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 0;
        constexpr static const char* visitor_name = "Varint";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "prefix",(*this).prefix());
            v(v, "value",(*this).value());
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "prefix",(*this).prefix());
            v(v, "value",(*this).value());
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "prefix",visitor_tag<decltype(std::declval<Varint>().prefix())>{});
            v(v, "value",visitor_tag<decltype(std::declval<Varint>().value())>{});
        }
    };
    struct EBM_API StatementRef{
        Varint id;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "StatementRef";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "id",(*this).id);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "id",(*this).id);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "id",visitor_tag<decltype(std::declval<StatementRef>().id)>{});
        }
    };
    struct EBM_API IOAttribute{
        ::futils::binary::flags_t<std::uint8_t, 3, 1, 1, 1, 2> flags_2_;
        bits_flag_alias_method_with_enum(flags_2_,0,endian,Endian);
        bits_flag_alias_method(flags_2_,1,sign);
        bits_flag_alias_method(flags_2_,2,is_peek);
        bits_flag_alias_method(flags_2_,3,vectorized);
        bits_flag_alias_method(flags_2_,4,reserved);
        StatementRef dynamic_ref;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
        constexpr static const char* visitor_name = "IOAttribute";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "endian",(*this).endian());
            v(v, "sign",(*this).sign());
            v(v, "is_peek",(*this).is_peek());
            v(v, "vectorized",(*this).vectorized());
            v(v, "reserved",(*this).reserved());
            v(v, "dynamic_ref",(*this).dynamic_ref);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "endian",(*this).endian());
            v(v, "sign",(*this).sign());
            v(v, "is_peek",(*this).is_peek());
            v(v, "vectorized",(*this).vectorized());
            v(v, "reserved",(*this).reserved());
            v(v, "dynamic_ref",(*this).dynamic_ref);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "endian",visitor_tag<decltype(std::declval<IOAttribute>().endian())>{});
            v(v, "sign",visitor_tag<decltype(std::declval<IOAttribute>().sign())>{});
            v(v, "is_peek",visitor_tag<decltype(std::declval<IOAttribute>().is_peek())>{});
            v(v, "vectorized",visitor_tag<decltype(std::declval<IOAttribute>().vectorized())>{});
            v(v, "reserved",visitor_tag<decltype(std::declval<IOAttribute>().reserved())>{});
            v(v, "dynamic_ref",visitor_tag<decltype(std::declval<IOAttribute>().dynamic_ref)>{});
        }
    };
    struct EBM_API String{
        Varint length;
        std::string data;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "String";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "length",(*this).length);
            v(v, "data",(*this).data);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "length",(*this).length);
            v(v, "data",(*this).data);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "length",visitor_tag<decltype(std::declval<String>().length)>{});
            v(v, "data",visitor_tag<decltype(std::declval<String>().data)>{});
        }
    };
    struct EBM_API IdentifierRef{
        Varint id;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "IdentifierRef";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "id",(*this).id);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "id",(*this).id);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "id",visitor_tag<decltype(std::declval<IdentifierRef>().id)>{});
        }
    };
    struct EBM_API TypeRef{
        Varint id;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "TypeRef";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "id",(*this).id);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "id",(*this).id);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "id",visitor_tag<decltype(std::declval<TypeRef>().id)>{});
        }
    };
    struct EBM_API ExpressionRef{
        Varint id;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "ExpressionRef";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "id",(*this).id);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "id",(*this).id);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "id",visitor_tag<decltype(std::declval<ExpressionRef>().id)>{});
        }
    };
    struct EBM_API StringRef{
        Varint id;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "StringRef";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "id",(*this).id);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "id",(*this).id);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "id",visitor_tag<decltype(std::declval<StringRef>().id)>{});
        }
    };
    struct EBM_API LoweredStatement{
        LoweringType lowering_type{};
        StatementRef block;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
        constexpr static const char* visitor_name = "LoweredStatement";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "lowering_type",(*this).lowering_type);
            v(v, "block",(*this).block);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "lowering_type",(*this).lowering_type);
            v(v, "block",(*this).block);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "lowering_type",visitor_tag<decltype(std::declval<LoweredStatement>().lowering_type)>{});
            v(v, "block",visitor_tag<decltype(std::declval<LoweredStatement>().block)>{});
        }
    };
    struct EBM_API LoweredExpression{
        LoweringType lowering_type{};
        ExpressionRef expression;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
        constexpr static const char* visitor_name = "LoweredExpression";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "lowering_type",(*this).lowering_type);
            v(v, "expression",(*this).expression);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "lowering_type",(*this).lowering_type);
            v(v, "expression",(*this).expression);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "lowering_type",visitor_tag<decltype(std::declval<LoweredExpression>().lowering_type)>{});
            v(v, "expression",visitor_tag<decltype(std::declval<LoweredExpression>().expression)>{});
        }
    };
    struct EBM_API LoopFlowControl{
        StatementRef related_statement;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "LoopFlowControl";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "related_statement",(*this).related_statement);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "related_statement",(*this).related_statement);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "related_statement",visitor_tag<decltype(std::declval<LoopFlowControl>().related_statement)>{});
        }
    };
    struct EBM_API AnyRef{
        Varint id;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "AnyRef";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "id",(*this).id);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "id",(*this).id);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "id",visitor_tag<decltype(std::declval<AnyRef>().id)>{});
        }
    };
    struct EBM_API RefAlias{
        AliasHint hint{};
        AnyRef from;
        AnyRef to;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
        constexpr static const char* visitor_name = "RefAlias";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "hint",(*this).hint);
            v(v, "from",(*this).from);
            v(v, "to",(*this).to);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "hint",(*this).hint);
            v(v, "from",(*this).from);
            v(v, "to",(*this).to);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "hint",visitor_tag<decltype(std::declval<RefAlias>().hint)>{});
            v(v, "from",visitor_tag<decltype(std::declval<RefAlias>().from)>{});
            v(v, "to",visitor_tag<decltype(std::declval<RefAlias>().to)>{});
        }
    };
    struct EBM_API Expressions{
        Varint len;
        std::vector<ExpressionRef> container;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "Expressions";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "len",(*this).len);
            v(v, "container",(*this).container);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "len",(*this).len);
            v(v, "container",(*this).container);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "len",visitor_tag<decltype(std::declval<Expressions>().len)>{});
            v(v, "container",visitor_tag<decltype(std::declval<Expressions>().container)>{});
        }
    };
    struct EBM_API CallDesc{
        ExpressionRef callee;
        Expressions arguments;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "CallDesc";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "callee",(*this).callee);
            v(v, "arguments",(*this).arguments);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "callee",(*this).callee);
            v(v, "arguments",(*this).arguments);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "callee",visitor_tag<decltype(std::declval<CallDesc>().callee)>{});
            v(v, "arguments",visitor_tag<decltype(std::declval<CallDesc>().arguments)>{});
        }
    };
    struct EBM_API Size{
        SizeUnit unit{};
        struct EBM_API union_struct_5{
        };
        struct EBM_API union_struct_6{
            Varint size;
        };
        struct EBM_API union_struct_7{
            Varint size;
        };
        struct EBM_API union_struct_8{
            Varint size;
        };
        struct EBM_API union_struct_9{
            ExpressionRef ref;
        };
        struct EBM_API union_struct_10{
            ExpressionRef ref;
        };
        struct EBM_API union_struct_11{
            ExpressionRef ref;
        };
        std::variant<std::monostate, union_struct_5, union_struct_6, union_struct_7, union_struct_8, union_struct_9, union_struct_10, union_struct_11> union_variant_4;
        const ExpressionRef* ref() const;
        ExpressionRef* ref();
        bool ref(ExpressionRef&& v);
        bool ref(const ExpressionRef& v);
        const Varint* size() const;
        Varint* size();
        bool size(Varint&& v);
        bool size(const Varint& v);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
        constexpr static const char* visitor_name = "Size";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "unit",(*this).unit);
            v(v, "ref",(*this).ref());
            v(v, "size",(*this).size());
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "unit",(*this).unit);
            v(v, "ref",(*this).ref());
            v(v, "size",(*this).size());
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "unit",visitor_tag<decltype(std::declval<Size>().unit)>{});
            v(v, "ref",visitor_tag<decltype(std::declval<Size>().ref())>{});
            v(v, "size",visitor_tag<decltype(std::declval<Size>().size())>{});
        }
    };
    struct EBM_API ExpressionBody{
        TypeRef type;
        ExpressionOp kind{};
        struct EBM_API union_struct_14{
            Varint int_value;
        };
        struct EBM_API union_struct_15{
            std::uint64_t int64_value = 0;
        };
        struct EBM_API union_struct_16{
            std::uint8_t bool_value = 0;
        };
        struct EBM_API union_struct_17{
            StringRef string_value;
        };
        struct EBM_API union_struct_18{
            TypeRef type_ref;
        };
        struct EBM_API union_struct_19{
            Varint char_value;
        };
        struct EBM_API union_struct_20{
            StatementRef id;
        };
        struct EBM_API union_struct_21{
            BinaryOp bop{};
            ExpressionRef left;
            ExpressionRef right;
        };
        struct EBM_API union_struct_22{
            UnaryOp uop{};
            ExpressionRef operand;
        };
        struct EBM_API union_struct_23{
            CallDesc call_desc;
        };
        struct EBM_API union_struct_24{
            ExpressionRef base;
            ExpressionRef index;
        };
        struct EBM_API union_struct_25{
            ExpressionRef base;
            ExpressionRef member;
        };
        struct EBM_API union_struct_26{
            TypeRef from_type;
            ExpressionRef source_expr;
            CastType cast_kind{};
        };
        struct EBM_API union_struct_27{
            ExpressionRef start;
            ExpressionRef end;
        };
        struct EBM_API union_struct_28{
            StatementRef endian_expr;
        };
        struct EBM_API union_struct_29{
            StreamType stream_type{};
            SizeUnit unit{};
        };
        struct EBM_API union_struct_30{
            StreamType stream_type{};
        };
        struct EBM_API union_struct_31{
            StreamType stream_type{};
            Size num_bytes;
        };
        struct EBM_API union_struct_32{
            ExpressionRef array_expr;
        };
        struct EBM_API union_struct_33{
            ExpressionRef target_expr;
        };
        struct EBM_API union_struct_34{
            ExpressionRef lowered_expr;
        };
        struct EBM_API union_struct_35{
            StatementRef target_stmt;
            StatementRef io_statement;
        };
        struct EBM_API union_struct_36{
            ExpressionRef target_expr;
            StatementRef io_statement;
        };
        struct EBM_API union_struct_37{
            StatementRef target_stmt;
            StatementRef conditional_stmt;
        };
        std::variant<std::monostate, union_struct_14, union_struct_15, union_struct_16, union_struct_17, union_struct_18, union_struct_19, union_struct_20, union_struct_21, union_struct_22, union_struct_23, union_struct_24, union_struct_25, union_struct_26, union_struct_27, union_struct_28, union_struct_29, union_struct_30, union_struct_31, union_struct_32, union_struct_33, union_struct_34, union_struct_35, union_struct_36, union_struct_37> union_variant_13;
        const ExpressionRef* array_expr() const;
        ExpressionRef* array_expr();
        bool array_expr(ExpressionRef&& v);
        bool array_expr(const ExpressionRef& v);
        const ExpressionRef* base() const;
        ExpressionRef* base();
        bool base(ExpressionRef&& v);
        bool base(const ExpressionRef& v);
        const std::uint8_t* bool_value() const;
        std::uint8_t* bool_value();
        bool bool_value(std::uint8_t&& v);
        bool bool_value(const std::uint8_t& v);
        const BinaryOp* bop() const;
        BinaryOp* bop();
        bool bop(BinaryOp&& v);
        bool bop(const BinaryOp& v);
        const CallDesc* call_desc() const;
        CallDesc* call_desc();
        bool call_desc(CallDesc&& v);
        bool call_desc(const CallDesc& v);
        const CastType* cast_kind() const;
        CastType* cast_kind();
        bool cast_kind(CastType&& v);
        bool cast_kind(const CastType& v);
        const Varint* char_value() const;
        Varint* char_value();
        bool char_value(Varint&& v);
        bool char_value(const Varint& v);
        const StatementRef* conditional_stmt() const;
        StatementRef* conditional_stmt();
        bool conditional_stmt(StatementRef&& v);
        bool conditional_stmt(const StatementRef& v);
        const ExpressionRef* end() const;
        ExpressionRef* end();
        bool end(ExpressionRef&& v);
        bool end(const ExpressionRef& v);
        const StatementRef* endian_expr() const;
        StatementRef* endian_expr();
        bool endian_expr(StatementRef&& v);
        bool endian_expr(const StatementRef& v);
        const TypeRef* from_type() const;
        TypeRef* from_type();
        bool from_type(TypeRef&& v);
        bool from_type(const TypeRef& v);
        const StatementRef* id() const;
        StatementRef* id();
        bool id(StatementRef&& v);
        bool id(const StatementRef& v);
        const ExpressionRef* index() const;
        ExpressionRef* index();
        bool index(ExpressionRef&& v);
        bool index(const ExpressionRef& v);
        const std::uint64_t* int64_value() const;
        std::uint64_t* int64_value();
        bool int64_value(std::uint64_t&& v);
        bool int64_value(const std::uint64_t& v);
        const Varint* int_value() const;
        Varint* int_value();
        bool int_value(Varint&& v);
        bool int_value(const Varint& v);
        const StatementRef* io_statement() const;
        StatementRef* io_statement();
        bool io_statement(StatementRef&& v);
        bool io_statement(const StatementRef& v);
        const ExpressionRef* left() const;
        ExpressionRef* left();
        bool left(ExpressionRef&& v);
        bool left(const ExpressionRef& v);
        const ExpressionRef* lowered_expr() const;
        ExpressionRef* lowered_expr();
        bool lowered_expr(ExpressionRef&& v);
        bool lowered_expr(const ExpressionRef& v);
        const ExpressionRef* member() const;
        ExpressionRef* member();
        bool member(ExpressionRef&& v);
        bool member(const ExpressionRef& v);
        const Size* num_bytes() const;
        Size* num_bytes();
        bool num_bytes(Size&& v);
        bool num_bytes(const Size& v);
        const ExpressionRef* operand() const;
        ExpressionRef* operand();
        bool operand(ExpressionRef&& v);
        bool operand(const ExpressionRef& v);
        const ExpressionRef* right() const;
        ExpressionRef* right();
        bool right(ExpressionRef&& v);
        bool right(const ExpressionRef& v);
        const ExpressionRef* source_expr() const;
        ExpressionRef* source_expr();
        bool source_expr(ExpressionRef&& v);
        bool source_expr(const ExpressionRef& v);
        const ExpressionRef* start() const;
        ExpressionRef* start();
        bool start(ExpressionRef&& v);
        bool start(const ExpressionRef& v);
        const StreamType* stream_type() const;
        StreamType* stream_type();
        bool stream_type(StreamType&& v);
        bool stream_type(const StreamType& v);
        const StringRef* string_value() const;
        StringRef* string_value();
        bool string_value(StringRef&& v);
        bool string_value(const StringRef& v);
        const ExpressionRef* target_expr() const;
        ExpressionRef* target_expr();
        bool target_expr(ExpressionRef&& v);
        bool target_expr(const ExpressionRef& v);
        const StatementRef* target_stmt() const;
        StatementRef* target_stmt();
        bool target_stmt(StatementRef&& v);
        bool target_stmt(const StatementRef& v);
        const TypeRef* type_ref() const;
        TypeRef* type_ref();
        bool type_ref(TypeRef&& v);
        bool type_ref(const TypeRef& v);
        const SizeUnit* unit() const;
        SizeUnit* unit();
        bool unit(SizeUnit&& v);
        bool unit(const SizeUnit& v);
        const UnaryOp* uop() const;
        UnaryOp* uop();
        bool uop(UnaryOp&& v);
        bool uop(const UnaryOp& v);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "ExpressionBody";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "type",(*this).type);
            v(v, "kind",(*this).kind);
            v(v, "array_expr",(*this).array_expr());
            v(v, "base",(*this).base());
            v(v, "bool_value",(*this).bool_value());
            v(v, "bop",(*this).bop());
            v(v, "call_desc",(*this).call_desc());
            v(v, "cast_kind",(*this).cast_kind());
            v(v, "char_value",(*this).char_value());
            v(v, "conditional_stmt",(*this).conditional_stmt());
            v(v, "end",(*this).end());
            v(v, "endian_expr",(*this).endian_expr());
            v(v, "from_type",(*this).from_type());
            v(v, "id",(*this).id());
            v(v, "index",(*this).index());
            v(v, "int64_value",(*this).int64_value());
            v(v, "int_value",(*this).int_value());
            v(v, "io_statement",(*this).io_statement());
            v(v, "left",(*this).left());
            v(v, "lowered_expr",(*this).lowered_expr());
            v(v, "member",(*this).member());
            v(v, "num_bytes",(*this).num_bytes());
            v(v, "operand",(*this).operand());
            v(v, "right",(*this).right());
            v(v, "source_expr",(*this).source_expr());
            v(v, "start",(*this).start());
            v(v, "stream_type",(*this).stream_type());
            v(v, "string_value",(*this).string_value());
            v(v, "target_expr",(*this).target_expr());
            v(v, "target_stmt",(*this).target_stmt());
            v(v, "type_ref",(*this).type_ref());
            v(v, "unit",(*this).unit());
            v(v, "uop",(*this).uop());
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "type",(*this).type);
            v(v, "kind",(*this).kind);
            v(v, "array_expr",(*this).array_expr());
            v(v, "base",(*this).base());
            v(v, "bool_value",(*this).bool_value());
            v(v, "bop",(*this).bop());
            v(v, "call_desc",(*this).call_desc());
            v(v, "cast_kind",(*this).cast_kind());
            v(v, "char_value",(*this).char_value());
            v(v, "conditional_stmt",(*this).conditional_stmt());
            v(v, "end",(*this).end());
            v(v, "endian_expr",(*this).endian_expr());
            v(v, "from_type",(*this).from_type());
            v(v, "id",(*this).id());
            v(v, "index",(*this).index());
            v(v, "int64_value",(*this).int64_value());
            v(v, "int_value",(*this).int_value());
            v(v, "io_statement",(*this).io_statement());
            v(v, "left",(*this).left());
            v(v, "lowered_expr",(*this).lowered_expr());
            v(v, "member",(*this).member());
            v(v, "num_bytes",(*this).num_bytes());
            v(v, "operand",(*this).operand());
            v(v, "right",(*this).right());
            v(v, "source_expr",(*this).source_expr());
            v(v, "start",(*this).start());
            v(v, "stream_type",(*this).stream_type());
            v(v, "string_value",(*this).string_value());
            v(v, "target_expr",(*this).target_expr());
            v(v, "target_stmt",(*this).target_stmt());
            v(v, "type_ref",(*this).type_ref());
            v(v, "unit",(*this).unit());
            v(v, "uop",(*this).uop());
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "type",visitor_tag<decltype(std::declval<ExpressionBody>().type)>{});
            v(v, "kind",visitor_tag<decltype(std::declval<ExpressionBody>().kind)>{});
            v(v, "array_expr",visitor_tag<decltype(std::declval<ExpressionBody>().array_expr())>{});
            v(v, "base",visitor_tag<decltype(std::declval<ExpressionBody>().base())>{});
            v(v, "bool_value",visitor_tag<decltype(std::declval<ExpressionBody>().bool_value())>{});
            v(v, "bop",visitor_tag<decltype(std::declval<ExpressionBody>().bop())>{});
            v(v, "call_desc",visitor_tag<decltype(std::declval<ExpressionBody>().call_desc())>{});
            v(v, "cast_kind",visitor_tag<decltype(std::declval<ExpressionBody>().cast_kind())>{});
            v(v, "char_value",visitor_tag<decltype(std::declval<ExpressionBody>().char_value())>{});
            v(v, "conditional_stmt",visitor_tag<decltype(std::declval<ExpressionBody>().conditional_stmt())>{});
            v(v, "end",visitor_tag<decltype(std::declval<ExpressionBody>().end())>{});
            v(v, "endian_expr",visitor_tag<decltype(std::declval<ExpressionBody>().endian_expr())>{});
            v(v, "from_type",visitor_tag<decltype(std::declval<ExpressionBody>().from_type())>{});
            v(v, "id",visitor_tag<decltype(std::declval<ExpressionBody>().id())>{});
            v(v, "index",visitor_tag<decltype(std::declval<ExpressionBody>().index())>{});
            v(v, "int64_value",visitor_tag<decltype(std::declval<ExpressionBody>().int64_value())>{});
            v(v, "int_value",visitor_tag<decltype(std::declval<ExpressionBody>().int_value())>{});
            v(v, "io_statement",visitor_tag<decltype(std::declval<ExpressionBody>().io_statement())>{});
            v(v, "left",visitor_tag<decltype(std::declval<ExpressionBody>().left())>{});
            v(v, "lowered_expr",visitor_tag<decltype(std::declval<ExpressionBody>().lowered_expr())>{});
            v(v, "member",visitor_tag<decltype(std::declval<ExpressionBody>().member())>{});
            v(v, "num_bytes",visitor_tag<decltype(std::declval<ExpressionBody>().num_bytes())>{});
            v(v, "operand",visitor_tag<decltype(std::declval<ExpressionBody>().operand())>{});
            v(v, "right",visitor_tag<decltype(std::declval<ExpressionBody>().right())>{});
            v(v, "source_expr",visitor_tag<decltype(std::declval<ExpressionBody>().source_expr())>{});
            v(v, "start",visitor_tag<decltype(std::declval<ExpressionBody>().start())>{});
            v(v, "stream_type",visitor_tag<decltype(std::declval<ExpressionBody>().stream_type())>{});
            v(v, "string_value",visitor_tag<decltype(std::declval<ExpressionBody>().string_value())>{});
            v(v, "target_expr",visitor_tag<decltype(std::declval<ExpressionBody>().target_expr())>{});
            v(v, "target_stmt",visitor_tag<decltype(std::declval<ExpressionBody>().target_stmt())>{});
            v(v, "type_ref",visitor_tag<decltype(std::declval<ExpressionBody>().type_ref())>{});
            v(v, "unit",visitor_tag<decltype(std::declval<ExpressionBody>().unit())>{});
            v(v, "uop",visitor_tag<decltype(std::declval<ExpressionBody>().uop())>{});
        }
    };
    struct EBM_API Expression{
        ExpressionRef id;
        ExpressionBody body;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "Expression";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "id",(*this).id);
            v(v, "body",(*this).body);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "id",(*this).id);
            v(v, "body",(*this).body);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "id",visitor_tag<decltype(std::declval<Expression>().id)>{});
            v(v, "body",visitor_tag<decltype(std::declval<Expression>().body)>{});
        }
    };
    struct EBM_API Condition{
        StatementRef flattened_statement;
        ExpressionRef cond;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "Condition";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "flattened_statement",(*this).flattened_statement);
            v(v, "cond",(*this).cond);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "flattened_statement",(*this).flattened_statement);
            v(v, "cond",(*this).cond);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "flattened_statement",visitor_tag<decltype(std::declval<Condition>().flattened_statement)>{});
            v(v, "cond",visitor_tag<decltype(std::declval<Condition>().cond)>{});
        }
    };
    struct EBM_API IfStatement{
        Condition condition;
        StatementRef then_block;
        StatementRef else_block;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "IfStatement";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "condition",(*this).condition);
            v(v, "then_block",(*this).then_block);
            v(v, "else_block",(*this).else_block);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "condition",(*this).condition);
            v(v, "then_block",(*this).then_block);
            v(v, "else_block",(*this).else_block);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "condition",visitor_tag<decltype(std::declval<IfStatement>().condition)>{});
            v(v, "then_block",visitor_tag<decltype(std::declval<IfStatement>().then_block)>{});
            v(v, "else_block",visitor_tag<decltype(std::declval<IfStatement>().else_block)>{});
        }
    };
    struct EBM_API Metadata{
        IdentifierRef name;
        Expressions values;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "Metadata";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "name",(*this).name);
            v(v, "values",(*this).values);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "name",(*this).name);
            v(v, "values",(*this).values);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "name",visitor_tag<decltype(std::declval<Metadata>().name)>{});
            v(v, "values",visitor_tag<decltype(std::declval<Metadata>().values)>{});
        }
    };
    struct EBM_API LoweredStatements{
        Varint len;
        std::vector<LoweredStatement> container;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "LoweredStatements";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "len",(*this).len);
            v(v, "container",(*this).container);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "len",(*this).len);
            v(v, "container",(*this).container);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "len",visitor_tag<decltype(std::declval<LoweredStatements>().len)>{});
            v(v, "container",visitor_tag<decltype(std::declval<LoweredStatements>().container)>{});
        }
    };
    struct EBM_API LoweredExpressions{
        Varint len;
        std::vector<LoweredExpression> container;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "LoweredExpressions";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "len",(*this).len);
            v(v, "container",(*this).container);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "len",(*this).len);
            v(v, "container",(*this).container);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "len",visitor_tag<decltype(std::declval<LoweredExpressions>().len)>{});
            v(v, "container",visitor_tag<decltype(std::declval<LoweredExpressions>().container)>{});
        }
    };
    struct EBM_API Block{
        Varint len;
        std::vector<StatementRef> container;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "Block";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "len",(*this).len);
            v(v, "container",(*this).container);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "len",(*this).len);
            v(v, "container",(*this).container);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "len",visitor_tag<decltype(std::declval<Block>().len)>{});
            v(v, "container",visitor_tag<decltype(std::declval<Block>().container)>{});
        }
    };
    struct EBM_API AssertDesc{
        Condition condition;
        StatementRef lowered_statement;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "AssertDesc";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "condition",(*this).condition);
            v(v, "lowered_statement",(*this).lowered_statement);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "condition",(*this).condition);
            v(v, "lowered_statement",(*this).lowered_statement);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "condition",visitor_tag<decltype(std::declval<AssertDesc>().condition)>{});
            v(v, "lowered_statement",visitor_tag<decltype(std::declval<AssertDesc>().lowered_statement)>{});
        }
    };
    struct EBM_API IOData{
        StatementRef io_ref;
        ExpressionRef target;
        TypeRef data_type;
        IOAttribute attribute;
        Size size;
        StatementRef lowered_stmt;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "IOData";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "io_ref",(*this).io_ref);
            v(v, "target",(*this).target);
            v(v, "data_type",(*this).data_type);
            v(v, "attribute",(*this).attribute);
            v(v, "size",(*this).size);
            v(v, "lowered_stmt",(*this).lowered_stmt);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "io_ref",(*this).io_ref);
            v(v, "target",(*this).target);
            v(v, "data_type",(*this).data_type);
            v(v, "attribute",(*this).attribute);
            v(v, "size",(*this).size);
            v(v, "lowered_stmt",(*this).lowered_stmt);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "io_ref",visitor_tag<decltype(std::declval<IOData>().io_ref)>{});
            v(v, "target",visitor_tag<decltype(std::declval<IOData>().target)>{});
            v(v, "data_type",visitor_tag<decltype(std::declval<IOData>().data_type)>{});
            v(v, "attribute",visitor_tag<decltype(std::declval<IOData>().attribute)>{});
            v(v, "size",visitor_tag<decltype(std::declval<IOData>().size)>{});
            v(v, "lowered_stmt",visitor_tag<decltype(std::declval<IOData>().lowered_stmt)>{});
        }
    };
    struct EBM_API LoopStatement{
        LoopType loop_type{};
        struct EBM_API union_struct_40{
        };
        struct EBM_API union_struct_41{
            Condition condition;
        };
        struct EBM_API union_struct_42{
            StatementRef item_var;
            ExpressionRef collection;
        };
        struct EBM_API union_struct_43{
            StatementRef init;
            Condition condition;
            StatementRef increment;
        };
        std::variant<std::monostate, union_struct_40, union_struct_41, union_struct_42, union_struct_43> union_variant_39;
        const ExpressionRef* collection() const;
        ExpressionRef* collection();
        bool collection(ExpressionRef&& v);
        bool collection(const ExpressionRef& v);
        const Condition* condition() const;
        Condition* condition();
        bool condition(Condition&& v);
        bool condition(const Condition& v);
        const StatementRef* increment() const;
        StatementRef* increment();
        bool increment(StatementRef&& v);
        bool increment(const StatementRef& v);
        const StatementRef* init() const;
        StatementRef* init();
        bool init(StatementRef&& v);
        bool init(const StatementRef& v);
        const StatementRef* item_var() const;
        StatementRef* item_var();
        bool item_var(StatementRef&& v);
        bool item_var(const StatementRef& v);
        StatementRef body;
        StatementRef lowered_statement;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
        constexpr static const char* visitor_name = "LoopStatement";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "loop_type",(*this).loop_type);
            v(v, "collection",(*this).collection());
            v(v, "condition",(*this).condition());
            v(v, "increment",(*this).increment());
            v(v, "init",(*this).init());
            v(v, "item_var",(*this).item_var());
            v(v, "body",(*this).body);
            v(v, "lowered_statement",(*this).lowered_statement);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "loop_type",(*this).loop_type);
            v(v, "collection",(*this).collection());
            v(v, "condition",(*this).condition());
            v(v, "increment",(*this).increment());
            v(v, "init",(*this).init());
            v(v, "item_var",(*this).item_var());
            v(v, "body",(*this).body);
            v(v, "lowered_statement",(*this).lowered_statement);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "loop_type",visitor_tag<decltype(std::declval<LoopStatement>().loop_type)>{});
            v(v, "collection",visitor_tag<decltype(std::declval<LoopStatement>().collection())>{});
            v(v, "condition",visitor_tag<decltype(std::declval<LoopStatement>().condition())>{});
            v(v, "increment",visitor_tag<decltype(std::declval<LoopStatement>().increment())>{});
            v(v, "init",visitor_tag<decltype(std::declval<LoopStatement>().init())>{});
            v(v, "item_var",visitor_tag<decltype(std::declval<LoopStatement>().item_var())>{});
            v(v, "body",visitor_tag<decltype(std::declval<LoopStatement>().body)>{});
            v(v, "lowered_statement",visitor_tag<decltype(std::declval<LoopStatement>().lowered_statement)>{});
        }
    };
    struct EBM_API MatchStatement{
        ExpressionRef target;
        ::futils::binary::flags_t<std::uint8_t, 1, 7> flags_44_;
        bits_flag_alias_method(flags_44_,0,is_exhaustive);
        bits_flag_alias_method(flags_44_,1,reserved);
        Block branches;
        StatementRef lowered_if_statement;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "MatchStatement";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "target",(*this).target);
            v(v, "is_exhaustive",(*this).is_exhaustive());
            v(v, "reserved",(*this).reserved());
            v(v, "branches",(*this).branches);
            v(v, "lowered_if_statement",(*this).lowered_if_statement);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "target",(*this).target);
            v(v, "is_exhaustive",(*this).is_exhaustive());
            v(v, "reserved",(*this).reserved());
            v(v, "branches",(*this).branches);
            v(v, "lowered_if_statement",(*this).lowered_if_statement);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "target",visitor_tag<decltype(std::declval<MatchStatement>().target)>{});
            v(v, "is_exhaustive",visitor_tag<decltype(std::declval<MatchStatement>().is_exhaustive())>{});
            v(v, "reserved",visitor_tag<decltype(std::declval<MatchStatement>().reserved())>{});
            v(v, "branches",visitor_tag<decltype(std::declval<MatchStatement>().branches)>{});
            v(v, "lowered_if_statement",visitor_tag<decltype(std::declval<MatchStatement>().lowered_if_statement)>{});
        }
    };
    struct EBM_API MatchBranch{
        Condition condition;
        StatementRef body;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "MatchBranch";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "condition",(*this).condition);
            v(v, "body",(*this).body);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "condition",(*this).condition);
            v(v, "body",(*this).body);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "condition",visitor_tag<decltype(std::declval<MatchBranch>().condition)>{});
            v(v, "body",visitor_tag<decltype(std::declval<MatchBranch>().body)>{});
        }
    };
    struct EBM_API FunctionDecl{
        IdentifierRef name;
        TypeRef return_type;
        Block params;
        StatementRef parent_format;
        StatementRef body;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "FunctionDecl";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "name",(*this).name);
            v(v, "return_type",(*this).return_type);
            v(v, "params",(*this).params);
            v(v, "parent_format",(*this).parent_format);
            v(v, "body",(*this).body);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "name",(*this).name);
            v(v, "return_type",(*this).return_type);
            v(v, "params",(*this).params);
            v(v, "parent_format",(*this).parent_format);
            v(v, "body",(*this).body);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "name",visitor_tag<decltype(std::declval<FunctionDecl>().name)>{});
            v(v, "return_type",visitor_tag<decltype(std::declval<FunctionDecl>().return_type)>{});
            v(v, "params",visitor_tag<decltype(std::declval<FunctionDecl>().params)>{});
            v(v, "parent_format",visitor_tag<decltype(std::declval<FunctionDecl>().parent_format)>{});
            v(v, "body",visitor_tag<decltype(std::declval<FunctionDecl>().body)>{});
        }
    };
    struct EBM_API VariableDecl{
        IdentifierRef name;
        TypeRef var_type;
        ExpressionRef initial_value;
        ::futils::binary::flags_t<std::uint8_t, 1, 1, 6> flags_45_;
        bits_flag_alias_method(flags_45_,0,is_constant);
        bits_flag_alias_method(flags_45_,1,is_reference);
        bits_flag_alias_method(flags_45_,2,reserved);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "VariableDecl";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "name",(*this).name);
            v(v, "var_type",(*this).var_type);
            v(v, "initial_value",(*this).initial_value);
            v(v, "is_constant",(*this).is_constant());
            v(v, "is_reference",(*this).is_reference());
            v(v, "reserved",(*this).reserved());
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "name",(*this).name);
            v(v, "var_type",(*this).var_type);
            v(v, "initial_value",(*this).initial_value);
            v(v, "is_constant",(*this).is_constant());
            v(v, "is_reference",(*this).is_reference());
            v(v, "reserved",(*this).reserved());
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "name",visitor_tag<decltype(std::declval<VariableDecl>().name)>{});
            v(v, "var_type",visitor_tag<decltype(std::declval<VariableDecl>().var_type)>{});
            v(v, "initial_value",visitor_tag<decltype(std::declval<VariableDecl>().initial_value)>{});
            v(v, "is_constant",visitor_tag<decltype(std::declval<VariableDecl>().is_constant())>{});
            v(v, "is_reference",visitor_tag<decltype(std::declval<VariableDecl>().is_reference())>{});
            v(v, "reserved",visitor_tag<decltype(std::declval<VariableDecl>().reserved())>{});
        }
    };
    struct EBM_API FieldDecl{
        IdentifierRef name;
        TypeRef field_type;
        StatementRef parent_struct;
        ::futils::binary::flags_t<std::uint8_t, 1, 7> flags_46_;
        bits_flag_alias_method(flags_46_,0,is_state_variable);
        bits_flag_alias_method(flags_46_,1,reserved);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "FieldDecl";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "name",(*this).name);
            v(v, "field_type",(*this).field_type);
            v(v, "parent_struct",(*this).parent_struct);
            v(v, "is_state_variable",(*this).is_state_variable());
            v(v, "reserved",(*this).reserved());
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "name",(*this).name);
            v(v, "field_type",(*this).field_type);
            v(v, "parent_struct",(*this).parent_struct);
            v(v, "is_state_variable",(*this).is_state_variable());
            v(v, "reserved",(*this).reserved());
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "name",visitor_tag<decltype(std::declval<FieldDecl>().name)>{});
            v(v, "field_type",visitor_tag<decltype(std::declval<FieldDecl>().field_type)>{});
            v(v, "parent_struct",visitor_tag<decltype(std::declval<FieldDecl>().parent_struct)>{});
            v(v, "is_state_variable",visitor_tag<decltype(std::declval<FieldDecl>().is_state_variable())>{});
            v(v, "reserved",visitor_tag<decltype(std::declval<FieldDecl>().reserved())>{});
        }
    };
    struct EBM_API EnumDecl{
        IdentifierRef name;
        TypeRef base_type;
        Block members;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "EnumDecl";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "name",(*this).name);
            v(v, "base_type",(*this).base_type);
            v(v, "members",(*this).members);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "name",(*this).name);
            v(v, "base_type",(*this).base_type);
            v(v, "members",(*this).members);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "name",visitor_tag<decltype(std::declval<EnumDecl>().name)>{});
            v(v, "base_type",visitor_tag<decltype(std::declval<EnumDecl>().base_type)>{});
            v(v, "members",visitor_tag<decltype(std::declval<EnumDecl>().members)>{});
        }
    };
    struct EBM_API EnumMemberDecl{
        IdentifierRef name;
        ExpressionRef value;
        StringRef string_repr;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "EnumMemberDecl";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "name",(*this).name);
            v(v, "value",(*this).value);
            v(v, "string_repr",(*this).string_repr);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "name",(*this).name);
            v(v, "value",(*this).value);
            v(v, "string_repr",(*this).string_repr);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "name",visitor_tag<decltype(std::declval<EnumMemberDecl>().name)>{});
            v(v, "value",visitor_tag<decltype(std::declval<EnumMemberDecl>().value)>{});
            v(v, "string_repr",visitor_tag<decltype(std::declval<EnumMemberDecl>().string_repr)>{});
        }
    };
    struct EBM_API StructDecl{
        IdentifierRef name;
        Block fields;
        StatementRef encode_fn;
        StatementRef decode_fn;
        ::futils::binary::flags_t<std::uint8_t, 1, 7> flags_47_;
        bits_flag_alias_method(flags_47_,0,is_recursive);
        bits_flag_alias_method(flags_47_,1,reserved);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "StructDecl";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "name",(*this).name);
            v(v, "fields",(*this).fields);
            v(v, "encode_fn",(*this).encode_fn);
            v(v, "decode_fn",(*this).decode_fn);
            v(v, "is_recursive",(*this).is_recursive());
            v(v, "reserved",(*this).reserved());
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "name",(*this).name);
            v(v, "fields",(*this).fields);
            v(v, "encode_fn",(*this).encode_fn);
            v(v, "decode_fn",(*this).decode_fn);
            v(v, "is_recursive",(*this).is_recursive());
            v(v, "reserved",(*this).reserved());
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "name",visitor_tag<decltype(std::declval<StructDecl>().name)>{});
            v(v, "fields",visitor_tag<decltype(std::declval<StructDecl>().fields)>{});
            v(v, "encode_fn",visitor_tag<decltype(std::declval<StructDecl>().encode_fn)>{});
            v(v, "decode_fn",visitor_tag<decltype(std::declval<StructDecl>().decode_fn)>{});
            v(v, "is_recursive",visitor_tag<decltype(std::declval<StructDecl>().is_recursive())>{});
            v(v, "reserved",visitor_tag<decltype(std::declval<StructDecl>().reserved())>{});
        }
    };
    struct EBM_API UnionDecl{
        IdentifierRef name;
        StatementRef parent_field;
        Block members;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "UnionDecl";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "name",(*this).name);
            v(v, "parent_field",(*this).parent_field);
            v(v, "members",(*this).members);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "name",(*this).name);
            v(v, "parent_field",(*this).parent_field);
            v(v, "members",(*this).members);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "name",visitor_tag<decltype(std::declval<UnionDecl>().name)>{});
            v(v, "parent_field",visitor_tag<decltype(std::declval<UnionDecl>().parent_field)>{});
            v(v, "members",visitor_tag<decltype(std::declval<UnionDecl>().members)>{});
        }
    };
    struct EBM_API UnionMemberDecl{
        IdentifierRef name;
        TypeRef field_type;
        ::futils::binary::flags_t<std::uint8_t, 1, 7> flags_48_;
        bits_flag_alias_method(flags_48_,0,is_state_variable);
        bits_flag_alias_method(flags_48_,1,reserved);
        StatementRef parent_union;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "UnionMemberDecl";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "name",(*this).name);
            v(v, "field_type",(*this).field_type);
            v(v, "is_state_variable",(*this).is_state_variable());
            v(v, "reserved",(*this).reserved());
            v(v, "parent_union",(*this).parent_union);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "name",(*this).name);
            v(v, "field_type",(*this).field_type);
            v(v, "is_state_variable",(*this).is_state_variable());
            v(v, "reserved",(*this).reserved());
            v(v, "parent_union",(*this).parent_union);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "name",visitor_tag<decltype(std::declval<UnionMemberDecl>().name)>{});
            v(v, "field_type",visitor_tag<decltype(std::declval<UnionMemberDecl>().field_type)>{});
            v(v, "is_state_variable",visitor_tag<decltype(std::declval<UnionMemberDecl>().is_state_variable())>{});
            v(v, "reserved",visitor_tag<decltype(std::declval<UnionMemberDecl>().reserved())>{});
            v(v, "parent_union",visitor_tag<decltype(std::declval<UnionMemberDecl>().parent_union)>{});
        }
    };
    struct EBM_API PropertyDecl{
        IdentifierRef name;
        StatementRef parent_format;
        TypeRef property_type;
        MergeMode merge_mode{};
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "PropertyDecl";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "name",(*this).name);
            v(v, "parent_format",(*this).parent_format);
            v(v, "property_type",(*this).property_type);
            v(v, "merge_mode",(*this).merge_mode);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "name",(*this).name);
            v(v, "parent_format",(*this).parent_format);
            v(v, "property_type",(*this).property_type);
            v(v, "merge_mode",(*this).merge_mode);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "name",visitor_tag<decltype(std::declval<PropertyDecl>().name)>{});
            v(v, "parent_format",visitor_tag<decltype(std::declval<PropertyDecl>().parent_format)>{});
            v(v, "property_type",visitor_tag<decltype(std::declval<PropertyDecl>().property_type)>{});
            v(v, "merge_mode",visitor_tag<decltype(std::declval<PropertyDecl>().merge_mode)>{});
        }
    };
    struct EBM_API PhiParam{
        Condition condition;
        ExpressionRef value;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "PhiParam";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "condition",(*this).condition);
            v(v, "value",(*this).value);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "condition",(*this).condition);
            v(v, "value",(*this).value);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "condition",visitor_tag<decltype(std::declval<PhiParam>().condition)>{});
            v(v, "value",visitor_tag<decltype(std::declval<PhiParam>().value)>{});
        }
    };
    struct EBM_API ErrorReport{
        StringRef message;
        Expressions arguments;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "ErrorReport";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "message",(*this).message);
            v(v, "arguments",(*this).arguments);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "message",(*this).message);
            v(v, "arguments",(*this).arguments);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "message",visitor_tag<decltype(std::declval<ErrorReport>().message)>{});
            v(v, "arguments",visitor_tag<decltype(std::declval<ErrorReport>().arguments)>{});
        }
    };
    struct EBM_API StatementBody{
        StatementOp kind{};
        struct EBM_API union_struct_51{
            Block block;
        };
        struct EBM_API union_struct_52{
            ExpressionRef target;
            ExpressionRef value;
            StatementRef previous_assignment;
        };
        struct EBM_API union_struct_53{
            ExpressionRef target;
            ExpressionRef value;
        };
        struct EBM_API union_struct_54{
            ExpressionRef value;
        };
        struct EBM_API union_struct_55{
            ExpressionRef value;
        };
        struct EBM_API union_struct_56{
            AssertDesc assert_desc;
        };
        struct EBM_API union_struct_57{
            IOData read_data;
        };
        struct EBM_API union_struct_58{
            IOData write_data;
        };
        struct EBM_API union_struct_59{
            ExpressionRef offset;
            StreamType stream_type{};
        };
        struct EBM_API union_struct_60{
            IfStatement if_statement;
        };
        struct EBM_API union_struct_61{
            LoopStatement loop;
        };
        struct EBM_API union_struct_62{
            MatchStatement match_statement;
        };
        struct EBM_API union_struct_63{
            MatchBranch match_branch;
        };
        struct EBM_API union_struct_64{
            LoopFlowControl break_;
        };
        struct EBM_API union_struct_65{
            LoopFlowControl continue_;
        };
        struct EBM_API union_struct_66{
            FunctionDecl func_decl;
        };
        struct EBM_API union_struct_67{
            VariableDecl var_decl;
        };
        struct EBM_API union_struct_68{
            FieldDecl field_decl;
        };
        struct EBM_API union_struct_69{
            EnumDecl enum_decl;
        };
        struct EBM_API union_struct_70{
            EnumMemberDecl enum_member_decl;
        };
        struct EBM_API union_struct_71{
            StructDecl struct_decl;
        };
        struct EBM_API union_struct_72{
            UnionDecl union_decl;
        };
        struct EBM_API union_struct_73{
            UnionMemberDecl union_member_decl;
        };
        struct EBM_API union_struct_74{
            Block block;
        };
        struct EBM_API union_struct_75{
            PropertyDecl property_decl;
        };
        struct EBM_API union_struct_76{
            Metadata metadata;
        };
        struct EBM_API union_struct_77{
            IdentifierRef module_name;
            IdentifierRef alias;
        };
        struct EBM_API union_struct_78{
            ExpressionRef target_var;
            Varint params_len;
            std::vector<PhiParam> params;
        };
        struct EBM_API union_struct_79{
            ErrorReport error_report;
        };
        struct EBM_API union_struct_80{
            ExpressionRef expression;
        };
        struct EBM_API union_struct_81{
            LoweredStatements lowered_statements;
        };
        std::variant<std::monostate, union_struct_51, union_struct_52, union_struct_53, union_struct_54, union_struct_55, union_struct_56, union_struct_57, union_struct_58, union_struct_59, union_struct_60, union_struct_61, union_struct_62, union_struct_63, union_struct_64, union_struct_65, union_struct_66, union_struct_67, union_struct_68, union_struct_69, union_struct_70, union_struct_71, union_struct_72, union_struct_73, union_struct_74, union_struct_75, union_struct_76, union_struct_77, union_struct_78, union_struct_79, union_struct_80, union_struct_81> union_variant_50;
        const IdentifierRef* alias() const;
        IdentifierRef* alias();
        bool alias(IdentifierRef&& v);
        bool alias(const IdentifierRef& v);
        const AssertDesc* assert_desc() const;
        AssertDesc* assert_desc();
        bool assert_desc(AssertDesc&& v);
        bool assert_desc(const AssertDesc& v);
        const Block* block() const;
        Block* block();
        bool block(Block&& v);
        bool block(const Block& v);
        const LoopFlowControl* break_() const;
        LoopFlowControl* break_();
        bool break_(LoopFlowControl&& v);
        bool break_(const LoopFlowControl& v);
        const LoopFlowControl* continue_() const;
        LoopFlowControl* continue_();
        bool continue_(LoopFlowControl&& v);
        bool continue_(const LoopFlowControl& v);
        const EnumDecl* enum_decl() const;
        EnumDecl* enum_decl();
        bool enum_decl(EnumDecl&& v);
        bool enum_decl(const EnumDecl& v);
        const EnumMemberDecl* enum_member_decl() const;
        EnumMemberDecl* enum_member_decl();
        bool enum_member_decl(EnumMemberDecl&& v);
        bool enum_member_decl(const EnumMemberDecl& v);
        const ErrorReport* error_report() const;
        ErrorReport* error_report();
        bool error_report(ErrorReport&& v);
        bool error_report(const ErrorReport& v);
        const ExpressionRef* expression() const;
        ExpressionRef* expression();
        bool expression(ExpressionRef&& v);
        bool expression(const ExpressionRef& v);
        const FieldDecl* field_decl() const;
        FieldDecl* field_decl();
        bool field_decl(FieldDecl&& v);
        bool field_decl(const FieldDecl& v);
        const FunctionDecl* func_decl() const;
        FunctionDecl* func_decl();
        bool func_decl(FunctionDecl&& v);
        bool func_decl(const FunctionDecl& v);
        const IfStatement* if_statement() const;
        IfStatement* if_statement();
        bool if_statement(IfStatement&& v);
        bool if_statement(const IfStatement& v);
        const LoopStatement* loop() const;
        LoopStatement* loop();
        bool loop(LoopStatement&& v);
        bool loop(const LoopStatement& v);
        const LoweredStatements* lowered_statements() const;
        LoweredStatements* lowered_statements();
        bool lowered_statements(LoweredStatements&& v);
        bool lowered_statements(const LoweredStatements& v);
        const MatchBranch* match_branch() const;
        MatchBranch* match_branch();
        bool match_branch(MatchBranch&& v);
        bool match_branch(const MatchBranch& v);
        const MatchStatement* match_statement() const;
        MatchStatement* match_statement();
        bool match_statement(MatchStatement&& v);
        bool match_statement(const MatchStatement& v);
        const Metadata* metadata() const;
        Metadata* metadata();
        bool metadata(Metadata&& v);
        bool metadata(const Metadata& v);
        const IdentifierRef* module_name() const;
        IdentifierRef* module_name();
        bool module_name(IdentifierRef&& v);
        bool module_name(const IdentifierRef& v);
        const ExpressionRef* offset() const;
        ExpressionRef* offset();
        bool offset(ExpressionRef&& v);
        bool offset(const ExpressionRef& v);
        const std::vector<PhiParam>* params() const;
        std::vector<PhiParam>* params();
        bool params(std::vector<PhiParam>&& v);
        bool params(const std::vector<PhiParam>& v);
        const Varint* params_len() const;
        Varint* params_len();
        bool params_len(Varint&& v);
        bool params_len(const Varint& v);
        const StatementRef* previous_assignment() const;
        StatementRef* previous_assignment();
        bool previous_assignment(StatementRef&& v);
        bool previous_assignment(const StatementRef& v);
        const PropertyDecl* property_decl() const;
        PropertyDecl* property_decl();
        bool property_decl(PropertyDecl&& v);
        bool property_decl(const PropertyDecl& v);
        const IOData* read_data() const;
        IOData* read_data();
        bool read_data(IOData&& v);
        bool read_data(const IOData& v);
        const StreamType* stream_type() const;
        StreamType* stream_type();
        bool stream_type(StreamType&& v);
        bool stream_type(const StreamType& v);
        const StructDecl* struct_decl() const;
        StructDecl* struct_decl();
        bool struct_decl(StructDecl&& v);
        bool struct_decl(const StructDecl& v);
        const ExpressionRef* target() const;
        ExpressionRef* target();
        bool target(ExpressionRef&& v);
        bool target(const ExpressionRef& v);
        const ExpressionRef* target_var() const;
        ExpressionRef* target_var();
        bool target_var(ExpressionRef&& v);
        bool target_var(const ExpressionRef& v);
        const UnionDecl* union_decl() const;
        UnionDecl* union_decl();
        bool union_decl(UnionDecl&& v);
        bool union_decl(const UnionDecl& v);
        const UnionMemberDecl* union_member_decl() const;
        UnionMemberDecl* union_member_decl();
        bool union_member_decl(UnionMemberDecl&& v);
        bool union_member_decl(const UnionMemberDecl& v);
        const ExpressionRef* value() const;
        ExpressionRef* value();
        bool value(ExpressionRef&& v);
        bool value(const ExpressionRef& v);
        const VariableDecl* var_decl() const;
        VariableDecl* var_decl();
        bool var_decl(VariableDecl&& v);
        bool var_decl(const VariableDecl& v);
        const IOData* write_data() const;
        IOData* write_data();
        bool write_data(IOData&& v);
        bool write_data(const IOData& v);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
        constexpr static const char* visitor_name = "StatementBody";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "kind",(*this).kind);
            v(v, "alias",(*this).alias());
            v(v, "assert_desc",(*this).assert_desc());
            v(v, "block",(*this).block());
            v(v, "break_",(*this).break_());
            v(v, "continue_",(*this).continue_());
            v(v, "enum_decl",(*this).enum_decl());
            v(v, "enum_member_decl",(*this).enum_member_decl());
            v(v, "error_report",(*this).error_report());
            v(v, "expression",(*this).expression());
            v(v, "field_decl",(*this).field_decl());
            v(v, "func_decl",(*this).func_decl());
            v(v, "if_statement",(*this).if_statement());
            v(v, "loop",(*this).loop());
            v(v, "lowered_statements",(*this).lowered_statements());
            v(v, "match_branch",(*this).match_branch());
            v(v, "match_statement",(*this).match_statement());
            v(v, "metadata",(*this).metadata());
            v(v, "module_name",(*this).module_name());
            v(v, "offset",(*this).offset());
            v(v, "params",(*this).params());
            v(v, "params_len",(*this).params_len());
            v(v, "previous_assignment",(*this).previous_assignment());
            v(v, "property_decl",(*this).property_decl());
            v(v, "read_data",(*this).read_data());
            v(v, "stream_type",(*this).stream_type());
            v(v, "struct_decl",(*this).struct_decl());
            v(v, "target",(*this).target());
            v(v, "target_var",(*this).target_var());
            v(v, "union_decl",(*this).union_decl());
            v(v, "union_member_decl",(*this).union_member_decl());
            v(v, "value",(*this).value());
            v(v, "var_decl",(*this).var_decl());
            v(v, "write_data",(*this).write_data());
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "kind",(*this).kind);
            v(v, "alias",(*this).alias());
            v(v, "assert_desc",(*this).assert_desc());
            v(v, "block",(*this).block());
            v(v, "break_",(*this).break_());
            v(v, "continue_",(*this).continue_());
            v(v, "enum_decl",(*this).enum_decl());
            v(v, "enum_member_decl",(*this).enum_member_decl());
            v(v, "error_report",(*this).error_report());
            v(v, "expression",(*this).expression());
            v(v, "field_decl",(*this).field_decl());
            v(v, "func_decl",(*this).func_decl());
            v(v, "if_statement",(*this).if_statement());
            v(v, "loop",(*this).loop());
            v(v, "lowered_statements",(*this).lowered_statements());
            v(v, "match_branch",(*this).match_branch());
            v(v, "match_statement",(*this).match_statement());
            v(v, "metadata",(*this).metadata());
            v(v, "module_name",(*this).module_name());
            v(v, "offset",(*this).offset());
            v(v, "params",(*this).params());
            v(v, "params_len",(*this).params_len());
            v(v, "previous_assignment",(*this).previous_assignment());
            v(v, "property_decl",(*this).property_decl());
            v(v, "read_data",(*this).read_data());
            v(v, "stream_type",(*this).stream_type());
            v(v, "struct_decl",(*this).struct_decl());
            v(v, "target",(*this).target());
            v(v, "target_var",(*this).target_var());
            v(v, "union_decl",(*this).union_decl());
            v(v, "union_member_decl",(*this).union_member_decl());
            v(v, "value",(*this).value());
            v(v, "var_decl",(*this).var_decl());
            v(v, "write_data",(*this).write_data());
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "kind",visitor_tag<decltype(std::declval<StatementBody>().kind)>{});
            v(v, "alias",visitor_tag<decltype(std::declval<StatementBody>().alias())>{});
            v(v, "assert_desc",visitor_tag<decltype(std::declval<StatementBody>().assert_desc())>{});
            v(v, "block",visitor_tag<decltype(std::declval<StatementBody>().block())>{});
            v(v, "break_",visitor_tag<decltype(std::declval<StatementBody>().break_())>{});
            v(v, "continue_",visitor_tag<decltype(std::declval<StatementBody>().continue_())>{});
            v(v, "enum_decl",visitor_tag<decltype(std::declval<StatementBody>().enum_decl())>{});
            v(v, "enum_member_decl",visitor_tag<decltype(std::declval<StatementBody>().enum_member_decl())>{});
            v(v, "error_report",visitor_tag<decltype(std::declval<StatementBody>().error_report())>{});
            v(v, "expression",visitor_tag<decltype(std::declval<StatementBody>().expression())>{});
            v(v, "field_decl",visitor_tag<decltype(std::declval<StatementBody>().field_decl())>{});
            v(v, "func_decl",visitor_tag<decltype(std::declval<StatementBody>().func_decl())>{});
            v(v, "if_statement",visitor_tag<decltype(std::declval<StatementBody>().if_statement())>{});
            v(v, "loop",visitor_tag<decltype(std::declval<StatementBody>().loop())>{});
            v(v, "lowered_statements",visitor_tag<decltype(std::declval<StatementBody>().lowered_statements())>{});
            v(v, "match_branch",visitor_tag<decltype(std::declval<StatementBody>().match_branch())>{});
            v(v, "match_statement",visitor_tag<decltype(std::declval<StatementBody>().match_statement())>{});
            v(v, "metadata",visitor_tag<decltype(std::declval<StatementBody>().metadata())>{});
            v(v, "module_name",visitor_tag<decltype(std::declval<StatementBody>().module_name())>{});
            v(v, "offset",visitor_tag<decltype(std::declval<StatementBody>().offset())>{});
            v(v, "params",visitor_tag<decltype(std::declval<StatementBody>().params())>{});
            v(v, "params_len",visitor_tag<decltype(std::declval<StatementBody>().params_len())>{});
            v(v, "previous_assignment",visitor_tag<decltype(std::declval<StatementBody>().previous_assignment())>{});
            v(v, "property_decl",visitor_tag<decltype(std::declval<StatementBody>().property_decl())>{});
            v(v, "read_data",visitor_tag<decltype(std::declval<StatementBody>().read_data())>{});
            v(v, "stream_type",visitor_tag<decltype(std::declval<StatementBody>().stream_type())>{});
            v(v, "struct_decl",visitor_tag<decltype(std::declval<StatementBody>().struct_decl())>{});
            v(v, "target",visitor_tag<decltype(std::declval<StatementBody>().target())>{});
            v(v, "target_var",visitor_tag<decltype(std::declval<StatementBody>().target_var())>{});
            v(v, "union_decl",visitor_tag<decltype(std::declval<StatementBody>().union_decl())>{});
            v(v, "union_member_decl",visitor_tag<decltype(std::declval<StatementBody>().union_member_decl())>{});
            v(v, "value",visitor_tag<decltype(std::declval<StatementBody>().value())>{});
            v(v, "var_decl",visitor_tag<decltype(std::declval<StatementBody>().var_decl())>{});
            v(v, "write_data",visitor_tag<decltype(std::declval<StatementBody>().write_data())>{});
        }
    };
    struct EBM_API Statement{
        StatementRef id;
        StatementBody body;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "Statement";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "id",(*this).id);
            v(v, "body",(*this).body);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "id",(*this).id);
            v(v, "body",(*this).body);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "id",visitor_tag<decltype(std::declval<Statement>().id)>{});
            v(v, "body",visitor_tag<decltype(std::declval<Statement>().body)>{});
        }
    };
    struct EBM_API Types{
        Varint len;
        std::vector<TypeRef> container;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "Types";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "len",(*this).len);
            v(v, "container",(*this).container);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "len",(*this).len);
            v(v, "container",(*this).container);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "len",visitor_tag<decltype(std::declval<Types>().len)>{});
            v(v, "container",visitor_tag<decltype(std::declval<Types>().container)>{});
        }
    };
    struct EBM_API TypeBody{
        TypeKind kind{};
        struct EBM_API union_struct_84{
            std::uint8_t size = 0;
        };
        struct EBM_API union_struct_85{
            std::uint8_t size = 0;
        };
        struct EBM_API union_struct_86{
            std::uint8_t size = 0;
        };
        struct EBM_API union_struct_87{
        };
        struct EBM_API union_struct_88{
            TypeRef element_type;
            Varint length;
        };
        struct EBM_API union_struct_89{
            TypeRef element_type;
        };
        struct EBM_API union_struct_90{
            StatementRef id;
        };
        struct EBM_API union_struct_91{
            StatementRef id;
        };
        struct EBM_API union_struct_92{
            StatementRef id;
            TypeRef base_type;
        };
        struct EBM_API union_struct_93{
            TypeRef common_type;
            Types members;
        };
        struct EBM_API union_struct_94{
            TypeRef property_type;
        };
        struct EBM_API union_struct_95{
            TypeRef inner_type;
        };
        struct EBM_API union_struct_96{
            TypeRef pointee_type;
        };
        struct EBM_API union_struct_97{
            TypeRef base_type;
        };
        struct EBM_API union_struct_98{
            TypeRef return_type;
            Types params;
        };
        std::variant<std::monostate, union_struct_84, union_struct_85, union_struct_86, union_struct_87, union_struct_88, union_struct_89, union_struct_90, union_struct_91, union_struct_92, union_struct_93, union_struct_94, union_struct_95, union_struct_96, union_struct_97, union_struct_98> union_variant_83;
        const TypeRef* base_type() const;
        TypeRef* base_type();
        bool base_type(TypeRef&& v);
        bool base_type(const TypeRef& v);
        const TypeRef* common_type() const;
        TypeRef* common_type();
        bool common_type(TypeRef&& v);
        bool common_type(const TypeRef& v);
        const TypeRef* element_type() const;
        TypeRef* element_type();
        bool element_type(TypeRef&& v);
        bool element_type(const TypeRef& v);
        const StatementRef* id() const;
        StatementRef* id();
        bool id(StatementRef&& v);
        bool id(const StatementRef& v);
        const TypeRef* inner_type() const;
        TypeRef* inner_type();
        bool inner_type(TypeRef&& v);
        bool inner_type(const TypeRef& v);
        const Varint* length() const;
        Varint* length();
        bool length(Varint&& v);
        bool length(const Varint& v);
        const Types* members() const;
        Types* members();
        bool members(Types&& v);
        bool members(const Types& v);
        const Types* params() const;
        Types* params();
        bool params(Types&& v);
        bool params(const Types& v);
        const TypeRef* pointee_type() const;
        TypeRef* pointee_type();
        bool pointee_type(TypeRef&& v);
        bool pointee_type(const TypeRef& v);
        const TypeRef* property_type() const;
        TypeRef* property_type();
        bool property_type(TypeRef&& v);
        bool property_type(const TypeRef& v);
        const TypeRef* return_type() const;
        TypeRef* return_type();
        bool return_type(TypeRef&& v);
        bool return_type(const TypeRef& v);
        const std::uint8_t* size() const;
        std::uint8_t* size();
        bool size(std::uint8_t&& v);
        bool size(const std::uint8_t& v);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
        constexpr static const char* visitor_name = "TypeBody";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "kind",(*this).kind);
            v(v, "base_type",(*this).base_type());
            v(v, "common_type",(*this).common_type());
            v(v, "element_type",(*this).element_type());
            v(v, "id",(*this).id());
            v(v, "inner_type",(*this).inner_type());
            v(v, "length",(*this).length());
            v(v, "members",(*this).members());
            v(v, "params",(*this).params());
            v(v, "pointee_type",(*this).pointee_type());
            v(v, "property_type",(*this).property_type());
            v(v, "return_type",(*this).return_type());
            v(v, "size",(*this).size());
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "kind",(*this).kind);
            v(v, "base_type",(*this).base_type());
            v(v, "common_type",(*this).common_type());
            v(v, "element_type",(*this).element_type());
            v(v, "id",(*this).id());
            v(v, "inner_type",(*this).inner_type());
            v(v, "length",(*this).length());
            v(v, "members",(*this).members());
            v(v, "params",(*this).params());
            v(v, "pointee_type",(*this).pointee_type());
            v(v, "property_type",(*this).property_type());
            v(v, "return_type",(*this).return_type());
            v(v, "size",(*this).size());
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "kind",visitor_tag<decltype(std::declval<TypeBody>().kind)>{});
            v(v, "base_type",visitor_tag<decltype(std::declval<TypeBody>().base_type())>{});
            v(v, "common_type",visitor_tag<decltype(std::declval<TypeBody>().common_type())>{});
            v(v, "element_type",visitor_tag<decltype(std::declval<TypeBody>().element_type())>{});
            v(v, "id",visitor_tag<decltype(std::declval<TypeBody>().id())>{});
            v(v, "inner_type",visitor_tag<decltype(std::declval<TypeBody>().inner_type())>{});
            v(v, "length",visitor_tag<decltype(std::declval<TypeBody>().length())>{});
            v(v, "members",visitor_tag<decltype(std::declval<TypeBody>().members())>{});
            v(v, "params",visitor_tag<decltype(std::declval<TypeBody>().params())>{});
            v(v, "pointee_type",visitor_tag<decltype(std::declval<TypeBody>().pointee_type())>{});
            v(v, "property_type",visitor_tag<decltype(std::declval<TypeBody>().property_type())>{});
            v(v, "return_type",visitor_tag<decltype(std::declval<TypeBody>().return_type())>{});
            v(v, "size",visitor_tag<decltype(std::declval<TypeBody>().size())>{});
        }
    };
    struct EBM_API Type{
        TypeRef id;
        TypeBody body;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "Type";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "id",(*this).id);
            v(v, "body",(*this).body);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "id",(*this).id);
            v(v, "body",(*this).body);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "id",visitor_tag<decltype(std::declval<Type>().id)>{});
            v(v, "body",visitor_tag<decltype(std::declval<Type>().body)>{});
        }
    };
    struct EBM_API Loc{
        AnyRef ident;
        Varint file_id;
        Varint line;
        Varint column;
        Varint start;
        Varint end;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "Loc";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "ident",(*this).ident);
            v(v, "file_id",(*this).file_id);
            v(v, "line",(*this).line);
            v(v, "column",(*this).column);
            v(v, "start",(*this).start);
            v(v, "end",(*this).end);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "ident",(*this).ident);
            v(v, "file_id",(*this).file_id);
            v(v, "line",(*this).line);
            v(v, "column",(*this).column);
            v(v, "start",(*this).start);
            v(v, "end",(*this).end);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "ident",visitor_tag<decltype(std::declval<Loc>().ident)>{});
            v(v, "file_id",visitor_tag<decltype(std::declval<Loc>().file_id)>{});
            v(v, "line",visitor_tag<decltype(std::declval<Loc>().line)>{});
            v(v, "column",visitor_tag<decltype(std::declval<Loc>().column)>{});
            v(v, "start",visitor_tag<decltype(std::declval<Loc>().start)>{});
            v(v, "end",visitor_tag<decltype(std::declval<Loc>().end)>{});
        }
    };
    struct EBM_API Identifier{
        IdentifierRef id;
        String body;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "Identifier";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "id",(*this).id);
            v(v, "body",(*this).body);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "id",(*this).id);
            v(v, "body",(*this).body);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "id",visitor_tag<decltype(std::declval<Identifier>().id)>{});
            v(v, "body",visitor_tag<decltype(std::declval<Identifier>().body)>{});
        }
    };
    struct EBM_API StringLiteral{
        StringRef id;
        String body;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "StringLiteral";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "id",(*this).id);
            v(v, "body",(*this).body);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "id",(*this).id);
            v(v, "body",(*this).body);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "id",visitor_tag<decltype(std::declval<StringLiteral>().id)>{});
            v(v, "body",visitor_tag<decltype(std::declval<StringLiteral>().body)>{});
        }
    };
    struct EBM_API DebugInfo{
        Varint len_files;
        std::vector<String> files;
        Varint len_locs;
        std::vector<Loc> locs;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        constexpr static const char* visitor_name = "DebugInfo";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "len_files",(*this).len_files);
            v(v, "files",(*this).files);
            v(v, "len_locs",(*this).len_locs);
            v(v, "locs",(*this).locs);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "len_files",(*this).len_files);
            v(v, "files",(*this).files);
            v(v, "len_locs",(*this).len_locs);
            v(v, "locs",(*this).locs);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "len_files",visitor_tag<decltype(std::declval<DebugInfo>().len_files)>{});
            v(v, "files",visitor_tag<decltype(std::declval<DebugInfo>().files)>{});
            v(v, "len_locs",visitor_tag<decltype(std::declval<DebugInfo>().len_locs)>{});
            v(v, "locs",visitor_tag<decltype(std::declval<DebugInfo>().locs)>{});
        }
    };
    struct EBM_API ExtendedBinaryModule{
        //"EBMG" (4 bytes)
        std::uint8_t version = 0;
        AnyRef max_id;
        Varint identifiers_len;
        std::vector<Identifier> identifiers;
        Varint strings_len;
        std::vector<StringLiteral> strings;
        Varint types_len;
        std::vector<Type> types;
        Varint statements_len;
        std::vector<Statement> statements;
        Varint expressions_len;
        std::vector<Expression> expressions;
        Varint aliases_len;
        std::vector<RefAlias> aliases;
        DebugInfo debug_info;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const ;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 5;
        constexpr static const char* visitor_name = "ExtendedBinaryModule";
        template<typename Visitor>
        constexpr void visit(Visitor&& v) {
            v(v, "magic","EBMG");
            v(v, "version",(*this).version);
            v(v, "max_id",(*this).max_id);
            v(v, "identifiers_len",(*this).identifiers_len);
            v(v, "identifiers",(*this).identifiers);
            v(v, "strings_len",(*this).strings_len);
            v(v, "strings",(*this).strings);
            v(v, "types_len",(*this).types_len);
            v(v, "types",(*this).types);
            v(v, "statements_len",(*this).statements_len);
            v(v, "statements",(*this).statements);
            v(v, "expressions_len",(*this).expressions_len);
            v(v, "expressions",(*this).expressions);
            v(v, "aliases_len",(*this).aliases_len);
            v(v, "aliases",(*this).aliases);
            v(v, "debug_info",(*this).debug_info);
        }
        template<typename Visitor>
        constexpr void visit(Visitor&& v) const {
            v(v, "magic","EBMG");
            v(v, "version",(*this).version);
            v(v, "max_id",(*this).max_id);
            v(v, "identifiers_len",(*this).identifiers_len);
            v(v, "identifiers",(*this).identifiers);
            v(v, "strings_len",(*this).strings_len);
            v(v, "strings",(*this).strings);
            v(v, "types_len",(*this).types_len);
            v(v, "types",(*this).types);
            v(v, "statements_len",(*this).statements_len);
            v(v, "statements",(*this).statements);
            v(v, "expressions_len",(*this).expressions_len);
            v(v, "expressions",(*this).expressions);
            v(v, "aliases_len",(*this).aliases_len);
            v(v, "aliases",(*this).aliases);
            v(v, "debug_info",(*this).debug_info);
        }
        template<typename T>
        struct visitor_tag {
            using type = T;
        };
        template<typename Visitor>
        static constexpr void visit_static(Visitor&& v) {
            v(v, "magic",visitor_tag<decltype("EBMG")>{});
            v(v, "version",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().version)>{});
            v(v, "max_id",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().max_id)>{});
            v(v, "identifiers_len",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().identifiers_len)>{});
            v(v, "identifiers",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().identifiers)>{});
            v(v, "strings_len",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().strings_len)>{});
            v(v, "strings",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().strings)>{});
            v(v, "types_len",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().types_len)>{});
            v(v, "types",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().types)>{});
            v(v, "statements_len",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().statements_len)>{});
            v(v, "statements",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().statements)>{});
            v(v, "expressions_len",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().expressions_len)>{});
            v(v, "expressions",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().expressions)>{});
            v(v, "aliases_len",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().aliases_len)>{});
            v(v, "aliases",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().aliases)>{});
            v(v, "debug_info",visitor_tag<decltype(std::declval<ExtendedBinaryModule>().debug_info)>{});
        }
    };
} // namespace ebm

