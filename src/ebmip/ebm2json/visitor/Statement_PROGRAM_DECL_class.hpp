/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_PROGRAM_DECL_class
  Available Variables:
    ctx: Context_Statement_PROGRAM_DECL
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
        module_: ebmgen::MappingTable
      item_id: ebm::StatementRef
      kind: const ebm::StatementKind&
      block: const ebm::Block&
        len: Varint
        container: std::vector<StatementRef>
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include "../codegen.hpp"
#include "ebm/extended_binary_module.hpp"

struct JSONWrapper {
    ebm2json::Context_Statement_PROGRAM_DECL* pctx;
    ebm::StatementRef ref;
    ebm2json::expected<ebm2json::Result> result;
    void as_json(futils::json::Stringer<>& js) {
        auto& ctx = *pctx;
        result = ctx.visit(ref);
    }
};

DEFINE_VISITOR(Statement_PROGRAM_DECL) {
    using namespace CODEGEN_NAMESPACE;
    /*here to write the hook*/
    auto& js = ctx.config().json_output;
    if (ctx.flags().pretty) {
        js.set_indent("  ");
    }
    auto obj = js.object();
    MAYBE(meta, get_metadata(ctx, ctx.item_id));
    if (meta.items.size()) {
        obj("metadata", [&] {
            auto items = js.object();
            for (auto& [key, data] : meta.items) {
                items(key, [&] {
                    auto items = js.array();
                    for (auto& item : data) {
                        items([&] {
                            auto value = item.get_string(ctx, 0);
                            if (value) {
                                js.string(*value);
                            }
                        });
                    }
                });
            }
        });
    }
    std::vector<JSONWrapper> structs, enums, variables;
    for (auto& b : ctx.block.container) {
        if (ctx.is(ebm::StatementKind::STRUCT_DECL, b)) {
            structs.push_back({&ctx, b});
        }
        else if (ctx.is(ebm::StatementKind::ENUM_DECL, b)) {
            enums.push_back({&ctx, b});
        }
        else if (ctx.is(ebm::StatementKind::VARIABLE_DECL, b)) {
            variables.push_back({&ctx, b});
        }
    }
#define CHECK(vec)          \
    for (auto& x : vec) {   \
        MAYBE(_, x.result); \
    }
    obj("structs", structs);
    CHECK(structs);
    obj("enums", enums);
    CHECK(enums);
    obj("variables", variables);
    CHECK(variables);
#undef CHECK
    return {};
}
