## 4. Code Generation Logic (Visitor Hooks)

### 4.1 Visitor Hook Overview
A visitor hook is a `.hpp` file containing a C++ code snippet. It is **not** a class definition. Instead, it's the literal body of a function that is dynamically generated by `ebmcodegen`. `ebmcodegen` generates functions like `visit_Statement_WRITE_DATA(...)`, and the content of your `.hpp` file (e.g., `visitor/Statement_WRITE_DATA.hpp`) is `#include`d directly into the body of that function. The function, and therefore your hook code, **must** return a value of type `expected<Result>`. The `Result` struct holds the generated code string in its `value` member.

### 4.2 Managing Visitor Hooks with `ebmtemplate.py`
The `script/ebmtemplate.py` script is a wrapper around `ebmcodegen` that simplifies the lifecycle of visitor hooks.
-   **`python script/ebmtemplate.py`**: Displays help.
-   **`python script/ebmtemplate.py interactive`**: Start an interactive guide through the script features.
-   **`python script/ebmtemplate.py <template_target>`**: Outputs a summary of the hook file to stdout.
-   **`python script/ebmtemplate.py <template_target> <lang>`**: Generates a new hook file (`.hpp`) in `src/ebmcg/ebm2<lang>/visitor/`.
-   **`python script/ebmtemplate.py update <lang>`**: Updates the auto-generated comment blocks (listing available variables) in all existing hooks for a given language.
-   **`python script/ebmtemplate.py test`**: Tests the generation of all available template targets.
-   **`python script/ebmtemplate.py list <lang>`**: List all defined templates in the specified [lang] directory.

### 4.3 Workflow for Implementing a Visitor Hook
1.  **Find the Target**: Decide which EBM node you want to handle. Use `tool/ebmcodegen --mode hooklist` to list available hooks.
2.  **Create the File**: Generate the hook file using `python script/ebmtemplate.py <template_target> <lang>`.
3.  **Implement the Logic**: Open the newly created file (`src/ebmcg/ebm2<lang>/visitor/<template_target>.hpp`). Replace the `/*here to write the hook*/` comment with your C++ implementation.
4.  **Build and Verify**: After implementing the hook, run `python script/unictest.py` (or `python script/unictest.py --print-stdout` for debugging) to build and verify your changes. This will trigger the build process and run the tests defined in the `unictest` framework. `unictest.py` will automatically pass the `--debug-unimplemented` flag to the code generator executable when appropriate. Also, remember to update `src/ebmcg/ebm2<lang>/main.cpp`'s Last updated time at creation of hook file to make the build system recognize the new file.

### 4.4 Visitor Hook API Reference

Visitor hooks function as the body of C++ functions generated by `ebmcodegen`. The key API elements available within these hooks are detailed below.

#### 4.4.1 Return Type and `Result` Struct

All visitor hooks must return a value of type `expected<Result>`.

-   **`expected<T>`**: A type representing the result of an operation that might fail. It holds a value of type `T` on success or error information on failure. In the `ebmgen` project, it is used in conjunction with the `MAYBE` macro for error handling.
-   **`Result` Struct**:
    -   `CodeWriter value`: This holds a `CodeWriter` object, which is a utility for efficiently building generated code, considering indentation and other formatting. The purpose of the hook is to construct the target language code within this `value` member.

#### 4.4.2 Available Variables

Each visitor hook has direct access to variables corresponding to the fields of the EBM node being visited. These variables are listed in the auto-generated comment block when you create a hook file using `ebmtemplate.py <template_target> <lang>`.

-   **Example**: For a `Statement_WRITE_DATA` hook, variables like `io_data` and `endian` would be available.
-   **Updating Variables**: If the EBM structure (`extended_binary_module.bgn`) is modified, run `python script/ebmtemplate.py update <lang>` to refresh the variable list in the comment blocks of existing hooks.

#### 4.4.3 Helper Functions and Macros

Several helper functions and macros are provided to simplify code generation logic within visitor hooks.

-   **`MAYBE(var, expr)`**: An error handling macro. If `expr` returns an `expected` type and it contains an error, the error is propagated, and the current function returns early. If successful, the value from `expr` is assigned to `var`.
    -   **Usage Example**: `MAYBE(sub_expr_str, visit_Expression(*this, some_expression_ref));`
-   **`visit_Expression(*this, expression_ref)`**: Recursively visits the EBM expression corresponding to the given `ExpressionRef` and returns the generated code as a result.
-   **`visit_Statement(*this, statement_ref)`**: Recursively visits the EBM statement corresponding to the given `StatementRef` and returns the generated code as a result.
-   **`std::format`**: The C++20 string formatting feature. Can be used to format generated code strings.
-   **`to_string(enum_value)`**: Used to convert EBM enumeration values (e.g., `SizeUnit`, `Endian`) into their corresponding string representations.

#### 4.4.4 Referring to `extended_binary_module.hpp`

For precise definitions of EBM structs, enums, and reference types (`StatementRef`, `ExpressionRef`, `TypeRef`, etc.), please refer to the `src/ebm/extended_binary_module.hpp` file. This file is automatically generated from `extended_binary_module.bgn`.

### 4.5 DSL (Domain Specific Language) for Visitor Hooks
The `ebmcodegen` tool supports a Domain Specific Language (DSL) for writing visitor hooks, offering a more concise and readable way to define code generation logic. This DSL is processed by `ebmcodegen` when invoked with `--mode dsl` and `--dsl-file=FILE`.

**DSL Syntax Overview:**
The DSL mixes C++ code, EBM node processing, and control flow constructs using special markers:
For practical examples of DSL usage, refer to `src/ebmcg/ebm2python/dsl_sample/`.
-   **`{% C++_CODE %}`**: Embeds C++ literal code directly into the generated output. (e.g., `{% int a = 0; %}`)
-   **`{{ C++_EXPRESSION }}`**: Embeds a C++ expression whose result is written to the output. (e.g., `{{ a }} += 1;`)
-   **`{* EBM_NODE_EXPRESSION *}`**: Processes an EBM node (e.g., `ExpressionRef`, `StatementRef`) by calling `visit_Object` and writing its generated output. (e.g., `{* expr *}`)
-   **`{& IDENTIFIER_EXPRESSION &}`**: Retrieves an identifier and writes it to the output. (e.g., `{& item_id &}`)
-   **`{! SPECIAL_MARKER !}`**: Used for advanced control flow and variable definitions within the DSL itself. The content inside these markers is parsed by a nested DSL.
    -   **`transfer_and_reset_writer`**: Generates C++ code to transfer the current `CodeWriter` content and reset it.
    -   **`for IDENT in (range(BEGIN, END, STEP) | COLLECTION)`**: Generates C++ `for` loops. Supports both numeric ranges and iteration over collections.
    -   **`endfor`**: Closes a `for` loop block.
    -   **`if (CONDITION)` / `elif (CONDITION)` / `else`**: Generates C++ `if`/`else if`/`else` blocks.
    -   **`endif`**: Closes an `if` block.
    -   **`VARIABLE := VALUE`**: Defines a C++ variable within the generated code. (e.g., `my_var := 42`)

Text outside these markers is treated as target language code and is escaped before being written to the output. The DSL also handles automatic indentation and dedentation based on the source formatting.
