// Code generated by json2cpp2
#pragma once
#include <cstdint>
#include <vector>
#include <array>
#include <optional>
#include <variant>
#include <string_view>

#include <binary/flags.h>
#include <binary/float.h>
#include <view/iovec.h>
#include <binary/number.h>
namespace bm2 {
    enum class HookFile {
        keyword = 0,
        generator_top = 1,
        file_top = 2,
        file_bottom = 3,
        bm_context = 4,
        flags = 5,
        eval_result = 6,
        escape_ident = 7,
        each_inner_block = 8,
        each_inner_function = 9,
        inner_function_start = 10,
        inner_function_each_code = 11,
        inner_block_start = 12,
        inner_block_each_code = 13,
        param_start = 14,
        param_each_code = 15,
        call_param_start = 16,
        call_param_each_code = 17,
        first_scan = 18,
        tree_scan = 19,
        inner_function_op = 20,
        inner_block_op = 21,
        eval_op = 22,
        type_op = 23,
        param_op = 24,
        call_param_op = 25,
        field_accessor_op = 26,
        type_accessor_op = 27,
    };
    constexpr const char* to_string(HookFile e) {
        switch (e) {
            case HookFile::keyword:
                return "keywords";
            case HookFile::generator_top:
                return "generator_top";
            case HookFile::file_top:
                return "file_top";
            case HookFile::file_bottom:
                return "file_bottom";
            case HookFile::bm_context:
                return "bm_context";
            case HookFile::flags:
                return "flags";
            case HookFile::eval_result:
                return "eval_result";
            case HookFile::escape_ident:
                return "escape_ident";
            case HookFile::each_inner_block:
                return "each_inner_block";
            case HookFile::each_inner_function:
                return "each_inner_function";
            case HookFile::inner_function_start:
                return "inner_function_start";
            case HookFile::inner_function_each_code:
                return "inner_function_each_code";
            case HookFile::inner_block_start:
                return "inner_block_start";
            case HookFile::inner_block_each_code:
                return "inner_block_each_code";
            case HookFile::param_start:
                return "param_start";
            case HookFile::param_each_code:
                return "param_each_code";
            case HookFile::call_param_start:
                return "call_param_start";
            case HookFile::call_param_each_code:
                return "call_param_each_code";
            case HookFile::first_scan:
                return "first_scan";
            case HookFile::tree_scan:
                return "tree_scan";
            case HookFile::inner_function_op:
                return "func";
            case HookFile::inner_block_op:
                return "block";
            case HookFile::eval_op:
                return "eval";
            case HookFile::type_op:
                return "type";
            case HookFile::param_op:
                return "param";
            case HookFile::call_param_op:
                return "call_param";
            case HookFile::field_accessor_op:
                return "field_accessor";
            case HookFile::type_accessor_op:
                return "type_accessor";
        }
        return "";
    }

    constexpr std::optional<HookFile> HookFile_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "keywords") {
            return HookFile::keyword;
        }
        if (str == "generator_top") {
            return HookFile::generator_top;
        }
        if (str == "file_top") {
            return HookFile::file_top;
        }
        if (str == "file_bottom") {
            return HookFile::file_bottom;
        }
        if (str == "bm_context") {
            return HookFile::bm_context;
        }
        if (str == "flags") {
            return HookFile::flags;
        }
        if (str == "eval_result") {
            return HookFile::eval_result;
        }
        if (str == "escape_ident") {
            return HookFile::escape_ident;
        }
        if (str == "each_inner_block") {
            return HookFile::each_inner_block;
        }
        if (str == "each_inner_function") {
            return HookFile::each_inner_function;
        }
        if (str == "inner_function_start") {
            return HookFile::inner_function_start;
        }
        if (str == "inner_function_each_code") {
            return HookFile::inner_function_each_code;
        }
        if (str == "inner_block_start") {
            return HookFile::inner_block_start;
        }
        if (str == "inner_block_each_code") {
            return HookFile::inner_block_each_code;
        }
        if (str == "param_start") {
            return HookFile::param_start;
        }
        if (str == "param_each_code") {
            return HookFile::param_each_code;
        }
        if (str == "call_param_start") {
            return HookFile::call_param_start;
        }
        if (str == "call_param_each_code") {
            return HookFile::call_param_each_code;
        }
        if (str == "first_scan") {
            return HookFile::first_scan;
        }
        if (str == "tree_scan") {
            return HookFile::tree_scan;
        }
        if (str == "func") {
            return HookFile::inner_function_op;
        }
        if (str == "block") {
            return HookFile::inner_block_op;
        }
        if (str == "eval") {
            return HookFile::eval_op;
        }
        if (str == "type") {
            return HookFile::type_op;
        }
        if (str == "param") {
            return HookFile::param_op;
        }
        if (str == "call_param") {
            return HookFile::call_param_op;
        }
        if (str == "field_accessor") {
            return HookFile::field_accessor_op;
        }
        if (str == "type_accessor") {
            return HookFile::type_accessor_op;
        }
        return std::nullopt;
    }
    enum class HookFileSub {
        main = 0,
        pre_main = 1,
        op = 2,
        empty = 3,
        value = 4,
        self = 5,
        field = 6,
        fallback = 7,
        no_fallback = 8,
        before = 9,
        after = 10,
        byte_length = 11,
        replacement = 12,
    };
    constexpr const char* to_string(HookFileSub e) {
        switch (e) {
            case HookFileSub::main:
                return "";
            case HookFileSub::pre_main:
                return "_pre_main";
            case HookFileSub::op:
                return "_op";
            case HookFileSub::empty:
                return "_empty";
            case HookFileSub::value:
                return "_value";
            case HookFileSub::self:
                return "_self";
            case HookFileSub::field:
                return "_field";
            case HookFileSub::fallback:
                return "_fallback";
            case HookFileSub::no_fallback:
                return "_no_fallback";
            case HookFileSub::before:
                return "_before";
            case HookFileSub::after:
                return "_after";
            case HookFileSub::byte_length:
                return "_byte_length";
            case HookFileSub::replacement:
                return "_replacement";
        }
        return "";
    }

    constexpr std::optional<HookFileSub> HookFileSub_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "") {
            return HookFileSub::main;
        }
        if (str == "_pre_main") {
            return HookFileSub::pre_main;
        }
        if (str == "_op") {
            return HookFileSub::op;
        }
        if (str == "_empty") {
            return HookFileSub::empty;
        }
        if (str == "_value") {
            return HookFileSub::value;
        }
        if (str == "_self") {
            return HookFileSub::self;
        }
        if (str == "_field") {
            return HookFileSub::field;
        }
        if (str == "_fallback") {
            return HookFileSub::fallback;
        }
        if (str == "_no_fallback") {
            return HookFileSub::no_fallback;
        }
        if (str == "_before") {
            return HookFileSub::before;
        }
        if (str == "_after") {
            return HookFileSub::after;
        }
        if (str == "_byte_length") {
            return HookFileSub::byte_length;
        }
        if (str == "_replacement") {
            return HookFileSub::replacement;
        }
        return std::nullopt;
    }
    enum class FuncName {
        eval = 0,
        inner_function = 1,
        inner_block = 2,
        add_parameter = 3,
        add_call_parameter = 4,
        type_to_string = 5,
        field_accessor = 6,
        type_accessor = 7,
    };
    constexpr const char* to_string(FuncName e) {
        switch (e) {
            case FuncName::eval:
                return "eval";
            case FuncName::inner_function:
                return "inner_function";
            case FuncName::inner_block:
                return "inner_block";
            case FuncName::add_parameter:
                return "add_parameter";
            case FuncName::add_call_parameter:
                return "add_call_parameter";
            case FuncName::type_to_string:
                return "type_to_string";
            case FuncName::field_accessor:
                return "field_accessor";
            case FuncName::type_accessor:
                return "type_accessor";
        }
        return "";
    }

    constexpr std::optional<FuncName> FuncName_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "eval") {
            return FuncName::eval;
        }
        if (str == "inner_function") {
            return FuncName::inner_function;
        }
        if (str == "inner_block") {
            return FuncName::inner_block;
        }
        if (str == "add_parameter") {
            return FuncName::add_parameter;
        }
        if (str == "add_call_parameter") {
            return FuncName::add_call_parameter;
        }
        if (str == "type_to_string") {
            return FuncName::type_to_string;
        }
        if (str == "field_accessor") {
            return FuncName::field_accessor;
        }
        if (str == "type_accessor") {
            return FuncName::type_accessor;
        }
        return std::nullopt;
    }
    enum class GenerateMode {
        generator = 0,
        config_ = 1,
        cmake = 2,
        header = 3,
        main = 4,
        js_worker = 5,
        js_ui = 6,
        js_ui_embed = 7,
        docs_json = 8,
        docs_markdown = 9,
    };
    constexpr const char* to_string(GenerateMode e) {
        switch (e) {
            case GenerateMode::generator:
                return "generator";
            case GenerateMode::config_:
                return "config";
            case GenerateMode::cmake:
                return "cmake";
            case GenerateMode::header:
                return "header";
            case GenerateMode::main:
                return "main";
            case GenerateMode::js_worker:
                return "js-worker";
            case GenerateMode::js_ui:
                return "js-ui";
            case GenerateMode::js_ui_embed:
                return "js-ui-embed";
            case GenerateMode::docs_json:
                return "docs-json";
            case GenerateMode::docs_markdown:
                return "docs-markdown";
        }
        return "";
    }

    constexpr std::optional<GenerateMode> GenerateMode_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "generator") {
            return GenerateMode::generator;
        }
        if (str == "config") {
            return GenerateMode::config_;
        }
        if (str == "cmake") {
            return GenerateMode::cmake;
        }
        if (str == "header") {
            return GenerateMode::header;
        }
        if (str == "main") {
            return GenerateMode::main;
        }
        if (str == "js-worker") {
            return GenerateMode::js_worker;
        }
        if (str == "js-ui") {
            return GenerateMode::js_ui;
        }
        if (str == "js-ui-embed") {
            return GenerateMode::js_ui_embed;
        }
        if (str == "docs-json") {
            return GenerateMode::docs_json;
        }
        if (str == "docs-markdown") {
            return GenerateMode::docs_markdown;
        }
        return std::nullopt;
    }
}  // namespace bm2
