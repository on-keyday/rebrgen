/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_READ_DATA
  Available variables:
    *this: Visitor
    module_: MappingTable
    item_id: StatementRef
    kind: StatementKind
    read_data: IOData
      io_ref: StatementRef
      target: ExpressionRef
      data_type: TypeRef
      attribute: IOAttribute
        endian: Endian
        sign: bool
        is_peek: bool
        has_lowered_statement: bool
        reserved: std::uint8_t
        dynamic_ref: *StatementRef
      size: Size
        unit: SizeUnit
        ref: *ExpressionRef
        size: *Varint
      lowered_statement: *LoweredIOStatement
        lowering_type: LoweringIOType
        io_statement: LoweredStatementRef
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

/*here to write the hook*/

if (auto lw = read_data.lowered_statement()) {
    return visit_Statement(*this, lw->io_statement.id);
}

MAYBE(target, visit_Expression(*this, read_data.target));
MAYBE(type, visit_Type(*this, read_data.data_type));
auto io_name = module_.get_associated_identifier(read_data.io_ref);

MAYBE(type_obj, module_.get_type(read_data.data_type));

CodeWriter w;

if (type_obj.body.kind == ebm::TypeKind::INT) {
    auto bit_size = type_obj.body.size()->value();
    auto byte_size = (bit_size + 7) / 8;
    w.writeln("let mut buf = [0u8; ", std::to_string(byte_size), "];");
    w.writeln(io_name, ".read_exact(&mut buf)?;");
    w.write(target.to_writer(), " = ", type.to_writer(), "::from_le_bytes(buf);");
}
else {
    return unexpect_error("unsupported type for READ_DATA");
}

return w;