/*license*/
// Code generated by ebmcodegen at https://github.com/on-keyday/rebrgen
#pragma once
// DO NOT EDIT THIS FILE MANUALLY. you should edit visitor implementation files instead.
#include <ebmcodegen/stub/entry.hpp>
#include <ebmcodegen/stub/util.hpp>
#include <ebmgen/common.hpp>
#include <ebmgen/convert/helper.hpp>
#include <ebmgen/mapping.hpp>
#include <code/code_writer.h>
#include <code/loc_writer.h>
#include <ebmcodegen/stub/writer_manager.hpp>
#include <concepts>
#include <strutil/append.h>
// This is a measure to prevent any impact on compilation even if a user mistakenly changes something like #include "lang/codegen.hpp" to #include "other_lang/codegen.hpp".
#ifndef EBM_CODEGEN_COMMON_INCLUDE_GUARD
#define EBM_CODEGEN_COMMON_INCLUDE_GUARD 1
#if __has_include("visitor/includes_before.hpp")
#include "visitor/includes_before.hpp"
#elif __has_include("visitor/dsl/includes_before_dsl.hpp")
#include "visitor/dsl/includes_before_dsl.hpp"
#elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorincludes_before.hpp")
#include "src/ebmcodegen/default_codegen_visitor/visitorincludes_before.hpp"
#endif
#if __has_include("visitor/includes.hpp")
#include "visitor/includes.hpp"
#elif __has_include("visitor/dsl/includes_dsl.hpp")
#include "visitor/dsl/includes_dsl.hpp"
#elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorincludes.hpp")
#include "src/ebmcodegen/default_codegen_visitor/visitorincludes.hpp"
#endif
#if __has_include("visitor/includes_after.hpp")
#include "visitor/includes_after.hpp"
#elif __has_include("visitor/dsl/includes_after_dsl.hpp")
#include "visitor/dsl/includes_after_dsl.hpp"
#elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorincludes_after.hpp")
#include "src/ebmcodegen/default_codegen_visitor/visitorincludes_after.hpp"
#endif
namespace ebm2all {
    struct MergedVisitor;
    using namespace ebmgen;
    using namespace ebmcodegen::util;
    using CodeWriter = futils::code::LocWriter<std::string,std::vector,ebm::AnyRef>;
    
    struct Result {
        private: CodeWriter value;
        public: Result(std::string v) { value.write(v); }
        Result(const char* v) { value.write(v); }
        Result(CodeWriter&& v) : value(std::move(v)) {}
        Result() = default;
        constexpr std::string to_string() const {
            return value.to_string();
        }
        constexpr const CodeWriter& to_writer() const {
            return value;
        }
        constexpr CodeWriter& to_writer() {
            return value;
        }
        #if __has_include("visitor/Result_before.hpp")
        #include "visitor/Result_before.hpp"
        #elif __has_include("visitor/dsl/Result_before_dsl.hpp")
        #include "visitor/dsl/Result_before_dsl.hpp"
        #elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorResult_before.hpp")
        #include "src/ebmcodegen/default_codegen_visitor/visitorResult_before.hpp"
        #endif
        #if __has_include("visitor/Result.hpp")
        #include "visitor/Result.hpp"
        #elif __has_include("visitor/dsl/Result_dsl.hpp")
        #include "visitor/dsl/Result_dsl.hpp"
        #elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorResult.hpp")
        #include "src/ebmcodegen/default_codegen_visitor/visitorResult.hpp"
        #endif
        #if __has_include("visitor/Result_after.hpp")
        #include "visitor/Result_after.hpp"
        #elif __has_include("visitor/dsl/Result_after_dsl.hpp")
        #include "visitor/dsl/Result_after_dsl.hpp"
        #elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorResult_after.hpp")
        #include "src/ebmcodegen/default_codegen_visitor/visitorResult_after.hpp"
        #endif
    };
    struct Flags : ebmcodegen::Flags {
        #define DEFINE_FLAG(type,name,default_,flag_name,flag_func,...) \
            static_assert(ebmcodegen::util::internal::is_c_ident(#name),"name must be a valid C identifier");type name = default_
        #define WEB_FILTERED(...) 
        #define WEB_UI_NAME(name) 
        #define WEB_LSP_NAME(name) 
        #define WEB_WORKER_NAME(name) 
        #define FILE_EXTENSIONS(...) 
        #define DEFINE_BOOL_FLAG(name,default_,flag_name,desc) DEFINE_FLAG(bool,name,default_,flag_name,VarBool,desc)
        #define DEFINE_STRING_FLAG(name,default_,flag_name,desc,arg_desc) DEFINE_FLAG(std::string_view,name,default_,flag_name,VarString<true>,desc,arg_desc)
        #define DEFINE_INT_FLAG(name,type,default_,flag_name,desc,arg_desc) DEFINE_FLAG(type,name,default_,flag_name,VarInt,desc,arg_desc)
        #define BEGIN_MAP_FLAG(name,MappedType,default_,flag_name,desc)static_assert(ebmcodegen::util::internal::is_c_ident(#name),"name must be a valid C identifier");MappedType name = default_;
        #define MAP_FLAG_ITEM(key,value) 
        #define END_MAP_FLAG() 
        #if __has_include("visitor/Flags_before.hpp")
        #include "visitor/Flags_before.hpp"
        #elif __has_include("visitor/dsl/Flags_before_dsl.hpp")
        #include "visitor/dsl/Flags_before_dsl.hpp"
        #elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorFlags_before.hpp")
        #include "src/ebmcodegen/default_codegen_visitor/visitorFlags_before.hpp"
        #endif
        #if __has_include("visitor/Flags.hpp")
        #include "visitor/Flags.hpp"
        #elif __has_include("visitor/dsl/Flags_dsl.hpp")
        #include "visitor/dsl/Flags_dsl.hpp"
        #elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorFlags.hpp")
        #include "src/ebmcodegen/default_codegen_visitor/visitorFlags.hpp"
        #endif
        #if __has_include("visitor/Flags_after.hpp")
        #include "visitor/Flags_after.hpp"
        #elif __has_include("visitor/dsl/Flags_after_dsl.hpp")
        #include "visitor/dsl/Flags_after_dsl.hpp"
        #elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorFlags_after.hpp")
        #include "src/ebmcodegen/default_codegen_visitor/visitorFlags_after.hpp"
        #endif
        #undef DEFINE_FLAG
        #undef WEB_FILTERED
        #undef DEFINE_BOOL_FLAG
        #undef DEFINE_STRING_FLAG
        #undef DEFINE_INT_FLAG
        #undef BEGIN_MAP_FLAG
        #undef MAP_FLAG_ITEM
        #undef END_MAP_FLAG
        #undef WEB_UI_NAME
        #undef WEB_LSP_NAME
        #undef WEB_WORKER_NAME
        #undef FILE_EXTENSIONS
        #if __has_include("visitor/Flags_struct_before.hpp")
        #include "visitor/Flags_struct_before.hpp"
        #elif __has_include("visitor/dsl/Flags_struct_before_dsl.hpp")
        #include "visitor/dsl/Flags_struct_before_dsl.hpp"
        #elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorFlags_struct_before.hpp")
        #include "src/ebmcodegen/default_codegen_visitor/visitorFlags_struct_before.hpp"
        #endif
        #if __has_include("visitor/Flags_struct.hpp")
        #include "visitor/Flags_struct.hpp"
        #elif __has_include("visitor/dsl/Flags_struct_dsl.hpp")
        #include "visitor/dsl/Flags_struct_dsl.hpp"
        #elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorFlags_struct.hpp")
        #include "src/ebmcodegen/default_codegen_visitor/visitorFlags_struct.hpp"
        #endif
        #if __has_include("visitor/Flags_struct_after.hpp")
        #include "visitor/Flags_struct_after.hpp"
        #elif __has_include("visitor/dsl/Flags_struct_after_dsl.hpp")
        #include "visitor/dsl/Flags_struct_after_dsl.hpp"
        #elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorFlags_struct_after.hpp")
        #include "src/ebmcodegen/default_codegen_visitor/visitorFlags_struct_after.hpp"
        #endif
        void bind(futils::cmdline::option::Context& ctx) {
            lang_name = "all";
            ui_lang_name = lang_name;
            lsp_name = lang_name;
            webworker_name = "ebm2all";
            file_extensions = {".all"};
            ebmcodegen::Flags::bind(ctx); // bind basis
            #define DEFINE_FLAG(type,name,default_,flag_name,flag_func,...) \
                ctx.flag_func(&name,flag_name,__VA_ARGS__)
            #define WEB_FILTERED(...) web_filtered.insert_range(std::set{__VA_ARGS__})
            #define WEB_UI_NAME(name) ui_lang_name = name
            #define WEB_LSP_NAME(name) lsp_name = name
            #define WEB_WORKER_NAME(name) webworker_name = name
            #define FILE_EXTENSIONS(...) file_extensions = std::vector<std::string_view>{__VA_ARGS__}
            #define DEFINE_BOOL_FLAG(name,default_,flag_name,desc) DEFINE_FLAG(bool,name,default_,flag_name,VarBool,desc)
            #define DEFINE_STRING_FLAG(name,default_,flag_name,desc,arg_desc) DEFINE_FLAG(std::string_view,name,default_,flag_name,VarString<true>,desc,arg_desc)
            #define DEFINE_INT_FLAG(name,type,default_,flag_name,desc,arg_desc) DEFINE_FLAG(type,name,default_,flag_name,VarInt,desc,arg_desc)
            #define BEGIN_MAP_FLAG(name,MappedType,default_,flag_name,desc){ std::map<std::string,MappedType> map__; auto& target__ = name; auto flag_name__ = flag_name; auto desc__ = desc; std::string arg_desc__ = "{"; 
            #define MAP_FLAG_ITEM(key,value) map__[key] = value;if (!arg_desc__.empty() && arg_desc__.back() != '{') { arg_desc__ += ","; }arg_desc__ += key;
            #define END_MAP_FLAG() ctx.VarMap(&target__,flag_name__,desc__,arg_desc__ + "}",std::move(map__)); }
            #if __has_include("visitor/Flags_before.hpp")
            #include "visitor/Flags_before.hpp"
            #elif __has_include("visitor/dsl/Flags_before_dsl.hpp")
            #include "visitor/dsl/Flags_before_dsl.hpp"
            #elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorFlags_before.hpp")
            #include "src/ebmcodegen/default_codegen_visitor/visitorFlags_before.hpp"
            #endif
            #if __has_include("visitor/Flags.hpp")
            #include "visitor/Flags.hpp"
            #elif __has_include("visitor/dsl/Flags_dsl.hpp")
            #include "visitor/dsl/Flags_dsl.hpp"
            #elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorFlags.hpp")
            #include "src/ebmcodegen/default_codegen_visitor/visitorFlags.hpp"
            #endif
            #if __has_include("visitor/Flags_after.hpp")
            #include "visitor/Flags_after.hpp"
            #elif __has_include("visitor/dsl/Flags_after_dsl.hpp")
            #include "visitor/dsl/Flags_after_dsl.hpp"
            #elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorFlags_after.hpp")
            #include "src/ebmcodegen/default_codegen_visitor/visitorFlags_after.hpp"
            #endif
            #undef DEFINE_FLAG
            #undef WEB_FILTERED
            #undef DEFINE_BOOL_FLAG
            #undef DEFINE_STRING_FLAG
            #undef DEFINE_INT_FLAG
            #undef BEGIN_MAP_FLAG
            #undef MAP_FLAG_ITEM
            #undef END_MAP_FLAG
            #undef WEB_UI_NAME
            #undef WEB_LSP_NAME
            #undef WEB_WORKER_NAME
            #undef FILE_EXTENSIONS
            #if __has_include("visitor/Flags_bind_before.hpp")
            #include "visitor/Flags_bind_before.hpp"
            #elif __has_include("visitor/dsl/Flags_bind_before_dsl.hpp")
            #include "visitor/dsl/Flags_bind_before_dsl.hpp"
            #elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorFlags_bind_before.hpp")
            #include "src/ebmcodegen/default_codegen_visitor/visitorFlags_bind_before.hpp"
            #endif
            #if __has_include("visitor/Flags_bind.hpp")
            #include "visitor/Flags_bind.hpp"
            #elif __has_include("visitor/dsl/Flags_bind_dsl.hpp")
            #include "visitor/dsl/Flags_bind_dsl.hpp"
            #elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorFlags_bind.hpp")
            #include "src/ebmcodegen/default_codegen_visitor/visitorFlags_bind.hpp"
            #endif
            #if __has_include("visitor/Flags_bind_after.hpp")
            #include "visitor/Flags_bind_after.hpp"
            #elif __has_include("visitor/dsl/Flags_bind_after_dsl.hpp")
            #include "visitor/dsl/Flags_bind_after_dsl.hpp"
            #elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorFlags_bind_after.hpp")
            #include "src/ebmcodegen/default_codegen_visitor/visitorFlags_bind_after.hpp"
            #endif
        }
    };
    struct Output : ebmcodegen::Output {
    #if __has_include("visitor/Output_before.hpp")
    #include "visitor/Output_before.hpp"
    #elif __has_include("visitor/dsl/Output_before_dsl.hpp")
    #include "visitor/dsl/Output_before_dsl.hpp"
    #elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorOutput_before.hpp")
    #include "src/ebmcodegen/default_codegen_visitor/visitorOutput_before.hpp"
    #endif
    #if __has_include("visitor/Output.hpp")
    #include "visitor/Output.hpp"
    #elif __has_include("visitor/dsl/Output_dsl.hpp")
    #include "visitor/dsl/Output_dsl.hpp"
    #elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorOutput.hpp")
    #include "src/ebmcodegen/default_codegen_visitor/visitorOutput.hpp"
    #endif
    #if __has_include("visitor/Output_after.hpp")
    #include "visitor/Output_after.hpp"
    #elif __has_include("visitor/dsl/Output_after_dsl.hpp")
    #include "visitor/dsl/Output_after_dsl.hpp"
    #elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorOutput_after.hpp")
    #include "src/ebmcodegen/default_codegen_visitor/visitorOutput_after.hpp"
    #endif
    };
    template <typename Tag>
    struct UserHook {}; // Hook tag
    template <typename Tag>
    struct UserDSLHook {}; // Hook tag
    template <typename Tag>
    struct DefaultCodegenVisitorHook {}; // Hook tag
    template <typename Tag>
    struct UserInlinedHook {}; // Hook tag
    template <typename Tag>
    struct UserInlinedDSLHook {}; // Hook tag
    template <typename Tag>
    struct DefaultCodegenVisitorInlinedHook {}; // Hook tag
    template<typename T>
    constexpr bool dependent_false = false;
    template<typename Context>
    concept HasVisitorInContext = requires(const Context& ctx) { ctx.visitor; };
    template<typename Context>
    concept HasLegacyVisitorInContext = requires(const Context& ctx) { *ctx.__legacy_compat_ptr; };
    template<typename Context>
    decltype(auto) get_visitor_from_context(Context&& ctx) {
        if constexpr (HasVisitorInContext<Context>) {
            return *ctx.visitor.__legacy_compat_ptr;
        }
        else if constexpr (HasLegacyVisitorInContext<Context>) {
            return *ctx.__legacy_compat_ptr;
        }
        else {
            static_assert(dependent_false<Context>, "No visitor found in context");
        }
    }
    template<typename Context>
    expected<Result> dispatch_entry(Context&& ctx);
    template<typename Context>
    expected<Result> dispatch_pre_visitor(Context&& ctx,ebm::ExtendedBinaryModule& ebm);
    template<typename Context>
    expected<Result> dispatch_post_entry(Context&& ctx,expected<Result>& entry_result);
    template<typename Context>
    expected<Result> dispatch_Statement_BLOCK(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_ASSIGNMENT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_YIELD(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_APPEND(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_RETURN(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_ERROR_RETURN(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_ASSERT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_READ_DATA(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_WRITE_DATA(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_IF_STATEMENT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_LOOP_STATEMENT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_MATCH_STATEMENT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_MATCH_BRANCH(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_BREAK(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_CONTINUE(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_FUNCTION_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_VARIABLE_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_PARAMETER_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_FIELD_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_COMPOSITE_FIELD_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_ENUM_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_ENUM_MEMBER_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_STRUCT_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_UNION_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_UNION_MEMBER_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_PROGRAM_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_PROPERTY_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_PROPERTY_MEMBER_DECL(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_METADATA(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_IMPORT_MODULE(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_EXPRESSION(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_ERROR_REPORT(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_LOWERED_IO_STATEMENTS(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_SUB_BYTE_RANGE(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_INIT_CHECK(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_ENDIAN_VARIABLE(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Statement_default(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {}) {
        switch(in.body.kind) {
            case ebm::StatementKind::BLOCK: {
                return dispatch_Statement_BLOCK(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::ASSIGNMENT: {
                return dispatch_Statement_ASSIGNMENT(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::YIELD: {
                return dispatch_Statement_YIELD(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::APPEND: {
                return dispatch_Statement_APPEND(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::RETURN: {
                return dispatch_Statement_RETURN(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::ERROR_RETURN: {
                return dispatch_Statement_ERROR_RETURN(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::ASSERT: {
                return dispatch_Statement_ASSERT(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::READ_DATA: {
                return dispatch_Statement_READ_DATA(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::WRITE_DATA: {
                return dispatch_Statement_WRITE_DATA(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::IF_STATEMENT: {
                return dispatch_Statement_IF_STATEMENT(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::LOOP_STATEMENT: {
                return dispatch_Statement_LOOP_STATEMENT(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::MATCH_STATEMENT: {
                return dispatch_Statement_MATCH_STATEMENT(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::MATCH_BRANCH: {
                return dispatch_Statement_MATCH_BRANCH(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::BREAK: {
                return dispatch_Statement_BREAK(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::CONTINUE: {
                return dispatch_Statement_CONTINUE(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::FUNCTION_DECL: {
                return dispatch_Statement_FUNCTION_DECL(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::VARIABLE_DECL: {
                return dispatch_Statement_VARIABLE_DECL(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::PARAMETER_DECL: {
                return dispatch_Statement_PARAMETER_DECL(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::FIELD_DECL: {
                return dispatch_Statement_FIELD_DECL(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::COMPOSITE_FIELD_DECL: {
                return dispatch_Statement_COMPOSITE_FIELD_DECL(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::ENUM_DECL: {
                return dispatch_Statement_ENUM_DECL(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::ENUM_MEMBER_DECL: {
                return dispatch_Statement_ENUM_MEMBER_DECL(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::STRUCT_DECL: {
                return dispatch_Statement_STRUCT_DECL(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::UNION_DECL: {
                return dispatch_Statement_UNION_DECL(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::UNION_MEMBER_DECL: {
                return dispatch_Statement_UNION_MEMBER_DECL(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::PROGRAM_DECL: {
                return dispatch_Statement_PROGRAM_DECL(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::PROPERTY_DECL: {
                return dispatch_Statement_PROPERTY_DECL(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::PROPERTY_MEMBER_DECL: {
                return dispatch_Statement_PROPERTY_MEMBER_DECL(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::METADATA: {
                return dispatch_Statement_METADATA(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::IMPORT_MODULE: {
                return dispatch_Statement_IMPORT_MODULE(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::EXPRESSION: {
                return dispatch_Statement_EXPRESSION(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::ERROR_REPORT: {
                return dispatch_Statement_ERROR_REPORT(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::LOWERED_IO_STATEMENTS: {
                return dispatch_Statement_LOWERED_IO_STATEMENTS(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::SUB_BYTE_RANGE: {
                return dispatch_Statement_SUB_BYTE_RANGE(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::INIT_CHECK: {
                return dispatch_Statement_INIT_CHECK(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::StatementKind::ENDIAN_VARIABLE: {
                return dispatch_Statement_ENDIAN_VARIABLE(std::forward<Context>(ctx),in,alias_ref);
            }
            default: {
                return unexpect_error("Unknown Statement kind: {}", to_string(in.body.kind));
            }
        }
    }
    template<typename Context>
    expected<Result> dispatch_Block(Context&& ctx,const ebm::Block& in);
    template<typename Context>
    expected<Result> dispatch_Block_default(Context&& ctx,const ebm::Block& in) {
        CodeWriter w;
        for(auto& elem:in.container) {
            auto result = visit_Statement(ctx,elem);
            if (!result) {
                return unexpect_error(std::move(result.error()));
            }
            w.write(result->to_writer());
        }
        return w;
    }
    template<typename Context>
    expected<Result> dispatch_Expression_LITERAL_INT(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_LITERAL_INT64(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_LITERAL_BOOL(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_LITERAL_STRING(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_LITERAL_TYPE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_LITERAL_CHAR(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_IDENTIFIER(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_BINARY_OP(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_UNARY_OP(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_CALL(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_INDEX_ACCESS(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_MEMBER_ACCESS(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_ENUM_MEMBER(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_TYPE_CAST(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_RANGE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_DEFAULT_VALUE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_IS_LITTLE_ENDIAN(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_GET_STREAM_OFFSET(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_GET_REMAINING_BYTES(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_CAN_READ_STREAM(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_ARRAY_SIZE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_ENUM_IS_DEFINED(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_IS_ERROR(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_MAX_VALUE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_READ_DATA(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_WRITE_DATA(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_CONDITIONAL_STATEMENT(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_CONDITIONAL(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_AVAILABLE(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_SIZEOF(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_SUB_RANGE_INIT(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_OR_COND(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_ADDRESS_OF(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_OPTIONAL_OF(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_SETTER_STATUS(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_SELF(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_AS_ARG(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Expression_default(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {}) {
        switch(in.body.kind) {
            case ebm::ExpressionKind::LITERAL_INT: {
                return dispatch_Expression_LITERAL_INT(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::LITERAL_INT64: {
                return dispatch_Expression_LITERAL_INT64(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::LITERAL_BOOL: {
                return dispatch_Expression_LITERAL_BOOL(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::LITERAL_STRING: {
                return dispatch_Expression_LITERAL_STRING(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::LITERAL_TYPE: {
                return dispatch_Expression_LITERAL_TYPE(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::LITERAL_CHAR: {
                return dispatch_Expression_LITERAL_CHAR(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::IDENTIFIER: {
                return dispatch_Expression_IDENTIFIER(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::BINARY_OP: {
                return dispatch_Expression_BINARY_OP(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::UNARY_OP: {
                return dispatch_Expression_UNARY_OP(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::CALL: {
                return dispatch_Expression_CALL(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::INDEX_ACCESS: {
                return dispatch_Expression_INDEX_ACCESS(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::MEMBER_ACCESS: {
                return dispatch_Expression_MEMBER_ACCESS(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::ENUM_MEMBER: {
                return dispatch_Expression_ENUM_MEMBER(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::TYPE_CAST: {
                return dispatch_Expression_TYPE_CAST(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::RANGE: {
                return dispatch_Expression_RANGE(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::DEFAULT_VALUE: {
                return dispatch_Expression_DEFAULT_VALUE(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::IS_LITTLE_ENDIAN: {
                return dispatch_Expression_IS_LITTLE_ENDIAN(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::GET_STREAM_OFFSET: {
                return dispatch_Expression_GET_STREAM_OFFSET(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::GET_REMAINING_BYTES: {
                return dispatch_Expression_GET_REMAINING_BYTES(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::CAN_READ_STREAM: {
                return dispatch_Expression_CAN_READ_STREAM(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::ARRAY_SIZE: {
                return dispatch_Expression_ARRAY_SIZE(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::ENUM_IS_DEFINED: {
                return dispatch_Expression_ENUM_IS_DEFINED(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::IS_ERROR: {
                return dispatch_Expression_IS_ERROR(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::MAX_VALUE: {
                return dispatch_Expression_MAX_VALUE(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::READ_DATA: {
                return dispatch_Expression_READ_DATA(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::WRITE_DATA: {
                return dispatch_Expression_WRITE_DATA(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::CONDITIONAL_STATEMENT: {
                return dispatch_Expression_CONDITIONAL_STATEMENT(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::CONDITIONAL: {
                return dispatch_Expression_CONDITIONAL(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::AVAILABLE: {
                return dispatch_Expression_AVAILABLE(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::SIZEOF: {
                return dispatch_Expression_SIZEOF(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::SUB_RANGE_INIT: {
                return dispatch_Expression_SUB_RANGE_INIT(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::OR_COND: {
                return dispatch_Expression_OR_COND(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::ADDRESS_OF: {
                return dispatch_Expression_ADDRESS_OF(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::OPTIONAL_OF: {
                return dispatch_Expression_OPTIONAL_OF(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::SETTER_STATUS: {
                return dispatch_Expression_SETTER_STATUS(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::SELF: {
                return dispatch_Expression_SELF(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::ExpressionKind::AS_ARG: {
                return dispatch_Expression_AS_ARG(std::forward<Context>(ctx),in,alias_ref);
            }
            default: {
                return unexpect_error("Unknown Expression kind: {}", to_string(in.body.kind));
            }
        }
    }
    template<typename Context>
    expected<Result> dispatch_Expressions(Context&& ctx,const ebm::Expressions& in);
    template<typename Context>
    expected<Result> dispatch_Expressions_default(Context&& ctx,const ebm::Expressions& in) {
        CodeWriter w;
        for(auto& elem:in.container) {
            auto result = visit_Expression(ctx,elem);
            if (!result) {
                return unexpect_error(std::move(result.error()));
            }
            w.write(result->to_writer());
        }
        return w;
    }
    template<typename Context>
    expected<Result> dispatch_Type_INT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Type_UINT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Type_USIZE(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Type_FLOAT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Type_STRUCT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Type_RECURSIVE_STRUCT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Type_BOOL(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Type_VOID(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Type_META(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Type_ENUM(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Type_ARRAY(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Type_VECTOR(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Type_VARIANT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Type_RANGE(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Type_ENCODER_RETURN(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Type_DECODER_RETURN(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Type_ENCODER_INPUT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Type_DECODER_INPUT(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Type_PROPERTY_SETTER_RETURN(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Type_OPTIONAL(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Type_PTR(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Type_FUNCTION(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Type(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {});
    template<typename Context>
    expected<Result> dispatch_Type_default(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {}) {
        switch(in.body.kind) {
            case ebm::TypeKind::INT: {
                return dispatch_Type_INT(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::UINT: {
                return dispatch_Type_UINT(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::USIZE: {
                return dispatch_Type_USIZE(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::FLOAT: {
                return dispatch_Type_FLOAT(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::STRUCT: {
                return dispatch_Type_STRUCT(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::RECURSIVE_STRUCT: {
                return dispatch_Type_RECURSIVE_STRUCT(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::BOOL: {
                return dispatch_Type_BOOL(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::VOID: {
                return dispatch_Type_VOID(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::META: {
                return dispatch_Type_META(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::ENUM: {
                return dispatch_Type_ENUM(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::ARRAY: {
                return dispatch_Type_ARRAY(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::VECTOR: {
                return dispatch_Type_VECTOR(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::VARIANT: {
                return dispatch_Type_VARIANT(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::RANGE: {
                return dispatch_Type_RANGE(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::ENCODER_RETURN: {
                return dispatch_Type_ENCODER_RETURN(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::DECODER_RETURN: {
                return dispatch_Type_DECODER_RETURN(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::ENCODER_INPUT: {
                return dispatch_Type_ENCODER_INPUT(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::DECODER_INPUT: {
                return dispatch_Type_DECODER_INPUT(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::PROPERTY_SETTER_RETURN: {
                return dispatch_Type_PROPERTY_SETTER_RETURN(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::OPTIONAL: {
                return dispatch_Type_OPTIONAL(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::PTR: {
                return dispatch_Type_PTR(std::forward<Context>(ctx),in,alias_ref);
            }
            case ebm::TypeKind::FUNCTION: {
                return dispatch_Type_FUNCTION(std::forward<Context>(ctx),in,alias_ref);
            }
            default: {
                return unexpect_error("Unknown Type kind: {}", to_string(in.body.kind));
            }
        }
    }
    template<typename Context>
    expected<Result> dispatch_Types(Context&& ctx,const ebm::Types& in);
    template<typename Context>
    expected<Result> dispatch_Types_default(Context&& ctx,const ebm::Types& in) {
        CodeWriter w;
        for(auto& elem:in.container) {
            auto result = visit_Type(ctx,elem);
            if (!result) {
                return unexpect_error(std::move(result.error()));
            }
            w.write(result->to_writer());
        }
        return w;
    }
    // for backward compatibility
    
    // generic visitor for Statement
    template<typename Context>
    expected<Result> visit_Statement(Context&& ctx,const ebm::Statement& in,ebm::StatementRef alias_ref = {}) {
        return dispatch_Statement(ctx,in,alias_ref);
    }
    // short-hand visitor for Statement
    template<typename Context>
    expected<Result> visit_Statement(Context&& ctx,const ebm::StatementRef& ref) {
        MAYBE(elem, get_visitor_from_context(ctx).module_.get_statement(ref));
        return dispatch_Statement(ctx,elem,ref);
    }
    // for DSL convenience
    template<typename Context>
    expected<Result> visit_Object(Context&& ctx,const ebm::Statement& in, ebm::StatementRef alias_ref = {})  {
        return visit_Statement(ctx,in,alias_ref);
    }
    // for DSL convenience
    template<typename Context>
    expected<Result> visit_Object(Context&& ctx, ebm::StatementRef ref)  {
        return visit_Statement(ctx,ref);
    }
    // list visitor for Block
    template<typename Context>
    expected<Result> visit_Block(Context&& ctx,const ebm::Block& in) {
        return dispatch_Block(ctx,in);
    }
    // for DSL convenience
    template<typename Context>
    expected<Result> visit_Object(Context&& ctx,const ebm::Block& in)  {
        return visit_Block(ctx,in);
    }
    // generic visitor for Expression
    template<typename Context>
    expected<Result> visit_Expression(Context&& ctx,const ebm::Expression& in,ebm::ExpressionRef alias_ref = {}) {
        return dispatch_Expression(ctx,in,alias_ref);
    }
    // short-hand visitor for Expression
    template<typename Context>
    expected<Result> visit_Expression(Context&& ctx,const ebm::ExpressionRef& ref) {
        MAYBE(elem, get_visitor_from_context(ctx).module_.get_expression(ref));
        return dispatch_Expression(ctx,elem,ref);
    }
    // for DSL convenience
    template<typename Context>
    expected<Result> visit_Object(Context&& ctx,const ebm::Expression& in, ebm::ExpressionRef alias_ref = {})  {
        return visit_Expression(ctx,in,alias_ref);
    }
    // for DSL convenience
    template<typename Context>
    expected<Result> visit_Object(Context&& ctx, ebm::ExpressionRef ref)  {
        return visit_Expression(ctx,ref);
    }
    // list visitor for Expressions
    template<typename Context>
    expected<Result> visit_Expressions(Context&& ctx,const ebm::Expressions& in) {
        return dispatch_Expressions(ctx,in);
    }
    // for DSL convenience
    template<typename Context>
    expected<Result> visit_Object(Context&& ctx,const ebm::Expressions& in)  {
        return visit_Expressions(ctx,in);
    }
    // generic visitor for Type
    template<typename Context>
    expected<Result> visit_Type(Context&& ctx,const ebm::Type& in,ebm::TypeRef alias_ref = {}) {
        return dispatch_Type(ctx,in,alias_ref);
    }
    // short-hand visitor for Type
    template<typename Context>
    expected<Result> visit_Type(Context&& ctx,const ebm::TypeRef& ref) {
        MAYBE(elem, get_visitor_from_context(ctx).module_.get_type(ref));
        return dispatch_Type(ctx,elem,ref);
    }
    // for DSL convenience
    template<typename Context>
    expected<Result> visit_Object(Context&& ctx,const ebm::Type& in, ebm::TypeRef alias_ref = {})  {
        return visit_Type(ctx,in,alias_ref);
    }
    // for DSL convenience
    template<typename Context>
    expected<Result> visit_Object(Context&& ctx, ebm::TypeRef ref)  {
        return visit_Type(ctx,ref);
    }
    // list visitor for Types
    template<typename Context>
    expected<Result> visit_Types(Context&& ctx,const ebm::Types& in) {
        return dispatch_Types(ctx,in);
    }
    // for DSL convenience
    template<typename Context>
    expected<Result> visit_Object(Context&& ctx,const ebm::Types& in)  {
        return visit_Types(ctx,in);
    }
    struct BaseVisitor {
        BaseVisitor(MergedVisitor* __legacy_compat_ptr,ebmgen::EBMProxy module_,Flags& flags,Output& output,futils::binary::writer& wm) :__legacy_compat_ptr(__legacy_compat_ptr),module_(module_, ebmgen::lazy_init),flags(flags),output(output),wm(wm){}
        static constexpr const char* program_name = "ebm2all";
        MergedVisitor* const __legacy_compat_ptr;
        ebmgen::MappingTable module_;
        Flags& flags;
        Output& output;
        ebmcodegen::WriterManager<CodeWriter> wm;
        #if __has_include("visitor/Visitor_before.hpp")
        #include "visitor/Visitor_before.hpp"
        #elif __has_include("visitor/dsl/Visitor_before_dsl.hpp")
        #include "visitor/dsl/Visitor_before_dsl.hpp"
        #elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorVisitor_before.hpp")
        #include "src/ebmcodegen/default_codegen_visitor/visitorVisitor_before.hpp"
        #endif
        #if __has_include("visitor/Visitor.hpp")
        #include "visitor/Visitor.hpp"
        #elif __has_include("visitor/dsl/Visitor_dsl.hpp")
        #include "visitor/dsl/Visitor_dsl.hpp"
        #elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorVisitor.hpp")
        #include "src/ebmcodegen/default_codegen_visitor/visitorVisitor.hpp"
        #endif
        #if __has_include("visitor/Visitor_after.hpp")
        #include "visitor/Visitor_after.hpp"
        #elif __has_include("visitor/dsl/Visitor_after_dsl.hpp")
        #include "visitor/dsl/Visitor_after_dsl.hpp"
        #elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorVisitor_after.hpp")
        #include "src/ebmcodegen/default_codegen_visitor/visitorVisitor_after.hpp"
        #endif
    };
    template<typename V>
    concept BaseVisitorLike = std::derived_from<V,BaseVisitor>;
    struct InitialContext : ebmcodegen::util::ContextBase<InitialContext> {
        BaseVisitor& visitor;
    };
    template<typename Tag>
    struct Visitor; // Customization point struct
    struct Context_entry : ebmcodegen::util::ContextBase<Context_entry> {
        BaseVisitor& visitor;
    };
    struct VisitorTag_entry {};
    template<typename VisitorImpl>
    concept has_visitor_entry = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_entry&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_ENTRY(instance_name) \
    auto& visitor = instance_name.visitor;
    struct Context_entry_before : ebmcodegen::util::ContextBase<Context_entry_before> {
        BaseVisitor& visitor;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_entry_before {};
    template<typename VisitorImpl>
    concept has_visitor_entry_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_entry_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_ENTRY_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& main_logic = instance_name.main_logic;
    struct Context_entry_after : ebmcodegen::util::ContextBase<Context_entry_after> {
        BaseVisitor& visitor;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_entry_after {};
    template<typename VisitorImpl>
    concept has_visitor_entry_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_entry_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_ENTRY_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_pre_visitor : ebmcodegen::util::ContextBase<Context_pre_visitor> {
        BaseVisitor& visitor;
        ebm::ExtendedBinaryModule& ebm;
    };
    struct VisitorTag_pre_visitor {};
    template<typename VisitorImpl>
    concept has_visitor_pre_visitor = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_pre_visitor&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_PRE_VISITOR(instance_name) \
    auto& visitor = instance_name.visitor;auto& ebm = instance_name.ebm;
    struct Context_pre_visitor_before : ebmcodegen::util::ContextBase<Context_pre_visitor_before> {
        BaseVisitor& visitor;
        ebm::ExtendedBinaryModule& ebm;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_pre_visitor_before {};
    template<typename VisitorImpl>
    concept has_visitor_pre_visitor_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_pre_visitor_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_PRE_VISITOR_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& ebm = instance_name.ebm;auto& main_logic = instance_name.main_logic;
    struct Context_pre_visitor_after : ebmcodegen::util::ContextBase<Context_pre_visitor_after> {
        BaseVisitor& visitor;
        ebm::ExtendedBinaryModule& ebm;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_pre_visitor_after {};
    template<typename VisitorImpl>
    concept has_visitor_pre_visitor_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_pre_visitor_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_PRE_VISITOR_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& ebm = instance_name.ebm;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_post_entry : ebmcodegen::util::ContextBase<Context_post_entry> {
        BaseVisitor& visitor;
        expected<Result>& entry_result;
    };
    struct VisitorTag_post_entry {};
    template<typename VisitorImpl>
    concept has_visitor_post_entry = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_post_entry&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_POST_ENTRY(instance_name) \
    auto& visitor = instance_name.visitor;auto& entry_result = instance_name.entry_result;
    struct Context_post_entry_before : ebmcodegen::util::ContextBase<Context_post_entry_before> {
        BaseVisitor& visitor;
        expected<Result>& entry_result;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_post_entry_before {};
    template<typename VisitorImpl>
    concept has_visitor_post_entry_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_post_entry_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_POST_ENTRY_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& entry_result = instance_name.entry_result;auto& main_logic = instance_name.main_logic;
    struct Context_post_entry_after : ebmcodegen::util::ContextBase<Context_post_entry_after> {
        BaseVisitor& visitor;
        expected<Result>& entry_result;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_post_entry_after {};
    template<typename VisitorImpl>
    concept has_visitor_post_entry_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_post_entry_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_POST_ENTRY_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& entry_result = instance_name.entry_result;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_BLOCK : ebmcodegen::util::ContextBase<Context_Statement_BLOCK> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Block& block;
    };
    struct VisitorTag_Statement_BLOCK {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_BLOCK = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_BLOCK&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_BLOCK(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& block = instance_name.block;
    struct Context_Statement_BLOCK_before : ebmcodegen::util::ContextBase<Context_Statement_BLOCK_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Block& block;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_BLOCK_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_BLOCK_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_BLOCK_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_BLOCK_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& block = instance_name.block;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_BLOCK_after : ebmcodegen::util::ContextBase<Context_Statement_BLOCK_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Block& block;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_BLOCK_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_BLOCK_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_BLOCK_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_BLOCK_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& block = instance_name.block;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_ASSIGNMENT : ebmcodegen::util::ContextBase<Context_Statement_ASSIGNMENT> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::StatementRef& previous_assignment;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
    };
    struct VisitorTag_Statement_ASSIGNMENT {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_ASSIGNMENT = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_ASSIGNMENT&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_ASSIGNMENT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& previous_assignment = instance_name.previous_assignment;auto& target = instance_name.target;auto& value = instance_name.value;
    struct Context_Statement_ASSIGNMENT_before : ebmcodegen::util::ContextBase<Context_Statement_ASSIGNMENT_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::StatementRef& previous_assignment;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_ASSIGNMENT_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_ASSIGNMENT_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_ASSIGNMENT_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_ASSIGNMENT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& previous_assignment = instance_name.previous_assignment;auto& target = instance_name.target;auto& value = instance_name.value;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_ASSIGNMENT_after : ebmcodegen::util::ContextBase<Context_Statement_ASSIGNMENT_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::StatementRef& previous_assignment;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_ASSIGNMENT_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_ASSIGNMENT_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_ASSIGNMENT_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_ASSIGNMENT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& previous_assignment = instance_name.previous_assignment;auto& target = instance_name.target;auto& value = instance_name.value;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_YIELD : ebmcodegen::util::ContextBase<Context_Statement_YIELD> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::StatementRef& previous_assignment;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
    };
    struct VisitorTag_Statement_YIELD {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_YIELD = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_YIELD&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_YIELD(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& previous_assignment = instance_name.previous_assignment;auto& target = instance_name.target;auto& value = instance_name.value;
    struct Context_Statement_YIELD_before : ebmcodegen::util::ContextBase<Context_Statement_YIELD_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::StatementRef& previous_assignment;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_YIELD_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_YIELD_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_YIELD_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_YIELD_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& previous_assignment = instance_name.previous_assignment;auto& target = instance_name.target;auto& value = instance_name.value;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_YIELD_after : ebmcodegen::util::ContextBase<Context_Statement_YIELD_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::StatementRef& previous_assignment;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_YIELD_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_YIELD_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_YIELD_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_YIELD_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& previous_assignment = instance_name.previous_assignment;auto& target = instance_name.target;auto& value = instance_name.value;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_APPEND : ebmcodegen::util::ContextBase<Context_Statement_APPEND> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
    };
    struct VisitorTag_Statement_APPEND {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_APPEND = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_APPEND&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_APPEND(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& target = instance_name.target;auto& value = instance_name.value;
    struct Context_Statement_APPEND_before : ebmcodegen::util::ContextBase<Context_Statement_APPEND_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_APPEND_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_APPEND_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_APPEND_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_APPEND_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& target = instance_name.target;auto& value = instance_name.value;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_APPEND_after : ebmcodegen::util::ContextBase<Context_Statement_APPEND_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ExpressionRef& target;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_APPEND_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_APPEND_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_APPEND_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_APPEND_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& target = instance_name.target;auto& value = instance_name.value;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_RETURN : ebmcodegen::util::ContextBase<Context_Statement_RETURN> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ExpressionRef& value;
    };
    struct VisitorTag_Statement_RETURN {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_RETURN = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_RETURN&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_RETURN(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& value = instance_name.value;
    struct Context_Statement_RETURN_before : ebmcodegen::util::ContextBase<Context_Statement_RETURN_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_RETURN_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_RETURN_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_RETURN_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_RETURN_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& value = instance_name.value;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_RETURN_after : ebmcodegen::util::ContextBase<Context_Statement_RETURN_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_RETURN_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_RETURN_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_RETURN_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_RETURN_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& value = instance_name.value;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_ERROR_RETURN : ebmcodegen::util::ContextBase<Context_Statement_ERROR_RETURN> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ExpressionRef& value;
    };
    struct VisitorTag_Statement_ERROR_RETURN {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_ERROR_RETURN = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_ERROR_RETURN&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_ERROR_RETURN(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& value = instance_name.value;
    struct Context_Statement_ERROR_RETURN_before : ebmcodegen::util::ContextBase<Context_Statement_ERROR_RETURN_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_ERROR_RETURN_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_ERROR_RETURN_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_ERROR_RETURN_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_ERROR_RETURN_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& value = instance_name.value;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_ERROR_RETURN_after : ebmcodegen::util::ContextBase<Context_Statement_ERROR_RETURN_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ExpressionRef& value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_ERROR_RETURN_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_ERROR_RETURN_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_ERROR_RETURN_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_ERROR_RETURN_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& value = instance_name.value;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_ASSERT : ebmcodegen::util::ContextBase<Context_Statement_ASSERT> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::AssertDesc& assert_desc;
    };
    struct VisitorTag_Statement_ASSERT {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_ASSERT = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_ASSERT&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_ASSERT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& assert_desc = instance_name.assert_desc;
    struct Context_Statement_ASSERT_before : ebmcodegen::util::ContextBase<Context_Statement_ASSERT_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::AssertDesc& assert_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_ASSERT_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_ASSERT_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_ASSERT_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_ASSERT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& assert_desc = instance_name.assert_desc;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_ASSERT_after : ebmcodegen::util::ContextBase<Context_Statement_ASSERT_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::AssertDesc& assert_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_ASSERT_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_ASSERT_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_ASSERT_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_ASSERT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& assert_desc = instance_name.assert_desc;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_READ_DATA : ebmcodegen::util::ContextBase<Context_Statement_READ_DATA> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IOData& read_data;
    };
    struct VisitorTag_Statement_READ_DATA {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_READ_DATA = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_READ_DATA&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_READ_DATA(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& read_data = instance_name.read_data;
    struct Context_Statement_READ_DATA_before : ebmcodegen::util::ContextBase<Context_Statement_READ_DATA_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IOData& read_data;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_READ_DATA_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_READ_DATA_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_READ_DATA_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_READ_DATA_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& read_data = instance_name.read_data;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_READ_DATA_after : ebmcodegen::util::ContextBase<Context_Statement_READ_DATA_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IOData& read_data;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_READ_DATA_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_READ_DATA_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_READ_DATA_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_READ_DATA_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& read_data = instance_name.read_data;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_WRITE_DATA : ebmcodegen::util::ContextBase<Context_Statement_WRITE_DATA> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IOData& write_data;
    };
    struct VisitorTag_Statement_WRITE_DATA {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_WRITE_DATA = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_WRITE_DATA&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_WRITE_DATA(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& write_data = instance_name.write_data;
    struct Context_Statement_WRITE_DATA_before : ebmcodegen::util::ContextBase<Context_Statement_WRITE_DATA_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IOData& write_data;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_WRITE_DATA_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_WRITE_DATA_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_WRITE_DATA_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_WRITE_DATA_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& write_data = instance_name.write_data;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_WRITE_DATA_after : ebmcodegen::util::ContextBase<Context_Statement_WRITE_DATA_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IOData& write_data;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_WRITE_DATA_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_WRITE_DATA_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_WRITE_DATA_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_WRITE_DATA_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& write_data = instance_name.write_data;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_IF_STATEMENT : ebmcodegen::util::ContextBase<Context_Statement_IF_STATEMENT> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IfStatement& if_statement;
    };
    struct VisitorTag_Statement_IF_STATEMENT {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_IF_STATEMENT = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_IF_STATEMENT&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_IF_STATEMENT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& if_statement = instance_name.if_statement;
    struct Context_Statement_IF_STATEMENT_before : ebmcodegen::util::ContextBase<Context_Statement_IF_STATEMENT_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IfStatement& if_statement;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_IF_STATEMENT_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_IF_STATEMENT_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_IF_STATEMENT_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_IF_STATEMENT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& if_statement = instance_name.if_statement;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_IF_STATEMENT_after : ebmcodegen::util::ContextBase<Context_Statement_IF_STATEMENT_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::IfStatement& if_statement;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_IF_STATEMENT_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_IF_STATEMENT_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_IF_STATEMENT_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_IF_STATEMENT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& if_statement = instance_name.if_statement;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_LOOP_STATEMENT : ebmcodegen::util::ContextBase<Context_Statement_LOOP_STATEMENT> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopStatement& loop;
    };
    struct VisitorTag_Statement_LOOP_STATEMENT {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_LOOP_STATEMENT = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_LOOP_STATEMENT&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_LOOP_STATEMENT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& loop = instance_name.loop;
    struct Context_Statement_LOOP_STATEMENT_before : ebmcodegen::util::ContextBase<Context_Statement_LOOP_STATEMENT_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopStatement& loop;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_LOOP_STATEMENT_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_LOOP_STATEMENT_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_LOOP_STATEMENT_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_LOOP_STATEMENT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& loop = instance_name.loop;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_LOOP_STATEMENT_after : ebmcodegen::util::ContextBase<Context_Statement_LOOP_STATEMENT_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopStatement& loop;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_LOOP_STATEMENT_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_LOOP_STATEMENT_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_LOOP_STATEMENT_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_LOOP_STATEMENT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& loop = instance_name.loop;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_MATCH_STATEMENT : ebmcodegen::util::ContextBase<Context_Statement_MATCH_STATEMENT> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::MatchStatement& match_statement;
    };
    struct VisitorTag_Statement_MATCH_STATEMENT {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_MATCH_STATEMENT = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_MATCH_STATEMENT&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_MATCH_STATEMENT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& match_statement = instance_name.match_statement;
    struct Context_Statement_MATCH_STATEMENT_before : ebmcodegen::util::ContextBase<Context_Statement_MATCH_STATEMENT_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::MatchStatement& match_statement;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_MATCH_STATEMENT_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_MATCH_STATEMENT_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_MATCH_STATEMENT_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_MATCH_STATEMENT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& match_statement = instance_name.match_statement;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_MATCH_STATEMENT_after : ebmcodegen::util::ContextBase<Context_Statement_MATCH_STATEMENT_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::MatchStatement& match_statement;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_MATCH_STATEMENT_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_MATCH_STATEMENT_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_MATCH_STATEMENT_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_MATCH_STATEMENT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& match_statement = instance_name.match_statement;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_MATCH_BRANCH : ebmcodegen::util::ContextBase<Context_Statement_MATCH_BRANCH> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::MatchBranch& match_branch;
    };
    struct VisitorTag_Statement_MATCH_BRANCH {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_MATCH_BRANCH = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_MATCH_BRANCH&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_MATCH_BRANCH(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& match_branch = instance_name.match_branch;
    struct Context_Statement_MATCH_BRANCH_before : ebmcodegen::util::ContextBase<Context_Statement_MATCH_BRANCH_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::MatchBranch& match_branch;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_MATCH_BRANCH_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_MATCH_BRANCH_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_MATCH_BRANCH_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_MATCH_BRANCH_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& match_branch = instance_name.match_branch;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_MATCH_BRANCH_after : ebmcodegen::util::ContextBase<Context_Statement_MATCH_BRANCH_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::MatchBranch& match_branch;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_MATCH_BRANCH_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_MATCH_BRANCH_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_MATCH_BRANCH_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_MATCH_BRANCH_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& match_branch = instance_name.match_branch;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_BREAK : ebmcodegen::util::ContextBase<Context_Statement_BREAK> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopFlowControl& break_;
    };
    struct VisitorTag_Statement_BREAK {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_BREAK = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_BREAK&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_BREAK(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& break_ = instance_name.break_;
    struct Context_Statement_BREAK_before : ebmcodegen::util::ContextBase<Context_Statement_BREAK_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopFlowControl& break_;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_BREAK_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_BREAK_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_BREAK_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_BREAK_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& break_ = instance_name.break_;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_BREAK_after : ebmcodegen::util::ContextBase<Context_Statement_BREAK_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopFlowControl& break_;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_BREAK_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_BREAK_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_BREAK_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_BREAK_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& break_ = instance_name.break_;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_CONTINUE : ebmcodegen::util::ContextBase<Context_Statement_CONTINUE> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopFlowControl& continue_;
    };
    struct VisitorTag_Statement_CONTINUE {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_CONTINUE = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_CONTINUE&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_CONTINUE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& continue_ = instance_name.continue_;
    struct Context_Statement_CONTINUE_before : ebmcodegen::util::ContextBase<Context_Statement_CONTINUE_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopFlowControl& continue_;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_CONTINUE_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_CONTINUE_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_CONTINUE_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_CONTINUE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& continue_ = instance_name.continue_;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_CONTINUE_after : ebmcodegen::util::ContextBase<Context_Statement_CONTINUE_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoopFlowControl& continue_;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_CONTINUE_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_CONTINUE_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_CONTINUE_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_CONTINUE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& continue_ = instance_name.continue_;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_FUNCTION_DECL : ebmcodegen::util::ContextBase<Context_Statement_FUNCTION_DECL> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::FunctionDecl& func_decl;
    };
    struct VisitorTag_Statement_FUNCTION_DECL {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_FUNCTION_DECL = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_FUNCTION_DECL&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_FUNCTION_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& func_decl = instance_name.func_decl;
    struct Context_Statement_FUNCTION_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_FUNCTION_DECL_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::FunctionDecl& func_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_FUNCTION_DECL_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_FUNCTION_DECL_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_FUNCTION_DECL_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_FUNCTION_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& func_decl = instance_name.func_decl;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_FUNCTION_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_FUNCTION_DECL_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::FunctionDecl& func_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_FUNCTION_DECL_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_FUNCTION_DECL_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_FUNCTION_DECL_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_FUNCTION_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& func_decl = instance_name.func_decl;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_VARIABLE_DECL : ebmcodegen::util::ContextBase<Context_Statement_VARIABLE_DECL> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::VariableDecl& var_decl;
    };
    struct VisitorTag_Statement_VARIABLE_DECL {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_VARIABLE_DECL = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_VARIABLE_DECL&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_VARIABLE_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& var_decl = instance_name.var_decl;
    struct Context_Statement_VARIABLE_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_VARIABLE_DECL_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::VariableDecl& var_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_VARIABLE_DECL_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_VARIABLE_DECL_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_VARIABLE_DECL_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_VARIABLE_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& var_decl = instance_name.var_decl;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_VARIABLE_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_VARIABLE_DECL_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::VariableDecl& var_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_VARIABLE_DECL_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_VARIABLE_DECL_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_VARIABLE_DECL_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_VARIABLE_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& var_decl = instance_name.var_decl;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_PARAMETER_DECL : ebmcodegen::util::ContextBase<Context_Statement_PARAMETER_DECL> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ParameterDecl& param_decl;
    };
    struct VisitorTag_Statement_PARAMETER_DECL {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_PARAMETER_DECL = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_PARAMETER_DECL&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_PARAMETER_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& param_decl = instance_name.param_decl;
    struct Context_Statement_PARAMETER_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_PARAMETER_DECL_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ParameterDecl& param_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_PARAMETER_DECL_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_PARAMETER_DECL_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_PARAMETER_DECL_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_PARAMETER_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& param_decl = instance_name.param_decl;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_PARAMETER_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_PARAMETER_DECL_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ParameterDecl& param_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_PARAMETER_DECL_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_PARAMETER_DECL_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_PARAMETER_DECL_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_PARAMETER_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& param_decl = instance_name.param_decl;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_FIELD_DECL : ebmcodegen::util::ContextBase<Context_Statement_FIELD_DECL> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::FieldDecl& field_decl;
    };
    struct VisitorTag_Statement_FIELD_DECL {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_FIELD_DECL = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_FIELD_DECL&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_FIELD_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& field_decl = instance_name.field_decl;
    struct Context_Statement_FIELD_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_FIELD_DECL_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::FieldDecl& field_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_FIELD_DECL_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_FIELD_DECL_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_FIELD_DECL_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_FIELD_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& field_decl = instance_name.field_decl;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_FIELD_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_FIELD_DECL_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::FieldDecl& field_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_FIELD_DECL_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_FIELD_DECL_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_FIELD_DECL_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_FIELD_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& field_decl = instance_name.field_decl;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_COMPOSITE_FIELD_DECL : ebmcodegen::util::ContextBase<Context_Statement_COMPOSITE_FIELD_DECL> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::CompositeFieldDecl& composite_field_decl;
    };
    struct VisitorTag_Statement_COMPOSITE_FIELD_DECL {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_COMPOSITE_FIELD_DECL = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_COMPOSITE_FIELD_DECL&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_COMPOSITE_FIELD_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& composite_field_decl = instance_name.composite_field_decl;
    struct Context_Statement_COMPOSITE_FIELD_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_COMPOSITE_FIELD_DECL_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::CompositeFieldDecl& composite_field_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_COMPOSITE_FIELD_DECL_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_COMPOSITE_FIELD_DECL_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_COMPOSITE_FIELD_DECL_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_COMPOSITE_FIELD_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& composite_field_decl = instance_name.composite_field_decl;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_COMPOSITE_FIELD_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_COMPOSITE_FIELD_DECL_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::CompositeFieldDecl& composite_field_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_COMPOSITE_FIELD_DECL_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_COMPOSITE_FIELD_DECL_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_COMPOSITE_FIELD_DECL_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_COMPOSITE_FIELD_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& composite_field_decl = instance_name.composite_field_decl;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_ENUM_DECL : ebmcodegen::util::ContextBase<Context_Statement_ENUM_DECL> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EnumDecl& enum_decl;
    };
    struct VisitorTag_Statement_ENUM_DECL {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_ENUM_DECL = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_ENUM_DECL&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_ENUM_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& enum_decl = instance_name.enum_decl;
    struct Context_Statement_ENUM_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_ENUM_DECL_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EnumDecl& enum_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_ENUM_DECL_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_ENUM_DECL_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_ENUM_DECL_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_ENUM_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& enum_decl = instance_name.enum_decl;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_ENUM_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_ENUM_DECL_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EnumDecl& enum_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_ENUM_DECL_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_ENUM_DECL_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_ENUM_DECL_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_ENUM_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& enum_decl = instance_name.enum_decl;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_ENUM_MEMBER_DECL : ebmcodegen::util::ContextBase<Context_Statement_ENUM_MEMBER_DECL> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EnumMemberDecl& enum_member_decl;
    };
    struct VisitorTag_Statement_ENUM_MEMBER_DECL {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_ENUM_MEMBER_DECL = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_ENUM_MEMBER_DECL&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_ENUM_MEMBER_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& enum_member_decl = instance_name.enum_member_decl;
    struct Context_Statement_ENUM_MEMBER_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_ENUM_MEMBER_DECL_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EnumMemberDecl& enum_member_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_ENUM_MEMBER_DECL_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_ENUM_MEMBER_DECL_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_ENUM_MEMBER_DECL_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_ENUM_MEMBER_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& enum_member_decl = instance_name.enum_member_decl;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_ENUM_MEMBER_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_ENUM_MEMBER_DECL_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EnumMemberDecl& enum_member_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_ENUM_MEMBER_DECL_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_ENUM_MEMBER_DECL_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_ENUM_MEMBER_DECL_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_ENUM_MEMBER_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& enum_member_decl = instance_name.enum_member_decl;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_STRUCT_DECL : ebmcodegen::util::ContextBase<Context_Statement_STRUCT_DECL> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::StructDecl& struct_decl;
    };
    struct VisitorTag_Statement_STRUCT_DECL {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_STRUCT_DECL = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_STRUCT_DECL&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_STRUCT_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& struct_decl = instance_name.struct_decl;
    struct Context_Statement_STRUCT_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_STRUCT_DECL_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::StructDecl& struct_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_STRUCT_DECL_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_STRUCT_DECL_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_STRUCT_DECL_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_STRUCT_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& struct_decl = instance_name.struct_decl;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_STRUCT_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_STRUCT_DECL_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::StructDecl& struct_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_STRUCT_DECL_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_STRUCT_DECL_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_STRUCT_DECL_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_STRUCT_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& struct_decl = instance_name.struct_decl;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_UNION_DECL : ebmcodegen::util::ContextBase<Context_Statement_UNION_DECL> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
    };
    struct VisitorTag_Statement_UNION_DECL {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_UNION_DECL = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_UNION_DECL&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_UNION_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;
    struct Context_Statement_UNION_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_UNION_DECL_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_UNION_DECL_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_UNION_DECL_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_UNION_DECL_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_UNION_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_UNION_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_UNION_DECL_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_UNION_DECL_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_UNION_DECL_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_UNION_DECL_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_UNION_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_UNION_MEMBER_DECL : ebmcodegen::util::ContextBase<Context_Statement_UNION_MEMBER_DECL> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
    };
    struct VisitorTag_Statement_UNION_MEMBER_DECL {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_UNION_MEMBER_DECL = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_UNION_MEMBER_DECL&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_UNION_MEMBER_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;
    struct Context_Statement_UNION_MEMBER_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_UNION_MEMBER_DECL_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_UNION_MEMBER_DECL_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_UNION_MEMBER_DECL_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_UNION_MEMBER_DECL_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_UNION_MEMBER_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_UNION_MEMBER_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_UNION_MEMBER_DECL_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_UNION_MEMBER_DECL_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_UNION_MEMBER_DECL_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_UNION_MEMBER_DECL_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_UNION_MEMBER_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_PROGRAM_DECL : ebmcodegen::util::ContextBase<Context_Statement_PROGRAM_DECL> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Block& block;
    };
    struct VisitorTag_Statement_PROGRAM_DECL {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_PROGRAM_DECL = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_PROGRAM_DECL&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_PROGRAM_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& block = instance_name.block;
    struct Context_Statement_PROGRAM_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_PROGRAM_DECL_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Block& block;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_PROGRAM_DECL_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_PROGRAM_DECL_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_PROGRAM_DECL_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_PROGRAM_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& block = instance_name.block;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_PROGRAM_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_PROGRAM_DECL_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Block& block;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_PROGRAM_DECL_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_PROGRAM_DECL_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_PROGRAM_DECL_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_PROGRAM_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& block = instance_name.block;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_PROPERTY_DECL : ebmcodegen::util::ContextBase<Context_Statement_PROPERTY_DECL> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::PropertyDecl& property_decl;
    };
    struct VisitorTag_Statement_PROPERTY_DECL {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_PROPERTY_DECL = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_PROPERTY_DECL&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_PROPERTY_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& property_decl = instance_name.property_decl;
    struct Context_Statement_PROPERTY_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_PROPERTY_DECL_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::PropertyDecl& property_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_PROPERTY_DECL_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_PROPERTY_DECL_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_PROPERTY_DECL_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_PROPERTY_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& property_decl = instance_name.property_decl;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_PROPERTY_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_PROPERTY_DECL_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::PropertyDecl& property_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_PROPERTY_DECL_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_PROPERTY_DECL_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_PROPERTY_DECL_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_PROPERTY_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& property_decl = instance_name.property_decl;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_PROPERTY_MEMBER_DECL : ebmcodegen::util::ContextBase<Context_Statement_PROPERTY_MEMBER_DECL> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::PropertyMemberDecl& property_member_decl;
    };
    struct VisitorTag_Statement_PROPERTY_MEMBER_DECL {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_PROPERTY_MEMBER_DECL = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_PROPERTY_MEMBER_DECL&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_PROPERTY_MEMBER_DECL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& property_member_decl = instance_name.property_member_decl;
    struct Context_Statement_PROPERTY_MEMBER_DECL_before : ebmcodegen::util::ContextBase<Context_Statement_PROPERTY_MEMBER_DECL_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::PropertyMemberDecl& property_member_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_PROPERTY_MEMBER_DECL_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_PROPERTY_MEMBER_DECL_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_PROPERTY_MEMBER_DECL_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_PROPERTY_MEMBER_DECL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& property_member_decl = instance_name.property_member_decl;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_PROPERTY_MEMBER_DECL_after : ebmcodegen::util::ContextBase<Context_Statement_PROPERTY_MEMBER_DECL_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::PropertyMemberDecl& property_member_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_PROPERTY_MEMBER_DECL_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_PROPERTY_MEMBER_DECL_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_PROPERTY_MEMBER_DECL_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_PROPERTY_MEMBER_DECL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& property_member_decl = instance_name.property_member_decl;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_METADATA : ebmcodegen::util::ContextBase<Context_Statement_METADATA> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Metadata& metadata;
    };
    struct VisitorTag_Statement_METADATA {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_METADATA = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_METADATA&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_METADATA(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& metadata = instance_name.metadata;
    struct Context_Statement_METADATA_before : ebmcodegen::util::ContextBase<Context_Statement_METADATA_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Metadata& metadata;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_METADATA_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_METADATA_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_METADATA_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_METADATA_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& metadata = instance_name.metadata;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_METADATA_after : ebmcodegen::util::ContextBase<Context_Statement_METADATA_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::Metadata& metadata;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_METADATA_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_METADATA_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_METADATA_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_METADATA_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& metadata = instance_name.metadata;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_IMPORT_MODULE : ebmcodegen::util::ContextBase<Context_Statement_IMPORT_MODULE> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ImportDecl& import_decl;
    };
    struct VisitorTag_Statement_IMPORT_MODULE {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_IMPORT_MODULE = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_IMPORT_MODULE&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_IMPORT_MODULE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& import_decl = instance_name.import_decl;
    struct Context_Statement_IMPORT_MODULE_before : ebmcodegen::util::ContextBase<Context_Statement_IMPORT_MODULE_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ImportDecl& import_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_IMPORT_MODULE_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_IMPORT_MODULE_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_IMPORT_MODULE_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_IMPORT_MODULE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& import_decl = instance_name.import_decl;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_IMPORT_MODULE_after : ebmcodegen::util::ContextBase<Context_Statement_IMPORT_MODULE_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ImportDecl& import_decl;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_IMPORT_MODULE_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_IMPORT_MODULE_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_IMPORT_MODULE_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_IMPORT_MODULE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& import_decl = instance_name.import_decl;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_EXPRESSION : ebmcodegen::util::ContextBase<Context_Statement_EXPRESSION> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ExpressionRef& expression;
    };
    struct VisitorTag_Statement_EXPRESSION {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_EXPRESSION = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_EXPRESSION&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_EXPRESSION(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& expression = instance_name.expression;
    struct Context_Statement_EXPRESSION_before : ebmcodegen::util::ContextBase<Context_Statement_EXPRESSION_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ExpressionRef& expression;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_EXPRESSION_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_EXPRESSION_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_EXPRESSION_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_EXPRESSION_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& expression = instance_name.expression;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_EXPRESSION_after : ebmcodegen::util::ContextBase<Context_Statement_EXPRESSION_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ExpressionRef& expression;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_EXPRESSION_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_EXPRESSION_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_EXPRESSION_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_EXPRESSION_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& expression = instance_name.expression;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_ERROR_REPORT : ebmcodegen::util::ContextBase<Context_Statement_ERROR_REPORT> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ErrorReport& error_report;
    };
    struct VisitorTag_Statement_ERROR_REPORT {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_ERROR_REPORT = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_ERROR_REPORT&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_ERROR_REPORT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& error_report = instance_name.error_report;
    struct Context_Statement_ERROR_REPORT_before : ebmcodegen::util::ContextBase<Context_Statement_ERROR_REPORT_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ErrorReport& error_report;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_ERROR_REPORT_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_ERROR_REPORT_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_ERROR_REPORT_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_ERROR_REPORT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& error_report = instance_name.error_report;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_ERROR_REPORT_after : ebmcodegen::util::ContextBase<Context_Statement_ERROR_REPORT_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::ErrorReport& error_report;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_ERROR_REPORT_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_ERROR_REPORT_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_ERROR_REPORT_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_ERROR_REPORT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& error_report = instance_name.error_report;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_LOWERED_IO_STATEMENTS : ebmcodegen::util::ContextBase<Context_Statement_LOWERED_IO_STATEMENTS> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoweredIOStatements& lowered_io_statements;
    };
    struct VisitorTag_Statement_LOWERED_IO_STATEMENTS {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_LOWERED_IO_STATEMENTS = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_LOWERED_IO_STATEMENTS&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_LOWERED_IO_STATEMENTS(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& lowered_io_statements = instance_name.lowered_io_statements;
    struct Context_Statement_LOWERED_IO_STATEMENTS_before : ebmcodegen::util::ContextBase<Context_Statement_LOWERED_IO_STATEMENTS_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoweredIOStatements& lowered_io_statements;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_LOWERED_IO_STATEMENTS_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_LOWERED_IO_STATEMENTS_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_LOWERED_IO_STATEMENTS_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_LOWERED_IO_STATEMENTS_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& lowered_io_statements = instance_name.lowered_io_statements;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_LOWERED_IO_STATEMENTS_after : ebmcodegen::util::ContextBase<Context_Statement_LOWERED_IO_STATEMENTS_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::LoweredIOStatements& lowered_io_statements;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_LOWERED_IO_STATEMENTS_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_LOWERED_IO_STATEMENTS_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_LOWERED_IO_STATEMENTS_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_LOWERED_IO_STATEMENTS_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& lowered_io_statements = instance_name.lowered_io_statements;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_SUB_BYTE_RANGE : ebmcodegen::util::ContextBase<Context_Statement_SUB_BYTE_RANGE> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::SubByteRange& sub_byte_range;
    };
    struct VisitorTag_Statement_SUB_BYTE_RANGE {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_SUB_BYTE_RANGE = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_SUB_BYTE_RANGE&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_SUB_BYTE_RANGE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& sub_byte_range = instance_name.sub_byte_range;
    struct Context_Statement_SUB_BYTE_RANGE_before : ebmcodegen::util::ContextBase<Context_Statement_SUB_BYTE_RANGE_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::SubByteRange& sub_byte_range;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_SUB_BYTE_RANGE_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_SUB_BYTE_RANGE_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_SUB_BYTE_RANGE_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_SUB_BYTE_RANGE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& sub_byte_range = instance_name.sub_byte_range;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_SUB_BYTE_RANGE_after : ebmcodegen::util::ContextBase<Context_Statement_SUB_BYTE_RANGE_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::SubByteRange& sub_byte_range;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_SUB_BYTE_RANGE_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_SUB_BYTE_RANGE_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_SUB_BYTE_RANGE_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_SUB_BYTE_RANGE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& sub_byte_range = instance_name.sub_byte_range;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_INIT_CHECK : ebmcodegen::util::ContextBase<Context_Statement_INIT_CHECK> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::InitCheck& init_check;
    };
    struct VisitorTag_Statement_INIT_CHECK {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_INIT_CHECK = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_INIT_CHECK&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_INIT_CHECK(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& init_check = instance_name.init_check;
    struct Context_Statement_INIT_CHECK_before : ebmcodegen::util::ContextBase<Context_Statement_INIT_CHECK_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::InitCheck& init_check;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_INIT_CHECK_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_INIT_CHECK_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_INIT_CHECK_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_INIT_CHECK_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& init_check = instance_name.init_check;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_INIT_CHECK_after : ebmcodegen::util::ContextBase<Context_Statement_INIT_CHECK_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::InitCheck& init_check;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_INIT_CHECK_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_INIT_CHECK_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_INIT_CHECK_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_INIT_CHECK_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& init_check = instance_name.init_check;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement_ENDIAN_VARIABLE : ebmcodegen::util::ContextBase<Context_Statement_ENDIAN_VARIABLE> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EndianVariable& endian_variable;
    };
    struct VisitorTag_Statement_ENDIAN_VARIABLE {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_ENDIAN_VARIABLE = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_ENDIAN_VARIABLE&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_ENDIAN_VARIABLE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& endian_variable = instance_name.endian_variable;
    struct Context_Statement_ENDIAN_VARIABLE_before : ebmcodegen::util::ContextBase<Context_Statement_ENDIAN_VARIABLE_before> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EndianVariable& endian_variable;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_ENDIAN_VARIABLE_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_ENDIAN_VARIABLE_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_ENDIAN_VARIABLE_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_ENDIAN_VARIABLE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& endian_variable = instance_name.endian_variable;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_ENDIAN_VARIABLE_after : ebmcodegen::util::ContextBase<Context_Statement_ENDIAN_VARIABLE_after> {
        BaseVisitor& visitor;
        ebm::StatementRef item_id;
        const ebm::StatementKind& kind;
        const ebm::EndianVariable& endian_variable;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_ENDIAN_VARIABLE_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_ENDIAN_VARIABLE_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_ENDIAN_VARIABLE_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_ENDIAN_VARIABLE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& endian_variable = instance_name.endian_variable;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Statement : ebmcodegen::util::ContextBase<Context_Statement> {
        BaseVisitor& visitor;
        const ebm::Statement& in;
        ebm::StatementRef alias_ref;
    };
    struct VisitorTag_Statement {};
    template<typename VisitorImpl>
    concept has_visitor_Statement = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& alias_ref = instance_name.alias_ref;
    struct Context_Statement_before : ebmcodegen::util::ContextBase<Context_Statement_before> {
        BaseVisitor& visitor;
        const ebm::Statement& in;
        ebm::StatementRef alias_ref;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Statement_before {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& alias_ref = instance_name.alias_ref;auto& main_logic = instance_name.main_logic;
    struct Context_Statement_after : ebmcodegen::util::ContextBase<Context_Statement_after> {
        BaseVisitor& visitor;
        const ebm::Statement& in;
        ebm::StatementRef alias_ref;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Statement_after {};
    template<typename VisitorImpl>
    concept has_visitor_Statement_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Statement_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_STATEMENT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& alias_ref = instance_name.alias_ref;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Block : ebmcodegen::util::ContextBase<Context_Block> {
        BaseVisitor& visitor;
        const ebm::Block& in;
    };
    struct VisitorTag_Block {};
    template<typename VisitorImpl>
    concept has_visitor_Block = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Block&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_BLOCK(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;
    struct Context_Block_before : ebmcodegen::util::ContextBase<Context_Block_before> {
        BaseVisitor& visitor;
        const ebm::Block& in;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Block_before {};
    template<typename VisitorImpl>
    concept has_visitor_Block_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Block_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_BLOCK_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& main_logic = instance_name.main_logic;
    struct Context_Block_after : ebmcodegen::util::ContextBase<Context_Block_after> {
        BaseVisitor& visitor;
        const ebm::Block& in;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Block_after {};
    template<typename VisitorImpl>
    concept has_visitor_Block_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Block_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_BLOCK_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_LITERAL_INT : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_INT> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Varint& int_value;
    };
    struct VisitorTag_Expression_LITERAL_INT {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_LITERAL_INT = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_LITERAL_INT&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_LITERAL_INT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& int_value = instance_name.int_value;
    struct Context_Expression_LITERAL_INT_before : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_INT_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Varint& int_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_LITERAL_INT_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_LITERAL_INT_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_LITERAL_INT_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_LITERAL_INT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& int_value = instance_name.int_value;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_LITERAL_INT_after : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_INT_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Varint& int_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_LITERAL_INT_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_LITERAL_INT_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_LITERAL_INT_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_LITERAL_INT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& int_value = instance_name.int_value;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_LITERAL_INT64 : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_INT64> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const std::uint64_t& int64_value;
    };
    struct VisitorTag_Expression_LITERAL_INT64 {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_LITERAL_INT64 = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_LITERAL_INT64&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_LITERAL_INT64(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& int64_value = instance_name.int64_value;
    struct Context_Expression_LITERAL_INT64_before : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_INT64_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const std::uint64_t& int64_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_LITERAL_INT64_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_LITERAL_INT64_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_LITERAL_INT64_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_LITERAL_INT64_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& int64_value = instance_name.int64_value;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_LITERAL_INT64_after : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_INT64_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const std::uint64_t& int64_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_LITERAL_INT64_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_LITERAL_INT64_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_LITERAL_INT64_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_LITERAL_INT64_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& int64_value = instance_name.int64_value;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_LITERAL_BOOL : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_BOOL> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const std::uint8_t& bool_value;
    };
    struct VisitorTag_Expression_LITERAL_BOOL {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_LITERAL_BOOL = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_LITERAL_BOOL&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_LITERAL_BOOL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& bool_value = instance_name.bool_value;
    struct Context_Expression_LITERAL_BOOL_before : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_BOOL_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const std::uint8_t& bool_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_LITERAL_BOOL_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_LITERAL_BOOL_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_LITERAL_BOOL_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_LITERAL_BOOL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& bool_value = instance_name.bool_value;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_LITERAL_BOOL_after : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_BOOL_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const std::uint8_t& bool_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_LITERAL_BOOL_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_LITERAL_BOOL_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_LITERAL_BOOL_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_LITERAL_BOOL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& bool_value = instance_name.bool_value;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_LITERAL_STRING : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_STRING> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StringRef& string_value;
    };
    struct VisitorTag_Expression_LITERAL_STRING {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_LITERAL_STRING = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_LITERAL_STRING&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_LITERAL_STRING(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& string_value = instance_name.string_value;
    struct Context_Expression_LITERAL_STRING_before : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_STRING_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StringRef& string_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_LITERAL_STRING_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_LITERAL_STRING_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_LITERAL_STRING_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_LITERAL_STRING_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& string_value = instance_name.string_value;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_LITERAL_STRING_after : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_STRING_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StringRef& string_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_LITERAL_STRING_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_LITERAL_STRING_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_LITERAL_STRING_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_LITERAL_STRING_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& string_value = instance_name.string_value;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_LITERAL_TYPE : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_TYPE> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::TypeRef& type_ref;
    };
    struct VisitorTag_Expression_LITERAL_TYPE {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_LITERAL_TYPE = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_LITERAL_TYPE&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_LITERAL_TYPE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& type_ref = instance_name.type_ref;
    struct Context_Expression_LITERAL_TYPE_before : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_TYPE_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::TypeRef& type_ref;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_LITERAL_TYPE_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_LITERAL_TYPE_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_LITERAL_TYPE_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_LITERAL_TYPE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& type_ref = instance_name.type_ref;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_LITERAL_TYPE_after : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_TYPE_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::TypeRef& type_ref;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_LITERAL_TYPE_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_LITERAL_TYPE_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_LITERAL_TYPE_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_LITERAL_TYPE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& type_ref = instance_name.type_ref;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_LITERAL_CHAR : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_CHAR> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Varint& char_value;
    };
    struct VisitorTag_Expression_LITERAL_CHAR {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_LITERAL_CHAR = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_LITERAL_CHAR&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_LITERAL_CHAR(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& char_value = instance_name.char_value;
    struct Context_Expression_LITERAL_CHAR_before : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_CHAR_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Varint& char_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_LITERAL_CHAR_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_LITERAL_CHAR_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_LITERAL_CHAR_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_LITERAL_CHAR_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& char_value = instance_name.char_value;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_LITERAL_CHAR_after : ebmcodegen::util::ContextBase<Context_Expression_LITERAL_CHAR_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Varint& char_value;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_LITERAL_CHAR_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_LITERAL_CHAR_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_LITERAL_CHAR_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_LITERAL_CHAR_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& char_value = instance_name.char_value;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_IDENTIFIER : ebmcodegen::util::ContextBase<Context_Expression_IDENTIFIER> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& id;
    };
    struct VisitorTag_Expression_IDENTIFIER {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_IDENTIFIER = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_IDENTIFIER&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_IDENTIFIER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& id = instance_name.id;
    struct Context_Expression_IDENTIFIER_before : ebmcodegen::util::ContextBase<Context_Expression_IDENTIFIER_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& id;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_IDENTIFIER_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_IDENTIFIER_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_IDENTIFIER_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_IDENTIFIER_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& id = instance_name.id;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_IDENTIFIER_after : ebmcodegen::util::ContextBase<Context_Expression_IDENTIFIER_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& id;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_IDENTIFIER_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_IDENTIFIER_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_IDENTIFIER_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_IDENTIFIER_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& id = instance_name.id;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_BINARY_OP : ebmcodegen::util::ContextBase<Context_Expression_BINARY_OP> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::BinaryOp& bop;
        const ebm::ExpressionRef& left;
        const ebm::ExpressionRef& right;
    };
    struct VisitorTag_Expression_BINARY_OP {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_BINARY_OP = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_BINARY_OP&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_BINARY_OP(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& bop = instance_name.bop;auto& left = instance_name.left;auto& right = instance_name.right;
    struct Context_Expression_BINARY_OP_before : ebmcodegen::util::ContextBase<Context_Expression_BINARY_OP_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::BinaryOp& bop;
        const ebm::ExpressionRef& left;
        const ebm::ExpressionRef& right;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_BINARY_OP_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_BINARY_OP_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_BINARY_OP_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_BINARY_OP_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& bop = instance_name.bop;auto& left = instance_name.left;auto& right = instance_name.right;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_BINARY_OP_after : ebmcodegen::util::ContextBase<Context_Expression_BINARY_OP_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::BinaryOp& bop;
        const ebm::ExpressionRef& left;
        const ebm::ExpressionRef& right;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_BINARY_OP_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_BINARY_OP_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_BINARY_OP_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_BINARY_OP_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& bop = instance_name.bop;auto& left = instance_name.left;auto& right = instance_name.right;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_UNARY_OP : ebmcodegen::util::ContextBase<Context_Expression_UNARY_OP> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& operand;
        const ebm::UnaryOp& uop;
    };
    struct VisitorTag_Expression_UNARY_OP {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_UNARY_OP = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_UNARY_OP&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_UNARY_OP(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& operand = instance_name.operand;auto& uop = instance_name.uop;
    struct Context_Expression_UNARY_OP_before : ebmcodegen::util::ContextBase<Context_Expression_UNARY_OP_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& operand;
        const ebm::UnaryOp& uop;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_UNARY_OP_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_UNARY_OP_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_UNARY_OP_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_UNARY_OP_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& operand = instance_name.operand;auto& uop = instance_name.uop;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_UNARY_OP_after : ebmcodegen::util::ContextBase<Context_Expression_UNARY_OP_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& operand;
        const ebm::UnaryOp& uop;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_UNARY_OP_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_UNARY_OP_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_UNARY_OP_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_UNARY_OP_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& operand = instance_name.operand;auto& uop = instance_name.uop;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_CALL : ebmcodegen::util::ContextBase<Context_Expression_CALL> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::CallDesc& call_desc;
    };
    struct VisitorTag_Expression_CALL {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_CALL = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_CALL&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_CALL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& call_desc = instance_name.call_desc;
    struct Context_Expression_CALL_before : ebmcodegen::util::ContextBase<Context_Expression_CALL_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::CallDesc& call_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_CALL_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_CALL_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_CALL_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_CALL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& call_desc = instance_name.call_desc;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_CALL_after : ebmcodegen::util::ContextBase<Context_Expression_CALL_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::CallDesc& call_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_CALL_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_CALL_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_CALL_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_CALL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& call_desc = instance_name.call_desc;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_INDEX_ACCESS : ebmcodegen::util::ContextBase<Context_Expression_INDEX_ACCESS> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& base;
        const ebm::ExpressionRef& index;
    };
    struct VisitorTag_Expression_INDEX_ACCESS {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_INDEX_ACCESS = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_INDEX_ACCESS&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_INDEX_ACCESS(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& base = instance_name.base;auto& index = instance_name.index;
    struct Context_Expression_INDEX_ACCESS_before : ebmcodegen::util::ContextBase<Context_Expression_INDEX_ACCESS_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& base;
        const ebm::ExpressionRef& index;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_INDEX_ACCESS_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_INDEX_ACCESS_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_INDEX_ACCESS_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_INDEX_ACCESS_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& base = instance_name.base;auto& index = instance_name.index;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_INDEX_ACCESS_after : ebmcodegen::util::ContextBase<Context_Expression_INDEX_ACCESS_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& base;
        const ebm::ExpressionRef& index;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_INDEX_ACCESS_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_INDEX_ACCESS_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_INDEX_ACCESS_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_INDEX_ACCESS_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& base = instance_name.base;auto& index = instance_name.index;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_MEMBER_ACCESS : ebmcodegen::util::ContextBase<Context_Expression_MEMBER_ACCESS> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& base;
        const ebm::ExpressionRef& member;
    };
    struct VisitorTag_Expression_MEMBER_ACCESS {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_MEMBER_ACCESS = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_MEMBER_ACCESS&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_MEMBER_ACCESS(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& base = instance_name.base;auto& member = instance_name.member;
    struct Context_Expression_MEMBER_ACCESS_before : ebmcodegen::util::ContextBase<Context_Expression_MEMBER_ACCESS_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& base;
        const ebm::ExpressionRef& member;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_MEMBER_ACCESS_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_MEMBER_ACCESS_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_MEMBER_ACCESS_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_MEMBER_ACCESS_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& base = instance_name.base;auto& member = instance_name.member;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_MEMBER_ACCESS_after : ebmcodegen::util::ContextBase<Context_Expression_MEMBER_ACCESS_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& base;
        const ebm::ExpressionRef& member;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_MEMBER_ACCESS_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_MEMBER_ACCESS_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_MEMBER_ACCESS_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_MEMBER_ACCESS_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& base = instance_name.base;auto& member = instance_name.member;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_ENUM_MEMBER : ebmcodegen::util::ContextBase<Context_Expression_ENUM_MEMBER> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& enum_decl;
        const ebm::ExpressionRef& member;
    };
    struct VisitorTag_Expression_ENUM_MEMBER {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_ENUM_MEMBER = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_ENUM_MEMBER&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_ENUM_MEMBER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& enum_decl = instance_name.enum_decl;auto& member = instance_name.member;
    struct Context_Expression_ENUM_MEMBER_before : ebmcodegen::util::ContextBase<Context_Expression_ENUM_MEMBER_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& enum_decl;
        const ebm::ExpressionRef& member;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_ENUM_MEMBER_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_ENUM_MEMBER_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_ENUM_MEMBER_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_ENUM_MEMBER_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& enum_decl = instance_name.enum_decl;auto& member = instance_name.member;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_ENUM_MEMBER_after : ebmcodegen::util::ContextBase<Context_Expression_ENUM_MEMBER_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& enum_decl;
        const ebm::ExpressionRef& member;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_ENUM_MEMBER_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_ENUM_MEMBER_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_ENUM_MEMBER_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_ENUM_MEMBER_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& enum_decl = instance_name.enum_decl;auto& member = instance_name.member;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_TYPE_CAST : ebmcodegen::util::ContextBase<Context_Expression_TYPE_CAST> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::CastType& cast_kind;
        const ebm::TypeRef& from_type;
        const ebm::ExpressionRef& source_expr;
    };
    struct VisitorTag_Expression_TYPE_CAST {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_TYPE_CAST = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_TYPE_CAST&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_TYPE_CAST(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& cast_kind = instance_name.cast_kind;auto& from_type = instance_name.from_type;auto& source_expr = instance_name.source_expr;
    struct Context_Expression_TYPE_CAST_before : ebmcodegen::util::ContextBase<Context_Expression_TYPE_CAST_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::CastType& cast_kind;
        const ebm::TypeRef& from_type;
        const ebm::ExpressionRef& source_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_TYPE_CAST_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_TYPE_CAST_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_TYPE_CAST_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_TYPE_CAST_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& cast_kind = instance_name.cast_kind;auto& from_type = instance_name.from_type;auto& source_expr = instance_name.source_expr;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_TYPE_CAST_after : ebmcodegen::util::ContextBase<Context_Expression_TYPE_CAST_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::CastType& cast_kind;
        const ebm::TypeRef& from_type;
        const ebm::ExpressionRef& source_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_TYPE_CAST_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_TYPE_CAST_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_TYPE_CAST_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_TYPE_CAST_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& cast_kind = instance_name.cast_kind;auto& from_type = instance_name.from_type;auto& source_expr = instance_name.source_expr;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_RANGE : ebmcodegen::util::ContextBase<Context_Expression_RANGE> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& end;
        const ebm::ExpressionRef& start;
    };
    struct VisitorTag_Expression_RANGE {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_RANGE = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_RANGE&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_RANGE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& end = instance_name.end;auto& start = instance_name.start;
    struct Context_Expression_RANGE_before : ebmcodegen::util::ContextBase<Context_Expression_RANGE_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& end;
        const ebm::ExpressionRef& start;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_RANGE_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_RANGE_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_RANGE_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_RANGE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& end = instance_name.end;auto& start = instance_name.start;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_RANGE_after : ebmcodegen::util::ContextBase<Context_Expression_RANGE_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& end;
        const ebm::ExpressionRef& start;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_RANGE_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_RANGE_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_RANGE_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_RANGE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& end = instance_name.end;auto& start = instance_name.start;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_DEFAULT_VALUE : ebmcodegen::util::ContextBase<Context_Expression_DEFAULT_VALUE> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
    };
    struct VisitorTag_Expression_DEFAULT_VALUE {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_DEFAULT_VALUE = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_DEFAULT_VALUE&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_DEFAULT_VALUE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;
    struct Context_Expression_DEFAULT_VALUE_before : ebmcodegen::util::ContextBase<Context_Expression_DEFAULT_VALUE_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_DEFAULT_VALUE_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_DEFAULT_VALUE_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_DEFAULT_VALUE_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_DEFAULT_VALUE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_DEFAULT_VALUE_after : ebmcodegen::util::ContextBase<Context_Expression_DEFAULT_VALUE_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_DEFAULT_VALUE_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_DEFAULT_VALUE_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_DEFAULT_VALUE_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_DEFAULT_VALUE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_IS_LITTLE_ENDIAN : ebmcodegen::util::ContextBase<Context_Expression_IS_LITTLE_ENDIAN> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& endian_expr;
    };
    struct VisitorTag_Expression_IS_LITTLE_ENDIAN {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_IS_LITTLE_ENDIAN = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_IS_LITTLE_ENDIAN&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_IS_LITTLE_ENDIAN(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& endian_expr = instance_name.endian_expr;
    struct Context_Expression_IS_LITTLE_ENDIAN_before : ebmcodegen::util::ContextBase<Context_Expression_IS_LITTLE_ENDIAN_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& endian_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_IS_LITTLE_ENDIAN_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_IS_LITTLE_ENDIAN_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_IS_LITTLE_ENDIAN_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_IS_LITTLE_ENDIAN_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& endian_expr = instance_name.endian_expr;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_IS_LITTLE_ENDIAN_after : ebmcodegen::util::ContextBase<Context_Expression_IS_LITTLE_ENDIAN_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& endian_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_IS_LITTLE_ENDIAN_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_IS_LITTLE_ENDIAN_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_IS_LITTLE_ENDIAN_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_IS_LITTLE_ENDIAN_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& endian_expr = instance_name.endian_expr;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_GET_STREAM_OFFSET : ebmcodegen::util::ContextBase<Context_Expression_GET_STREAM_OFFSET> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StreamType& stream_type;
        const ebm::SizeUnit& unit;
    };
    struct VisitorTag_Expression_GET_STREAM_OFFSET {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_GET_STREAM_OFFSET = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_GET_STREAM_OFFSET&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_GET_STREAM_OFFSET(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& stream_type = instance_name.stream_type;auto& unit = instance_name.unit;
    struct Context_Expression_GET_STREAM_OFFSET_before : ebmcodegen::util::ContextBase<Context_Expression_GET_STREAM_OFFSET_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StreamType& stream_type;
        const ebm::SizeUnit& unit;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_GET_STREAM_OFFSET_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_GET_STREAM_OFFSET_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_GET_STREAM_OFFSET_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_GET_STREAM_OFFSET_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& stream_type = instance_name.stream_type;auto& unit = instance_name.unit;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_GET_STREAM_OFFSET_after : ebmcodegen::util::ContextBase<Context_Expression_GET_STREAM_OFFSET_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StreamType& stream_type;
        const ebm::SizeUnit& unit;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_GET_STREAM_OFFSET_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_GET_STREAM_OFFSET_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_GET_STREAM_OFFSET_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_GET_STREAM_OFFSET_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& stream_type = instance_name.stream_type;auto& unit = instance_name.unit;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_GET_REMAINING_BYTES : ebmcodegen::util::ContextBase<Context_Expression_GET_REMAINING_BYTES> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StreamType& stream_type;
    };
    struct VisitorTag_Expression_GET_REMAINING_BYTES {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_GET_REMAINING_BYTES = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_GET_REMAINING_BYTES&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_GET_REMAINING_BYTES(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& stream_type = instance_name.stream_type;
    struct Context_Expression_GET_REMAINING_BYTES_before : ebmcodegen::util::ContextBase<Context_Expression_GET_REMAINING_BYTES_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StreamType& stream_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_GET_REMAINING_BYTES_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_GET_REMAINING_BYTES_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_GET_REMAINING_BYTES_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_GET_REMAINING_BYTES_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& stream_type = instance_name.stream_type;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_GET_REMAINING_BYTES_after : ebmcodegen::util::ContextBase<Context_Expression_GET_REMAINING_BYTES_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StreamType& stream_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_GET_REMAINING_BYTES_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_GET_REMAINING_BYTES_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_GET_REMAINING_BYTES_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_GET_REMAINING_BYTES_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& stream_type = instance_name.stream_type;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_CAN_READ_STREAM : ebmcodegen::util::ContextBase<Context_Expression_CAN_READ_STREAM> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_ref;
        const ebm::Size& num_bytes;
        const ebm::StreamType& stream_type;
    };
    struct VisitorTag_Expression_CAN_READ_STREAM {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_CAN_READ_STREAM = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_CAN_READ_STREAM&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_CAN_READ_STREAM(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& io_ref = instance_name.io_ref;auto& num_bytes = instance_name.num_bytes;auto& stream_type = instance_name.stream_type;
    struct Context_Expression_CAN_READ_STREAM_before : ebmcodegen::util::ContextBase<Context_Expression_CAN_READ_STREAM_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_ref;
        const ebm::Size& num_bytes;
        const ebm::StreamType& stream_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_CAN_READ_STREAM_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_CAN_READ_STREAM_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_CAN_READ_STREAM_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_CAN_READ_STREAM_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& io_ref = instance_name.io_ref;auto& num_bytes = instance_name.num_bytes;auto& stream_type = instance_name.stream_type;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_CAN_READ_STREAM_after : ebmcodegen::util::ContextBase<Context_Expression_CAN_READ_STREAM_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_ref;
        const ebm::Size& num_bytes;
        const ebm::StreamType& stream_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_CAN_READ_STREAM_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_CAN_READ_STREAM_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_CAN_READ_STREAM_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_CAN_READ_STREAM_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& io_ref = instance_name.io_ref;auto& num_bytes = instance_name.num_bytes;auto& stream_type = instance_name.stream_type;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_ARRAY_SIZE : ebmcodegen::util::ContextBase<Context_Expression_ARRAY_SIZE> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& array_expr;
    };
    struct VisitorTag_Expression_ARRAY_SIZE {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_ARRAY_SIZE = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_ARRAY_SIZE&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_ARRAY_SIZE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& array_expr = instance_name.array_expr;
    struct Context_Expression_ARRAY_SIZE_before : ebmcodegen::util::ContextBase<Context_Expression_ARRAY_SIZE_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& array_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_ARRAY_SIZE_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_ARRAY_SIZE_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_ARRAY_SIZE_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_ARRAY_SIZE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& array_expr = instance_name.array_expr;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_ARRAY_SIZE_after : ebmcodegen::util::ContextBase<Context_Expression_ARRAY_SIZE_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& array_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_ARRAY_SIZE_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_ARRAY_SIZE_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_ARRAY_SIZE_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_ARRAY_SIZE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& array_expr = instance_name.array_expr;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_ENUM_IS_DEFINED : ebmcodegen::util::ContextBase<Context_Expression_ENUM_IS_DEFINED> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
    };
    struct VisitorTag_Expression_ENUM_IS_DEFINED {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_ENUM_IS_DEFINED = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_ENUM_IS_DEFINED&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_ENUM_IS_DEFINED(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& lowered_expr = instance_name.lowered_expr;auto& target_expr = instance_name.target_expr;
    struct Context_Expression_ENUM_IS_DEFINED_before : ebmcodegen::util::ContextBase<Context_Expression_ENUM_IS_DEFINED_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_ENUM_IS_DEFINED_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_ENUM_IS_DEFINED_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_ENUM_IS_DEFINED_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_ENUM_IS_DEFINED_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& lowered_expr = instance_name.lowered_expr;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_ENUM_IS_DEFINED_after : ebmcodegen::util::ContextBase<Context_Expression_ENUM_IS_DEFINED_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_ENUM_IS_DEFINED_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_ENUM_IS_DEFINED_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_ENUM_IS_DEFINED_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_ENUM_IS_DEFINED_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& lowered_expr = instance_name.lowered_expr;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_IS_ERROR : ebmcodegen::util::ContextBase<Context_Expression_IS_ERROR> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
    };
    struct VisitorTag_Expression_IS_ERROR {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_IS_ERROR = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_IS_ERROR&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_IS_ERROR(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& target_expr = instance_name.target_expr;
    struct Context_Expression_IS_ERROR_before : ebmcodegen::util::ContextBase<Context_Expression_IS_ERROR_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_IS_ERROR_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_IS_ERROR_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_IS_ERROR_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_IS_ERROR_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_IS_ERROR_after : ebmcodegen::util::ContextBase<Context_Expression_IS_ERROR_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_IS_ERROR_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_IS_ERROR_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_IS_ERROR_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_IS_ERROR_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_MAX_VALUE : ebmcodegen::util::ContextBase<Context_Expression_MAX_VALUE> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
    };
    struct VisitorTag_Expression_MAX_VALUE {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_MAX_VALUE = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_MAX_VALUE&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_MAX_VALUE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& lowered_expr = instance_name.lowered_expr;
    struct Context_Expression_MAX_VALUE_before : ebmcodegen::util::ContextBase<Context_Expression_MAX_VALUE_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_MAX_VALUE_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_MAX_VALUE_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_MAX_VALUE_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_MAX_VALUE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& lowered_expr = instance_name.lowered_expr;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_MAX_VALUE_after : ebmcodegen::util::ContextBase<Context_Expression_MAX_VALUE_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_MAX_VALUE_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_MAX_VALUE_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_MAX_VALUE_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_MAX_VALUE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& lowered_expr = instance_name.lowered_expr;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_READ_DATA : ebmcodegen::util::ContextBase<Context_Expression_READ_DATA> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_statement;
        const ebm::StatementRef& target_stmt;
    };
    struct VisitorTag_Expression_READ_DATA {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_READ_DATA = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_READ_DATA&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_READ_DATA(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& io_statement = instance_name.io_statement;auto& target_stmt = instance_name.target_stmt;
    struct Context_Expression_READ_DATA_before : ebmcodegen::util::ContextBase<Context_Expression_READ_DATA_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_statement;
        const ebm::StatementRef& target_stmt;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_READ_DATA_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_READ_DATA_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_READ_DATA_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_READ_DATA_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& io_statement = instance_name.io_statement;auto& target_stmt = instance_name.target_stmt;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_READ_DATA_after : ebmcodegen::util::ContextBase<Context_Expression_READ_DATA_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_statement;
        const ebm::StatementRef& target_stmt;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_READ_DATA_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_READ_DATA_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_READ_DATA_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_READ_DATA_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& io_statement = instance_name.io_statement;auto& target_stmt = instance_name.target_stmt;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_WRITE_DATA : ebmcodegen::util::ContextBase<Context_Expression_WRITE_DATA> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_statement;
        const ebm::ExpressionRef& target_expr;
    };
    struct VisitorTag_Expression_WRITE_DATA {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_WRITE_DATA = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_WRITE_DATA&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_WRITE_DATA(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& io_statement = instance_name.io_statement;auto& target_expr = instance_name.target_expr;
    struct Context_Expression_WRITE_DATA_before : ebmcodegen::util::ContextBase<Context_Expression_WRITE_DATA_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_statement;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_WRITE_DATA_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_WRITE_DATA_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_WRITE_DATA_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_WRITE_DATA_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& io_statement = instance_name.io_statement;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_WRITE_DATA_after : ebmcodegen::util::ContextBase<Context_Expression_WRITE_DATA_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& io_statement;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_WRITE_DATA_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_WRITE_DATA_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_WRITE_DATA_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_WRITE_DATA_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& io_statement = instance_name.io_statement;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_CONDITIONAL_STATEMENT : ebmcodegen::util::ContextBase<Context_Expression_CONDITIONAL_STATEMENT> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& conditional_stmt;
        const ebm::StatementRef& target_stmt;
    };
    struct VisitorTag_Expression_CONDITIONAL_STATEMENT {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_CONDITIONAL_STATEMENT = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_CONDITIONAL_STATEMENT&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_CONDITIONAL_STATEMENT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& conditional_stmt = instance_name.conditional_stmt;auto& target_stmt = instance_name.target_stmt;
    struct Context_Expression_CONDITIONAL_STATEMENT_before : ebmcodegen::util::ContextBase<Context_Expression_CONDITIONAL_STATEMENT_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& conditional_stmt;
        const ebm::StatementRef& target_stmt;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_CONDITIONAL_STATEMENT_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_CONDITIONAL_STATEMENT_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_CONDITIONAL_STATEMENT_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_CONDITIONAL_STATEMENT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& conditional_stmt = instance_name.conditional_stmt;auto& target_stmt = instance_name.target_stmt;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_CONDITIONAL_STATEMENT_after : ebmcodegen::util::ContextBase<Context_Expression_CONDITIONAL_STATEMENT_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& conditional_stmt;
        const ebm::StatementRef& target_stmt;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_CONDITIONAL_STATEMENT_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_CONDITIONAL_STATEMENT_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_CONDITIONAL_STATEMENT_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_CONDITIONAL_STATEMENT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& conditional_stmt = instance_name.conditional_stmt;auto& target_stmt = instance_name.target_stmt;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_CONDITIONAL : ebmcodegen::util::ContextBase<Context_Expression_CONDITIONAL> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& condition;
        const ebm::ExpressionRef& else_;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& then;
    };
    struct VisitorTag_Expression_CONDITIONAL {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_CONDITIONAL = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_CONDITIONAL&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_CONDITIONAL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& condition = instance_name.condition;auto& else_ = instance_name.else_;auto& lowered_expr = instance_name.lowered_expr;auto& then = instance_name.then;
    struct Context_Expression_CONDITIONAL_before : ebmcodegen::util::ContextBase<Context_Expression_CONDITIONAL_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& condition;
        const ebm::ExpressionRef& else_;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& then;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_CONDITIONAL_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_CONDITIONAL_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_CONDITIONAL_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_CONDITIONAL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& condition = instance_name.condition;auto& else_ = instance_name.else_;auto& lowered_expr = instance_name.lowered_expr;auto& then = instance_name.then;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_CONDITIONAL_after : ebmcodegen::util::ContextBase<Context_Expression_CONDITIONAL_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& condition;
        const ebm::ExpressionRef& else_;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& then;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_CONDITIONAL_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_CONDITIONAL_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_CONDITIONAL_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_CONDITIONAL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& condition = instance_name.condition;auto& else_ = instance_name.else_;auto& lowered_expr = instance_name.lowered_expr;auto& then = instance_name.then;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_AVAILABLE : ebmcodegen::util::ContextBase<Context_Expression_AVAILABLE> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
    };
    struct VisitorTag_Expression_AVAILABLE {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_AVAILABLE = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_AVAILABLE&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_AVAILABLE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& lowered_expr = instance_name.lowered_expr;auto& target_expr = instance_name.target_expr;
    struct Context_Expression_AVAILABLE_before : ebmcodegen::util::ContextBase<Context_Expression_AVAILABLE_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_AVAILABLE_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_AVAILABLE_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_AVAILABLE_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_AVAILABLE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& lowered_expr = instance_name.lowered_expr;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_AVAILABLE_after : ebmcodegen::util::ContextBase<Context_Expression_AVAILABLE_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_AVAILABLE_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_AVAILABLE_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_AVAILABLE_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_AVAILABLE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& lowered_expr = instance_name.lowered_expr;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_SIZEOF : ebmcodegen::util::ContextBase<Context_Expression_SIZEOF> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
    };
    struct VisitorTag_Expression_SIZEOF {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_SIZEOF = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_SIZEOF&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_SIZEOF(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& lowered_expr = instance_name.lowered_expr;auto& target_expr = instance_name.target_expr;
    struct Context_Expression_SIZEOF_before : ebmcodegen::util::ContextBase<Context_Expression_SIZEOF_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_SIZEOF_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_SIZEOF_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_SIZEOF_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_SIZEOF_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& lowered_expr = instance_name.lowered_expr;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_SIZEOF_after : ebmcodegen::util::ContextBase<Context_Expression_SIZEOF_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::LoweredExpressionRef& lowered_expr;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_SIZEOF_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_SIZEOF_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_SIZEOF_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_SIZEOF_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& lowered_expr = instance_name.lowered_expr;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_SUB_RANGE_INIT : ebmcodegen::util::ContextBase<Context_Expression_SUB_RANGE_INIT> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& sub_range;
    };
    struct VisitorTag_Expression_SUB_RANGE_INIT {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_SUB_RANGE_INIT = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_SUB_RANGE_INIT&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_SUB_RANGE_INIT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& sub_range = instance_name.sub_range;
    struct Context_Expression_SUB_RANGE_INIT_before : ebmcodegen::util::ContextBase<Context_Expression_SUB_RANGE_INIT_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& sub_range;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_SUB_RANGE_INIT_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_SUB_RANGE_INIT_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_SUB_RANGE_INIT_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_SUB_RANGE_INIT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& sub_range = instance_name.sub_range;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_SUB_RANGE_INIT_after : ebmcodegen::util::ContextBase<Context_Expression_SUB_RANGE_INIT_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::StatementRef& sub_range;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_SUB_RANGE_INIT_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_SUB_RANGE_INIT_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_SUB_RANGE_INIT_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_SUB_RANGE_INIT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& sub_range = instance_name.sub_range;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_OR_COND : ebmcodegen::util::ContextBase<Context_Expression_OR_COND> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Expressions& or_cond;
    };
    struct VisitorTag_Expression_OR_COND {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_OR_COND = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_OR_COND&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_OR_COND(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& or_cond = instance_name.or_cond;
    struct Context_Expression_OR_COND_before : ebmcodegen::util::ContextBase<Context_Expression_OR_COND_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Expressions& or_cond;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_OR_COND_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_OR_COND_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_OR_COND_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_OR_COND_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& or_cond = instance_name.or_cond;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_OR_COND_after : ebmcodegen::util::ContextBase<Context_Expression_OR_COND_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::Expressions& or_cond;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_OR_COND_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_OR_COND_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_OR_COND_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_OR_COND_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& or_cond = instance_name.or_cond;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_ADDRESS_OF : ebmcodegen::util::ContextBase<Context_Expression_ADDRESS_OF> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
    };
    struct VisitorTag_Expression_ADDRESS_OF {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_ADDRESS_OF = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_ADDRESS_OF&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_ADDRESS_OF(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& target_expr = instance_name.target_expr;
    struct Context_Expression_ADDRESS_OF_before : ebmcodegen::util::ContextBase<Context_Expression_ADDRESS_OF_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_ADDRESS_OF_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_ADDRESS_OF_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_ADDRESS_OF_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_ADDRESS_OF_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_ADDRESS_OF_after : ebmcodegen::util::ContextBase<Context_Expression_ADDRESS_OF_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_ADDRESS_OF_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_ADDRESS_OF_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_ADDRESS_OF_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_ADDRESS_OF_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_OPTIONAL_OF : ebmcodegen::util::ContextBase<Context_Expression_OPTIONAL_OF> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
    };
    struct VisitorTag_Expression_OPTIONAL_OF {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_OPTIONAL_OF = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_OPTIONAL_OF&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_OPTIONAL_OF(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& target_expr = instance_name.target_expr;
    struct Context_Expression_OPTIONAL_OF_before : ebmcodegen::util::ContextBase<Context_Expression_OPTIONAL_OF_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_OPTIONAL_OF_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_OPTIONAL_OF_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_OPTIONAL_OF_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_OPTIONAL_OF_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_OPTIONAL_OF_after : ebmcodegen::util::ContextBase<Context_Expression_OPTIONAL_OF_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_OPTIONAL_OF_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_OPTIONAL_OF_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_OPTIONAL_OF_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_OPTIONAL_OF_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_SETTER_STATUS : ebmcodegen::util::ContextBase<Context_Expression_SETTER_STATUS> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::SetterStatus& setter_status;
    };
    struct VisitorTag_Expression_SETTER_STATUS {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_SETTER_STATUS = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_SETTER_STATUS&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_SETTER_STATUS(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& setter_status = instance_name.setter_status;
    struct Context_Expression_SETTER_STATUS_before : ebmcodegen::util::ContextBase<Context_Expression_SETTER_STATUS_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::SetterStatus& setter_status;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_SETTER_STATUS_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_SETTER_STATUS_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_SETTER_STATUS_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_SETTER_STATUS_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& setter_status = instance_name.setter_status;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_SETTER_STATUS_after : ebmcodegen::util::ContextBase<Context_Expression_SETTER_STATUS_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::SetterStatus& setter_status;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_SETTER_STATUS_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_SETTER_STATUS_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_SETTER_STATUS_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_SETTER_STATUS_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& setter_status = instance_name.setter_status;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_SELF : ebmcodegen::util::ContextBase<Context_Expression_SELF> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
    };
    struct VisitorTag_Expression_SELF {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_SELF = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_SELF&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_SELF(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;
    struct Context_Expression_SELF_before : ebmcodegen::util::ContextBase<Context_Expression_SELF_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_SELF_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_SELF_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_SELF_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_SELF_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_SELF_after : ebmcodegen::util::ContextBase<Context_Expression_SELF_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_SELF_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_SELF_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_SELF_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_SELF_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression_AS_ARG : ebmcodegen::util::ContextBase<Context_Expression_AS_ARG> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
    };
    struct VisitorTag_Expression_AS_ARG {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_AS_ARG = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_AS_ARG&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_AS_ARG(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& target_expr = instance_name.target_expr;
    struct Context_Expression_AS_ARG_before : ebmcodegen::util::ContextBase<Context_Expression_AS_ARG_before> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_AS_ARG_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_AS_ARG_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_AS_ARG_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_AS_ARG_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_AS_ARG_after : ebmcodegen::util::ContextBase<Context_Expression_AS_ARG_after> {
        BaseVisitor& visitor;
        ebm::ExpressionRef item_id;
        const ebm::TypeRef& type;
        const ebm::ExpressionKind& kind;
        const ebm::ExpressionRef& target_expr;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_AS_ARG_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_AS_ARG_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_AS_ARG_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_AS_ARG_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& type = instance_name.type;auto& kind = instance_name.kind;auto& target_expr = instance_name.target_expr;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expression : ebmcodegen::util::ContextBase<Context_Expression> {
        BaseVisitor& visitor;
        const ebm::Expression& in;
        ebm::ExpressionRef alias_ref;
    };
    struct VisitorTag_Expression {};
    template<typename VisitorImpl>
    concept has_visitor_Expression = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& alias_ref = instance_name.alias_ref;
    struct Context_Expression_before : ebmcodegen::util::ContextBase<Context_Expression_before> {
        BaseVisitor& visitor;
        const ebm::Expression& in;
        ebm::ExpressionRef alias_ref;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expression_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& alias_ref = instance_name.alias_ref;auto& main_logic = instance_name.main_logic;
    struct Context_Expression_after : ebmcodegen::util::ContextBase<Context_Expression_after> {
        BaseVisitor& visitor;
        const ebm::Expression& in;
        ebm::ExpressionRef alias_ref;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expression_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expression_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expression_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSION_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& alias_ref = instance_name.alias_ref;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Expressions : ebmcodegen::util::ContextBase<Context_Expressions> {
        BaseVisitor& visitor;
        const ebm::Expressions& in;
    };
    struct VisitorTag_Expressions {};
    template<typename VisitorImpl>
    concept has_visitor_Expressions = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expressions&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSIONS(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;
    struct Context_Expressions_before : ebmcodegen::util::ContextBase<Context_Expressions_before> {
        BaseVisitor& visitor;
        const ebm::Expressions& in;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Expressions_before {};
    template<typename VisitorImpl>
    concept has_visitor_Expressions_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expressions_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSIONS_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& main_logic = instance_name.main_logic;
    struct Context_Expressions_after : ebmcodegen::util::ContextBase<Context_Expressions_after> {
        BaseVisitor& visitor;
        const ebm::Expressions& in;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Expressions_after {};
    template<typename VisitorImpl>
    concept has_visitor_Expressions_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Expressions_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_EXPRESSIONS_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_INT : ebmcodegen::util::ContextBase<Context_Type_INT> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
    };
    struct VisitorTag_Type_INT {};
    template<typename VisitorImpl>
    concept has_visitor_Type_INT = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_INT&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_INT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& size = instance_name.size;
    struct Context_Type_INT_before : ebmcodegen::util::ContextBase<Context_Type_INT_before> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_INT_before {};
    template<typename VisitorImpl>
    concept has_visitor_Type_INT_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_INT_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_INT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& size = instance_name.size;auto& main_logic = instance_name.main_logic;
    struct Context_Type_INT_after : ebmcodegen::util::ContextBase<Context_Type_INT_after> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_INT_after {};
    template<typename VisitorImpl>
    concept has_visitor_Type_INT_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_INT_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_INT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& size = instance_name.size;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_UINT : ebmcodegen::util::ContextBase<Context_Type_UINT> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
    };
    struct VisitorTag_Type_UINT {};
    template<typename VisitorImpl>
    concept has_visitor_Type_UINT = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_UINT&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_UINT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& size = instance_name.size;
    struct Context_Type_UINT_before : ebmcodegen::util::ContextBase<Context_Type_UINT_before> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_UINT_before {};
    template<typename VisitorImpl>
    concept has_visitor_Type_UINT_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_UINT_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_UINT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& size = instance_name.size;auto& main_logic = instance_name.main_logic;
    struct Context_Type_UINT_after : ebmcodegen::util::ContextBase<Context_Type_UINT_after> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_UINT_after {};
    template<typename VisitorImpl>
    concept has_visitor_Type_UINT_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_UINT_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_UINT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& size = instance_name.size;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_USIZE : ebmcodegen::util::ContextBase<Context_Type_USIZE> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    struct VisitorTag_Type_USIZE {};
    template<typename VisitorImpl>
    concept has_visitor_Type_USIZE = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_USIZE&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_USIZE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;
    struct Context_Type_USIZE_before : ebmcodegen::util::ContextBase<Context_Type_USIZE_before> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_USIZE_before {};
    template<typename VisitorImpl>
    concept has_visitor_Type_USIZE_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_USIZE_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_USIZE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    struct Context_Type_USIZE_after : ebmcodegen::util::ContextBase<Context_Type_USIZE_after> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_USIZE_after {};
    template<typename VisitorImpl>
    concept has_visitor_Type_USIZE_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_USIZE_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_USIZE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_FLOAT : ebmcodegen::util::ContextBase<Context_Type_FLOAT> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
    };
    struct VisitorTag_Type_FLOAT {};
    template<typename VisitorImpl>
    concept has_visitor_Type_FLOAT = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_FLOAT&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_FLOAT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& size = instance_name.size;
    struct Context_Type_FLOAT_before : ebmcodegen::util::ContextBase<Context_Type_FLOAT_before> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_FLOAT_before {};
    template<typename VisitorImpl>
    concept has_visitor_Type_FLOAT_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_FLOAT_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_FLOAT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& size = instance_name.size;auto& main_logic = instance_name.main_logic;
    struct Context_Type_FLOAT_after : ebmcodegen::util::ContextBase<Context_Type_FLOAT_after> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::Varint& size;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_FLOAT_after {};
    template<typename VisitorImpl>
    concept has_visitor_Type_FLOAT_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_FLOAT_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_FLOAT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& size = instance_name.size;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_STRUCT : ebmcodegen::util::ContextBase<Context_Type_STRUCT> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::StatementRef& id;
    };
    struct VisitorTag_Type_STRUCT {};
    template<typename VisitorImpl>
    concept has_visitor_Type_STRUCT = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_STRUCT&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_STRUCT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& id = instance_name.id;
    struct Context_Type_STRUCT_before : ebmcodegen::util::ContextBase<Context_Type_STRUCT_before> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::StatementRef& id;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_STRUCT_before {};
    template<typename VisitorImpl>
    concept has_visitor_Type_STRUCT_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_STRUCT_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_STRUCT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& id = instance_name.id;auto& main_logic = instance_name.main_logic;
    struct Context_Type_STRUCT_after : ebmcodegen::util::ContextBase<Context_Type_STRUCT_after> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::StatementRef& id;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_STRUCT_after {};
    template<typename VisitorImpl>
    concept has_visitor_Type_STRUCT_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_STRUCT_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_STRUCT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& id = instance_name.id;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_RECURSIVE_STRUCT : ebmcodegen::util::ContextBase<Context_Type_RECURSIVE_STRUCT> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::StatementRef& id;
    };
    struct VisitorTag_Type_RECURSIVE_STRUCT {};
    template<typename VisitorImpl>
    concept has_visitor_Type_RECURSIVE_STRUCT = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_RECURSIVE_STRUCT&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_RECURSIVE_STRUCT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& id = instance_name.id;
    struct Context_Type_RECURSIVE_STRUCT_before : ebmcodegen::util::ContextBase<Context_Type_RECURSIVE_STRUCT_before> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::StatementRef& id;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_RECURSIVE_STRUCT_before {};
    template<typename VisitorImpl>
    concept has_visitor_Type_RECURSIVE_STRUCT_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_RECURSIVE_STRUCT_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_RECURSIVE_STRUCT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& id = instance_name.id;auto& main_logic = instance_name.main_logic;
    struct Context_Type_RECURSIVE_STRUCT_after : ebmcodegen::util::ContextBase<Context_Type_RECURSIVE_STRUCT_after> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::StatementRef& id;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_RECURSIVE_STRUCT_after {};
    template<typename VisitorImpl>
    concept has_visitor_Type_RECURSIVE_STRUCT_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_RECURSIVE_STRUCT_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_RECURSIVE_STRUCT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& id = instance_name.id;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_BOOL : ebmcodegen::util::ContextBase<Context_Type_BOOL> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    struct VisitorTag_Type_BOOL {};
    template<typename VisitorImpl>
    concept has_visitor_Type_BOOL = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_BOOL&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_BOOL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;
    struct Context_Type_BOOL_before : ebmcodegen::util::ContextBase<Context_Type_BOOL_before> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_BOOL_before {};
    template<typename VisitorImpl>
    concept has_visitor_Type_BOOL_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_BOOL_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_BOOL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    struct Context_Type_BOOL_after : ebmcodegen::util::ContextBase<Context_Type_BOOL_after> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_BOOL_after {};
    template<typename VisitorImpl>
    concept has_visitor_Type_BOOL_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_BOOL_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_BOOL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_VOID : ebmcodegen::util::ContextBase<Context_Type_VOID> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    struct VisitorTag_Type_VOID {};
    template<typename VisitorImpl>
    concept has_visitor_Type_VOID = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_VOID&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_VOID(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;
    struct Context_Type_VOID_before : ebmcodegen::util::ContextBase<Context_Type_VOID_before> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_VOID_before {};
    template<typename VisitorImpl>
    concept has_visitor_Type_VOID_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_VOID_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_VOID_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    struct Context_Type_VOID_after : ebmcodegen::util::ContextBase<Context_Type_VOID_after> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_VOID_after {};
    template<typename VisitorImpl>
    concept has_visitor_Type_VOID_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_VOID_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_VOID_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_META : ebmcodegen::util::ContextBase<Context_Type_META> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    struct VisitorTag_Type_META {};
    template<typename VisitorImpl>
    concept has_visitor_Type_META = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_META&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_META(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;
    struct Context_Type_META_before : ebmcodegen::util::ContextBase<Context_Type_META_before> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_META_before {};
    template<typename VisitorImpl>
    concept has_visitor_Type_META_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_META_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_META_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    struct Context_Type_META_after : ebmcodegen::util::ContextBase<Context_Type_META_after> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_META_after {};
    template<typename VisitorImpl>
    concept has_visitor_Type_META_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_META_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_META_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_ENUM : ebmcodegen::util::ContextBase<Context_Type_ENUM> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& base_type;
        const ebm::StatementRef& id;
    };
    struct VisitorTag_Type_ENUM {};
    template<typename VisitorImpl>
    concept has_visitor_Type_ENUM = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_ENUM&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_ENUM(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& base_type = instance_name.base_type;auto& id = instance_name.id;
    struct Context_Type_ENUM_before : ebmcodegen::util::ContextBase<Context_Type_ENUM_before> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& base_type;
        const ebm::StatementRef& id;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_ENUM_before {};
    template<typename VisitorImpl>
    concept has_visitor_Type_ENUM_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_ENUM_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_ENUM_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& base_type = instance_name.base_type;auto& id = instance_name.id;auto& main_logic = instance_name.main_logic;
    struct Context_Type_ENUM_after : ebmcodegen::util::ContextBase<Context_Type_ENUM_after> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& base_type;
        const ebm::StatementRef& id;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_ENUM_after {};
    template<typename VisitorImpl>
    concept has_visitor_Type_ENUM_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_ENUM_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_ENUM_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& base_type = instance_name.base_type;auto& id = instance_name.id;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_ARRAY : ebmcodegen::util::ContextBase<Context_Type_ARRAY> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& element_type;
        const ebm::Varint& length;
    };
    struct VisitorTag_Type_ARRAY {};
    template<typename VisitorImpl>
    concept has_visitor_Type_ARRAY = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_ARRAY&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_ARRAY(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& element_type = instance_name.element_type;auto& length = instance_name.length;
    struct Context_Type_ARRAY_before : ebmcodegen::util::ContextBase<Context_Type_ARRAY_before> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& element_type;
        const ebm::Varint& length;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_ARRAY_before {};
    template<typename VisitorImpl>
    concept has_visitor_Type_ARRAY_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_ARRAY_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_ARRAY_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& element_type = instance_name.element_type;auto& length = instance_name.length;auto& main_logic = instance_name.main_logic;
    struct Context_Type_ARRAY_after : ebmcodegen::util::ContextBase<Context_Type_ARRAY_after> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& element_type;
        const ebm::Varint& length;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_ARRAY_after {};
    template<typename VisitorImpl>
    concept has_visitor_Type_ARRAY_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_ARRAY_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_ARRAY_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& element_type = instance_name.element_type;auto& length = instance_name.length;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_VECTOR : ebmcodegen::util::ContextBase<Context_Type_VECTOR> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& element_type;
    };
    struct VisitorTag_Type_VECTOR {};
    template<typename VisitorImpl>
    concept has_visitor_Type_VECTOR = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_VECTOR&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_VECTOR(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& element_type = instance_name.element_type;
    struct Context_Type_VECTOR_before : ebmcodegen::util::ContextBase<Context_Type_VECTOR_before> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& element_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_VECTOR_before {};
    template<typename VisitorImpl>
    concept has_visitor_Type_VECTOR_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_VECTOR_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_VECTOR_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& element_type = instance_name.element_type;auto& main_logic = instance_name.main_logic;
    struct Context_Type_VECTOR_after : ebmcodegen::util::ContextBase<Context_Type_VECTOR_after> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& element_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_VECTOR_after {};
    template<typename VisitorImpl>
    concept has_visitor_Type_VECTOR_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_VECTOR_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_VECTOR_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& element_type = instance_name.element_type;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_VARIANT : ebmcodegen::util::ContextBase<Context_Type_VARIANT> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& common_type;
        const ebm::Types& members;
        const ebm::StatementRef& related_field;
    };
    struct VisitorTag_Type_VARIANT {};
    template<typename VisitorImpl>
    concept has_visitor_Type_VARIANT = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_VARIANT&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_VARIANT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& common_type = instance_name.common_type;auto& members = instance_name.members;auto& related_field = instance_name.related_field;
    struct Context_Type_VARIANT_before : ebmcodegen::util::ContextBase<Context_Type_VARIANT_before> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& common_type;
        const ebm::Types& members;
        const ebm::StatementRef& related_field;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_VARIANT_before {};
    template<typename VisitorImpl>
    concept has_visitor_Type_VARIANT_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_VARIANT_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_VARIANT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& common_type = instance_name.common_type;auto& members = instance_name.members;auto& related_field = instance_name.related_field;auto& main_logic = instance_name.main_logic;
    struct Context_Type_VARIANT_after : ebmcodegen::util::ContextBase<Context_Type_VARIANT_after> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& common_type;
        const ebm::Types& members;
        const ebm::StatementRef& related_field;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_VARIANT_after {};
    template<typename VisitorImpl>
    concept has_visitor_Type_VARIANT_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_VARIANT_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_VARIANT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& common_type = instance_name.common_type;auto& members = instance_name.members;auto& related_field = instance_name.related_field;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_RANGE : ebmcodegen::util::ContextBase<Context_Type_RANGE> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& base_type;
    };
    struct VisitorTag_Type_RANGE {};
    template<typename VisitorImpl>
    concept has_visitor_Type_RANGE = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_RANGE&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_RANGE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& base_type = instance_name.base_type;
    struct Context_Type_RANGE_before : ebmcodegen::util::ContextBase<Context_Type_RANGE_before> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& base_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_RANGE_before {};
    template<typename VisitorImpl>
    concept has_visitor_Type_RANGE_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_RANGE_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_RANGE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& base_type = instance_name.base_type;auto& main_logic = instance_name.main_logic;
    struct Context_Type_RANGE_after : ebmcodegen::util::ContextBase<Context_Type_RANGE_after> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& base_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_RANGE_after {};
    template<typename VisitorImpl>
    concept has_visitor_Type_RANGE_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_RANGE_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_RANGE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& base_type = instance_name.base_type;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_ENCODER_RETURN : ebmcodegen::util::ContextBase<Context_Type_ENCODER_RETURN> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    struct VisitorTag_Type_ENCODER_RETURN {};
    template<typename VisitorImpl>
    concept has_visitor_Type_ENCODER_RETURN = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_ENCODER_RETURN&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_ENCODER_RETURN(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;
    struct Context_Type_ENCODER_RETURN_before : ebmcodegen::util::ContextBase<Context_Type_ENCODER_RETURN_before> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_ENCODER_RETURN_before {};
    template<typename VisitorImpl>
    concept has_visitor_Type_ENCODER_RETURN_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_ENCODER_RETURN_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_ENCODER_RETURN_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    struct Context_Type_ENCODER_RETURN_after : ebmcodegen::util::ContextBase<Context_Type_ENCODER_RETURN_after> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_ENCODER_RETURN_after {};
    template<typename VisitorImpl>
    concept has_visitor_Type_ENCODER_RETURN_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_ENCODER_RETURN_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_ENCODER_RETURN_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_DECODER_RETURN : ebmcodegen::util::ContextBase<Context_Type_DECODER_RETURN> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    struct VisitorTag_Type_DECODER_RETURN {};
    template<typename VisitorImpl>
    concept has_visitor_Type_DECODER_RETURN = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_DECODER_RETURN&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_DECODER_RETURN(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;
    struct Context_Type_DECODER_RETURN_before : ebmcodegen::util::ContextBase<Context_Type_DECODER_RETURN_before> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_DECODER_RETURN_before {};
    template<typename VisitorImpl>
    concept has_visitor_Type_DECODER_RETURN_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_DECODER_RETURN_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_DECODER_RETURN_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    struct Context_Type_DECODER_RETURN_after : ebmcodegen::util::ContextBase<Context_Type_DECODER_RETURN_after> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_DECODER_RETURN_after {};
    template<typename VisitorImpl>
    concept has_visitor_Type_DECODER_RETURN_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_DECODER_RETURN_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_DECODER_RETURN_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_ENCODER_INPUT : ebmcodegen::util::ContextBase<Context_Type_ENCODER_INPUT> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    struct VisitorTag_Type_ENCODER_INPUT {};
    template<typename VisitorImpl>
    concept has_visitor_Type_ENCODER_INPUT = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_ENCODER_INPUT&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_ENCODER_INPUT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;
    struct Context_Type_ENCODER_INPUT_before : ebmcodegen::util::ContextBase<Context_Type_ENCODER_INPUT_before> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_ENCODER_INPUT_before {};
    template<typename VisitorImpl>
    concept has_visitor_Type_ENCODER_INPUT_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_ENCODER_INPUT_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_ENCODER_INPUT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    struct Context_Type_ENCODER_INPUT_after : ebmcodegen::util::ContextBase<Context_Type_ENCODER_INPUT_after> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_ENCODER_INPUT_after {};
    template<typename VisitorImpl>
    concept has_visitor_Type_ENCODER_INPUT_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_ENCODER_INPUT_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_ENCODER_INPUT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_DECODER_INPUT : ebmcodegen::util::ContextBase<Context_Type_DECODER_INPUT> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    struct VisitorTag_Type_DECODER_INPUT {};
    template<typename VisitorImpl>
    concept has_visitor_Type_DECODER_INPUT = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_DECODER_INPUT&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_DECODER_INPUT(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;
    struct Context_Type_DECODER_INPUT_before : ebmcodegen::util::ContextBase<Context_Type_DECODER_INPUT_before> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_DECODER_INPUT_before {};
    template<typename VisitorImpl>
    concept has_visitor_Type_DECODER_INPUT_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_DECODER_INPUT_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_DECODER_INPUT_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    struct Context_Type_DECODER_INPUT_after : ebmcodegen::util::ContextBase<Context_Type_DECODER_INPUT_after> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_DECODER_INPUT_after {};
    template<typename VisitorImpl>
    concept has_visitor_Type_DECODER_INPUT_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_DECODER_INPUT_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_DECODER_INPUT_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_PROPERTY_SETTER_RETURN : ebmcodegen::util::ContextBase<Context_Type_PROPERTY_SETTER_RETURN> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
    };
    struct VisitorTag_Type_PROPERTY_SETTER_RETURN {};
    template<typename VisitorImpl>
    concept has_visitor_Type_PROPERTY_SETTER_RETURN = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_PROPERTY_SETTER_RETURN&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_PROPERTY_SETTER_RETURN(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;
    struct Context_Type_PROPERTY_SETTER_RETURN_before : ebmcodegen::util::ContextBase<Context_Type_PROPERTY_SETTER_RETURN_before> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_PROPERTY_SETTER_RETURN_before {};
    template<typename VisitorImpl>
    concept has_visitor_Type_PROPERTY_SETTER_RETURN_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_PROPERTY_SETTER_RETURN_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_PROPERTY_SETTER_RETURN_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;
    struct Context_Type_PROPERTY_SETTER_RETURN_after : ebmcodegen::util::ContextBase<Context_Type_PROPERTY_SETTER_RETURN_after> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_PROPERTY_SETTER_RETURN_after {};
    template<typename VisitorImpl>
    concept has_visitor_Type_PROPERTY_SETTER_RETURN_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_PROPERTY_SETTER_RETURN_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_PROPERTY_SETTER_RETURN_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_OPTIONAL : ebmcodegen::util::ContextBase<Context_Type_OPTIONAL> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& inner_type;
    };
    struct VisitorTag_Type_OPTIONAL {};
    template<typename VisitorImpl>
    concept has_visitor_Type_OPTIONAL = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_OPTIONAL&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_OPTIONAL(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& inner_type = instance_name.inner_type;
    struct Context_Type_OPTIONAL_before : ebmcodegen::util::ContextBase<Context_Type_OPTIONAL_before> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& inner_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_OPTIONAL_before {};
    template<typename VisitorImpl>
    concept has_visitor_Type_OPTIONAL_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_OPTIONAL_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_OPTIONAL_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& inner_type = instance_name.inner_type;auto& main_logic = instance_name.main_logic;
    struct Context_Type_OPTIONAL_after : ebmcodegen::util::ContextBase<Context_Type_OPTIONAL_after> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& inner_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_OPTIONAL_after {};
    template<typename VisitorImpl>
    concept has_visitor_Type_OPTIONAL_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_OPTIONAL_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_OPTIONAL_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& inner_type = instance_name.inner_type;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_PTR : ebmcodegen::util::ContextBase<Context_Type_PTR> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& pointee_type;
    };
    struct VisitorTag_Type_PTR {};
    template<typename VisitorImpl>
    concept has_visitor_Type_PTR = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_PTR&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_PTR(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& pointee_type = instance_name.pointee_type;
    struct Context_Type_PTR_before : ebmcodegen::util::ContextBase<Context_Type_PTR_before> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& pointee_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_PTR_before {};
    template<typename VisitorImpl>
    concept has_visitor_Type_PTR_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_PTR_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_PTR_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& pointee_type = instance_name.pointee_type;auto& main_logic = instance_name.main_logic;
    struct Context_Type_PTR_after : ebmcodegen::util::ContextBase<Context_Type_PTR_after> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::TypeRef& pointee_type;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_PTR_after {};
    template<typename VisitorImpl>
    concept has_visitor_Type_PTR_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_PTR_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_PTR_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& pointee_type = instance_name.pointee_type;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type_FUNCTION : ebmcodegen::util::ContextBase<Context_Type_FUNCTION> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::FuncTypeDesc& func_desc;
    };
    struct VisitorTag_Type_FUNCTION {};
    template<typename VisitorImpl>
    concept has_visitor_Type_FUNCTION = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_FUNCTION&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_FUNCTION(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& func_desc = instance_name.func_desc;
    struct Context_Type_FUNCTION_before : ebmcodegen::util::ContextBase<Context_Type_FUNCTION_before> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::FuncTypeDesc& func_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_FUNCTION_before {};
    template<typename VisitorImpl>
    concept has_visitor_Type_FUNCTION_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_FUNCTION_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_FUNCTION_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& func_desc = instance_name.func_desc;auto& main_logic = instance_name.main_logic;
    struct Context_Type_FUNCTION_after : ebmcodegen::util::ContextBase<Context_Type_FUNCTION_after> {
        BaseVisitor& visitor;
        ebm::TypeRef item_id;
        const ebm::TypeKind& kind;
        const ebm::FuncTypeDesc& func_desc;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_FUNCTION_after {};
    template<typename VisitorImpl>
    concept has_visitor_Type_FUNCTION_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_FUNCTION_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_FUNCTION_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& item_id = instance_name.item_id;auto& kind = instance_name.kind;auto& func_desc = instance_name.func_desc;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Type : ebmcodegen::util::ContextBase<Context_Type> {
        BaseVisitor& visitor;
        const ebm::Type& in;
        ebm::TypeRef alias_ref;
    };
    struct VisitorTag_Type {};
    template<typename VisitorImpl>
    concept has_visitor_Type = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& alias_ref = instance_name.alias_ref;
    struct Context_Type_before : ebmcodegen::util::ContextBase<Context_Type_before> {
        BaseVisitor& visitor;
        const ebm::Type& in;
        ebm::TypeRef alias_ref;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Type_before {};
    template<typename VisitorImpl>
    concept has_visitor_Type_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& alias_ref = instance_name.alias_ref;auto& main_logic = instance_name.main_logic;
    struct Context_Type_after : ebmcodegen::util::ContextBase<Context_Type_after> {
        BaseVisitor& visitor;
        const ebm::Type& in;
        ebm::TypeRef alias_ref;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Type_after {};
    template<typename VisitorImpl>
    concept has_visitor_Type_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Type_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPE_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& alias_ref = instance_name.alias_ref;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    struct Context_Types : ebmcodegen::util::ContextBase<Context_Types> {
        BaseVisitor& visitor;
        const ebm::Types& in;
    };
    struct VisitorTag_Types {};
    template<typename VisitorImpl>
    concept has_visitor_Types = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Types&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPES(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;
    struct Context_Types_before : ebmcodegen::util::ContextBase<Context_Types_before> {
        BaseVisitor& visitor;
        const ebm::Types& in;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
    };
    struct VisitorTag_Types_before {};
    template<typename VisitorImpl>
    concept has_visitor_Types_before = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Types_before&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPES_BEFORE(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& main_logic = instance_name.main_logic;
    struct Context_Types_after : ebmcodegen::util::ContextBase<Context_Types_after> {
        BaseVisitor& visitor;
        const ebm::Types& in;
        ebmcodegen::util::MainLogicWrapper<Result> main_logic;
        expected<Result>& result;
    };
    struct VisitorTag_Types_after {};
    template<typename VisitorImpl>
    concept has_visitor_Types_after = requires(VisitorImpl v) {
         { v.visit(std::declval<Context_Types_after&>()) } -> std::convertible_to<expected<Result>>;
    };
    // Deconstruct context fields
    #define EBM2ALL_DECONSTRUCT_TYPES_AFTER(instance_name) \
    auto& visitor = instance_name.visitor;auto& in = instance_name.in;auto& main_logic = instance_name.main_logic;auto& result = instance_name.result;
    #define EBM2ALL_CODEGEN_VISITOR_entry ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_entry>>
    #define EBM2ALL_CODEGEN_CONTEXT_entry ebm2all::Context_entry
    #define EBM2ALL_CODEGEN_VISITOR_entry_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_entry_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_entry_before ebm2all::Context_entry_before
    #define EBM2ALL_CODEGEN_VISITOR_entry_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_entry_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_entry_after ebm2all::Context_entry_after
    #define EBM2ALL_CODEGEN_VISITOR_pre_visitor ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_pre_visitor>>
    #define EBM2ALL_CODEGEN_CONTEXT_pre_visitor ebm2all::Context_pre_visitor
    #define EBM2ALL_CODEGEN_VISITOR_pre_visitor_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_pre_visitor_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_pre_visitor_before ebm2all::Context_pre_visitor_before
    #define EBM2ALL_CODEGEN_VISITOR_pre_visitor_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_pre_visitor_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_pre_visitor_after ebm2all::Context_pre_visitor_after
    #define EBM2ALL_CODEGEN_VISITOR_post_entry ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_post_entry>>
    #define EBM2ALL_CODEGEN_CONTEXT_post_entry ebm2all::Context_post_entry
    #define EBM2ALL_CODEGEN_VISITOR_post_entry_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_post_entry_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_post_entry_before ebm2all::Context_post_entry_before
    #define EBM2ALL_CODEGEN_VISITOR_post_entry_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_post_entry_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_post_entry_after ebm2all::Context_post_entry_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_BLOCK ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_BLOCK>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_BLOCK ebm2all::Context_Statement_BLOCK
    #define EBM2ALL_CODEGEN_VISITOR_Statement_BLOCK_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_BLOCK_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_BLOCK_before ebm2all::Context_Statement_BLOCK_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_BLOCK_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_BLOCK_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_BLOCK_after ebm2all::Context_Statement_BLOCK_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_ASSIGNMENT ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_ASSIGNMENT>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_ASSIGNMENT ebm2all::Context_Statement_ASSIGNMENT
    #define EBM2ALL_CODEGEN_VISITOR_Statement_ASSIGNMENT_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_ASSIGNMENT_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_ASSIGNMENT_before ebm2all::Context_Statement_ASSIGNMENT_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_ASSIGNMENT_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_ASSIGNMENT_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_ASSIGNMENT_after ebm2all::Context_Statement_ASSIGNMENT_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_YIELD ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_YIELD>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_YIELD ebm2all::Context_Statement_YIELD
    #define EBM2ALL_CODEGEN_VISITOR_Statement_YIELD_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_YIELD_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_YIELD_before ebm2all::Context_Statement_YIELD_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_YIELD_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_YIELD_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_YIELD_after ebm2all::Context_Statement_YIELD_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_APPEND ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_APPEND>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_APPEND ebm2all::Context_Statement_APPEND
    #define EBM2ALL_CODEGEN_VISITOR_Statement_APPEND_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_APPEND_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_APPEND_before ebm2all::Context_Statement_APPEND_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_APPEND_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_APPEND_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_APPEND_after ebm2all::Context_Statement_APPEND_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_RETURN ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_RETURN>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_RETURN ebm2all::Context_Statement_RETURN
    #define EBM2ALL_CODEGEN_VISITOR_Statement_RETURN_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_RETURN_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_RETURN_before ebm2all::Context_Statement_RETURN_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_RETURN_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_RETURN_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_RETURN_after ebm2all::Context_Statement_RETURN_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_ERROR_RETURN ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_ERROR_RETURN>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_ERROR_RETURN ebm2all::Context_Statement_ERROR_RETURN
    #define EBM2ALL_CODEGEN_VISITOR_Statement_ERROR_RETURN_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_ERROR_RETURN_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_ERROR_RETURN_before ebm2all::Context_Statement_ERROR_RETURN_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_ERROR_RETURN_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_ERROR_RETURN_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_ERROR_RETURN_after ebm2all::Context_Statement_ERROR_RETURN_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_ASSERT ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_ASSERT>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_ASSERT ebm2all::Context_Statement_ASSERT
    #define EBM2ALL_CODEGEN_VISITOR_Statement_ASSERT_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_ASSERT_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_ASSERT_before ebm2all::Context_Statement_ASSERT_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_ASSERT_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_ASSERT_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_ASSERT_after ebm2all::Context_Statement_ASSERT_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_READ_DATA ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_READ_DATA>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_READ_DATA ebm2all::Context_Statement_READ_DATA
    #define EBM2ALL_CODEGEN_VISITOR_Statement_READ_DATA_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_READ_DATA_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_READ_DATA_before ebm2all::Context_Statement_READ_DATA_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_READ_DATA_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_READ_DATA_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_READ_DATA_after ebm2all::Context_Statement_READ_DATA_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_WRITE_DATA ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_WRITE_DATA>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_WRITE_DATA ebm2all::Context_Statement_WRITE_DATA
    #define EBM2ALL_CODEGEN_VISITOR_Statement_WRITE_DATA_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_WRITE_DATA_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_WRITE_DATA_before ebm2all::Context_Statement_WRITE_DATA_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_WRITE_DATA_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_WRITE_DATA_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_WRITE_DATA_after ebm2all::Context_Statement_WRITE_DATA_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_IF_STATEMENT ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_IF_STATEMENT>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_IF_STATEMENT ebm2all::Context_Statement_IF_STATEMENT
    #define EBM2ALL_CODEGEN_VISITOR_Statement_IF_STATEMENT_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_IF_STATEMENT_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_IF_STATEMENT_before ebm2all::Context_Statement_IF_STATEMENT_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_IF_STATEMENT_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_IF_STATEMENT_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_IF_STATEMENT_after ebm2all::Context_Statement_IF_STATEMENT_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_LOOP_STATEMENT ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_LOOP_STATEMENT>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_LOOP_STATEMENT ebm2all::Context_Statement_LOOP_STATEMENT
    #define EBM2ALL_CODEGEN_VISITOR_Statement_LOOP_STATEMENT_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_LOOP_STATEMENT_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_LOOP_STATEMENT_before ebm2all::Context_Statement_LOOP_STATEMENT_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_LOOP_STATEMENT_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_LOOP_STATEMENT_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_LOOP_STATEMENT_after ebm2all::Context_Statement_LOOP_STATEMENT_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_MATCH_STATEMENT ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_MATCH_STATEMENT>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_MATCH_STATEMENT ebm2all::Context_Statement_MATCH_STATEMENT
    #define EBM2ALL_CODEGEN_VISITOR_Statement_MATCH_STATEMENT_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_MATCH_STATEMENT_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_MATCH_STATEMENT_before ebm2all::Context_Statement_MATCH_STATEMENT_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_MATCH_STATEMENT_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_MATCH_STATEMENT_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_MATCH_STATEMENT_after ebm2all::Context_Statement_MATCH_STATEMENT_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_MATCH_BRANCH ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_MATCH_BRANCH>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_MATCH_BRANCH ebm2all::Context_Statement_MATCH_BRANCH
    #define EBM2ALL_CODEGEN_VISITOR_Statement_MATCH_BRANCH_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_MATCH_BRANCH_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_MATCH_BRANCH_before ebm2all::Context_Statement_MATCH_BRANCH_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_MATCH_BRANCH_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_MATCH_BRANCH_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_MATCH_BRANCH_after ebm2all::Context_Statement_MATCH_BRANCH_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_BREAK ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_BREAK>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_BREAK ebm2all::Context_Statement_BREAK
    #define EBM2ALL_CODEGEN_VISITOR_Statement_BREAK_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_BREAK_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_BREAK_before ebm2all::Context_Statement_BREAK_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_BREAK_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_BREAK_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_BREAK_after ebm2all::Context_Statement_BREAK_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_CONTINUE ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_CONTINUE>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_CONTINUE ebm2all::Context_Statement_CONTINUE
    #define EBM2ALL_CODEGEN_VISITOR_Statement_CONTINUE_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_CONTINUE_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_CONTINUE_before ebm2all::Context_Statement_CONTINUE_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_CONTINUE_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_CONTINUE_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_CONTINUE_after ebm2all::Context_Statement_CONTINUE_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_FUNCTION_DECL ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_FUNCTION_DECL>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_FUNCTION_DECL ebm2all::Context_Statement_FUNCTION_DECL
    #define EBM2ALL_CODEGEN_VISITOR_Statement_FUNCTION_DECL_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_FUNCTION_DECL_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_FUNCTION_DECL_before ebm2all::Context_Statement_FUNCTION_DECL_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_FUNCTION_DECL_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_FUNCTION_DECL_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_FUNCTION_DECL_after ebm2all::Context_Statement_FUNCTION_DECL_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_VARIABLE_DECL ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_VARIABLE_DECL>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_VARIABLE_DECL ebm2all::Context_Statement_VARIABLE_DECL
    #define EBM2ALL_CODEGEN_VISITOR_Statement_VARIABLE_DECL_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_VARIABLE_DECL_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_VARIABLE_DECL_before ebm2all::Context_Statement_VARIABLE_DECL_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_VARIABLE_DECL_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_VARIABLE_DECL_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_VARIABLE_DECL_after ebm2all::Context_Statement_VARIABLE_DECL_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_PARAMETER_DECL ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_PARAMETER_DECL>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_PARAMETER_DECL ebm2all::Context_Statement_PARAMETER_DECL
    #define EBM2ALL_CODEGEN_VISITOR_Statement_PARAMETER_DECL_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_PARAMETER_DECL_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_PARAMETER_DECL_before ebm2all::Context_Statement_PARAMETER_DECL_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_PARAMETER_DECL_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_PARAMETER_DECL_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_PARAMETER_DECL_after ebm2all::Context_Statement_PARAMETER_DECL_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_FIELD_DECL ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_FIELD_DECL>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_FIELD_DECL ebm2all::Context_Statement_FIELD_DECL
    #define EBM2ALL_CODEGEN_VISITOR_Statement_FIELD_DECL_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_FIELD_DECL_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_FIELD_DECL_before ebm2all::Context_Statement_FIELD_DECL_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_FIELD_DECL_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_FIELD_DECL_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_FIELD_DECL_after ebm2all::Context_Statement_FIELD_DECL_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_COMPOSITE_FIELD_DECL ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_COMPOSITE_FIELD_DECL>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_COMPOSITE_FIELD_DECL ebm2all::Context_Statement_COMPOSITE_FIELD_DECL
    #define EBM2ALL_CODEGEN_VISITOR_Statement_COMPOSITE_FIELD_DECL_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_COMPOSITE_FIELD_DECL_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_COMPOSITE_FIELD_DECL_before ebm2all::Context_Statement_COMPOSITE_FIELD_DECL_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_COMPOSITE_FIELD_DECL_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_COMPOSITE_FIELD_DECL_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_COMPOSITE_FIELD_DECL_after ebm2all::Context_Statement_COMPOSITE_FIELD_DECL_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_ENUM_DECL ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_ENUM_DECL>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_ENUM_DECL ebm2all::Context_Statement_ENUM_DECL
    #define EBM2ALL_CODEGEN_VISITOR_Statement_ENUM_DECL_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_ENUM_DECL_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_ENUM_DECL_before ebm2all::Context_Statement_ENUM_DECL_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_ENUM_DECL_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_ENUM_DECL_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_ENUM_DECL_after ebm2all::Context_Statement_ENUM_DECL_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_ENUM_MEMBER_DECL ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_ENUM_MEMBER_DECL>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_ENUM_MEMBER_DECL ebm2all::Context_Statement_ENUM_MEMBER_DECL
    #define EBM2ALL_CODEGEN_VISITOR_Statement_ENUM_MEMBER_DECL_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_ENUM_MEMBER_DECL_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_ENUM_MEMBER_DECL_before ebm2all::Context_Statement_ENUM_MEMBER_DECL_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_ENUM_MEMBER_DECL_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_ENUM_MEMBER_DECL_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_ENUM_MEMBER_DECL_after ebm2all::Context_Statement_ENUM_MEMBER_DECL_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_STRUCT_DECL ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_STRUCT_DECL>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_STRUCT_DECL ebm2all::Context_Statement_STRUCT_DECL
    #define EBM2ALL_CODEGEN_VISITOR_Statement_STRUCT_DECL_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_STRUCT_DECL_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_STRUCT_DECL_before ebm2all::Context_Statement_STRUCT_DECL_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_STRUCT_DECL_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_STRUCT_DECL_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_STRUCT_DECL_after ebm2all::Context_Statement_STRUCT_DECL_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_UNION_DECL ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_UNION_DECL>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_UNION_DECL ebm2all::Context_Statement_UNION_DECL
    #define EBM2ALL_CODEGEN_VISITOR_Statement_UNION_DECL_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_UNION_DECL_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_UNION_DECL_before ebm2all::Context_Statement_UNION_DECL_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_UNION_DECL_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_UNION_DECL_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_UNION_DECL_after ebm2all::Context_Statement_UNION_DECL_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_UNION_MEMBER_DECL ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_UNION_MEMBER_DECL>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_UNION_MEMBER_DECL ebm2all::Context_Statement_UNION_MEMBER_DECL
    #define EBM2ALL_CODEGEN_VISITOR_Statement_UNION_MEMBER_DECL_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_UNION_MEMBER_DECL_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_UNION_MEMBER_DECL_before ebm2all::Context_Statement_UNION_MEMBER_DECL_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_UNION_MEMBER_DECL_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_UNION_MEMBER_DECL_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_UNION_MEMBER_DECL_after ebm2all::Context_Statement_UNION_MEMBER_DECL_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_PROGRAM_DECL ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_PROGRAM_DECL>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_PROGRAM_DECL ebm2all::Context_Statement_PROGRAM_DECL
    #define EBM2ALL_CODEGEN_VISITOR_Statement_PROGRAM_DECL_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_PROGRAM_DECL_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_PROGRAM_DECL_before ebm2all::Context_Statement_PROGRAM_DECL_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_PROGRAM_DECL_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_PROGRAM_DECL_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_PROGRAM_DECL_after ebm2all::Context_Statement_PROGRAM_DECL_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_PROPERTY_DECL ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_PROPERTY_DECL>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_PROPERTY_DECL ebm2all::Context_Statement_PROPERTY_DECL
    #define EBM2ALL_CODEGEN_VISITOR_Statement_PROPERTY_DECL_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_PROPERTY_DECL_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_PROPERTY_DECL_before ebm2all::Context_Statement_PROPERTY_DECL_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_PROPERTY_DECL_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_PROPERTY_DECL_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_PROPERTY_DECL_after ebm2all::Context_Statement_PROPERTY_DECL_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_PROPERTY_MEMBER_DECL ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_PROPERTY_MEMBER_DECL>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_PROPERTY_MEMBER_DECL ebm2all::Context_Statement_PROPERTY_MEMBER_DECL
    #define EBM2ALL_CODEGEN_VISITOR_Statement_PROPERTY_MEMBER_DECL_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_PROPERTY_MEMBER_DECL_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_PROPERTY_MEMBER_DECL_before ebm2all::Context_Statement_PROPERTY_MEMBER_DECL_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_PROPERTY_MEMBER_DECL_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_PROPERTY_MEMBER_DECL_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_PROPERTY_MEMBER_DECL_after ebm2all::Context_Statement_PROPERTY_MEMBER_DECL_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_METADATA ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_METADATA>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_METADATA ebm2all::Context_Statement_METADATA
    #define EBM2ALL_CODEGEN_VISITOR_Statement_METADATA_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_METADATA_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_METADATA_before ebm2all::Context_Statement_METADATA_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_METADATA_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_METADATA_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_METADATA_after ebm2all::Context_Statement_METADATA_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_IMPORT_MODULE ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_IMPORT_MODULE>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_IMPORT_MODULE ebm2all::Context_Statement_IMPORT_MODULE
    #define EBM2ALL_CODEGEN_VISITOR_Statement_IMPORT_MODULE_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_IMPORT_MODULE_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_IMPORT_MODULE_before ebm2all::Context_Statement_IMPORT_MODULE_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_IMPORT_MODULE_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_IMPORT_MODULE_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_IMPORT_MODULE_after ebm2all::Context_Statement_IMPORT_MODULE_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_EXPRESSION ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_EXPRESSION>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_EXPRESSION ebm2all::Context_Statement_EXPRESSION
    #define EBM2ALL_CODEGEN_VISITOR_Statement_EXPRESSION_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_EXPRESSION_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_EXPRESSION_before ebm2all::Context_Statement_EXPRESSION_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_EXPRESSION_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_EXPRESSION_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_EXPRESSION_after ebm2all::Context_Statement_EXPRESSION_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_ERROR_REPORT ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_ERROR_REPORT>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_ERROR_REPORT ebm2all::Context_Statement_ERROR_REPORT
    #define EBM2ALL_CODEGEN_VISITOR_Statement_ERROR_REPORT_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_ERROR_REPORT_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_ERROR_REPORT_before ebm2all::Context_Statement_ERROR_REPORT_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_ERROR_REPORT_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_ERROR_REPORT_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_ERROR_REPORT_after ebm2all::Context_Statement_ERROR_REPORT_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_LOWERED_IO_STATEMENTS ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_LOWERED_IO_STATEMENTS>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_LOWERED_IO_STATEMENTS ebm2all::Context_Statement_LOWERED_IO_STATEMENTS
    #define EBM2ALL_CODEGEN_VISITOR_Statement_LOWERED_IO_STATEMENTS_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_LOWERED_IO_STATEMENTS_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_LOWERED_IO_STATEMENTS_before ebm2all::Context_Statement_LOWERED_IO_STATEMENTS_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_LOWERED_IO_STATEMENTS_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_LOWERED_IO_STATEMENTS_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_LOWERED_IO_STATEMENTS_after ebm2all::Context_Statement_LOWERED_IO_STATEMENTS_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_SUB_BYTE_RANGE ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_SUB_BYTE_RANGE>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_SUB_BYTE_RANGE ebm2all::Context_Statement_SUB_BYTE_RANGE
    #define EBM2ALL_CODEGEN_VISITOR_Statement_SUB_BYTE_RANGE_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_SUB_BYTE_RANGE_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_SUB_BYTE_RANGE_before ebm2all::Context_Statement_SUB_BYTE_RANGE_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_SUB_BYTE_RANGE_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_SUB_BYTE_RANGE_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_SUB_BYTE_RANGE_after ebm2all::Context_Statement_SUB_BYTE_RANGE_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_INIT_CHECK ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_INIT_CHECK>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_INIT_CHECK ebm2all::Context_Statement_INIT_CHECK
    #define EBM2ALL_CODEGEN_VISITOR_Statement_INIT_CHECK_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_INIT_CHECK_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_INIT_CHECK_before ebm2all::Context_Statement_INIT_CHECK_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_INIT_CHECK_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_INIT_CHECK_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_INIT_CHECK_after ebm2all::Context_Statement_INIT_CHECK_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement_ENDIAN_VARIABLE ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_ENDIAN_VARIABLE>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_ENDIAN_VARIABLE ebm2all::Context_Statement_ENDIAN_VARIABLE
    #define EBM2ALL_CODEGEN_VISITOR_Statement_ENDIAN_VARIABLE_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_ENDIAN_VARIABLE_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_ENDIAN_VARIABLE_before ebm2all::Context_Statement_ENDIAN_VARIABLE_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_ENDIAN_VARIABLE_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_ENDIAN_VARIABLE_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_ENDIAN_VARIABLE_after ebm2all::Context_Statement_ENDIAN_VARIABLE_after
    #define EBM2ALL_CODEGEN_VISITOR_Statement ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement ebm2all::Context_Statement
    #define EBM2ALL_CODEGEN_VISITOR_Statement_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_before ebm2all::Context_Statement_before
    #define EBM2ALL_CODEGEN_VISITOR_Statement_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Statement_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Statement_after ebm2all::Context_Statement_after
    #define EBM2ALL_CODEGEN_VISITOR_Block ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Block>>
    #define EBM2ALL_CODEGEN_CONTEXT_Block ebm2all::Context_Block
    #define EBM2ALL_CODEGEN_VISITOR_Block_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Block_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Block_before ebm2all::Context_Block_before
    #define EBM2ALL_CODEGEN_VISITOR_Block_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Block_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Block_after ebm2all::Context_Block_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_LITERAL_INT ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_LITERAL_INT>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_LITERAL_INT ebm2all::Context_Expression_LITERAL_INT
    #define EBM2ALL_CODEGEN_VISITOR_Expression_LITERAL_INT_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_LITERAL_INT_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_LITERAL_INT_before ebm2all::Context_Expression_LITERAL_INT_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_LITERAL_INT_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_LITERAL_INT_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_LITERAL_INT_after ebm2all::Context_Expression_LITERAL_INT_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_LITERAL_INT64 ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_LITERAL_INT64>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_LITERAL_INT64 ebm2all::Context_Expression_LITERAL_INT64
    #define EBM2ALL_CODEGEN_VISITOR_Expression_LITERAL_INT64_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_LITERAL_INT64_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_LITERAL_INT64_before ebm2all::Context_Expression_LITERAL_INT64_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_LITERAL_INT64_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_LITERAL_INT64_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_LITERAL_INT64_after ebm2all::Context_Expression_LITERAL_INT64_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_LITERAL_BOOL ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_LITERAL_BOOL>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_LITERAL_BOOL ebm2all::Context_Expression_LITERAL_BOOL
    #define EBM2ALL_CODEGEN_VISITOR_Expression_LITERAL_BOOL_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_LITERAL_BOOL_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_LITERAL_BOOL_before ebm2all::Context_Expression_LITERAL_BOOL_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_LITERAL_BOOL_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_LITERAL_BOOL_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_LITERAL_BOOL_after ebm2all::Context_Expression_LITERAL_BOOL_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_LITERAL_STRING ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_LITERAL_STRING>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_LITERAL_STRING ebm2all::Context_Expression_LITERAL_STRING
    #define EBM2ALL_CODEGEN_VISITOR_Expression_LITERAL_STRING_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_LITERAL_STRING_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_LITERAL_STRING_before ebm2all::Context_Expression_LITERAL_STRING_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_LITERAL_STRING_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_LITERAL_STRING_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_LITERAL_STRING_after ebm2all::Context_Expression_LITERAL_STRING_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_LITERAL_TYPE ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_LITERAL_TYPE>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_LITERAL_TYPE ebm2all::Context_Expression_LITERAL_TYPE
    #define EBM2ALL_CODEGEN_VISITOR_Expression_LITERAL_TYPE_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_LITERAL_TYPE_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_LITERAL_TYPE_before ebm2all::Context_Expression_LITERAL_TYPE_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_LITERAL_TYPE_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_LITERAL_TYPE_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_LITERAL_TYPE_after ebm2all::Context_Expression_LITERAL_TYPE_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_LITERAL_CHAR ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_LITERAL_CHAR>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_LITERAL_CHAR ebm2all::Context_Expression_LITERAL_CHAR
    #define EBM2ALL_CODEGEN_VISITOR_Expression_LITERAL_CHAR_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_LITERAL_CHAR_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_LITERAL_CHAR_before ebm2all::Context_Expression_LITERAL_CHAR_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_LITERAL_CHAR_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_LITERAL_CHAR_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_LITERAL_CHAR_after ebm2all::Context_Expression_LITERAL_CHAR_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_IDENTIFIER ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_IDENTIFIER>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_IDENTIFIER ebm2all::Context_Expression_IDENTIFIER
    #define EBM2ALL_CODEGEN_VISITOR_Expression_IDENTIFIER_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_IDENTIFIER_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_IDENTIFIER_before ebm2all::Context_Expression_IDENTIFIER_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_IDENTIFIER_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_IDENTIFIER_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_IDENTIFIER_after ebm2all::Context_Expression_IDENTIFIER_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_BINARY_OP ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_BINARY_OP>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_BINARY_OP ebm2all::Context_Expression_BINARY_OP
    #define EBM2ALL_CODEGEN_VISITOR_Expression_BINARY_OP_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_BINARY_OP_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_BINARY_OP_before ebm2all::Context_Expression_BINARY_OP_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_BINARY_OP_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_BINARY_OP_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_BINARY_OP_after ebm2all::Context_Expression_BINARY_OP_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_UNARY_OP ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_UNARY_OP>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_UNARY_OP ebm2all::Context_Expression_UNARY_OP
    #define EBM2ALL_CODEGEN_VISITOR_Expression_UNARY_OP_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_UNARY_OP_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_UNARY_OP_before ebm2all::Context_Expression_UNARY_OP_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_UNARY_OP_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_UNARY_OP_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_UNARY_OP_after ebm2all::Context_Expression_UNARY_OP_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_CALL ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_CALL>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_CALL ebm2all::Context_Expression_CALL
    #define EBM2ALL_CODEGEN_VISITOR_Expression_CALL_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_CALL_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_CALL_before ebm2all::Context_Expression_CALL_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_CALL_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_CALL_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_CALL_after ebm2all::Context_Expression_CALL_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_INDEX_ACCESS ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_INDEX_ACCESS>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_INDEX_ACCESS ebm2all::Context_Expression_INDEX_ACCESS
    #define EBM2ALL_CODEGEN_VISITOR_Expression_INDEX_ACCESS_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_INDEX_ACCESS_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_INDEX_ACCESS_before ebm2all::Context_Expression_INDEX_ACCESS_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_INDEX_ACCESS_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_INDEX_ACCESS_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_INDEX_ACCESS_after ebm2all::Context_Expression_INDEX_ACCESS_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_MEMBER_ACCESS ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_MEMBER_ACCESS>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_MEMBER_ACCESS ebm2all::Context_Expression_MEMBER_ACCESS
    #define EBM2ALL_CODEGEN_VISITOR_Expression_MEMBER_ACCESS_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_MEMBER_ACCESS_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_MEMBER_ACCESS_before ebm2all::Context_Expression_MEMBER_ACCESS_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_MEMBER_ACCESS_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_MEMBER_ACCESS_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_MEMBER_ACCESS_after ebm2all::Context_Expression_MEMBER_ACCESS_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_ENUM_MEMBER ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_ENUM_MEMBER>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_ENUM_MEMBER ebm2all::Context_Expression_ENUM_MEMBER
    #define EBM2ALL_CODEGEN_VISITOR_Expression_ENUM_MEMBER_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_ENUM_MEMBER_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_ENUM_MEMBER_before ebm2all::Context_Expression_ENUM_MEMBER_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_ENUM_MEMBER_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_ENUM_MEMBER_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_ENUM_MEMBER_after ebm2all::Context_Expression_ENUM_MEMBER_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_TYPE_CAST ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_TYPE_CAST>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_TYPE_CAST ebm2all::Context_Expression_TYPE_CAST
    #define EBM2ALL_CODEGEN_VISITOR_Expression_TYPE_CAST_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_TYPE_CAST_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_TYPE_CAST_before ebm2all::Context_Expression_TYPE_CAST_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_TYPE_CAST_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_TYPE_CAST_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_TYPE_CAST_after ebm2all::Context_Expression_TYPE_CAST_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_RANGE ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_RANGE>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_RANGE ebm2all::Context_Expression_RANGE
    #define EBM2ALL_CODEGEN_VISITOR_Expression_RANGE_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_RANGE_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_RANGE_before ebm2all::Context_Expression_RANGE_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_RANGE_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_RANGE_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_RANGE_after ebm2all::Context_Expression_RANGE_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_DEFAULT_VALUE ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_DEFAULT_VALUE>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_DEFAULT_VALUE ebm2all::Context_Expression_DEFAULT_VALUE
    #define EBM2ALL_CODEGEN_VISITOR_Expression_DEFAULT_VALUE_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_DEFAULT_VALUE_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_DEFAULT_VALUE_before ebm2all::Context_Expression_DEFAULT_VALUE_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_DEFAULT_VALUE_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_DEFAULT_VALUE_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_DEFAULT_VALUE_after ebm2all::Context_Expression_DEFAULT_VALUE_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_IS_LITTLE_ENDIAN ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_IS_LITTLE_ENDIAN>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_IS_LITTLE_ENDIAN ebm2all::Context_Expression_IS_LITTLE_ENDIAN
    #define EBM2ALL_CODEGEN_VISITOR_Expression_IS_LITTLE_ENDIAN_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_IS_LITTLE_ENDIAN_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_IS_LITTLE_ENDIAN_before ebm2all::Context_Expression_IS_LITTLE_ENDIAN_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_IS_LITTLE_ENDIAN_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_IS_LITTLE_ENDIAN_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_IS_LITTLE_ENDIAN_after ebm2all::Context_Expression_IS_LITTLE_ENDIAN_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_GET_STREAM_OFFSET ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_GET_STREAM_OFFSET>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_GET_STREAM_OFFSET ebm2all::Context_Expression_GET_STREAM_OFFSET
    #define EBM2ALL_CODEGEN_VISITOR_Expression_GET_STREAM_OFFSET_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_GET_STREAM_OFFSET_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_GET_STREAM_OFFSET_before ebm2all::Context_Expression_GET_STREAM_OFFSET_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_GET_STREAM_OFFSET_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_GET_STREAM_OFFSET_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_GET_STREAM_OFFSET_after ebm2all::Context_Expression_GET_STREAM_OFFSET_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_GET_REMAINING_BYTES ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_GET_REMAINING_BYTES>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_GET_REMAINING_BYTES ebm2all::Context_Expression_GET_REMAINING_BYTES
    #define EBM2ALL_CODEGEN_VISITOR_Expression_GET_REMAINING_BYTES_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_GET_REMAINING_BYTES_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_GET_REMAINING_BYTES_before ebm2all::Context_Expression_GET_REMAINING_BYTES_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_GET_REMAINING_BYTES_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_GET_REMAINING_BYTES_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_GET_REMAINING_BYTES_after ebm2all::Context_Expression_GET_REMAINING_BYTES_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_CAN_READ_STREAM ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_CAN_READ_STREAM>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_CAN_READ_STREAM ebm2all::Context_Expression_CAN_READ_STREAM
    #define EBM2ALL_CODEGEN_VISITOR_Expression_CAN_READ_STREAM_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_CAN_READ_STREAM_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_CAN_READ_STREAM_before ebm2all::Context_Expression_CAN_READ_STREAM_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_CAN_READ_STREAM_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_CAN_READ_STREAM_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_CAN_READ_STREAM_after ebm2all::Context_Expression_CAN_READ_STREAM_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_ARRAY_SIZE ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_ARRAY_SIZE>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_ARRAY_SIZE ebm2all::Context_Expression_ARRAY_SIZE
    #define EBM2ALL_CODEGEN_VISITOR_Expression_ARRAY_SIZE_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_ARRAY_SIZE_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_ARRAY_SIZE_before ebm2all::Context_Expression_ARRAY_SIZE_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_ARRAY_SIZE_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_ARRAY_SIZE_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_ARRAY_SIZE_after ebm2all::Context_Expression_ARRAY_SIZE_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_ENUM_IS_DEFINED ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_ENUM_IS_DEFINED>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_ENUM_IS_DEFINED ebm2all::Context_Expression_ENUM_IS_DEFINED
    #define EBM2ALL_CODEGEN_VISITOR_Expression_ENUM_IS_DEFINED_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_ENUM_IS_DEFINED_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_ENUM_IS_DEFINED_before ebm2all::Context_Expression_ENUM_IS_DEFINED_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_ENUM_IS_DEFINED_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_ENUM_IS_DEFINED_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_ENUM_IS_DEFINED_after ebm2all::Context_Expression_ENUM_IS_DEFINED_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_IS_ERROR ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_IS_ERROR>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_IS_ERROR ebm2all::Context_Expression_IS_ERROR
    #define EBM2ALL_CODEGEN_VISITOR_Expression_IS_ERROR_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_IS_ERROR_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_IS_ERROR_before ebm2all::Context_Expression_IS_ERROR_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_IS_ERROR_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_IS_ERROR_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_IS_ERROR_after ebm2all::Context_Expression_IS_ERROR_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_MAX_VALUE ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_MAX_VALUE>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_MAX_VALUE ebm2all::Context_Expression_MAX_VALUE
    #define EBM2ALL_CODEGEN_VISITOR_Expression_MAX_VALUE_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_MAX_VALUE_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_MAX_VALUE_before ebm2all::Context_Expression_MAX_VALUE_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_MAX_VALUE_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_MAX_VALUE_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_MAX_VALUE_after ebm2all::Context_Expression_MAX_VALUE_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_READ_DATA ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_READ_DATA>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_READ_DATA ebm2all::Context_Expression_READ_DATA
    #define EBM2ALL_CODEGEN_VISITOR_Expression_READ_DATA_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_READ_DATA_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_READ_DATA_before ebm2all::Context_Expression_READ_DATA_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_READ_DATA_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_READ_DATA_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_READ_DATA_after ebm2all::Context_Expression_READ_DATA_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_WRITE_DATA ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_WRITE_DATA>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_WRITE_DATA ebm2all::Context_Expression_WRITE_DATA
    #define EBM2ALL_CODEGEN_VISITOR_Expression_WRITE_DATA_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_WRITE_DATA_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_WRITE_DATA_before ebm2all::Context_Expression_WRITE_DATA_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_WRITE_DATA_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_WRITE_DATA_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_WRITE_DATA_after ebm2all::Context_Expression_WRITE_DATA_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_CONDITIONAL_STATEMENT ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_CONDITIONAL_STATEMENT>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_CONDITIONAL_STATEMENT ebm2all::Context_Expression_CONDITIONAL_STATEMENT
    #define EBM2ALL_CODEGEN_VISITOR_Expression_CONDITIONAL_STATEMENT_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_CONDITIONAL_STATEMENT_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_CONDITIONAL_STATEMENT_before ebm2all::Context_Expression_CONDITIONAL_STATEMENT_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_CONDITIONAL_STATEMENT_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_CONDITIONAL_STATEMENT_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_CONDITIONAL_STATEMENT_after ebm2all::Context_Expression_CONDITIONAL_STATEMENT_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_CONDITIONAL ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_CONDITIONAL>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_CONDITIONAL ebm2all::Context_Expression_CONDITIONAL
    #define EBM2ALL_CODEGEN_VISITOR_Expression_CONDITIONAL_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_CONDITIONAL_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_CONDITIONAL_before ebm2all::Context_Expression_CONDITIONAL_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_CONDITIONAL_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_CONDITIONAL_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_CONDITIONAL_after ebm2all::Context_Expression_CONDITIONAL_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_AVAILABLE ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_AVAILABLE>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_AVAILABLE ebm2all::Context_Expression_AVAILABLE
    #define EBM2ALL_CODEGEN_VISITOR_Expression_AVAILABLE_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_AVAILABLE_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_AVAILABLE_before ebm2all::Context_Expression_AVAILABLE_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_AVAILABLE_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_AVAILABLE_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_AVAILABLE_after ebm2all::Context_Expression_AVAILABLE_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_SIZEOF ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_SIZEOF>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_SIZEOF ebm2all::Context_Expression_SIZEOF
    #define EBM2ALL_CODEGEN_VISITOR_Expression_SIZEOF_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_SIZEOF_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_SIZEOF_before ebm2all::Context_Expression_SIZEOF_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_SIZEOF_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_SIZEOF_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_SIZEOF_after ebm2all::Context_Expression_SIZEOF_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_SUB_RANGE_INIT ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_SUB_RANGE_INIT>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_SUB_RANGE_INIT ebm2all::Context_Expression_SUB_RANGE_INIT
    #define EBM2ALL_CODEGEN_VISITOR_Expression_SUB_RANGE_INIT_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_SUB_RANGE_INIT_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_SUB_RANGE_INIT_before ebm2all::Context_Expression_SUB_RANGE_INIT_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_SUB_RANGE_INIT_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_SUB_RANGE_INIT_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_SUB_RANGE_INIT_after ebm2all::Context_Expression_SUB_RANGE_INIT_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_OR_COND ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_OR_COND>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_OR_COND ebm2all::Context_Expression_OR_COND
    #define EBM2ALL_CODEGEN_VISITOR_Expression_OR_COND_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_OR_COND_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_OR_COND_before ebm2all::Context_Expression_OR_COND_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_OR_COND_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_OR_COND_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_OR_COND_after ebm2all::Context_Expression_OR_COND_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_ADDRESS_OF ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_ADDRESS_OF>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_ADDRESS_OF ebm2all::Context_Expression_ADDRESS_OF
    #define EBM2ALL_CODEGEN_VISITOR_Expression_ADDRESS_OF_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_ADDRESS_OF_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_ADDRESS_OF_before ebm2all::Context_Expression_ADDRESS_OF_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_ADDRESS_OF_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_ADDRESS_OF_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_ADDRESS_OF_after ebm2all::Context_Expression_ADDRESS_OF_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_OPTIONAL_OF ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_OPTIONAL_OF>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_OPTIONAL_OF ebm2all::Context_Expression_OPTIONAL_OF
    #define EBM2ALL_CODEGEN_VISITOR_Expression_OPTIONAL_OF_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_OPTIONAL_OF_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_OPTIONAL_OF_before ebm2all::Context_Expression_OPTIONAL_OF_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_OPTIONAL_OF_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_OPTIONAL_OF_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_OPTIONAL_OF_after ebm2all::Context_Expression_OPTIONAL_OF_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_SETTER_STATUS ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_SETTER_STATUS>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_SETTER_STATUS ebm2all::Context_Expression_SETTER_STATUS
    #define EBM2ALL_CODEGEN_VISITOR_Expression_SETTER_STATUS_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_SETTER_STATUS_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_SETTER_STATUS_before ebm2all::Context_Expression_SETTER_STATUS_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_SETTER_STATUS_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_SETTER_STATUS_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_SETTER_STATUS_after ebm2all::Context_Expression_SETTER_STATUS_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_SELF ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_SELF>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_SELF ebm2all::Context_Expression_SELF
    #define EBM2ALL_CODEGEN_VISITOR_Expression_SELF_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_SELF_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_SELF_before ebm2all::Context_Expression_SELF_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_SELF_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_SELF_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_SELF_after ebm2all::Context_Expression_SELF_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression_AS_ARG ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_AS_ARG>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_AS_ARG ebm2all::Context_Expression_AS_ARG
    #define EBM2ALL_CODEGEN_VISITOR_Expression_AS_ARG_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_AS_ARG_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_AS_ARG_before ebm2all::Context_Expression_AS_ARG_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_AS_ARG_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_AS_ARG_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_AS_ARG_after ebm2all::Context_Expression_AS_ARG_after
    #define EBM2ALL_CODEGEN_VISITOR_Expression ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression ebm2all::Context_Expression
    #define EBM2ALL_CODEGEN_VISITOR_Expression_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_before ebm2all::Context_Expression_before
    #define EBM2ALL_CODEGEN_VISITOR_Expression_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expression_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expression_after ebm2all::Context_Expression_after
    #define EBM2ALL_CODEGEN_VISITOR_Expressions ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expressions>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expressions ebm2all::Context_Expressions
    #define EBM2ALL_CODEGEN_VISITOR_Expressions_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expressions_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expressions_before ebm2all::Context_Expressions_before
    #define EBM2ALL_CODEGEN_VISITOR_Expressions_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Expressions_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Expressions_after ebm2all::Context_Expressions_after
    #define EBM2ALL_CODEGEN_VISITOR_Type_INT ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_INT>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_INT ebm2all::Context_Type_INT
    #define EBM2ALL_CODEGEN_VISITOR_Type_INT_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_INT_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_INT_before ebm2all::Context_Type_INT_before
    #define EBM2ALL_CODEGEN_VISITOR_Type_INT_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_INT_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_INT_after ebm2all::Context_Type_INT_after
    #define EBM2ALL_CODEGEN_VISITOR_Type_UINT ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_UINT>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_UINT ebm2all::Context_Type_UINT
    #define EBM2ALL_CODEGEN_VISITOR_Type_UINT_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_UINT_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_UINT_before ebm2all::Context_Type_UINT_before
    #define EBM2ALL_CODEGEN_VISITOR_Type_UINT_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_UINT_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_UINT_after ebm2all::Context_Type_UINT_after
    #define EBM2ALL_CODEGEN_VISITOR_Type_USIZE ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_USIZE>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_USIZE ebm2all::Context_Type_USIZE
    #define EBM2ALL_CODEGEN_VISITOR_Type_USIZE_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_USIZE_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_USIZE_before ebm2all::Context_Type_USIZE_before
    #define EBM2ALL_CODEGEN_VISITOR_Type_USIZE_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_USIZE_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_USIZE_after ebm2all::Context_Type_USIZE_after
    #define EBM2ALL_CODEGEN_VISITOR_Type_FLOAT ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_FLOAT>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_FLOAT ebm2all::Context_Type_FLOAT
    #define EBM2ALL_CODEGEN_VISITOR_Type_FLOAT_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_FLOAT_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_FLOAT_before ebm2all::Context_Type_FLOAT_before
    #define EBM2ALL_CODEGEN_VISITOR_Type_FLOAT_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_FLOAT_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_FLOAT_after ebm2all::Context_Type_FLOAT_after
    #define EBM2ALL_CODEGEN_VISITOR_Type_STRUCT ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_STRUCT>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_STRUCT ebm2all::Context_Type_STRUCT
    #define EBM2ALL_CODEGEN_VISITOR_Type_STRUCT_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_STRUCT_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_STRUCT_before ebm2all::Context_Type_STRUCT_before
    #define EBM2ALL_CODEGEN_VISITOR_Type_STRUCT_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_STRUCT_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_STRUCT_after ebm2all::Context_Type_STRUCT_after
    #define EBM2ALL_CODEGEN_VISITOR_Type_RECURSIVE_STRUCT ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_RECURSIVE_STRUCT>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_RECURSIVE_STRUCT ebm2all::Context_Type_RECURSIVE_STRUCT
    #define EBM2ALL_CODEGEN_VISITOR_Type_RECURSIVE_STRUCT_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_RECURSIVE_STRUCT_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_RECURSIVE_STRUCT_before ebm2all::Context_Type_RECURSIVE_STRUCT_before
    #define EBM2ALL_CODEGEN_VISITOR_Type_RECURSIVE_STRUCT_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_RECURSIVE_STRUCT_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_RECURSIVE_STRUCT_after ebm2all::Context_Type_RECURSIVE_STRUCT_after
    #define EBM2ALL_CODEGEN_VISITOR_Type_BOOL ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_BOOL>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_BOOL ebm2all::Context_Type_BOOL
    #define EBM2ALL_CODEGEN_VISITOR_Type_BOOL_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_BOOL_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_BOOL_before ebm2all::Context_Type_BOOL_before
    #define EBM2ALL_CODEGEN_VISITOR_Type_BOOL_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_BOOL_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_BOOL_after ebm2all::Context_Type_BOOL_after
    #define EBM2ALL_CODEGEN_VISITOR_Type_VOID ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_VOID>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_VOID ebm2all::Context_Type_VOID
    #define EBM2ALL_CODEGEN_VISITOR_Type_VOID_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_VOID_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_VOID_before ebm2all::Context_Type_VOID_before
    #define EBM2ALL_CODEGEN_VISITOR_Type_VOID_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_VOID_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_VOID_after ebm2all::Context_Type_VOID_after
    #define EBM2ALL_CODEGEN_VISITOR_Type_META ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_META>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_META ebm2all::Context_Type_META
    #define EBM2ALL_CODEGEN_VISITOR_Type_META_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_META_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_META_before ebm2all::Context_Type_META_before
    #define EBM2ALL_CODEGEN_VISITOR_Type_META_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_META_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_META_after ebm2all::Context_Type_META_after
    #define EBM2ALL_CODEGEN_VISITOR_Type_ENUM ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_ENUM>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_ENUM ebm2all::Context_Type_ENUM
    #define EBM2ALL_CODEGEN_VISITOR_Type_ENUM_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_ENUM_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_ENUM_before ebm2all::Context_Type_ENUM_before
    #define EBM2ALL_CODEGEN_VISITOR_Type_ENUM_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_ENUM_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_ENUM_after ebm2all::Context_Type_ENUM_after
    #define EBM2ALL_CODEGEN_VISITOR_Type_ARRAY ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_ARRAY>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_ARRAY ebm2all::Context_Type_ARRAY
    #define EBM2ALL_CODEGEN_VISITOR_Type_ARRAY_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_ARRAY_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_ARRAY_before ebm2all::Context_Type_ARRAY_before
    #define EBM2ALL_CODEGEN_VISITOR_Type_ARRAY_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_ARRAY_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_ARRAY_after ebm2all::Context_Type_ARRAY_after
    #define EBM2ALL_CODEGEN_VISITOR_Type_VECTOR ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_VECTOR>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_VECTOR ebm2all::Context_Type_VECTOR
    #define EBM2ALL_CODEGEN_VISITOR_Type_VECTOR_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_VECTOR_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_VECTOR_before ebm2all::Context_Type_VECTOR_before
    #define EBM2ALL_CODEGEN_VISITOR_Type_VECTOR_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_VECTOR_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_VECTOR_after ebm2all::Context_Type_VECTOR_after
    #define EBM2ALL_CODEGEN_VISITOR_Type_VARIANT ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_VARIANT>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_VARIANT ebm2all::Context_Type_VARIANT
    #define EBM2ALL_CODEGEN_VISITOR_Type_VARIANT_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_VARIANT_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_VARIANT_before ebm2all::Context_Type_VARIANT_before
    #define EBM2ALL_CODEGEN_VISITOR_Type_VARIANT_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_VARIANT_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_VARIANT_after ebm2all::Context_Type_VARIANT_after
    #define EBM2ALL_CODEGEN_VISITOR_Type_RANGE ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_RANGE>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_RANGE ebm2all::Context_Type_RANGE
    #define EBM2ALL_CODEGEN_VISITOR_Type_RANGE_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_RANGE_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_RANGE_before ebm2all::Context_Type_RANGE_before
    #define EBM2ALL_CODEGEN_VISITOR_Type_RANGE_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_RANGE_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_RANGE_after ebm2all::Context_Type_RANGE_after
    #define EBM2ALL_CODEGEN_VISITOR_Type_ENCODER_RETURN ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_ENCODER_RETURN>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_ENCODER_RETURN ebm2all::Context_Type_ENCODER_RETURN
    #define EBM2ALL_CODEGEN_VISITOR_Type_ENCODER_RETURN_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_ENCODER_RETURN_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_ENCODER_RETURN_before ebm2all::Context_Type_ENCODER_RETURN_before
    #define EBM2ALL_CODEGEN_VISITOR_Type_ENCODER_RETURN_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_ENCODER_RETURN_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_ENCODER_RETURN_after ebm2all::Context_Type_ENCODER_RETURN_after
    #define EBM2ALL_CODEGEN_VISITOR_Type_DECODER_RETURN ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_DECODER_RETURN>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_DECODER_RETURN ebm2all::Context_Type_DECODER_RETURN
    #define EBM2ALL_CODEGEN_VISITOR_Type_DECODER_RETURN_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_DECODER_RETURN_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_DECODER_RETURN_before ebm2all::Context_Type_DECODER_RETURN_before
    #define EBM2ALL_CODEGEN_VISITOR_Type_DECODER_RETURN_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_DECODER_RETURN_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_DECODER_RETURN_after ebm2all::Context_Type_DECODER_RETURN_after
    #define EBM2ALL_CODEGEN_VISITOR_Type_ENCODER_INPUT ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_ENCODER_INPUT>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_ENCODER_INPUT ebm2all::Context_Type_ENCODER_INPUT
    #define EBM2ALL_CODEGEN_VISITOR_Type_ENCODER_INPUT_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_ENCODER_INPUT_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_ENCODER_INPUT_before ebm2all::Context_Type_ENCODER_INPUT_before
    #define EBM2ALL_CODEGEN_VISITOR_Type_ENCODER_INPUT_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_ENCODER_INPUT_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_ENCODER_INPUT_after ebm2all::Context_Type_ENCODER_INPUT_after
    #define EBM2ALL_CODEGEN_VISITOR_Type_DECODER_INPUT ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_DECODER_INPUT>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_DECODER_INPUT ebm2all::Context_Type_DECODER_INPUT
    #define EBM2ALL_CODEGEN_VISITOR_Type_DECODER_INPUT_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_DECODER_INPUT_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_DECODER_INPUT_before ebm2all::Context_Type_DECODER_INPUT_before
    #define EBM2ALL_CODEGEN_VISITOR_Type_DECODER_INPUT_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_DECODER_INPUT_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_DECODER_INPUT_after ebm2all::Context_Type_DECODER_INPUT_after
    #define EBM2ALL_CODEGEN_VISITOR_Type_PROPERTY_SETTER_RETURN ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_PROPERTY_SETTER_RETURN>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_PROPERTY_SETTER_RETURN ebm2all::Context_Type_PROPERTY_SETTER_RETURN
    #define EBM2ALL_CODEGEN_VISITOR_Type_PROPERTY_SETTER_RETURN_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_PROPERTY_SETTER_RETURN_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_PROPERTY_SETTER_RETURN_before ebm2all::Context_Type_PROPERTY_SETTER_RETURN_before
    #define EBM2ALL_CODEGEN_VISITOR_Type_PROPERTY_SETTER_RETURN_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_PROPERTY_SETTER_RETURN_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_PROPERTY_SETTER_RETURN_after ebm2all::Context_Type_PROPERTY_SETTER_RETURN_after
    #define EBM2ALL_CODEGEN_VISITOR_Type_OPTIONAL ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_OPTIONAL>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_OPTIONAL ebm2all::Context_Type_OPTIONAL
    #define EBM2ALL_CODEGEN_VISITOR_Type_OPTIONAL_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_OPTIONAL_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_OPTIONAL_before ebm2all::Context_Type_OPTIONAL_before
    #define EBM2ALL_CODEGEN_VISITOR_Type_OPTIONAL_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_OPTIONAL_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_OPTIONAL_after ebm2all::Context_Type_OPTIONAL_after
    #define EBM2ALL_CODEGEN_VISITOR_Type_PTR ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_PTR>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_PTR ebm2all::Context_Type_PTR
    #define EBM2ALL_CODEGEN_VISITOR_Type_PTR_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_PTR_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_PTR_before ebm2all::Context_Type_PTR_before
    #define EBM2ALL_CODEGEN_VISITOR_Type_PTR_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_PTR_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_PTR_after ebm2all::Context_Type_PTR_after
    #define EBM2ALL_CODEGEN_VISITOR_Type_FUNCTION ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_FUNCTION>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_FUNCTION ebm2all::Context_Type_FUNCTION
    #define EBM2ALL_CODEGEN_VISITOR_Type_FUNCTION_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_FUNCTION_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_FUNCTION_before ebm2all::Context_Type_FUNCTION_before
    #define EBM2ALL_CODEGEN_VISITOR_Type_FUNCTION_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_FUNCTION_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_FUNCTION_after ebm2all::Context_Type_FUNCTION_after
    #define EBM2ALL_CODEGEN_VISITOR_Type ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type ebm2all::Context_Type
    #define EBM2ALL_CODEGEN_VISITOR_Type_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_before ebm2all::Context_Type_before
    #define EBM2ALL_CODEGEN_VISITOR_Type_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Type_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Type_after ebm2all::Context_Type_after
    #define EBM2ALL_CODEGEN_VISITOR_Types ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Types>>
    #define EBM2ALL_CODEGEN_CONTEXT_Types ebm2all::Context_Types
    #define EBM2ALL_CODEGEN_VISITOR_Types_before ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Types_before>>
    #define EBM2ALL_CODEGEN_CONTEXT_Types_before ebm2all::Context_Types_before
    #define EBM2ALL_CODEGEN_VISITOR_Types_after ebm2all::Visitor<ebm2all::UserHook<ebm2all::VisitorTag_Types_after>>
    #define EBM2ALL_CODEGEN_CONTEXT_Types_after ebm2all::Context_Types_after
    #define CODEGEN_NAMESPACE ebm2all
    #define CODEGEN_VISITOR(name) EBM2ALL_CODEGEN_VISITOR_##name
    #define CODEGEN_CONTEXT_PARAMETERS(name) EBM2ALL_CODEGEN_CONTEXT_PARAMETERS_##name
    #define CODEGEN_CONTEXT(name) EBM2ALL_CODEGEN_CONTEXT_##name
}  // namespace ebm2all
#if __has_include("visitor/post_includes_before.hpp")
#include "visitor/post_includes_before.hpp"
#elif __has_include("visitor/dsl/post_includes_before_dsl.hpp")
#include "visitor/dsl/post_includes_before_dsl.hpp"
#elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorpost_includes_before.hpp")
#include "src/ebmcodegen/default_codegen_visitor/visitorpost_includes_before.hpp"
#endif
#if __has_include("visitor/post_includes.hpp")
#include "visitor/post_includes.hpp"
#elif __has_include("visitor/dsl/post_includes_dsl.hpp")
#include "visitor/dsl/post_includes_dsl.hpp"
#elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorpost_includes.hpp")
#include "src/ebmcodegen/default_codegen_visitor/visitorpost_includes.hpp"
#endif
#if __has_include("visitor/post_includes_after.hpp")
#include "visitor/post_includes_after.hpp"
#elif __has_include("visitor/dsl/post_includes_after_dsl.hpp")
#include "visitor/dsl/post_includes_after_dsl.hpp"
#elif __has_include("src/ebmcodegen/default_codegen_visitor/visitorpost_includes_after.hpp")
#include "src/ebmcodegen/default_codegen_visitor/visitorpost_includes_after.hpp"
#endif
#endif // EBM_CODEGEN_COMMON_INCLUDE_GUARD
