/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_PROGRAM_DECL_class
  Available Variables:
    ctx: Context_Statement_PROGRAM_DECL
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        module_: ebmgen::MappingTable
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
      item_id: ebm::StatementRef
      kind: const ebm::StatementKind&
      block: const ebm::Block&
        len: Varint
        container: std::vector<StatementRef>
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include <unordered_map>
#include "../codegen.hpp"
#include "ebm/extended_binary_module.hpp"
#include "ebmcg/ebm2c/codegen.hpp"
#include "ebmcodegen/stub/dependency.hpp"
#include "ebmgen/common.hpp"
#include "includes.hpp"
DEFINE_VISITOR_CLASS(Statement_PROGRAM_DECL) {
    using Context = CODEGEN_CONTEXT(Statement_PROGRAM_DECL);
    struct C_Context {
        std::vector<ebm2c::Struct> structs;
        std::unordered_map<std::uint64_t, ebm2c::Union> unions;
        std::vector<ebm2c::VectorType> vector_types;
        std::vector<ebm2c::Enum> enums;
    };

    DEFINE_VISITOR_FUNCTION(Statement_PROGRAM_DECL) {
        using namespace CODEGEN_NAMESPACE;
        C_Context c_ctx;
        MAYBE_VOID(ok, collect_structs(ctx, c_ctx));

        auto get_field_type = [&](ebm::StatementRef field_ref) -> expected<std::pair<Result, ebm::TypeRef>> {
            if (auto field = ctx.get_field<"field_decl.field_type">(field_ref)) {
                return ctx.visit(*field).transform([&](auto&& x) {
                    return std::make_pair(x, *field);
                });
            }
            else if (auto composite = ctx.get_field<"composite_field_decl.composite_type">(field_ref)) {
                return ctx.visit(*composite).transform([&](auto&& x) {
                    return std::make_pair(x, *composite);
                });
            }
            else {
                return unexpect_error("failed to get field type");
            }
        };
        CodeWriter w;
        w.writeln("#include <stdint.h>");
        w.writeln("");
        w.writeln("// Forward declarations");
        for (auto& s : c_ctx.structs) {
            auto ident = ctx.identifier(s.id);
            w.writeln("typedef struct ", ident, " ", ident, ";");
        }

        // enums first
        for (auto& e : c_ctx.enums) {
            MAYBE(enum_, ctx.visit(e.id));
            w.writeln(enum_.to_writer());
        }
        for (auto& e : c_ctx.enums) {
            auto ident = ctx.identifier(e.id);
            w.writeln("typedef enum ", ident, " ", ident, ";");
        }
        w.writeln("");

        w.writeln("typedef struct EncoderInput {");
        {
            auto scope = w.indent_scope();
            w.writeln("uint8_t* data;");
            w.writeln("uint8_t* data_end;");
            w.writeln("size_t offset;");
        }
        w.writeln("} EncoderInput;");
        w.writeln("");

        if (c_ctx.vector_types.size() > 0) {
            w.writeln("// Vector type definitions");
            w.writeln("#define VECTOR_OF(type) type##_vector");
            w.writeln("typedef struct {");
            {
                auto scope = w.indent_scope();
                w.writeln("void* data;");
                w.writeln("size_t size;");
                w.writeln("size_t capacity;");
            }
            w.writeln("} VECTOR_OF(void);");
        }
        w.writeln("typedef struct DecoderInput {");
        {
            auto scope = w.indent_scope();
            w.writeln("const uint8_t* data;");
            w.writeln("const uint8_t* data_end;");
            w.writeln("size_t offset;");
            if (c_ctx.vector_types.size() > 0) {
                w.writeln("int (*append)(struct DecoderInput* self, VECTOR_OF(void)* vector, const void* data,size_t size);");
            }
        }
        w.writeln("} DecoderInput;");
        w.writeln("");
        if (c_ctx.vector_types.size() > 0) {
            for (auto& v : c_ctx.vector_types) {
                MAYBE(elem_type, ctx.visit(v.elem_type));
                w.writeln("typedef struct {");
                {
                    auto scope = w.indent_scope();
                    w.writeln(elem_type.to_writer(), "* data;");
                    w.writeln(ctx.config().usize_type_name, " size;");
                    w.writeln(ctx.config().usize_type_name, " capacity;");
                }
                w.writeln("} VECTOR_OF(", elem_type.to_writer(), ");");
                w.writeln("");
            }
            w.writeln("#ifndef VECTOR_APPEND");
            w.writeln("#define VECTOR_APPEND(vector, value) do { \\");
            {
                auto scope = w.indent_scope();
                w.writeln("if (!input->append) {\\");
                w.indent_writeln("return -1; \\");
                w.writeln("} \\");
                w.writeln("int res = input->append(input, &(vector), (VECTOR_OF(void)*) &(value), sizeof((value))); \\");
                w.writeln("if (res != 0) { \\");
                w.indent_writeln("return res; \\");
                w.writeln("} \\");
            }
            w.writeln("} while(0)");
            w.writeln("#endif");
            w.writeln("");
        }
        std::vector<ebm::StatementRef> composite_fns;
        auto collect_composite_fn = [&](ebm::StatementRef composite) -> expected<void> {
            auto comp = ctx.get_field<"composite_field_decl">(composite);
            if (!comp) {
                return {};
            }
            for (auto& f : comp->fields.container) {
                auto decl = ctx.get_field<"field_decl">(f);
                if (!decl) {
                    continue;
                }
                auto getter = decl->composite_getter();
                auto setter = decl->composite_setter();
                if (getter) {
                    composite_fns.push_back(getter->id);
                }
                if (setter) {
                    composite_fns.push_back(setter->id);
                }
            }
            return {};
        };
        auto write_union = [&](Union& u) -> expected<void> {
            auto ident = std::format("Union{}", get_id(u.id));
            w.writeln("union ", ident, " {");
            auto scope = w.indent_scope();
            for (auto& v : u.variants) {
                auto var_ident = ctx.identifier(v.id);
                w.writeln("struct {");
                auto var_scope = w.indent_scope();
                for (auto& f : v.fields) {
                    auto field_ident = ctx.identifier(f.id);
                    MAYBE(typ, get_field_type(f.id));
                    w.writeln(typ.first.to_writer(), " ", field_ident, ";");
                    MAYBE_VOID(ok, collect_composite_fn(f.id));
                }
                var_scope.execute();
                w.writeln("}", var_ident, ";");
            }
            scope.execute();
            w.writeln("};");
            w.writeln("");
            return {};
        };
        for (auto& s : c_ctx.structs) {
            auto ident = ctx.identifier(s.id);
            w.writeln("struct ", ident, " {");
            auto scope = w.indent_scope();
            for (auto& f : s.fields) {
                auto field_ident = ctx.identifier(f.id);
                MAYBE(typ, get_field_type(f.id));
                if (auto found = c_ctx.unions.find(ebmgen::get_id(typ.second)); found != c_ctx.unions.end()) {
                    MAYBE_VOID(ok, write_union(found->second));
                }
                w.writeln(typ.first.to_writer(), " ", field_ident, ";");
                MAYBE_VOID(ok, collect_composite_fn(f.id));
            }
            scope.execute();
            w.writeln("};");
            w.writeln("");
        }
        for (auto& composite_fn_ref : composite_fns) {
            MAYBE(func, ctx.visit(composite_fn_ref));
            w.writeln(func.to_writer());
        }
        // write encoding/decoding functions if any
        for (auto& s : c_ctx.structs) {
            if (s.encode_function) {
                MAYBE(func, ctx.visit(*s.encode_function));
                w.writeln(func.to_writer());
            }
            if (s.decode_function) {
                MAYBE(func, ctx.visit(*s.decode_function));
                w.writeln(func.to_writer());
            }
        }
        return w;
    };

    ebmgen::expected<void> collect_structs(Context & ctx, C_Context & c_ctx) {
        auto handle_struct_decl = [&](std::vector<ebm2c::Struct>& structs, ebm::StatementRef stmt_ref) {
            auto struct_ = ctx.get_field<"struct_decl">(stmt_ref);
            if (!struct_) {
                return;
            }
            Struct s;
            s.id = stmt_ref;
            for (auto& decl_ref : struct_->fields.container) {
                auto composite = ctx.get_field<"composite_field_decl">(decl_ref);
                if (composite && composite->kind != ebm::CompositeFieldKind::BULK_PRIMITIVE) {
                    for (auto& inner_field : composite->fields.container) {
                        s.fields.push_back(Field{.id = inner_field});
                    }
                    continue;
                }
                s.fields.push_back(Field{.id = decl_ref});
            }
            if (auto encode_func = struct_->encode_fn()) {
                s.encode_function = *encode_func;
            }
            if (auto decode_func = struct_->decode_fn()) {
                s.decode_function = *decode_func;
            }
            structs.push_back(s);
        };
        MAYBE(sorted, sorted_struct(ctx));
        for (auto stmt_ref : sorted) {
            handle_struct_decl(c_ctx.structs, stmt_ref);
        }
        for (auto& e : ctx.module().module().statements) {
            auto enum_decl = ctx.get_field<"enum_decl">(e.id);
            if (!enum_decl) {
                continue;
            }
            ebm2c::Enum en{.id = e.id};
            c_ctx.enums.push_back(en);
        }
        for (auto& s : ctx.module().module().types) {
            if (s.body.kind == ebm::TypeKind::VECTOR) {
                MAYBE(elem_type, s.body.element_type());
                ebm2c::VectorType v{.elem_type = elem_type};
                c_ctx.vector_types.push_back(v);
                continue;
            }
            auto variant_desc = s.body.variant_desc();
            if (!variant_desc) {
                continue;
            }
            Union u{.id = s.id};
            for (auto member_type_ref : variant_desc->members.container) {
                auto struct_key = ctx.get_field<"body.id">(member_type_ref);
                if (!struct_key) {
                    continue;
                }
                handle_struct_decl(u.variants, *struct_key);
            }
            c_ctx.unions[ebmgen::get_id(s.id)] = u;
        }
        return {};
    }
};
