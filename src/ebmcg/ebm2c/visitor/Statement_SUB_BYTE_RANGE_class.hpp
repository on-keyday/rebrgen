/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_SUB_BYTE_RANGE_class
  Available Variables:
    ctx: Context_Statement_SUB_BYTE_RANGE
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
        module_: ebmgen::MappingTable
      item_id: ebm::StatementRef
      kind: const ebm::StatementKind&
      sub_byte_range: const ebm::SubByteRange&
        stream_type: StreamType
        range_type: SubByteRangeType
        expression: *ExpressionRef
        length: *ExpressionRef
        offset: *ExpressionRef
        io_ref: StatementRef
        parent_io_ref: WeakStatementRef
        io_statement: StatementRef
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

#include "../codegen.hpp"
DEFINE_VISITOR(Statement_SUB_BYTE_RANGE) {
    using namespace CODEGEN_NAMESPACE;
    auto io_name = ctx.identifier(ctx.sub_byte_range.io_ref);
    auto io_name_base = io_name + "_base";

    auto parent_io_name = ctx.identifier(ctx.sub_byte_range.parent_io_ref);
    std::string type_name = ctx.sub_byte_range.stream_type == ebm::StreamType::OUTPUT ? ctx.config().encoder_input_type : ctx.config().decoder_input_type;
    // remove * from type name if it is pointer type, because we declare variable here
    if (type_name.ends_with("*")) {
        type_name.pop_back();
    }

    CodeWriter w;
    if (ctx.config().on_destructor_generation) {
        // simply point to parent io
        w.write(type_name, "* ", io_name, " = ", parent_io_name, ";");
        return w;
    }

    w.write(type_name, " ", io_name_base, " = *", parent_io_name, ";");
    w.write(type_name, "* ", io_name, " = &", io_name_base, ";");
    w.writeln("");

    if (ctx.sub_byte_range.range_type == ebm::SubByteRangeType::bytes) {
        MAYBE(len, ctx.visit(*ctx.sub_byte_range.length()));
        w.writeln(io_name_base, ".data = ", parent_io_name, "->data + ", parent_io_name, "->offset;");
        w.writeln(io_name_base, ".data_end = ", io_name_base, ".data + ", len.to_writer(), ";");
        // strictly clamp to data_end of parent here
        w.writeln("if (", parent_io_name, "->data_end < ", io_name_base, ".data_end) {");
        w.indent_writeln("EBM_EMIT_ERROR(\"Sub-byte range exceeds parent IO data end\");");
        w.indent_writeln("return -1;");
        w.writeln("}");
        w.writeln(io_name_base, ".offset = 0;");
        // Advance parent
        w.write(parent_io_name, "->offset += ", len.to_writer(), ";");
        w.writeln("");
    }
    else if (ctx.sub_byte_range.range_type == ebm::SubByteRangeType::seek_bytes) {
        MAYBE(len, ctx.visit(*ctx.sub_byte_range.length()));
        MAYBE(off, ctx.visit(*ctx.sub_byte_range.offset()));
        w.write(io_name_base, ".data = ", parent_io_name, "->data + ", off.to_writer(), ";");
        w.writeln("");
        w.write(io_name_base, ".data_end = ", io_name_base, ".data + ", len.to_writer(), ";");
        w.writeln("");
        // strictly clamp to data_end of parent here
        w.writeln("if (", parent_io_name, "->data_end < ", io_name_base, ".data_end) {");
        w.indent_writeln("EBM_EMIT_ERROR(\"Sub-byte range exceeds parent IO data end\");");
        w.indent_writeln("return -1;");
        w.writeln("}");
        w.write(io_name_base, ".offset = 0;");
        w.writeln("");
    }

    MAYBE(io_stmt, ctx.visit(ctx.sub_byte_range.io_statement));
    w.write(io_stmt.to_writer());

    return w;
}
