/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_READ_DATA
  Available variables:
    *this: Visitor
    module_: MappingTable
    item_id: StatementRef
    generator_default_logic: std::function<expected<Result>()>
    default_logic: std::function<expected<Result>()>
    kind: StatementKind
    read_data: IOData
      io_ref: StatementRef
      target: ExpressionRef
      data_type: TypeRef
      attribute: IOAttribute
        endian: Endian
        sign: bool
        is_peek: bool
        has_lowered_statement: bool
        reserved: std::uint8_t
        dynamic_ref: *StatementRef
      size: Size
        unit: SizeUnit
        ref: *ExpressionRef
        size: *Varint
      lowered_statement: *LoweredIOStatement
        lowering_type: LoweringIOType
        io_statement: LoweredStatementRef
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

/*here to write the hook*/

if (auto lw = read_data.lowered_statement()) {
    return visit_Statement(*this, lw->io_statement.id);
}

MAYBE(target, visit_Expression(*this, read_data.target));
MAYBE(type, module_.get_type(read_data.data_type));
auto io_name = module_.get_associated_identifier(read_data.io_ref);
MAYBE(size, get_size_str(*this, read_data.size));

CodeWriter w;

if (auto cand = is_bytes_type(*this, read_data.data_type)) {
    if (cand == BytesType::array) {
        w.writeln(io_name, ".read_exact(&mut ", target.to_writer(), ")?;");
    }
    else {
        w.writeln(target.to_writer(), ".resize(", size, ",0);");
        w.writeln(io_name, ".read_exact(&mut ", target.to_writer(), ")?;");
    }
}
else {
    return unexpect_error("unsupported type for READ_DATA: {}", to_string(type.body.kind));
}

return w;