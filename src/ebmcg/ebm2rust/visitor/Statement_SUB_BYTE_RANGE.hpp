/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_SUB_BYTE_RANGE
  Available variables:
    *this: Visitor
    module_: MappingTable
    item_id: StatementRef
    kind: StatementKind
    sub_byte_range: SubByteRange
      stream_type: StreamType
      range_type: SubByteRangeType
      expression: *ExpressionRef
      length: *ExpressionRef
      offset: *ExpressionRef
      io_ref: StatementRef
      parent_io_ref: StatementRef
      io_statement: StatementRef
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

/*here to write the hook*/

auto io_ = module_.get_associated_identifier(sub_byte_range.io_ref);
MAYBE(do_io, visit_Statement(*this, sub_byte_range.io_statement));

CodeWriter w;
auto parent_io_ = module_.get_associated_identifier(sub_byte_range.parent_io_ref);
MAYBE(length, sub_byte_range.length());
MAYBE(length_str, visit_Expression(*this, length));

if (sub_byte_range.stream_type == ebm::StreamType::INPUT) {
    w.writeln("let mut ", io_, " = Vec::new();");
    w.writeln(io_, ".resize(", length_str.to_writer(), ",0);");
    w.writeln(parent_io_, ".read_exact(&mut ", io_, ")?;");
    w.writeln("let mut ", io_, " = std::io::Cursor::new(", io_, ");");
}
else {
    w.writeln("let mut ", io_, " = std::io::Cursor::new(Vec::new());");
}
w.write(do_io.to_writer());
if (sub_byte_range.stream_type == ebm::StreamType::OUTPUT) {
    w.writeln("if (", length_str.to_writer(), " as usize) != ", io_, ".get_ref().len() {");
    w.indent_writeln("return Err(anyhow::anyhow!(\"written length mismatch: {} != {}\", ", length_str.to_writer(), ", ", io_, ".get_ref().len()));");
    w.writeln("}");
    w.writeln(parent_io_, ".write_all(&", io_, ".get_ref())?;");
}

return w;