/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_FUNCTION_DECL_class
  Available Variables:
    ctx: Context_Statement_FUNCTION_DECL
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
        module_: ebmgen::MappingTable
      item_id: ebm::StatementRef
      kind: const ebm::StatementKind&
      func_decl: const ebm::FunctionDecl&
        name: IdentifierRef
        return_type: TypeRef
        params: Block
          len: Varint
          container: std::vector<StatementRef>
        parent_format: WeakStatementRef
        kind: FunctionKind
        property: *WeakStatementRef
        body: StatementRef
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

/*here to write the hook*/

#include "../codegen.hpp"
DEFINE_VISITOR(Statement_FUNCTION_DECL) {
    auto name = ctx.identifier();
    MAYBE(return_type_str, ctx.visit(ctx.func_decl.return_type));

    // first, traverse body to determine parameter types
    auto prev = ctx.config().current_function;
    const auto restore = futils::helper::defer([&]() {
        ctx.config().current_function = prev;
    });
    ctx.config().current_function = ctx.item_id;
    MAYBE(body_str, ctx.visit(ctx.func_decl.body));

    CodeWriter w;
    if (ctx.func_decl.kind == ebm::FunctionKind::PROPERTY_SETTER) {
        if (name.starts_with("r#")) {
            name = name.substr(2);
        }
        name = "set_" + name;
    }
    w.write("pub fn ", name, "(");

    // Parameters
    bool first_param = true;
    if (!is_nil(ctx.func_decl.parent_format)) {  // Check if it's a method (has a parent format)
        if (ctx.func_decl.kind == ebm::FunctionKind::METHOD || ctx.func_decl.kind == ebm::FunctionKind::ENCODE || ctx.func_decl.kind == ebm::FunctionKind::PROPERTY_GETTER) {
            w.write("&self");
        }
        else {
            w.write("&mut self");
        }
        first_param = false;
    }

    for (auto& param_ref : ctx.func_decl.params.container) {
        MAYBE(param_stmt, ctx.get(param_ref));
        if (param_stmt.body.kind == ebm::StatementKind::PARAMETER_DECL) {
            auto param_name = ctx.identifier(param_ref);
            MAYBE(param_decl, param_stmt.body.param_decl());
            MAYBE(param_type_str, ctx.visit(param_decl.param_type));  // Correctly extract the string value
            if (!first_param) {
                w.write(", ");
            }
            w.write(param_name, ": ");
            if (param_decl.is_state_variable()) {
                w.write("&mut ");
            }
            w.write(param_type_str.to_writer());
            first_param = false;
        }
    }
    w.writeln(") -> ", return_type_str.to_writer(), " {");
    {
        auto scope = w.indent_scope();
        w.write(body_str.to_writer());
    }
    w.writeln("}");

    return w;
}