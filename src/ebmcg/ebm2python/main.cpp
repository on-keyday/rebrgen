/*license*/
// Code generated by ebmcodegen at https://github.com/on-keyday/rebrgen
#include <ebmcodegen/stub/entry.hpp>
#include <ebmgen/common.hpp>
#include <ebmgen/convert/helper.hpp>
#include <ebmgen/mapping.hpp>
#include <code/code_writer.h>
#if __has_include("visitor/includes.hpp")
#include "visitor/includes.hpp"
#elif __has_include("ebmcodegen/default_visitor/includes.hpp")
#include "ebmcodegen/default_visitor/includes.hpp"
#endif

struct Flags : ebmcodegen::Flags {
#if __has_include("visitor/Flags.hpp")
#include "visitor/Flags.hpp"
#elif __has_include("ebmcodegen/default_visitor/Flags.hpp")
#include "ebmcodegen/default_visitor/Flags.hpp"
#endif
};
struct Output : ebmcodegen::Output {
#if __has_include("visitor/Output.hpp")
#include "visitor/Output.hpp"
#elif __has_include("ebmcodegen/default_visitor/Output.hpp")
#include "ebmcodegen/default_visitor/Output.hpp"
#endif
};
namespace ebm2python {
    using namespace ebmgen;
    template<typename Visitor>
    expected<void> visit_Statement(Visitor&& visitor,const ebm::Statement& in);
    template<typename Visitor>
    concept has_visitor_Statement_BLOCK = requires(Visitor v) {
         { v.visit_Statement_BLOCK(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().block()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_BLOCK_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().block()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_BLOCK(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_BLOCK_pre_validate.hpp")
        #include "visitor/Statement_BLOCK_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_BLOCK_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_BLOCK_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.block()) {
            return unexpect_error("Unexpected null pointer for StatementBody::block");
        }
        auto& block = *in.body.block();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_BLOCK_pre_visit.hpp")
        #include "visitor/Statement_BLOCK_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_BLOCK_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_BLOCK_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_BLOCK<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_BLOCK(in.id,kind,block));
        }
        else if constexpr (has_visitor_Statement_BLOCK_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,block));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_BLOCK_post_visit.hpp")
        #include "visitor/Statement_BLOCK_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_BLOCK_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_BLOCK_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_ASSIGNMENT = requires(Visitor v) {
         { v.visit_Statement_ASSIGNMENT(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().previous_assignment(),*std::declval<const ebm::StatementBody&>().target(),*std::declval<const ebm::StatementBody&>().value()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_ASSIGNMENT_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().previous_assignment(),*std::declval<const ebm::StatementBody&>().target(),*std::declval<const ebm::StatementBody&>().value()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_ASSIGNMENT(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_ASSIGNMENT_pre_validate.hpp")
        #include "visitor/Statement_ASSIGNMENT_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_ASSIGNMENT_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_ASSIGNMENT_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.previous_assignment()) {
            return unexpect_error("Unexpected null pointer for StatementBody::previous_assignment");
        }
        auto& previous_assignment = *in.body.previous_assignment();
        if (!in.body.target()) {
            return unexpect_error("Unexpected null pointer for StatementBody::target");
        }
        auto& target = *in.body.target();
        if (!in.body.value()) {
            return unexpect_error("Unexpected null pointer for StatementBody::value");
        }
        auto& value = *in.body.value();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_ASSIGNMENT_pre_visit.hpp")
        #include "visitor/Statement_ASSIGNMENT_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_ASSIGNMENT_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_ASSIGNMENT_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_ASSIGNMENT<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_ASSIGNMENT(in.id,kind,previous_assignment,target,value));
        }
        else if constexpr (has_visitor_Statement_ASSIGNMENT_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,previous_assignment,target,value));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_ASSIGNMENT_post_visit.hpp")
        #include "visitor/Statement_ASSIGNMENT_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_ASSIGNMENT_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_ASSIGNMENT_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_APPEND = requires(Visitor v) {
         { v.visit_Statement_APPEND(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().target(),*std::declval<const ebm::StatementBody&>().value()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_APPEND_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().target(),*std::declval<const ebm::StatementBody&>().value()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_APPEND(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_APPEND_pre_validate.hpp")
        #include "visitor/Statement_APPEND_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_APPEND_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_APPEND_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.target()) {
            return unexpect_error("Unexpected null pointer for StatementBody::target");
        }
        auto& target = *in.body.target();
        if (!in.body.value()) {
            return unexpect_error("Unexpected null pointer for StatementBody::value");
        }
        auto& value = *in.body.value();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_APPEND_pre_visit.hpp")
        #include "visitor/Statement_APPEND_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_APPEND_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_APPEND_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_APPEND<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_APPEND(in.id,kind,target,value));
        }
        else if constexpr (has_visitor_Statement_APPEND_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,target,value));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_APPEND_post_visit.hpp")
        #include "visitor/Statement_APPEND_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_APPEND_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_APPEND_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_RETURN = requires(Visitor v) {
         { v.visit_Statement_RETURN(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().value()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_RETURN_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().value()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_RETURN(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_RETURN_pre_validate.hpp")
        #include "visitor/Statement_RETURN_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_RETURN_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_RETURN_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.value()) {
            return unexpect_error("Unexpected null pointer for StatementBody::value");
        }
        auto& value = *in.body.value();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_RETURN_pre_visit.hpp")
        #include "visitor/Statement_RETURN_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_RETURN_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_RETURN_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_RETURN<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_RETURN(in.id,kind,value));
        }
        else if constexpr (has_visitor_Statement_RETURN_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,value));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_RETURN_post_visit.hpp")
        #include "visitor/Statement_RETURN_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_RETURN_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_RETURN_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_ERROR_RETURN = requires(Visitor v) {
         { v.visit_Statement_ERROR_RETURN(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().value()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_ERROR_RETURN_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().value()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_ERROR_RETURN(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_ERROR_RETURN_pre_validate.hpp")
        #include "visitor/Statement_ERROR_RETURN_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_ERROR_RETURN_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_ERROR_RETURN_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.value()) {
            return unexpect_error("Unexpected null pointer for StatementBody::value");
        }
        auto& value = *in.body.value();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_ERROR_RETURN_pre_visit.hpp")
        #include "visitor/Statement_ERROR_RETURN_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_ERROR_RETURN_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_ERROR_RETURN_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_ERROR_RETURN<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_ERROR_RETURN(in.id,kind,value));
        }
        else if constexpr (has_visitor_Statement_ERROR_RETURN_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,value));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_ERROR_RETURN_post_visit.hpp")
        #include "visitor/Statement_ERROR_RETURN_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_ERROR_RETURN_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_ERROR_RETURN_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_ASSERT = requires(Visitor v) {
         { v.visit_Statement_ASSERT(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().assert_desc()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_ASSERT_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().assert_desc()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_ASSERT(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_ASSERT_pre_validate.hpp")
        #include "visitor/Statement_ASSERT_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_ASSERT_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_ASSERT_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.assert_desc()) {
            return unexpect_error("Unexpected null pointer for StatementBody::assert_desc");
        }
        auto& assert_desc = *in.body.assert_desc();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_ASSERT_pre_visit.hpp")
        #include "visitor/Statement_ASSERT_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_ASSERT_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_ASSERT_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_ASSERT<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_ASSERT(in.id,kind,assert_desc));
        }
        else if constexpr (has_visitor_Statement_ASSERT_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,assert_desc));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_ASSERT_post_visit.hpp")
        #include "visitor/Statement_ASSERT_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_ASSERT_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_ASSERT_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_READ_DATA = requires(Visitor v) {
         { v.visit_Statement_READ_DATA(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().read_data()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_READ_DATA_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().read_data()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_READ_DATA(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_READ_DATA_pre_validate.hpp")
        #include "visitor/Statement_READ_DATA_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_READ_DATA_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_READ_DATA_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.read_data()) {
            return unexpect_error("Unexpected null pointer for StatementBody::read_data");
        }
        auto& read_data = *in.body.read_data();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_READ_DATA_pre_visit.hpp")
        #include "visitor/Statement_READ_DATA_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_READ_DATA_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_READ_DATA_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_READ_DATA<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_READ_DATA(in.id,kind,read_data));
        }
        else if constexpr (has_visitor_Statement_READ_DATA_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,read_data));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_READ_DATA_post_visit.hpp")
        #include "visitor/Statement_READ_DATA_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_READ_DATA_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_READ_DATA_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_WRITE_DATA = requires(Visitor v) {
         { v.visit_Statement_WRITE_DATA(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().write_data()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_WRITE_DATA_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().write_data()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_WRITE_DATA(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_WRITE_DATA_pre_validate.hpp")
        #include "visitor/Statement_WRITE_DATA_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_WRITE_DATA_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_WRITE_DATA_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.write_data()) {
            return unexpect_error("Unexpected null pointer for StatementBody::write_data");
        }
        auto& write_data = *in.body.write_data();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_WRITE_DATA_pre_visit.hpp")
        #include "visitor/Statement_WRITE_DATA_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_WRITE_DATA_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_WRITE_DATA_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_WRITE_DATA<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_WRITE_DATA(in.id,kind,write_data));
        }
        else if constexpr (has_visitor_Statement_WRITE_DATA_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,write_data));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_WRITE_DATA_post_visit.hpp")
        #include "visitor/Statement_WRITE_DATA_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_WRITE_DATA_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_WRITE_DATA_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_SEEK_STREAM = requires(Visitor v) {
         { v.visit_Statement_SEEK_STREAM(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().offset(),*std::declval<const ebm::StatementBody&>().stream_type()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_SEEK_STREAM_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().offset(),*std::declval<const ebm::StatementBody&>().stream_type()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_SEEK_STREAM(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_SEEK_STREAM_pre_validate.hpp")
        #include "visitor/Statement_SEEK_STREAM_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_SEEK_STREAM_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_SEEK_STREAM_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.offset()) {
            return unexpect_error("Unexpected null pointer for StatementBody::offset");
        }
        auto& offset = *in.body.offset();
        if (!in.body.stream_type()) {
            return unexpect_error("Unexpected null pointer for StatementBody::stream_type");
        }
        auto& stream_type = *in.body.stream_type();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_SEEK_STREAM_pre_visit.hpp")
        #include "visitor/Statement_SEEK_STREAM_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_SEEK_STREAM_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_SEEK_STREAM_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_SEEK_STREAM<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_SEEK_STREAM(in.id,kind,offset,stream_type));
        }
        else if constexpr (has_visitor_Statement_SEEK_STREAM_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,offset,stream_type));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_SEEK_STREAM_post_visit.hpp")
        #include "visitor/Statement_SEEK_STREAM_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_SEEK_STREAM_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_SEEK_STREAM_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_IF_STATEMENT = requires(Visitor v) {
         { v.visit_Statement_IF_STATEMENT(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().if_statement()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_IF_STATEMENT_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().if_statement()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_IF_STATEMENT(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_IF_STATEMENT_pre_validate.hpp")
        #include "visitor/Statement_IF_STATEMENT_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_IF_STATEMENT_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_IF_STATEMENT_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.if_statement()) {
            return unexpect_error("Unexpected null pointer for StatementBody::if_statement");
        }
        auto& if_statement = *in.body.if_statement();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_IF_STATEMENT_pre_visit.hpp")
        #include "visitor/Statement_IF_STATEMENT_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_IF_STATEMENT_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_IF_STATEMENT_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_IF_STATEMENT<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_IF_STATEMENT(in.id,kind,if_statement));
        }
        else if constexpr (has_visitor_Statement_IF_STATEMENT_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,if_statement));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_IF_STATEMENT_post_visit.hpp")
        #include "visitor/Statement_IF_STATEMENT_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_IF_STATEMENT_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_IF_STATEMENT_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_LOOP_STATEMENT = requires(Visitor v) {
         { v.visit_Statement_LOOP_STATEMENT(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().loop()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_LOOP_STATEMENT_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().loop()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_LOOP_STATEMENT(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_LOOP_STATEMENT_pre_validate.hpp")
        #include "visitor/Statement_LOOP_STATEMENT_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_LOOP_STATEMENT_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_LOOP_STATEMENT_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.loop()) {
            return unexpect_error("Unexpected null pointer for StatementBody::loop");
        }
        auto& loop = *in.body.loop();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_LOOP_STATEMENT_pre_visit.hpp")
        #include "visitor/Statement_LOOP_STATEMENT_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_LOOP_STATEMENT_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_LOOP_STATEMENT_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_LOOP_STATEMENT<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_LOOP_STATEMENT(in.id,kind,loop));
        }
        else if constexpr (has_visitor_Statement_LOOP_STATEMENT_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,loop));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_LOOP_STATEMENT_post_visit.hpp")
        #include "visitor/Statement_LOOP_STATEMENT_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_LOOP_STATEMENT_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_LOOP_STATEMENT_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_MATCH_STATEMENT = requires(Visitor v) {
         { v.visit_Statement_MATCH_STATEMENT(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().match_statement()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_MATCH_STATEMENT_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().match_statement()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_MATCH_STATEMENT(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_MATCH_STATEMENT_pre_validate.hpp")
        #include "visitor/Statement_MATCH_STATEMENT_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_MATCH_STATEMENT_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_MATCH_STATEMENT_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.match_statement()) {
            return unexpect_error("Unexpected null pointer for StatementBody::match_statement");
        }
        auto& match_statement = *in.body.match_statement();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_MATCH_STATEMENT_pre_visit.hpp")
        #include "visitor/Statement_MATCH_STATEMENT_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_MATCH_STATEMENT_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_MATCH_STATEMENT_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_MATCH_STATEMENT<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_MATCH_STATEMENT(in.id,kind,match_statement));
        }
        else if constexpr (has_visitor_Statement_MATCH_STATEMENT_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,match_statement));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_MATCH_STATEMENT_post_visit.hpp")
        #include "visitor/Statement_MATCH_STATEMENT_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_MATCH_STATEMENT_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_MATCH_STATEMENT_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_MATCH_BRANCH = requires(Visitor v) {
         { v.visit_Statement_MATCH_BRANCH(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().match_branch()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_MATCH_BRANCH_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().match_branch()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_MATCH_BRANCH(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_MATCH_BRANCH_pre_validate.hpp")
        #include "visitor/Statement_MATCH_BRANCH_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_MATCH_BRANCH_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_MATCH_BRANCH_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.match_branch()) {
            return unexpect_error("Unexpected null pointer for StatementBody::match_branch");
        }
        auto& match_branch = *in.body.match_branch();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_MATCH_BRANCH_pre_visit.hpp")
        #include "visitor/Statement_MATCH_BRANCH_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_MATCH_BRANCH_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_MATCH_BRANCH_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_MATCH_BRANCH<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_MATCH_BRANCH(in.id,kind,match_branch));
        }
        else if constexpr (has_visitor_Statement_MATCH_BRANCH_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,match_branch));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_MATCH_BRANCH_post_visit.hpp")
        #include "visitor/Statement_MATCH_BRANCH_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_MATCH_BRANCH_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_MATCH_BRANCH_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_BREAK = requires(Visitor v) {
         { v.visit_Statement_BREAK(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().break_()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_BREAK_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().break_()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_BREAK(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_BREAK_pre_validate.hpp")
        #include "visitor/Statement_BREAK_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_BREAK_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_BREAK_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.break_()) {
            return unexpect_error("Unexpected null pointer for StatementBody::break_");
        }
        auto& break_ = *in.body.break_();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_BREAK_pre_visit.hpp")
        #include "visitor/Statement_BREAK_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_BREAK_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_BREAK_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_BREAK<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_BREAK(in.id,kind,break_));
        }
        else if constexpr (has_visitor_Statement_BREAK_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,break_));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_BREAK_post_visit.hpp")
        #include "visitor/Statement_BREAK_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_BREAK_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_BREAK_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_CONTINUE = requires(Visitor v) {
         { v.visit_Statement_CONTINUE(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().continue_()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_CONTINUE_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().continue_()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_CONTINUE(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_CONTINUE_pre_validate.hpp")
        #include "visitor/Statement_CONTINUE_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_CONTINUE_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_CONTINUE_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.continue_()) {
            return unexpect_error("Unexpected null pointer for StatementBody::continue_");
        }
        auto& continue_ = *in.body.continue_();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_CONTINUE_pre_visit.hpp")
        #include "visitor/Statement_CONTINUE_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_CONTINUE_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_CONTINUE_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_CONTINUE<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_CONTINUE(in.id,kind,continue_));
        }
        else if constexpr (has_visitor_Statement_CONTINUE_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,continue_));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_CONTINUE_post_visit.hpp")
        #include "visitor/Statement_CONTINUE_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_CONTINUE_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_CONTINUE_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_FUNCTION_DECL = requires(Visitor v) {
         { v.visit_Statement_FUNCTION_DECL(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().func_decl()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_FUNCTION_DECL_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().func_decl()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_FUNCTION_DECL(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_FUNCTION_DECL_pre_validate.hpp")
        #include "visitor/Statement_FUNCTION_DECL_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_FUNCTION_DECL_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_FUNCTION_DECL_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.func_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::func_decl");
        }
        auto& func_decl = *in.body.func_decl();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_FUNCTION_DECL_pre_visit.hpp")
        #include "visitor/Statement_FUNCTION_DECL_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_FUNCTION_DECL_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_FUNCTION_DECL_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_FUNCTION_DECL<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_FUNCTION_DECL(in.id,kind,func_decl));
        }
        else if constexpr (has_visitor_Statement_FUNCTION_DECL_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,func_decl));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_FUNCTION_DECL_post_visit.hpp")
        #include "visitor/Statement_FUNCTION_DECL_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_FUNCTION_DECL_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_FUNCTION_DECL_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_VARIABLE_DECL = requires(Visitor v) {
         { v.visit_Statement_VARIABLE_DECL(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().var_decl()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_VARIABLE_DECL_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().var_decl()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_VARIABLE_DECL(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_VARIABLE_DECL_pre_validate.hpp")
        #include "visitor/Statement_VARIABLE_DECL_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_VARIABLE_DECL_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_VARIABLE_DECL_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.var_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::var_decl");
        }
        auto& var_decl = *in.body.var_decl();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_VARIABLE_DECL_pre_visit.hpp")
        #include "visitor/Statement_VARIABLE_DECL_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_VARIABLE_DECL_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_VARIABLE_DECL_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_VARIABLE_DECL<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_VARIABLE_DECL(in.id,kind,var_decl));
        }
        else if constexpr (has_visitor_Statement_VARIABLE_DECL_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,var_decl));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_VARIABLE_DECL_post_visit.hpp")
        #include "visitor/Statement_VARIABLE_DECL_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_VARIABLE_DECL_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_VARIABLE_DECL_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_FIELD_DECL = requires(Visitor v) {
         { v.visit_Statement_FIELD_DECL(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().field_decl()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_FIELD_DECL_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().field_decl()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_FIELD_DECL(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_FIELD_DECL_pre_validate.hpp")
        #include "visitor/Statement_FIELD_DECL_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_FIELD_DECL_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_FIELD_DECL_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.field_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::field_decl");
        }
        auto& field_decl = *in.body.field_decl();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_FIELD_DECL_pre_visit.hpp")
        #include "visitor/Statement_FIELD_DECL_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_FIELD_DECL_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_FIELD_DECL_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_FIELD_DECL<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_FIELD_DECL(in.id,kind,field_decl));
        }
        else if constexpr (has_visitor_Statement_FIELD_DECL_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,field_decl));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_FIELD_DECL_post_visit.hpp")
        #include "visitor/Statement_FIELD_DECL_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_FIELD_DECL_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_FIELD_DECL_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_ENUM_DECL = requires(Visitor v) {
         { v.visit_Statement_ENUM_DECL(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().enum_decl()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_ENUM_DECL_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().enum_decl()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_ENUM_DECL(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_ENUM_DECL_pre_validate.hpp")
        #include "visitor/Statement_ENUM_DECL_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_ENUM_DECL_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_ENUM_DECL_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.enum_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::enum_decl");
        }
        auto& enum_decl = *in.body.enum_decl();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_ENUM_DECL_pre_visit.hpp")
        #include "visitor/Statement_ENUM_DECL_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_ENUM_DECL_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_ENUM_DECL_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_ENUM_DECL<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_ENUM_DECL(in.id,kind,enum_decl));
        }
        else if constexpr (has_visitor_Statement_ENUM_DECL_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,enum_decl));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_ENUM_DECL_post_visit.hpp")
        #include "visitor/Statement_ENUM_DECL_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_ENUM_DECL_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_ENUM_DECL_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_ENUM_MEMBER_DECL = requires(Visitor v) {
         { v.visit_Statement_ENUM_MEMBER_DECL(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().enum_member_decl()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_ENUM_MEMBER_DECL_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().enum_member_decl()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_ENUM_MEMBER_DECL(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_ENUM_MEMBER_DECL_pre_validate.hpp")
        #include "visitor/Statement_ENUM_MEMBER_DECL_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_ENUM_MEMBER_DECL_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_ENUM_MEMBER_DECL_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.enum_member_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::enum_member_decl");
        }
        auto& enum_member_decl = *in.body.enum_member_decl();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_ENUM_MEMBER_DECL_pre_visit.hpp")
        #include "visitor/Statement_ENUM_MEMBER_DECL_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_ENUM_MEMBER_DECL_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_ENUM_MEMBER_DECL_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_ENUM_MEMBER_DECL<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_ENUM_MEMBER_DECL(in.id,kind,enum_member_decl));
        }
        else if constexpr (has_visitor_Statement_ENUM_MEMBER_DECL_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,enum_member_decl));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_ENUM_MEMBER_DECL_post_visit.hpp")
        #include "visitor/Statement_ENUM_MEMBER_DECL_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_ENUM_MEMBER_DECL_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_ENUM_MEMBER_DECL_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_STRUCT_DECL = requires(Visitor v) {
         { v.visit_Statement_STRUCT_DECL(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().struct_decl()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_STRUCT_DECL_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().struct_decl()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_STRUCT_DECL(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_STRUCT_DECL_pre_validate.hpp")
        #include "visitor/Statement_STRUCT_DECL_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_STRUCT_DECL_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_STRUCT_DECL_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.struct_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::struct_decl");
        }
        auto& struct_decl = *in.body.struct_decl();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_STRUCT_DECL_pre_visit.hpp")
        #include "visitor/Statement_STRUCT_DECL_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_STRUCT_DECL_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_STRUCT_DECL_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_STRUCT_DECL<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_STRUCT_DECL(in.id,kind,struct_decl));
        }
        else if constexpr (has_visitor_Statement_STRUCT_DECL_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,struct_decl));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_STRUCT_DECL_post_visit.hpp")
        #include "visitor/Statement_STRUCT_DECL_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_STRUCT_DECL_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_STRUCT_DECL_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_UNION_DECL = requires(Visitor v) {
         { v.visit_Statement_UNION_DECL(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().union_decl()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_UNION_DECL_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().union_decl()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_UNION_DECL(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_UNION_DECL_pre_validate.hpp")
        #include "visitor/Statement_UNION_DECL_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_UNION_DECL_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_UNION_DECL_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.union_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::union_decl");
        }
        auto& union_decl = *in.body.union_decl();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_UNION_DECL_pre_visit.hpp")
        #include "visitor/Statement_UNION_DECL_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_UNION_DECL_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_UNION_DECL_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_UNION_DECL<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_UNION_DECL(in.id,kind,union_decl));
        }
        else if constexpr (has_visitor_Statement_UNION_DECL_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,union_decl));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_UNION_DECL_post_visit.hpp")
        #include "visitor/Statement_UNION_DECL_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_UNION_DECL_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_UNION_DECL_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_UNION_MEMBER_DECL = requires(Visitor v) {
         { v.visit_Statement_UNION_MEMBER_DECL(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().union_member_decl()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_UNION_MEMBER_DECL_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().union_member_decl()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_UNION_MEMBER_DECL(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_UNION_MEMBER_DECL_pre_validate.hpp")
        #include "visitor/Statement_UNION_MEMBER_DECL_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_UNION_MEMBER_DECL_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_UNION_MEMBER_DECL_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.union_member_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::union_member_decl");
        }
        auto& union_member_decl = *in.body.union_member_decl();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_UNION_MEMBER_DECL_pre_visit.hpp")
        #include "visitor/Statement_UNION_MEMBER_DECL_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_UNION_MEMBER_DECL_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_UNION_MEMBER_DECL_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_UNION_MEMBER_DECL<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_UNION_MEMBER_DECL(in.id,kind,union_member_decl));
        }
        else if constexpr (has_visitor_Statement_UNION_MEMBER_DECL_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,union_member_decl));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_UNION_MEMBER_DECL_post_visit.hpp")
        #include "visitor/Statement_UNION_MEMBER_DECL_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_UNION_MEMBER_DECL_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_UNION_MEMBER_DECL_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_PROGRAM_DECL = requires(Visitor v) {
         { v.visit_Statement_PROGRAM_DECL(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().block()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_PROGRAM_DECL_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().block()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_PROGRAM_DECL(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_PROGRAM_DECL_pre_validate.hpp")
        #include "visitor/Statement_PROGRAM_DECL_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_PROGRAM_DECL_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_PROGRAM_DECL_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.block()) {
            return unexpect_error("Unexpected null pointer for StatementBody::block");
        }
        auto& block = *in.body.block();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_PROGRAM_DECL_pre_visit.hpp")
        #include "visitor/Statement_PROGRAM_DECL_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_PROGRAM_DECL_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_PROGRAM_DECL_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_PROGRAM_DECL<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_PROGRAM_DECL(in.id,kind,block));
        }
        else if constexpr (has_visitor_Statement_PROGRAM_DECL_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,block));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_PROGRAM_DECL_post_visit.hpp")
        #include "visitor/Statement_PROGRAM_DECL_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_PROGRAM_DECL_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_PROGRAM_DECL_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_STATE_DECL = requires(Visitor v) {
         { v.visit_Statement_STATE_DECL(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().state_decl()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_STATE_DECL_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().state_decl()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_STATE_DECL(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_STATE_DECL_pre_validate.hpp")
        #include "visitor/Statement_STATE_DECL_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_STATE_DECL_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_STATE_DECL_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.state_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::state_decl");
        }
        auto& state_decl = *in.body.state_decl();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_STATE_DECL_pre_visit.hpp")
        #include "visitor/Statement_STATE_DECL_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_STATE_DECL_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_STATE_DECL_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_STATE_DECL<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_STATE_DECL(in.id,kind,state_decl));
        }
        else if constexpr (has_visitor_Statement_STATE_DECL_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,state_decl));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_STATE_DECL_post_visit.hpp")
        #include "visitor/Statement_STATE_DECL_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_STATE_DECL_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_STATE_DECL_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_BIT_FIELD_DECL = requires(Visitor v) {
         { v.visit_Statement_BIT_FIELD_DECL(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().bit_field_decl()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_BIT_FIELD_DECL_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().bit_field_decl()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_BIT_FIELD_DECL(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_BIT_FIELD_DECL_pre_validate.hpp")
        #include "visitor/Statement_BIT_FIELD_DECL_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_BIT_FIELD_DECL_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_BIT_FIELD_DECL_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.bit_field_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::bit_field_decl");
        }
        auto& bit_field_decl = *in.body.bit_field_decl();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_BIT_FIELD_DECL_pre_visit.hpp")
        #include "visitor/Statement_BIT_FIELD_DECL_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_BIT_FIELD_DECL_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_BIT_FIELD_DECL_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_BIT_FIELD_DECL<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_BIT_FIELD_DECL(in.id,kind,bit_field_decl));
        }
        else if constexpr (has_visitor_Statement_BIT_FIELD_DECL_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,bit_field_decl));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_BIT_FIELD_DECL_post_visit.hpp")
        #include "visitor/Statement_BIT_FIELD_DECL_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_BIT_FIELD_DECL_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_BIT_FIELD_DECL_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_PROPERTY_DECL = requires(Visitor v) {
         { v.visit_Statement_PROPERTY_DECL(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().property_decl()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_PROPERTY_DECL_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().property_decl()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_PROPERTY_DECL(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_PROPERTY_DECL_pre_validate.hpp")
        #include "visitor/Statement_PROPERTY_DECL_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_PROPERTY_DECL_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_PROPERTY_DECL_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.property_decl()) {
            return unexpect_error("Unexpected null pointer for StatementBody::property_decl");
        }
        auto& property_decl = *in.body.property_decl();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_PROPERTY_DECL_pre_visit.hpp")
        #include "visitor/Statement_PROPERTY_DECL_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_PROPERTY_DECL_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_PROPERTY_DECL_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_PROPERTY_DECL<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_PROPERTY_DECL(in.id,kind,property_decl));
        }
        else if constexpr (has_visitor_Statement_PROPERTY_DECL_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,property_decl));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_PROPERTY_DECL_post_visit.hpp")
        #include "visitor/Statement_PROPERTY_DECL_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_PROPERTY_DECL_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_PROPERTY_DECL_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_METADATA = requires(Visitor v) {
         { v.visit_Statement_METADATA(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().metadata()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_METADATA_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().metadata()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_METADATA(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_METADATA_pre_validate.hpp")
        #include "visitor/Statement_METADATA_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_METADATA_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_METADATA_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.metadata()) {
            return unexpect_error("Unexpected null pointer for StatementBody::metadata");
        }
        auto& metadata = *in.body.metadata();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_METADATA_pre_visit.hpp")
        #include "visitor/Statement_METADATA_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_METADATA_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_METADATA_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_METADATA<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_METADATA(in.id,kind,metadata));
        }
        else if constexpr (has_visitor_Statement_METADATA_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,metadata));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_METADATA_post_visit.hpp")
        #include "visitor/Statement_METADATA_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_METADATA_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_METADATA_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_IMPORT_MODULE = requires(Visitor v) {
         { v.visit_Statement_IMPORT_MODULE(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().alias(),*std::declval<const ebm::StatementBody&>().module_name()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_IMPORT_MODULE_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().alias(),*std::declval<const ebm::StatementBody&>().module_name()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_IMPORT_MODULE(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_IMPORT_MODULE_pre_validate.hpp")
        #include "visitor/Statement_IMPORT_MODULE_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_IMPORT_MODULE_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_IMPORT_MODULE_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.alias()) {
            return unexpect_error("Unexpected null pointer for StatementBody::alias");
        }
        auto& alias = *in.body.alias();
        if (!in.body.module_name()) {
            return unexpect_error("Unexpected null pointer for StatementBody::module_name");
        }
        auto& module_name = *in.body.module_name();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_IMPORT_MODULE_pre_visit.hpp")
        #include "visitor/Statement_IMPORT_MODULE_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_IMPORT_MODULE_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_IMPORT_MODULE_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_IMPORT_MODULE<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_IMPORT_MODULE(in.id,kind,alias,module_name));
        }
        else if constexpr (has_visitor_Statement_IMPORT_MODULE_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,alias,module_name));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_IMPORT_MODULE_post_visit.hpp")
        #include "visitor/Statement_IMPORT_MODULE_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_IMPORT_MODULE_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_IMPORT_MODULE_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_EXPRESSION = requires(Visitor v) {
         { v.visit_Statement_EXPRESSION(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().expression()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_EXPRESSION_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().expression()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_EXPRESSION(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_EXPRESSION_pre_validate.hpp")
        #include "visitor/Statement_EXPRESSION_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_EXPRESSION_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_EXPRESSION_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.expression()) {
            return unexpect_error("Unexpected null pointer for StatementBody::expression");
        }
        auto& expression = *in.body.expression();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_EXPRESSION_pre_visit.hpp")
        #include "visitor/Statement_EXPRESSION_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_EXPRESSION_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_EXPRESSION_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_EXPRESSION<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_EXPRESSION(in.id,kind,expression));
        }
        else if constexpr (has_visitor_Statement_EXPRESSION_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,expression));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_EXPRESSION_post_visit.hpp")
        #include "visitor/Statement_EXPRESSION_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_EXPRESSION_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_EXPRESSION_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_PHI_NODE = requires(Visitor v) {
         { v.visit_Statement_PHI_NODE(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().params(),*std::declval<const ebm::StatementBody&>().params_len(),*std::declval<const ebm::StatementBody&>().target_var()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_PHI_NODE_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().params(),*std::declval<const ebm::StatementBody&>().params_len(),*std::declval<const ebm::StatementBody&>().target_var()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_PHI_NODE(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_PHI_NODE_pre_validate.hpp")
        #include "visitor/Statement_PHI_NODE_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_PHI_NODE_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_PHI_NODE_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.params()) {
            return unexpect_error("Unexpected null pointer for StatementBody::params");
        }
        auto& params = *in.body.params();
        if (!in.body.params_len()) {
            return unexpect_error("Unexpected null pointer for StatementBody::params_len");
        }
        auto& params_len = *in.body.params_len();
        if (!in.body.target_var()) {
            return unexpect_error("Unexpected null pointer for StatementBody::target_var");
        }
        auto& target_var = *in.body.target_var();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_PHI_NODE_pre_visit.hpp")
        #include "visitor/Statement_PHI_NODE_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_PHI_NODE_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_PHI_NODE_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_PHI_NODE<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_PHI_NODE(in.id,kind,params,params_len,target_var));
        }
        else if constexpr (has_visitor_Statement_PHI_NODE_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,params,params_len,target_var));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_PHI_NODE_post_visit.hpp")
        #include "visitor/Statement_PHI_NODE_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_PHI_NODE_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_PHI_NODE_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_ERROR_REPORT = requires(Visitor v) {
         { v.visit_Statement_ERROR_REPORT(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().error_report()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_ERROR_REPORT_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().error_report()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_ERROR_REPORT(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_ERROR_REPORT_pre_validate.hpp")
        #include "visitor/Statement_ERROR_REPORT_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_ERROR_REPORT_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_ERROR_REPORT_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.error_report()) {
            return unexpect_error("Unexpected null pointer for StatementBody::error_report");
        }
        auto& error_report = *in.body.error_report();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_ERROR_REPORT_pre_visit.hpp")
        #include "visitor/Statement_ERROR_REPORT_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_ERROR_REPORT_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_ERROR_REPORT_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_ERROR_REPORT<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_ERROR_REPORT(in.id,kind,error_report));
        }
        else if constexpr (has_visitor_Statement_ERROR_REPORT_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,error_report));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_ERROR_REPORT_post_visit.hpp")
        #include "visitor/Statement_ERROR_REPORT_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_ERROR_REPORT_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_ERROR_REPORT_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Statement_LOWERED_STATEMENTS = requires(Visitor v) {
         { v.visit_Statement_LOWERED_STATEMENTS(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().lowered_statements()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Statement_LOWERED_STATEMENTS_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::StatementRef&>(),std::declval<const ebm::StatementBody&>().kind,*std::declval<const ebm::StatementBody&>().lowered_statements()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Statement_LOWERED_STATEMENTS(Visitor&& visitor,const ebm::Statement& in) {
        #if __has_include("visitor/Statement_pre_validate.hpp")
        #include "visitor/Statement_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Statement_LOWERED_STATEMENTS_pre_validate.hpp")
        #include "visitor/Statement_LOWERED_STATEMENTS_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_LOWERED_STATEMENTS_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Statement_LOWERED_STATEMENTS_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.lowered_statements()) {
            return unexpect_error("Unexpected null pointer for StatementBody::lowered_statements");
        }
        auto& lowered_statements = *in.body.lowered_statements();
        #if __has_include("visitor/Statement_pre_visit.hpp")
        #include "visitor/Statement_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_LOWERED_STATEMENTS_pre_visit.hpp")
        #include "visitor/Statement_LOWERED_STATEMENTS_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_LOWERED_STATEMENTS_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_LOWERED_STATEMENTS_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Statement_LOWERED_STATEMENTS<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Statement_LOWERED_STATEMENTS(in.id,kind,lowered_statements));
        }
        else if constexpr (has_visitor_Statement_LOWERED_STATEMENTS_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,lowered_statements));
        }
        #if __has_include("visitor/Statement_post_visit.hpp")
        #include "visitor/Statement_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_post_visit.hpp"
        #endif
        #if __has_include("visitor/Statement_LOWERED_STATEMENTS_post_visit.hpp")
        #include "visitor/Statement_LOWERED_STATEMENTS_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Statement_LOWERED_STATEMENTS_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Statement_LOWERED_STATEMENTS_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    expected<void> visit_Statement(Visitor&& visitor,const ebm::Statement& in) {
        switch (in.body.kind) {
        case ebm::StatementOp::BLOCK:
            return visit_Statement_BLOCK(visitor,in);
        case ebm::StatementOp::ASSIGNMENT:
            return visit_Statement_ASSIGNMENT(visitor,in);
        case ebm::StatementOp::APPEND:
            return visit_Statement_APPEND(visitor,in);
        case ebm::StatementOp::RETURN:
            return visit_Statement_RETURN(visitor,in);
        case ebm::StatementOp::ERROR_RETURN:
            return visit_Statement_ERROR_RETURN(visitor,in);
        case ebm::StatementOp::ASSERT:
            return visit_Statement_ASSERT(visitor,in);
        case ebm::StatementOp::READ_DATA:
            return visit_Statement_READ_DATA(visitor,in);
        case ebm::StatementOp::WRITE_DATA:
            return visit_Statement_WRITE_DATA(visitor,in);
        case ebm::StatementOp::SEEK_STREAM:
            return visit_Statement_SEEK_STREAM(visitor,in);
        case ebm::StatementOp::IF_STATEMENT:
            return visit_Statement_IF_STATEMENT(visitor,in);
        case ebm::StatementOp::LOOP_STATEMENT:
            return visit_Statement_LOOP_STATEMENT(visitor,in);
        case ebm::StatementOp::MATCH_STATEMENT:
            return visit_Statement_MATCH_STATEMENT(visitor,in);
        case ebm::StatementOp::MATCH_BRANCH:
            return visit_Statement_MATCH_BRANCH(visitor,in);
        case ebm::StatementOp::BREAK:
            return visit_Statement_BREAK(visitor,in);
        case ebm::StatementOp::CONTINUE:
            return visit_Statement_CONTINUE(visitor,in);
        case ebm::StatementOp::FUNCTION_DECL:
            return visit_Statement_FUNCTION_DECL(visitor,in);
        case ebm::StatementOp::VARIABLE_DECL:
            return visit_Statement_VARIABLE_DECL(visitor,in);
        case ebm::StatementOp::FIELD_DECL:
            return visit_Statement_FIELD_DECL(visitor,in);
        case ebm::StatementOp::ENUM_DECL:
            return visit_Statement_ENUM_DECL(visitor,in);
        case ebm::StatementOp::ENUM_MEMBER_DECL:
            return visit_Statement_ENUM_MEMBER_DECL(visitor,in);
        case ebm::StatementOp::STRUCT_DECL:
            return visit_Statement_STRUCT_DECL(visitor,in);
        case ebm::StatementOp::UNION_DECL:
            return visit_Statement_UNION_DECL(visitor,in);
        case ebm::StatementOp::UNION_MEMBER_DECL:
            return visit_Statement_UNION_MEMBER_DECL(visitor,in);
        case ebm::StatementOp::PROGRAM_DECL:
            return visit_Statement_PROGRAM_DECL(visitor,in);
        case ebm::StatementOp::STATE_DECL:
            return visit_Statement_STATE_DECL(visitor,in);
        case ebm::StatementOp::BIT_FIELD_DECL:
            return visit_Statement_BIT_FIELD_DECL(visitor,in);
        case ebm::StatementOp::PROPERTY_DECL:
            return visit_Statement_PROPERTY_DECL(visitor,in);
        case ebm::StatementOp::METADATA:
            return visit_Statement_METADATA(visitor,in);
        case ebm::StatementOp::IMPORT_MODULE:
            return visit_Statement_IMPORT_MODULE(visitor,in);
        case ebm::StatementOp::EXPRESSION:
            return visit_Statement_EXPRESSION(visitor,in);
        case ebm::StatementOp::PHI_NODE:
            return visit_Statement_PHI_NODE(visitor,in);
        case ebm::StatementOp::ERROR_REPORT:
            return visit_Statement_ERROR_REPORT(visitor,in);
        case ebm::StatementOp::LOWERED_STATEMENTS:
            return visit_Statement_LOWERED_STATEMENTS(visitor,in);
        default:
            return unexpect_error("Unknown Statement kind: {}", to_string(in.body.kind));
        }
    }
    template<typename Visitor>
    expected<void> visit_Expression(Visitor&& visitor,const ebm::Expression& in);
    template<typename Visitor>
    concept has_visitor_Expression_LITERAL_INT = requires(Visitor v) {
         { v.visit_Expression_LITERAL_INT(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().int_value()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Expression_LITERAL_INT_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().int_value()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Expression_LITERAL_INT(Visitor&& visitor,const ebm::Expression& in) {
        #if __has_include("visitor/Expression_pre_validate.hpp")
        #include "visitor/Expression_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Expression_LITERAL_INT_pre_validate.hpp")
        #include "visitor/Expression_LITERAL_INT_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_LITERAL_INT_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_LITERAL_INT_pre_validate.hpp"
        #endif
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.int_value()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::int_value");
        }
        auto& int_value = *in.body.int_value();
        #if __has_include("visitor/Expression_pre_visit.hpp")
        #include "visitor/Expression_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_LITERAL_INT_pre_visit.hpp")
        #include "visitor/Expression_LITERAL_INT_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_LITERAL_INT_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_LITERAL_INT_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Expression_LITERAL_INT<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Expression_LITERAL_INT(in.id,type,kind,int_value));
        }
        else if constexpr (has_visitor_Expression_LITERAL_INT_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,type,kind,int_value));
        }
        #if __has_include("visitor/Expression_post_visit.hpp")
        #include "visitor/Expression_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_post_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_LITERAL_INT_post_visit.hpp")
        #include "visitor/Expression_LITERAL_INT_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_LITERAL_INT_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_LITERAL_INT_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Expression_LITERAL_INT64 = requires(Visitor v) {
         { v.visit_Expression_LITERAL_INT64(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().int64_value()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Expression_LITERAL_INT64_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().int64_value()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Expression_LITERAL_INT64(Visitor&& visitor,const ebm::Expression& in) {
        #if __has_include("visitor/Expression_pre_validate.hpp")
        #include "visitor/Expression_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Expression_LITERAL_INT64_pre_validate.hpp")
        #include "visitor/Expression_LITERAL_INT64_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_LITERAL_INT64_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_LITERAL_INT64_pre_validate.hpp"
        #endif
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.int64_value()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::int64_value");
        }
        auto& int64_value = *in.body.int64_value();
        #if __has_include("visitor/Expression_pre_visit.hpp")
        #include "visitor/Expression_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_LITERAL_INT64_pre_visit.hpp")
        #include "visitor/Expression_LITERAL_INT64_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_LITERAL_INT64_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_LITERAL_INT64_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Expression_LITERAL_INT64<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Expression_LITERAL_INT64(in.id,type,kind,int64_value));
        }
        else if constexpr (has_visitor_Expression_LITERAL_INT64_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,type,kind,int64_value));
        }
        #if __has_include("visitor/Expression_post_visit.hpp")
        #include "visitor/Expression_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_post_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_LITERAL_INT64_post_visit.hpp")
        #include "visitor/Expression_LITERAL_INT64_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_LITERAL_INT64_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_LITERAL_INT64_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Expression_LITERAL_BOOL = requires(Visitor v) {
         { v.visit_Expression_LITERAL_BOOL(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().bool_value()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Expression_LITERAL_BOOL_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().bool_value()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Expression_LITERAL_BOOL(Visitor&& visitor,const ebm::Expression& in) {
        #if __has_include("visitor/Expression_pre_validate.hpp")
        #include "visitor/Expression_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Expression_LITERAL_BOOL_pre_validate.hpp")
        #include "visitor/Expression_LITERAL_BOOL_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_LITERAL_BOOL_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_LITERAL_BOOL_pre_validate.hpp"
        #endif
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.bool_value()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::bool_value");
        }
        auto& bool_value = *in.body.bool_value();
        #if __has_include("visitor/Expression_pre_visit.hpp")
        #include "visitor/Expression_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_LITERAL_BOOL_pre_visit.hpp")
        #include "visitor/Expression_LITERAL_BOOL_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_LITERAL_BOOL_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_LITERAL_BOOL_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Expression_LITERAL_BOOL<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Expression_LITERAL_BOOL(in.id,type,kind,bool_value));
        }
        else if constexpr (has_visitor_Expression_LITERAL_BOOL_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,type,kind,bool_value));
        }
        #if __has_include("visitor/Expression_post_visit.hpp")
        #include "visitor/Expression_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_post_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_LITERAL_BOOL_post_visit.hpp")
        #include "visitor/Expression_LITERAL_BOOL_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_LITERAL_BOOL_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_LITERAL_BOOL_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Expression_LITERAL_STRING = requires(Visitor v) {
         { v.visit_Expression_LITERAL_STRING(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().string_value()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Expression_LITERAL_STRING_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().string_value()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Expression_LITERAL_STRING(Visitor&& visitor,const ebm::Expression& in) {
        #if __has_include("visitor/Expression_pre_validate.hpp")
        #include "visitor/Expression_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Expression_LITERAL_STRING_pre_validate.hpp")
        #include "visitor/Expression_LITERAL_STRING_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_LITERAL_STRING_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_LITERAL_STRING_pre_validate.hpp"
        #endif
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.string_value()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::string_value");
        }
        auto& string_value = *in.body.string_value();
        #if __has_include("visitor/Expression_pre_visit.hpp")
        #include "visitor/Expression_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_LITERAL_STRING_pre_visit.hpp")
        #include "visitor/Expression_LITERAL_STRING_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_LITERAL_STRING_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_LITERAL_STRING_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Expression_LITERAL_STRING<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Expression_LITERAL_STRING(in.id,type,kind,string_value));
        }
        else if constexpr (has_visitor_Expression_LITERAL_STRING_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,type,kind,string_value));
        }
        #if __has_include("visitor/Expression_post_visit.hpp")
        #include "visitor/Expression_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_post_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_LITERAL_STRING_post_visit.hpp")
        #include "visitor/Expression_LITERAL_STRING_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_LITERAL_STRING_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_LITERAL_STRING_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Expression_LITERAL_TYPE = requires(Visitor v) {
         { v.visit_Expression_LITERAL_TYPE(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().type_ref()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Expression_LITERAL_TYPE_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().type_ref()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Expression_LITERAL_TYPE(Visitor&& visitor,const ebm::Expression& in) {
        #if __has_include("visitor/Expression_pre_validate.hpp")
        #include "visitor/Expression_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Expression_LITERAL_TYPE_pre_validate.hpp")
        #include "visitor/Expression_LITERAL_TYPE_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_LITERAL_TYPE_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_LITERAL_TYPE_pre_validate.hpp"
        #endif
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.type_ref()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::type_ref");
        }
        auto& type_ref = *in.body.type_ref();
        #if __has_include("visitor/Expression_pre_visit.hpp")
        #include "visitor/Expression_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_LITERAL_TYPE_pre_visit.hpp")
        #include "visitor/Expression_LITERAL_TYPE_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_LITERAL_TYPE_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_LITERAL_TYPE_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Expression_LITERAL_TYPE<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Expression_LITERAL_TYPE(in.id,type,kind,type_ref));
        }
        else if constexpr (has_visitor_Expression_LITERAL_TYPE_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,type,kind,type_ref));
        }
        #if __has_include("visitor/Expression_post_visit.hpp")
        #include "visitor/Expression_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_post_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_LITERAL_TYPE_post_visit.hpp")
        #include "visitor/Expression_LITERAL_TYPE_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_LITERAL_TYPE_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_LITERAL_TYPE_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Expression_IDENTIFIER = requires(Visitor v) {
         { v.visit_Expression_IDENTIFIER(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().id()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Expression_IDENTIFIER_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().id()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Expression_IDENTIFIER(Visitor&& visitor,const ebm::Expression& in) {
        #if __has_include("visitor/Expression_pre_validate.hpp")
        #include "visitor/Expression_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Expression_IDENTIFIER_pre_validate.hpp")
        #include "visitor/Expression_IDENTIFIER_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_IDENTIFIER_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_IDENTIFIER_pre_validate.hpp"
        #endif
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.id()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::id");
        }
        auto& id = *in.body.id();
        #if __has_include("visitor/Expression_pre_visit.hpp")
        #include "visitor/Expression_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_IDENTIFIER_pre_visit.hpp")
        #include "visitor/Expression_IDENTIFIER_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_IDENTIFIER_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_IDENTIFIER_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Expression_IDENTIFIER<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Expression_IDENTIFIER(in.id,type,kind,id));
        }
        else if constexpr (has_visitor_Expression_IDENTIFIER_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,type,kind,id));
        }
        #if __has_include("visitor/Expression_post_visit.hpp")
        #include "visitor/Expression_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_post_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_IDENTIFIER_post_visit.hpp")
        #include "visitor/Expression_IDENTIFIER_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_IDENTIFIER_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_IDENTIFIER_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Expression_BINARY_OP = requires(Visitor v) {
         { v.visit_Expression_BINARY_OP(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().bop(),*std::declval<const ebm::ExpressionBody&>().left(),*std::declval<const ebm::ExpressionBody&>().right()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Expression_BINARY_OP_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().bop(),*std::declval<const ebm::ExpressionBody&>().left(),*std::declval<const ebm::ExpressionBody&>().right()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Expression_BINARY_OP(Visitor&& visitor,const ebm::Expression& in) {
        #if __has_include("visitor/Expression_pre_validate.hpp")
        #include "visitor/Expression_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Expression_BINARY_OP_pre_validate.hpp")
        #include "visitor/Expression_BINARY_OP_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_BINARY_OP_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_BINARY_OP_pre_validate.hpp"
        #endif
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.bop()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::bop");
        }
        auto& bop = *in.body.bop();
        if (!in.body.left()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::left");
        }
        auto& left = *in.body.left();
        if (!in.body.right()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::right");
        }
        auto& right = *in.body.right();
        #if __has_include("visitor/Expression_pre_visit.hpp")
        #include "visitor/Expression_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_BINARY_OP_pre_visit.hpp")
        #include "visitor/Expression_BINARY_OP_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_BINARY_OP_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_BINARY_OP_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Expression_BINARY_OP<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Expression_BINARY_OP(in.id,type,kind,bop,left,right));
        }
        else if constexpr (has_visitor_Expression_BINARY_OP_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,type,kind,bop,left,right));
        }
        #if __has_include("visitor/Expression_post_visit.hpp")
        #include "visitor/Expression_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_post_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_BINARY_OP_post_visit.hpp")
        #include "visitor/Expression_BINARY_OP_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_BINARY_OP_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_BINARY_OP_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Expression_UNARY_OP = requires(Visitor v) {
         { v.visit_Expression_UNARY_OP(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().operand(),*std::declval<const ebm::ExpressionBody&>().uop()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Expression_UNARY_OP_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().operand(),*std::declval<const ebm::ExpressionBody&>().uop()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Expression_UNARY_OP(Visitor&& visitor,const ebm::Expression& in) {
        #if __has_include("visitor/Expression_pre_validate.hpp")
        #include "visitor/Expression_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Expression_UNARY_OP_pre_validate.hpp")
        #include "visitor/Expression_UNARY_OP_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_UNARY_OP_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_UNARY_OP_pre_validate.hpp"
        #endif
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.operand()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::operand");
        }
        auto& operand = *in.body.operand();
        if (!in.body.uop()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::uop");
        }
        auto& uop = *in.body.uop();
        #if __has_include("visitor/Expression_pre_visit.hpp")
        #include "visitor/Expression_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_UNARY_OP_pre_visit.hpp")
        #include "visitor/Expression_UNARY_OP_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_UNARY_OP_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_UNARY_OP_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Expression_UNARY_OP<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Expression_UNARY_OP(in.id,type,kind,operand,uop));
        }
        else if constexpr (has_visitor_Expression_UNARY_OP_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,type,kind,operand,uop));
        }
        #if __has_include("visitor/Expression_post_visit.hpp")
        #include "visitor/Expression_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_post_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_UNARY_OP_post_visit.hpp")
        #include "visitor/Expression_UNARY_OP_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_UNARY_OP_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_UNARY_OP_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Expression_CALL = requires(Visitor v) {
         { v.visit_Expression_CALL(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().call_desc()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Expression_CALL_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().call_desc()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Expression_CALL(Visitor&& visitor,const ebm::Expression& in) {
        #if __has_include("visitor/Expression_pre_validate.hpp")
        #include "visitor/Expression_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Expression_CALL_pre_validate.hpp")
        #include "visitor/Expression_CALL_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_CALL_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_CALL_pre_validate.hpp"
        #endif
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.call_desc()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::call_desc");
        }
        auto& call_desc = *in.body.call_desc();
        #if __has_include("visitor/Expression_pre_visit.hpp")
        #include "visitor/Expression_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_CALL_pre_visit.hpp")
        #include "visitor/Expression_CALL_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_CALL_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_CALL_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Expression_CALL<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Expression_CALL(in.id,type,kind,call_desc));
        }
        else if constexpr (has_visitor_Expression_CALL_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,type,kind,call_desc));
        }
        #if __has_include("visitor/Expression_post_visit.hpp")
        #include "visitor/Expression_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_post_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_CALL_post_visit.hpp")
        #include "visitor/Expression_CALL_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_CALL_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_CALL_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Expression_INDEX_ACCESS = requires(Visitor v) {
         { v.visit_Expression_INDEX_ACCESS(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().base(),*std::declval<const ebm::ExpressionBody&>().index()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Expression_INDEX_ACCESS_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().base(),*std::declval<const ebm::ExpressionBody&>().index()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Expression_INDEX_ACCESS(Visitor&& visitor,const ebm::Expression& in) {
        #if __has_include("visitor/Expression_pre_validate.hpp")
        #include "visitor/Expression_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Expression_INDEX_ACCESS_pre_validate.hpp")
        #include "visitor/Expression_INDEX_ACCESS_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_INDEX_ACCESS_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_INDEX_ACCESS_pre_validate.hpp"
        #endif
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.base()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::base");
        }
        auto& base = *in.body.base();
        if (!in.body.index()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::index");
        }
        auto& index = *in.body.index();
        #if __has_include("visitor/Expression_pre_visit.hpp")
        #include "visitor/Expression_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_INDEX_ACCESS_pre_visit.hpp")
        #include "visitor/Expression_INDEX_ACCESS_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_INDEX_ACCESS_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_INDEX_ACCESS_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Expression_INDEX_ACCESS<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Expression_INDEX_ACCESS(in.id,type,kind,base,index));
        }
        else if constexpr (has_visitor_Expression_INDEX_ACCESS_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,type,kind,base,index));
        }
        #if __has_include("visitor/Expression_post_visit.hpp")
        #include "visitor/Expression_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_post_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_INDEX_ACCESS_post_visit.hpp")
        #include "visitor/Expression_INDEX_ACCESS_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_INDEX_ACCESS_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_INDEX_ACCESS_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Expression_MEMBER_ACCESS = requires(Visitor v) {
         { v.visit_Expression_MEMBER_ACCESS(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().base(),*std::declval<const ebm::ExpressionBody&>().member()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Expression_MEMBER_ACCESS_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().base(),*std::declval<const ebm::ExpressionBody&>().member()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Expression_MEMBER_ACCESS(Visitor&& visitor,const ebm::Expression& in) {
        #if __has_include("visitor/Expression_pre_validate.hpp")
        #include "visitor/Expression_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Expression_MEMBER_ACCESS_pre_validate.hpp")
        #include "visitor/Expression_MEMBER_ACCESS_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_MEMBER_ACCESS_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_MEMBER_ACCESS_pre_validate.hpp"
        #endif
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.base()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::base");
        }
        auto& base = *in.body.base();
        if (!in.body.member()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::member");
        }
        auto& member = *in.body.member();
        #if __has_include("visitor/Expression_pre_visit.hpp")
        #include "visitor/Expression_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_MEMBER_ACCESS_pre_visit.hpp")
        #include "visitor/Expression_MEMBER_ACCESS_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_MEMBER_ACCESS_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_MEMBER_ACCESS_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Expression_MEMBER_ACCESS<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Expression_MEMBER_ACCESS(in.id,type,kind,base,member));
        }
        else if constexpr (has_visitor_Expression_MEMBER_ACCESS_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,type,kind,base,member));
        }
        #if __has_include("visitor/Expression_post_visit.hpp")
        #include "visitor/Expression_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_post_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_MEMBER_ACCESS_post_visit.hpp")
        #include "visitor/Expression_MEMBER_ACCESS_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_MEMBER_ACCESS_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_MEMBER_ACCESS_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Expression_TYPE_CAST = requires(Visitor v) {
         { v.visit_Expression_TYPE_CAST(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().cast_kind(),*std::declval<const ebm::ExpressionBody&>().from_type(),*std::declval<const ebm::ExpressionBody&>().source_expr()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Expression_TYPE_CAST_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().cast_kind(),*std::declval<const ebm::ExpressionBody&>().from_type(),*std::declval<const ebm::ExpressionBody&>().source_expr()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Expression_TYPE_CAST(Visitor&& visitor,const ebm::Expression& in) {
        #if __has_include("visitor/Expression_pre_validate.hpp")
        #include "visitor/Expression_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Expression_TYPE_CAST_pre_validate.hpp")
        #include "visitor/Expression_TYPE_CAST_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_TYPE_CAST_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_TYPE_CAST_pre_validate.hpp"
        #endif
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.cast_kind()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::cast_kind");
        }
        auto& cast_kind = *in.body.cast_kind();
        if (!in.body.from_type()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::from_type");
        }
        auto& from_type = *in.body.from_type();
        if (!in.body.source_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::source_expr");
        }
        auto& source_expr = *in.body.source_expr();
        #if __has_include("visitor/Expression_pre_visit.hpp")
        #include "visitor/Expression_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_TYPE_CAST_pre_visit.hpp")
        #include "visitor/Expression_TYPE_CAST_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_TYPE_CAST_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_TYPE_CAST_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Expression_TYPE_CAST<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Expression_TYPE_CAST(in.id,type,kind,cast_kind,from_type,source_expr));
        }
        else if constexpr (has_visitor_Expression_TYPE_CAST_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,type,kind,cast_kind,from_type,source_expr));
        }
        #if __has_include("visitor/Expression_post_visit.hpp")
        #include "visitor/Expression_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_post_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_TYPE_CAST_post_visit.hpp")
        #include "visitor/Expression_TYPE_CAST_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_TYPE_CAST_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_TYPE_CAST_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Expression_RANGE = requires(Visitor v) {
         { v.visit_Expression_RANGE(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().end(),*std::declval<const ebm::ExpressionBody&>().start()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Expression_RANGE_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().end(),*std::declval<const ebm::ExpressionBody&>().start()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Expression_RANGE(Visitor&& visitor,const ebm::Expression& in) {
        #if __has_include("visitor/Expression_pre_validate.hpp")
        #include "visitor/Expression_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Expression_RANGE_pre_validate.hpp")
        #include "visitor/Expression_RANGE_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_RANGE_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_RANGE_pre_validate.hpp"
        #endif
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.end()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::end");
        }
        auto& end = *in.body.end();
        if (!in.body.start()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::start");
        }
        auto& start = *in.body.start();
        #if __has_include("visitor/Expression_pre_visit.hpp")
        #include "visitor/Expression_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_RANGE_pre_visit.hpp")
        #include "visitor/Expression_RANGE_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_RANGE_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_RANGE_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Expression_RANGE<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Expression_RANGE(in.id,type,kind,end,start));
        }
        else if constexpr (has_visitor_Expression_RANGE_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,type,kind,end,start));
        }
        #if __has_include("visitor/Expression_post_visit.hpp")
        #include "visitor/Expression_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_post_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_RANGE_post_visit.hpp")
        #include "visitor/Expression_RANGE_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_RANGE_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_RANGE_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Expression_DEFAULT_VALUE = requires(Visitor v) {
         { v.visit_Expression_DEFAULT_VALUE(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Expression_DEFAULT_VALUE_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Expression_DEFAULT_VALUE(Visitor&& visitor,const ebm::Expression& in) {
        #if __has_include("visitor/Expression_pre_validate.hpp")
        #include "visitor/Expression_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Expression_DEFAULT_VALUE_pre_validate.hpp")
        #include "visitor/Expression_DEFAULT_VALUE_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_DEFAULT_VALUE_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_DEFAULT_VALUE_pre_validate.hpp"
        #endif
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        #if __has_include("visitor/Expression_pre_visit.hpp")
        #include "visitor/Expression_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_DEFAULT_VALUE_pre_visit.hpp")
        #include "visitor/Expression_DEFAULT_VALUE_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_DEFAULT_VALUE_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_DEFAULT_VALUE_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Expression_DEFAULT_VALUE<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Expression_DEFAULT_VALUE(in.id,type,kind));
        }
        else if constexpr (has_visitor_Expression_DEFAULT_VALUE_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,type,kind));
        }
        #if __has_include("visitor/Expression_post_visit.hpp")
        #include "visitor/Expression_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_post_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_DEFAULT_VALUE_post_visit.hpp")
        #include "visitor/Expression_DEFAULT_VALUE_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_DEFAULT_VALUE_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_DEFAULT_VALUE_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Expression_IS_LITTLE_ENDIAN = requires(Visitor v) {
         { v.visit_Expression_IS_LITTLE_ENDIAN(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().endian_expr()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Expression_IS_LITTLE_ENDIAN_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().endian_expr()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Expression_IS_LITTLE_ENDIAN(Visitor&& visitor,const ebm::Expression& in) {
        #if __has_include("visitor/Expression_pre_validate.hpp")
        #include "visitor/Expression_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Expression_IS_LITTLE_ENDIAN_pre_validate.hpp")
        #include "visitor/Expression_IS_LITTLE_ENDIAN_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_IS_LITTLE_ENDIAN_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_IS_LITTLE_ENDIAN_pre_validate.hpp"
        #endif
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.endian_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::endian_expr");
        }
        auto& endian_expr = *in.body.endian_expr();
        #if __has_include("visitor/Expression_pre_visit.hpp")
        #include "visitor/Expression_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_IS_LITTLE_ENDIAN_pre_visit.hpp")
        #include "visitor/Expression_IS_LITTLE_ENDIAN_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_IS_LITTLE_ENDIAN_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_IS_LITTLE_ENDIAN_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Expression_IS_LITTLE_ENDIAN<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Expression_IS_LITTLE_ENDIAN(in.id,type,kind,endian_expr));
        }
        else if constexpr (has_visitor_Expression_IS_LITTLE_ENDIAN_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,type,kind,endian_expr));
        }
        #if __has_include("visitor/Expression_post_visit.hpp")
        #include "visitor/Expression_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_post_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_IS_LITTLE_ENDIAN_post_visit.hpp")
        #include "visitor/Expression_IS_LITTLE_ENDIAN_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_IS_LITTLE_ENDIAN_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_IS_LITTLE_ENDIAN_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Expression_GET_STREAM_OFFSET = requires(Visitor v) {
         { v.visit_Expression_GET_STREAM_OFFSET(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().stream_type(),*std::declval<const ebm::ExpressionBody&>().unit()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Expression_GET_STREAM_OFFSET_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().stream_type(),*std::declval<const ebm::ExpressionBody&>().unit()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Expression_GET_STREAM_OFFSET(Visitor&& visitor,const ebm::Expression& in) {
        #if __has_include("visitor/Expression_pre_validate.hpp")
        #include "visitor/Expression_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Expression_GET_STREAM_OFFSET_pre_validate.hpp")
        #include "visitor/Expression_GET_STREAM_OFFSET_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_GET_STREAM_OFFSET_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_GET_STREAM_OFFSET_pre_validate.hpp"
        #endif
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.stream_type()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::stream_type");
        }
        auto& stream_type = *in.body.stream_type();
        if (!in.body.unit()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::unit");
        }
        auto& unit = *in.body.unit();
        #if __has_include("visitor/Expression_pre_visit.hpp")
        #include "visitor/Expression_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_GET_STREAM_OFFSET_pre_visit.hpp")
        #include "visitor/Expression_GET_STREAM_OFFSET_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_GET_STREAM_OFFSET_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_GET_STREAM_OFFSET_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Expression_GET_STREAM_OFFSET<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Expression_GET_STREAM_OFFSET(in.id,type,kind,stream_type,unit));
        }
        else if constexpr (has_visitor_Expression_GET_STREAM_OFFSET_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,type,kind,stream_type,unit));
        }
        #if __has_include("visitor/Expression_post_visit.hpp")
        #include "visitor/Expression_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_post_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_GET_STREAM_OFFSET_post_visit.hpp")
        #include "visitor/Expression_GET_STREAM_OFFSET_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_GET_STREAM_OFFSET_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_GET_STREAM_OFFSET_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Expression_GET_REMAINING_BYTES = requires(Visitor v) {
         { v.visit_Expression_GET_REMAINING_BYTES(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().stream_type()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Expression_GET_REMAINING_BYTES_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().stream_type()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Expression_GET_REMAINING_BYTES(Visitor&& visitor,const ebm::Expression& in) {
        #if __has_include("visitor/Expression_pre_validate.hpp")
        #include "visitor/Expression_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Expression_GET_REMAINING_BYTES_pre_validate.hpp")
        #include "visitor/Expression_GET_REMAINING_BYTES_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_GET_REMAINING_BYTES_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_GET_REMAINING_BYTES_pre_validate.hpp"
        #endif
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.stream_type()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::stream_type");
        }
        auto& stream_type = *in.body.stream_type();
        #if __has_include("visitor/Expression_pre_visit.hpp")
        #include "visitor/Expression_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_GET_REMAINING_BYTES_pre_visit.hpp")
        #include "visitor/Expression_GET_REMAINING_BYTES_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_GET_REMAINING_BYTES_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_GET_REMAINING_BYTES_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Expression_GET_REMAINING_BYTES<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Expression_GET_REMAINING_BYTES(in.id,type,kind,stream_type));
        }
        else if constexpr (has_visitor_Expression_GET_REMAINING_BYTES_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,type,kind,stream_type));
        }
        #if __has_include("visitor/Expression_post_visit.hpp")
        #include "visitor/Expression_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_post_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_GET_REMAINING_BYTES_post_visit.hpp")
        #include "visitor/Expression_GET_REMAINING_BYTES_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_GET_REMAINING_BYTES_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_GET_REMAINING_BYTES_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Expression_CAN_READ_STREAM = requires(Visitor v) {
         { v.visit_Expression_CAN_READ_STREAM(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().num_bytes(),*std::declval<const ebm::ExpressionBody&>().stream_type()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Expression_CAN_READ_STREAM_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().num_bytes(),*std::declval<const ebm::ExpressionBody&>().stream_type()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Expression_CAN_READ_STREAM(Visitor&& visitor,const ebm::Expression& in) {
        #if __has_include("visitor/Expression_pre_validate.hpp")
        #include "visitor/Expression_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Expression_CAN_READ_STREAM_pre_validate.hpp")
        #include "visitor/Expression_CAN_READ_STREAM_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_CAN_READ_STREAM_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_CAN_READ_STREAM_pre_validate.hpp"
        #endif
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.num_bytes()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::num_bytes");
        }
        auto& num_bytes = *in.body.num_bytes();
        if (!in.body.stream_type()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::stream_type");
        }
        auto& stream_type = *in.body.stream_type();
        #if __has_include("visitor/Expression_pre_visit.hpp")
        #include "visitor/Expression_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_CAN_READ_STREAM_pre_visit.hpp")
        #include "visitor/Expression_CAN_READ_STREAM_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_CAN_READ_STREAM_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_CAN_READ_STREAM_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Expression_CAN_READ_STREAM<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Expression_CAN_READ_STREAM(in.id,type,kind,num_bytes,stream_type));
        }
        else if constexpr (has_visitor_Expression_CAN_READ_STREAM_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,type,kind,num_bytes,stream_type));
        }
        #if __has_include("visitor/Expression_post_visit.hpp")
        #include "visitor/Expression_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_post_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_CAN_READ_STREAM_post_visit.hpp")
        #include "visitor/Expression_CAN_READ_STREAM_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_CAN_READ_STREAM_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_CAN_READ_STREAM_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Expression_ARRAY_SIZE = requires(Visitor v) {
         { v.visit_Expression_ARRAY_SIZE(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().array_expr()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Expression_ARRAY_SIZE_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().array_expr()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Expression_ARRAY_SIZE(Visitor&& visitor,const ebm::Expression& in) {
        #if __has_include("visitor/Expression_pre_validate.hpp")
        #include "visitor/Expression_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Expression_ARRAY_SIZE_pre_validate.hpp")
        #include "visitor/Expression_ARRAY_SIZE_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_ARRAY_SIZE_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_ARRAY_SIZE_pre_validate.hpp"
        #endif
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.array_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::array_expr");
        }
        auto& array_expr = *in.body.array_expr();
        #if __has_include("visitor/Expression_pre_visit.hpp")
        #include "visitor/Expression_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_ARRAY_SIZE_pre_visit.hpp")
        #include "visitor/Expression_ARRAY_SIZE_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_ARRAY_SIZE_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_ARRAY_SIZE_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Expression_ARRAY_SIZE<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Expression_ARRAY_SIZE(in.id,type,kind,array_expr));
        }
        else if constexpr (has_visitor_Expression_ARRAY_SIZE_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,type,kind,array_expr));
        }
        #if __has_include("visitor/Expression_post_visit.hpp")
        #include "visitor/Expression_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_post_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_ARRAY_SIZE_post_visit.hpp")
        #include "visitor/Expression_ARRAY_SIZE_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_ARRAY_SIZE_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_ARRAY_SIZE_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Expression_IS_ERROR = requires(Visitor v) {
         { v.visit_Expression_IS_ERROR(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().target_expr()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Expression_IS_ERROR_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().target_expr()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Expression_IS_ERROR(Visitor&& visitor,const ebm::Expression& in) {
        #if __has_include("visitor/Expression_pre_validate.hpp")
        #include "visitor/Expression_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Expression_IS_ERROR_pre_validate.hpp")
        #include "visitor/Expression_IS_ERROR_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_IS_ERROR_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_IS_ERROR_pre_validate.hpp"
        #endif
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.target_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::target_expr");
        }
        auto& target_expr = *in.body.target_expr();
        #if __has_include("visitor/Expression_pre_visit.hpp")
        #include "visitor/Expression_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_IS_ERROR_pre_visit.hpp")
        #include "visitor/Expression_IS_ERROR_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_IS_ERROR_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_IS_ERROR_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Expression_IS_ERROR<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Expression_IS_ERROR(in.id,type,kind,target_expr));
        }
        else if constexpr (has_visitor_Expression_IS_ERROR_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,type,kind,target_expr));
        }
        #if __has_include("visitor/Expression_post_visit.hpp")
        #include "visitor/Expression_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_post_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_IS_ERROR_post_visit.hpp")
        #include "visitor/Expression_IS_ERROR_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_IS_ERROR_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_IS_ERROR_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Expression_MAX_VALUE = requires(Visitor v) {
         { v.visit_Expression_MAX_VALUE(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().lowered_expr()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Expression_MAX_VALUE_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().lowered_expr()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Expression_MAX_VALUE(Visitor&& visitor,const ebm::Expression& in) {
        #if __has_include("visitor/Expression_pre_validate.hpp")
        #include "visitor/Expression_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Expression_MAX_VALUE_pre_validate.hpp")
        #include "visitor/Expression_MAX_VALUE_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_MAX_VALUE_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_MAX_VALUE_pre_validate.hpp"
        #endif
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.lowered_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::lowered_expr");
        }
        auto& lowered_expr = *in.body.lowered_expr();
        #if __has_include("visitor/Expression_pre_visit.hpp")
        #include "visitor/Expression_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_MAX_VALUE_pre_visit.hpp")
        #include "visitor/Expression_MAX_VALUE_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_MAX_VALUE_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_MAX_VALUE_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Expression_MAX_VALUE<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Expression_MAX_VALUE(in.id,type,kind,lowered_expr));
        }
        else if constexpr (has_visitor_Expression_MAX_VALUE_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,type,kind,lowered_expr));
        }
        #if __has_include("visitor/Expression_post_visit.hpp")
        #include "visitor/Expression_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_post_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_MAX_VALUE_post_visit.hpp")
        #include "visitor/Expression_MAX_VALUE_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_MAX_VALUE_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_MAX_VALUE_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Expression_READ_DATA = requires(Visitor v) {
         { v.visit_Expression_READ_DATA(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().io_statement(),*std::declval<const ebm::ExpressionBody&>().target_stmt()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Expression_READ_DATA_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().io_statement(),*std::declval<const ebm::ExpressionBody&>().target_stmt()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Expression_READ_DATA(Visitor&& visitor,const ebm::Expression& in) {
        #if __has_include("visitor/Expression_pre_validate.hpp")
        #include "visitor/Expression_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Expression_READ_DATA_pre_validate.hpp")
        #include "visitor/Expression_READ_DATA_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_READ_DATA_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_READ_DATA_pre_validate.hpp"
        #endif
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.io_statement()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::io_statement");
        }
        auto& io_statement = *in.body.io_statement();
        if (!in.body.target_stmt()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::target_stmt");
        }
        auto& target_stmt = *in.body.target_stmt();
        #if __has_include("visitor/Expression_pre_visit.hpp")
        #include "visitor/Expression_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_READ_DATA_pre_visit.hpp")
        #include "visitor/Expression_READ_DATA_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_READ_DATA_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_READ_DATA_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Expression_READ_DATA<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Expression_READ_DATA(in.id,type,kind,io_statement,target_stmt));
        }
        else if constexpr (has_visitor_Expression_READ_DATA_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,type,kind,io_statement,target_stmt));
        }
        #if __has_include("visitor/Expression_post_visit.hpp")
        #include "visitor/Expression_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_post_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_READ_DATA_post_visit.hpp")
        #include "visitor/Expression_READ_DATA_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_READ_DATA_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_READ_DATA_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Expression_WRITE_DATA = requires(Visitor v) {
         { v.visit_Expression_WRITE_DATA(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().io_statement(),*std::declval<const ebm::ExpressionBody&>().target_expr()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Expression_WRITE_DATA_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::ExpressionRef&>(),std::declval<const ebm::ExpressionBody&>().type,std::declval<const ebm::ExpressionBody&>().kind,*std::declval<const ebm::ExpressionBody&>().io_statement(),*std::declval<const ebm::ExpressionBody&>().target_expr()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Expression_WRITE_DATA(Visitor&& visitor,const ebm::Expression& in) {
        #if __has_include("visitor/Expression_pre_validate.hpp")
        #include "visitor/Expression_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Expression_WRITE_DATA_pre_validate.hpp")
        #include "visitor/Expression_WRITE_DATA_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_WRITE_DATA_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Expression_WRITE_DATA_pre_validate.hpp"
        #endif
        auto& type = in.body.type;
        auto& kind = in.body.kind;
        if (!in.body.io_statement()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::io_statement");
        }
        auto& io_statement = *in.body.io_statement();
        if (!in.body.target_expr()) {
            return unexpect_error("Unexpected null pointer for ExpressionBody::target_expr");
        }
        auto& target_expr = *in.body.target_expr();
        #if __has_include("visitor/Expression_pre_visit.hpp")
        #include "visitor/Expression_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_WRITE_DATA_pre_visit.hpp")
        #include "visitor/Expression_WRITE_DATA_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_WRITE_DATA_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_WRITE_DATA_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Expression_WRITE_DATA<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Expression_WRITE_DATA(in.id,type,kind,io_statement,target_expr));
        }
        else if constexpr (has_visitor_Expression_WRITE_DATA_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,type,kind,io_statement,target_expr));
        }
        #if __has_include("visitor/Expression_post_visit.hpp")
        #include "visitor/Expression_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_post_visit.hpp"
        #endif
        #if __has_include("visitor/Expression_WRITE_DATA_post_visit.hpp")
        #include "visitor/Expression_WRITE_DATA_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Expression_WRITE_DATA_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Expression_WRITE_DATA_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    expected<void> visit_Expression(Visitor&& visitor,const ebm::Expression& in) {
        switch (in.body.kind) {
        case ebm::ExpressionOp::LITERAL_INT:
            return visit_Expression_LITERAL_INT(visitor,in);
        case ebm::ExpressionOp::LITERAL_INT64:
            return visit_Expression_LITERAL_INT64(visitor,in);
        case ebm::ExpressionOp::LITERAL_BOOL:
            return visit_Expression_LITERAL_BOOL(visitor,in);
        case ebm::ExpressionOp::LITERAL_STRING:
            return visit_Expression_LITERAL_STRING(visitor,in);
        case ebm::ExpressionOp::LITERAL_TYPE:
            return visit_Expression_LITERAL_TYPE(visitor,in);
        case ebm::ExpressionOp::IDENTIFIER:
            return visit_Expression_IDENTIFIER(visitor,in);
        case ebm::ExpressionOp::BINARY_OP:
            return visit_Expression_BINARY_OP(visitor,in);
        case ebm::ExpressionOp::UNARY_OP:
            return visit_Expression_UNARY_OP(visitor,in);
        case ebm::ExpressionOp::CALL:
            return visit_Expression_CALL(visitor,in);
        case ebm::ExpressionOp::INDEX_ACCESS:
            return visit_Expression_INDEX_ACCESS(visitor,in);
        case ebm::ExpressionOp::MEMBER_ACCESS:
            return visit_Expression_MEMBER_ACCESS(visitor,in);
        case ebm::ExpressionOp::TYPE_CAST:
            return visit_Expression_TYPE_CAST(visitor,in);
        case ebm::ExpressionOp::RANGE:
            return visit_Expression_RANGE(visitor,in);
        case ebm::ExpressionOp::DEFAULT_VALUE:
            return visit_Expression_DEFAULT_VALUE(visitor,in);
        case ebm::ExpressionOp::IS_LITTLE_ENDIAN:
            return visit_Expression_IS_LITTLE_ENDIAN(visitor,in);
        case ebm::ExpressionOp::GET_STREAM_OFFSET:
            return visit_Expression_GET_STREAM_OFFSET(visitor,in);
        case ebm::ExpressionOp::GET_REMAINING_BYTES:
            return visit_Expression_GET_REMAINING_BYTES(visitor,in);
        case ebm::ExpressionOp::CAN_READ_STREAM:
            return visit_Expression_CAN_READ_STREAM(visitor,in);
        case ebm::ExpressionOp::ARRAY_SIZE:
            return visit_Expression_ARRAY_SIZE(visitor,in);
        case ebm::ExpressionOp::IS_ERROR:
            return visit_Expression_IS_ERROR(visitor,in);
        case ebm::ExpressionOp::MAX_VALUE:
            return visit_Expression_MAX_VALUE(visitor,in);
        case ebm::ExpressionOp::READ_DATA:
            return visit_Expression_READ_DATA(visitor,in);
        case ebm::ExpressionOp::WRITE_DATA:
            return visit_Expression_WRITE_DATA(visitor,in);
        default:
            return unexpect_error("Unknown Expression kind: {}", to_string(in.body.kind));
        }
    }
    template<typename Visitor>
    expected<void> visit_Type(Visitor&& visitor,const ebm::Type& in);
    template<typename Visitor>
    concept has_visitor_Type_INT = requires(Visitor v) {
         { v.visit_Type_INT(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().size()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Type_INT_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().size()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Type_INT(Visitor&& visitor,const ebm::Type& in) {
        #if __has_include("visitor/Type_pre_validate.hpp")
        #include "visitor/Type_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Type_INT_pre_validate.hpp")
        #include "visitor/Type_INT_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_INT_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_INT_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.size()) {
            return unexpect_error("Unexpected null pointer for TypeBody::size");
        }
        auto& size = *in.body.size();
        #if __has_include("visitor/Type_pre_visit.hpp")
        #include "visitor/Type_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Type_INT_pre_visit.hpp")
        #include "visitor/Type_INT_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_INT_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_INT_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Type_INT<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Type_INT(in.id,kind,size));
        }
        else if constexpr (has_visitor_Type_INT_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,size));
        }
        #if __has_include("visitor/Type_post_visit.hpp")
        #include "visitor/Type_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_post_visit.hpp"
        #endif
        #if __has_include("visitor/Type_INT_post_visit.hpp")
        #include "visitor/Type_INT_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_INT_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_INT_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Type_UINT = requires(Visitor v) {
         { v.visit_Type_UINT(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().size()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Type_UINT_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().size()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Type_UINT(Visitor&& visitor,const ebm::Type& in) {
        #if __has_include("visitor/Type_pre_validate.hpp")
        #include "visitor/Type_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Type_UINT_pre_validate.hpp")
        #include "visitor/Type_UINT_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_UINT_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_UINT_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.size()) {
            return unexpect_error("Unexpected null pointer for TypeBody::size");
        }
        auto& size = *in.body.size();
        #if __has_include("visitor/Type_pre_visit.hpp")
        #include "visitor/Type_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Type_UINT_pre_visit.hpp")
        #include "visitor/Type_UINT_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_UINT_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_UINT_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Type_UINT<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Type_UINT(in.id,kind,size));
        }
        else if constexpr (has_visitor_Type_UINT_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,size));
        }
        #if __has_include("visitor/Type_post_visit.hpp")
        #include "visitor/Type_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_post_visit.hpp"
        #endif
        #if __has_include("visitor/Type_UINT_post_visit.hpp")
        #include "visitor/Type_UINT_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_UINT_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_UINT_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Type_FLOAT = requires(Visitor v) {
         { v.visit_Type_FLOAT(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().size()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Type_FLOAT_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().size()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Type_FLOAT(Visitor&& visitor,const ebm::Type& in) {
        #if __has_include("visitor/Type_pre_validate.hpp")
        #include "visitor/Type_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Type_FLOAT_pre_validate.hpp")
        #include "visitor/Type_FLOAT_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_FLOAT_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_FLOAT_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.size()) {
            return unexpect_error("Unexpected null pointer for TypeBody::size");
        }
        auto& size = *in.body.size();
        #if __has_include("visitor/Type_pre_visit.hpp")
        #include "visitor/Type_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Type_FLOAT_pre_visit.hpp")
        #include "visitor/Type_FLOAT_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_FLOAT_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_FLOAT_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Type_FLOAT<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Type_FLOAT(in.id,kind,size));
        }
        else if constexpr (has_visitor_Type_FLOAT_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,size));
        }
        #if __has_include("visitor/Type_post_visit.hpp")
        #include "visitor/Type_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_post_visit.hpp"
        #endif
        #if __has_include("visitor/Type_FLOAT_post_visit.hpp")
        #include "visitor/Type_FLOAT_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_FLOAT_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_FLOAT_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Type_STRUCT = requires(Visitor v) {
         { v.visit_Type_STRUCT(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().id()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Type_STRUCT_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().id()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Type_STRUCT(Visitor&& visitor,const ebm::Type& in) {
        #if __has_include("visitor/Type_pre_validate.hpp")
        #include "visitor/Type_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Type_STRUCT_pre_validate.hpp")
        #include "visitor/Type_STRUCT_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_STRUCT_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_STRUCT_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.id()) {
            return unexpect_error("Unexpected null pointer for TypeBody::id");
        }
        auto& id = *in.body.id();
        #if __has_include("visitor/Type_pre_visit.hpp")
        #include "visitor/Type_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Type_STRUCT_pre_visit.hpp")
        #include "visitor/Type_STRUCT_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_STRUCT_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_STRUCT_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Type_STRUCT<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Type_STRUCT(in.id,kind,id));
        }
        else if constexpr (has_visitor_Type_STRUCT_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,id));
        }
        #if __has_include("visitor/Type_post_visit.hpp")
        #include "visitor/Type_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_post_visit.hpp"
        #endif
        #if __has_include("visitor/Type_STRUCT_post_visit.hpp")
        #include "visitor/Type_STRUCT_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_STRUCT_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_STRUCT_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Type_RECURSIVE_STRUCT = requires(Visitor v) {
         { v.visit_Type_RECURSIVE_STRUCT(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().id()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Type_RECURSIVE_STRUCT_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().id()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Type_RECURSIVE_STRUCT(Visitor&& visitor,const ebm::Type& in) {
        #if __has_include("visitor/Type_pre_validate.hpp")
        #include "visitor/Type_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Type_RECURSIVE_STRUCT_pre_validate.hpp")
        #include "visitor/Type_RECURSIVE_STRUCT_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_RECURSIVE_STRUCT_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_RECURSIVE_STRUCT_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.id()) {
            return unexpect_error("Unexpected null pointer for TypeBody::id");
        }
        auto& id = *in.body.id();
        #if __has_include("visitor/Type_pre_visit.hpp")
        #include "visitor/Type_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Type_RECURSIVE_STRUCT_pre_visit.hpp")
        #include "visitor/Type_RECURSIVE_STRUCT_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_RECURSIVE_STRUCT_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_RECURSIVE_STRUCT_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Type_RECURSIVE_STRUCT<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Type_RECURSIVE_STRUCT(in.id,kind,id));
        }
        else if constexpr (has_visitor_Type_RECURSIVE_STRUCT_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,id));
        }
        #if __has_include("visitor/Type_post_visit.hpp")
        #include "visitor/Type_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_post_visit.hpp"
        #endif
        #if __has_include("visitor/Type_RECURSIVE_STRUCT_post_visit.hpp")
        #include "visitor/Type_RECURSIVE_STRUCT_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_RECURSIVE_STRUCT_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_RECURSIVE_STRUCT_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Type_BOOL = requires(Visitor v) {
         { v.visit_Type_BOOL(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Type_BOOL_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Type_BOOL(Visitor&& visitor,const ebm::Type& in) {
        #if __has_include("visitor/Type_pre_validate.hpp")
        #include "visitor/Type_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Type_BOOL_pre_validate.hpp")
        #include "visitor/Type_BOOL_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_BOOL_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_BOOL_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        #if __has_include("visitor/Type_pre_visit.hpp")
        #include "visitor/Type_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Type_BOOL_pre_visit.hpp")
        #include "visitor/Type_BOOL_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_BOOL_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_BOOL_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Type_BOOL<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Type_BOOL(in.id,kind));
        }
        else if constexpr (has_visitor_Type_BOOL_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind));
        }
        #if __has_include("visitor/Type_post_visit.hpp")
        #include "visitor/Type_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_post_visit.hpp"
        #endif
        #if __has_include("visitor/Type_BOOL_post_visit.hpp")
        #include "visitor/Type_BOOL_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_BOOL_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_BOOL_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Type_VOID = requires(Visitor v) {
         { v.visit_Type_VOID(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Type_VOID_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Type_VOID(Visitor&& visitor,const ebm::Type& in) {
        #if __has_include("visitor/Type_pre_validate.hpp")
        #include "visitor/Type_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Type_VOID_pre_validate.hpp")
        #include "visitor/Type_VOID_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_VOID_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_VOID_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        #if __has_include("visitor/Type_pre_visit.hpp")
        #include "visitor/Type_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Type_VOID_pre_visit.hpp")
        #include "visitor/Type_VOID_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_VOID_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_VOID_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Type_VOID<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Type_VOID(in.id,kind));
        }
        else if constexpr (has_visitor_Type_VOID_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind));
        }
        #if __has_include("visitor/Type_post_visit.hpp")
        #include "visitor/Type_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_post_visit.hpp"
        #endif
        #if __has_include("visitor/Type_VOID_post_visit.hpp")
        #include "visitor/Type_VOID_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_VOID_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_VOID_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Type_META = requires(Visitor v) {
         { v.visit_Type_META(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Type_META_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Type_META(Visitor&& visitor,const ebm::Type& in) {
        #if __has_include("visitor/Type_pre_validate.hpp")
        #include "visitor/Type_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Type_META_pre_validate.hpp")
        #include "visitor/Type_META_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_META_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_META_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        #if __has_include("visitor/Type_pre_visit.hpp")
        #include "visitor/Type_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Type_META_pre_visit.hpp")
        #include "visitor/Type_META_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_META_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_META_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Type_META<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Type_META(in.id,kind));
        }
        else if constexpr (has_visitor_Type_META_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind));
        }
        #if __has_include("visitor/Type_post_visit.hpp")
        #include "visitor/Type_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_post_visit.hpp"
        #endif
        #if __has_include("visitor/Type_META_post_visit.hpp")
        #include "visitor/Type_META_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_META_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_META_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Type_ENUM = requires(Visitor v) {
         { v.visit_Type_ENUM(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().base_type(),*std::declval<const ebm::TypeBody&>().id()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Type_ENUM_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().base_type(),*std::declval<const ebm::TypeBody&>().id()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Type_ENUM(Visitor&& visitor,const ebm::Type& in) {
        #if __has_include("visitor/Type_pre_validate.hpp")
        #include "visitor/Type_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Type_ENUM_pre_validate.hpp")
        #include "visitor/Type_ENUM_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_ENUM_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_ENUM_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.base_type()) {
            return unexpect_error("Unexpected null pointer for TypeBody::base_type");
        }
        auto& base_type = *in.body.base_type();
        if (!in.body.id()) {
            return unexpect_error("Unexpected null pointer for TypeBody::id");
        }
        auto& id = *in.body.id();
        #if __has_include("visitor/Type_pre_visit.hpp")
        #include "visitor/Type_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Type_ENUM_pre_visit.hpp")
        #include "visitor/Type_ENUM_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_ENUM_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_ENUM_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Type_ENUM<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Type_ENUM(in.id,kind,base_type,id));
        }
        else if constexpr (has_visitor_Type_ENUM_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,base_type,id));
        }
        #if __has_include("visitor/Type_post_visit.hpp")
        #include "visitor/Type_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_post_visit.hpp"
        #endif
        #if __has_include("visitor/Type_ENUM_post_visit.hpp")
        #include "visitor/Type_ENUM_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_ENUM_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_ENUM_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Type_ARRAY = requires(Visitor v) {
         { v.visit_Type_ARRAY(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().element_type(),*std::declval<const ebm::TypeBody&>().length()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Type_ARRAY_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().element_type(),*std::declval<const ebm::TypeBody&>().length()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Type_ARRAY(Visitor&& visitor,const ebm::Type& in) {
        #if __has_include("visitor/Type_pre_validate.hpp")
        #include "visitor/Type_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Type_ARRAY_pre_validate.hpp")
        #include "visitor/Type_ARRAY_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_ARRAY_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_ARRAY_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.element_type()) {
            return unexpect_error("Unexpected null pointer for TypeBody::element_type");
        }
        auto& element_type = *in.body.element_type();
        if (!in.body.length()) {
            return unexpect_error("Unexpected null pointer for TypeBody::length");
        }
        auto& length = *in.body.length();
        #if __has_include("visitor/Type_pre_visit.hpp")
        #include "visitor/Type_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Type_ARRAY_pre_visit.hpp")
        #include "visitor/Type_ARRAY_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_ARRAY_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_ARRAY_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Type_ARRAY<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Type_ARRAY(in.id,kind,element_type,length));
        }
        else if constexpr (has_visitor_Type_ARRAY_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,element_type,length));
        }
        #if __has_include("visitor/Type_post_visit.hpp")
        #include "visitor/Type_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_post_visit.hpp"
        #endif
        #if __has_include("visitor/Type_ARRAY_post_visit.hpp")
        #include "visitor/Type_ARRAY_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_ARRAY_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_ARRAY_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Type_VECTOR = requires(Visitor v) {
         { v.visit_Type_VECTOR(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().element_type()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Type_VECTOR_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().element_type()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Type_VECTOR(Visitor&& visitor,const ebm::Type& in) {
        #if __has_include("visitor/Type_pre_validate.hpp")
        #include "visitor/Type_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Type_VECTOR_pre_validate.hpp")
        #include "visitor/Type_VECTOR_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_VECTOR_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_VECTOR_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.element_type()) {
            return unexpect_error("Unexpected null pointer for TypeBody::element_type");
        }
        auto& element_type = *in.body.element_type();
        #if __has_include("visitor/Type_pre_visit.hpp")
        #include "visitor/Type_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Type_VECTOR_pre_visit.hpp")
        #include "visitor/Type_VECTOR_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_VECTOR_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_VECTOR_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Type_VECTOR<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Type_VECTOR(in.id,kind,element_type));
        }
        else if constexpr (has_visitor_Type_VECTOR_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,element_type));
        }
        #if __has_include("visitor/Type_post_visit.hpp")
        #include "visitor/Type_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_post_visit.hpp"
        #endif
        #if __has_include("visitor/Type_VECTOR_post_visit.hpp")
        #include "visitor/Type_VECTOR_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_VECTOR_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_VECTOR_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Type_VARIANT = requires(Visitor v) {
         { v.visit_Type_VARIANT(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().common_type(),*std::declval<const ebm::TypeBody&>().members()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Type_VARIANT_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().common_type(),*std::declval<const ebm::TypeBody&>().members()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Type_VARIANT(Visitor&& visitor,const ebm::Type& in) {
        #if __has_include("visitor/Type_pre_validate.hpp")
        #include "visitor/Type_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Type_VARIANT_pre_validate.hpp")
        #include "visitor/Type_VARIANT_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_VARIANT_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_VARIANT_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.common_type()) {
            return unexpect_error("Unexpected null pointer for TypeBody::common_type");
        }
        auto& common_type = *in.body.common_type();
        if (!in.body.members()) {
            return unexpect_error("Unexpected null pointer for TypeBody::members");
        }
        auto& members = *in.body.members();
        #if __has_include("visitor/Type_pre_visit.hpp")
        #include "visitor/Type_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Type_VARIANT_pre_visit.hpp")
        #include "visitor/Type_VARIANT_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_VARIANT_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_VARIANT_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Type_VARIANT<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Type_VARIANT(in.id,kind,common_type,members));
        }
        else if constexpr (has_visitor_Type_VARIANT_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,common_type,members));
        }
        #if __has_include("visitor/Type_post_visit.hpp")
        #include "visitor/Type_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_post_visit.hpp"
        #endif
        #if __has_include("visitor/Type_VARIANT_post_visit.hpp")
        #include "visitor/Type_VARIANT_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_VARIANT_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_VARIANT_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Type_RANGE = requires(Visitor v) {
         { v.visit_Type_RANGE(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().base_type()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Type_RANGE_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().base_type()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Type_RANGE(Visitor&& visitor,const ebm::Type& in) {
        #if __has_include("visitor/Type_pre_validate.hpp")
        #include "visitor/Type_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Type_RANGE_pre_validate.hpp")
        #include "visitor/Type_RANGE_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_RANGE_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_RANGE_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.base_type()) {
            return unexpect_error("Unexpected null pointer for TypeBody::base_type");
        }
        auto& base_type = *in.body.base_type();
        #if __has_include("visitor/Type_pre_visit.hpp")
        #include "visitor/Type_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Type_RANGE_pre_visit.hpp")
        #include "visitor/Type_RANGE_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_RANGE_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_RANGE_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Type_RANGE<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Type_RANGE(in.id,kind,base_type));
        }
        else if constexpr (has_visitor_Type_RANGE_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,base_type));
        }
        #if __has_include("visitor/Type_post_visit.hpp")
        #include "visitor/Type_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_post_visit.hpp"
        #endif
        #if __has_include("visitor/Type_RANGE_post_visit.hpp")
        #include "visitor/Type_RANGE_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_RANGE_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_RANGE_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Type_ENCODER_RETURN = requires(Visitor v) {
         { v.visit_Type_ENCODER_RETURN(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Type_ENCODER_RETURN_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Type_ENCODER_RETURN(Visitor&& visitor,const ebm::Type& in) {
        #if __has_include("visitor/Type_pre_validate.hpp")
        #include "visitor/Type_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Type_ENCODER_RETURN_pre_validate.hpp")
        #include "visitor/Type_ENCODER_RETURN_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_ENCODER_RETURN_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_ENCODER_RETURN_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        #if __has_include("visitor/Type_pre_visit.hpp")
        #include "visitor/Type_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Type_ENCODER_RETURN_pre_visit.hpp")
        #include "visitor/Type_ENCODER_RETURN_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_ENCODER_RETURN_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_ENCODER_RETURN_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Type_ENCODER_RETURN<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Type_ENCODER_RETURN(in.id,kind));
        }
        else if constexpr (has_visitor_Type_ENCODER_RETURN_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind));
        }
        #if __has_include("visitor/Type_post_visit.hpp")
        #include "visitor/Type_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_post_visit.hpp"
        #endif
        #if __has_include("visitor/Type_ENCODER_RETURN_post_visit.hpp")
        #include "visitor/Type_ENCODER_RETURN_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_ENCODER_RETURN_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_ENCODER_RETURN_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Type_DECODER_RETURN = requires(Visitor v) {
         { v.visit_Type_DECODER_RETURN(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Type_DECODER_RETURN_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Type_DECODER_RETURN(Visitor&& visitor,const ebm::Type& in) {
        #if __has_include("visitor/Type_pre_validate.hpp")
        #include "visitor/Type_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Type_DECODER_RETURN_pre_validate.hpp")
        #include "visitor/Type_DECODER_RETURN_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_DECODER_RETURN_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_DECODER_RETURN_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        #if __has_include("visitor/Type_pre_visit.hpp")
        #include "visitor/Type_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Type_DECODER_RETURN_pre_visit.hpp")
        #include "visitor/Type_DECODER_RETURN_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_DECODER_RETURN_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_DECODER_RETURN_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Type_DECODER_RETURN<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Type_DECODER_RETURN(in.id,kind));
        }
        else if constexpr (has_visitor_Type_DECODER_RETURN_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind));
        }
        #if __has_include("visitor/Type_post_visit.hpp")
        #include "visitor/Type_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_post_visit.hpp"
        #endif
        #if __has_include("visitor/Type_DECODER_RETURN_post_visit.hpp")
        #include "visitor/Type_DECODER_RETURN_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_DECODER_RETURN_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_DECODER_RETURN_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Type_PROPERTY_SETTER_RETURN = requires(Visitor v) {
         { v.visit_Type_PROPERTY_SETTER_RETURN(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().property_type()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Type_PROPERTY_SETTER_RETURN_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().property_type()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Type_PROPERTY_SETTER_RETURN(Visitor&& visitor,const ebm::Type& in) {
        #if __has_include("visitor/Type_pre_validate.hpp")
        #include "visitor/Type_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Type_PROPERTY_SETTER_RETURN_pre_validate.hpp")
        #include "visitor/Type_PROPERTY_SETTER_RETURN_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_PROPERTY_SETTER_RETURN_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_PROPERTY_SETTER_RETURN_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.property_type()) {
            return unexpect_error("Unexpected null pointer for TypeBody::property_type");
        }
        auto& property_type = *in.body.property_type();
        #if __has_include("visitor/Type_pre_visit.hpp")
        #include "visitor/Type_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Type_PROPERTY_SETTER_RETURN_pre_visit.hpp")
        #include "visitor/Type_PROPERTY_SETTER_RETURN_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_PROPERTY_SETTER_RETURN_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_PROPERTY_SETTER_RETURN_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Type_PROPERTY_SETTER_RETURN<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Type_PROPERTY_SETTER_RETURN(in.id,kind,property_type));
        }
        else if constexpr (has_visitor_Type_PROPERTY_SETTER_RETURN_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,property_type));
        }
        #if __has_include("visitor/Type_post_visit.hpp")
        #include "visitor/Type_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_post_visit.hpp"
        #endif
        #if __has_include("visitor/Type_PROPERTY_SETTER_RETURN_post_visit.hpp")
        #include "visitor/Type_PROPERTY_SETTER_RETURN_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_PROPERTY_SETTER_RETURN_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_PROPERTY_SETTER_RETURN_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Type_OPTIONAL = requires(Visitor v) {
         { v.visit_Type_OPTIONAL(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().inner_type()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Type_OPTIONAL_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().inner_type()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Type_OPTIONAL(Visitor&& visitor,const ebm::Type& in) {
        #if __has_include("visitor/Type_pre_validate.hpp")
        #include "visitor/Type_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Type_OPTIONAL_pre_validate.hpp")
        #include "visitor/Type_OPTIONAL_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_OPTIONAL_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_OPTIONAL_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.inner_type()) {
            return unexpect_error("Unexpected null pointer for TypeBody::inner_type");
        }
        auto& inner_type = *in.body.inner_type();
        #if __has_include("visitor/Type_pre_visit.hpp")
        #include "visitor/Type_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Type_OPTIONAL_pre_visit.hpp")
        #include "visitor/Type_OPTIONAL_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_OPTIONAL_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_OPTIONAL_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Type_OPTIONAL<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Type_OPTIONAL(in.id,kind,inner_type));
        }
        else if constexpr (has_visitor_Type_OPTIONAL_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,inner_type));
        }
        #if __has_include("visitor/Type_post_visit.hpp")
        #include "visitor/Type_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_post_visit.hpp"
        #endif
        #if __has_include("visitor/Type_OPTIONAL_post_visit.hpp")
        #include "visitor/Type_OPTIONAL_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_OPTIONAL_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_OPTIONAL_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Type_PTR = requires(Visitor v) {
         { v.visit_Type_PTR(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().pointee_type()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Type_PTR_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().pointee_type()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Type_PTR(Visitor&& visitor,const ebm::Type& in) {
        #if __has_include("visitor/Type_pre_validate.hpp")
        #include "visitor/Type_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Type_PTR_pre_validate.hpp")
        #include "visitor/Type_PTR_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_PTR_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_PTR_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.pointee_type()) {
            return unexpect_error("Unexpected null pointer for TypeBody::pointee_type");
        }
        auto& pointee_type = *in.body.pointee_type();
        #if __has_include("visitor/Type_pre_visit.hpp")
        #include "visitor/Type_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Type_PTR_pre_visit.hpp")
        #include "visitor/Type_PTR_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_PTR_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_PTR_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Type_PTR<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Type_PTR(in.id,kind,pointee_type));
        }
        else if constexpr (has_visitor_Type_PTR_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,pointee_type));
        }
        #if __has_include("visitor/Type_post_visit.hpp")
        #include "visitor/Type_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_post_visit.hpp"
        #endif
        #if __has_include("visitor/Type_PTR_post_visit.hpp")
        #include "visitor/Type_PTR_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_PTR_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_PTR_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    concept has_visitor_Type_FUNCTION = requires(Visitor v) {
         { v.visit_Type_FUNCTION(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().params(),*std::declval<const ebm::TypeBody&>().return_type()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    concept has_visitor_Type_FUNCTION_call = requires(Visitor fn) {
         { fn(std::declval<const ebm::TypeRef&>(),std::declval<const ebm::TypeBody&>().kind,*std::declval<const ebm::TypeBody&>().params(),*std::declval<const ebm::TypeBody&>().return_type()) } -> std::convertible_to<expected<void>>;
    };
    template<typename Visitor>
    expected<void> visit_Type_FUNCTION(Visitor&& visitor,const ebm::Type& in) {
        #if __has_include("visitor/Type_pre_validate.hpp")
        #include "visitor/Type_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_validate.hpp"
        #endif
        #if __has_include("visitor/Type_FUNCTION_pre_validate.hpp")
        #include "visitor/Type_FUNCTION_pre_validate.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_FUNCTION_pre_validate.hpp")
        #include "ebmcodegen/default_visitor/Type_FUNCTION_pre_validate.hpp"
        #endif
        auto& kind = in.body.kind;
        if (!in.body.params()) {
            return unexpect_error("Unexpected null pointer for TypeBody::params");
        }
        auto& params = *in.body.params();
        if (!in.body.return_type()) {
            return unexpect_error("Unexpected null pointer for TypeBody::return_type");
        }
        auto& return_type = *in.body.return_type();
        #if __has_include("visitor/Type_pre_visit.hpp")
        #include "visitor/Type_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_pre_visit.hpp"
        #endif
        #if __has_include("visitor/Type_FUNCTION_pre_visit.hpp")
        #include "visitor/Type_FUNCTION_pre_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_FUNCTION_pre_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_FUNCTION_pre_visit.hpp"
        #endif
        if constexpr (has_visitor_Type_FUNCTION<Visitor>) {
            MAYBE_VOID(result, visitor.visit_Type_FUNCTION(in.id,kind,params,return_type));
        }
        else if constexpr (has_visitor_Type_FUNCTION_call<Visitor>) {
            MAYBE_VOID(result,visitor(in.id,kind,params,return_type));
        }
        #if __has_include("visitor/Type_post_visit.hpp")
        #include "visitor/Type_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_post_visit.hpp"
        #endif
        #if __has_include("visitor/Type_FUNCTION_post_visit.hpp")
        #include "visitor/Type_FUNCTION_post_visit.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Type_FUNCTION_post_visit.hpp")
        #include "ebmcodegen/default_visitor/Type_FUNCTION_post_visit.hpp"
        #endif
        return {};
    }
    template<typename Visitor>
    expected<void> visit_Type(Visitor&& visitor,const ebm::Type& in) {
        switch (in.body.kind) {
        case ebm::TypeKind::INT:
            return visit_Type_INT(visitor,in);
        case ebm::TypeKind::UINT:
            return visit_Type_UINT(visitor,in);
        case ebm::TypeKind::FLOAT:
            return visit_Type_FLOAT(visitor,in);
        case ebm::TypeKind::STRUCT:
            return visit_Type_STRUCT(visitor,in);
        case ebm::TypeKind::RECURSIVE_STRUCT:
            return visit_Type_RECURSIVE_STRUCT(visitor,in);
        case ebm::TypeKind::BOOL:
            return visit_Type_BOOL(visitor,in);
        case ebm::TypeKind::VOID:
            return visit_Type_VOID(visitor,in);
        case ebm::TypeKind::META:
            return visit_Type_META(visitor,in);
        case ebm::TypeKind::ENUM:
            return visit_Type_ENUM(visitor,in);
        case ebm::TypeKind::ARRAY:
            return visit_Type_ARRAY(visitor,in);
        case ebm::TypeKind::VECTOR:
            return visit_Type_VECTOR(visitor,in);
        case ebm::TypeKind::VARIANT:
            return visit_Type_VARIANT(visitor,in);
        case ebm::TypeKind::RANGE:
            return visit_Type_RANGE(visitor,in);
        case ebm::TypeKind::ENCODER_RETURN:
            return visit_Type_ENCODER_RETURN(visitor,in);
        case ebm::TypeKind::DECODER_RETURN:
            return visit_Type_DECODER_RETURN(visitor,in);
        case ebm::TypeKind::PROPERTY_SETTER_RETURN:
            return visit_Type_PROPERTY_SETTER_RETURN(visitor,in);
        case ebm::TypeKind::OPTIONAL:
            return visit_Type_OPTIONAL(visitor,in);
        case ebm::TypeKind::PTR:
            return visit_Type_PTR(visitor,in);
        case ebm::TypeKind::FUNCTION:
            return visit_Type_FUNCTION(visitor,in);
        default:
            return unexpect_error("Unknown Type kind: {}", to_string(in.body.kind));
        }
    }
    struct Visitor {
        static constexpr const char* program_name = "ebm2python";
        ebmgen::MappingTable module_;
        futils::code::CodeWriter<futils::binary::writer&> root;
        Visitor(const ebm::ExtendedBinaryModule& m,futils::binary::writer& w) : module_(m), root{w} {}
        #if __has_include("visitor/Visitor.hpp")
        #include "visitor/Visitor.hpp"
        #elif __has_include("ebmcodegen/default_visitor/Visitor.hpp")
        #include "ebmcodegen/default_visitor/Visitor.hpp"
        #endif
        expected<void> entry() {
            #if __has_include("visitor/entry.hpp")
            #include "visitor/entry.hpp"
            #elif __has_include("ebmcodegen/default_visitor/entry.hpp")
            #include "ebmcodegen/default_visitor/entry.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_BLOCK(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::Block& block) {
            #if __has_include("visitor/Statement_BLOCK.hpp")
            #include "visitor/Statement_BLOCK.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_BLOCK.hpp")
            #include "ebmcodegen/default_visitor/Statement_BLOCK.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_ASSIGNMENT(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::StatementRef& previous_assignment,const ebm::ExpressionRef& target,const ebm::ExpressionRef& value) {
            #if __has_include("visitor/Statement_ASSIGNMENT.hpp")
            #include "visitor/Statement_ASSIGNMENT.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_ASSIGNMENT.hpp")
            #include "ebmcodegen/default_visitor/Statement_ASSIGNMENT.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_APPEND(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::ExpressionRef& target,const ebm::ExpressionRef& value) {
            #if __has_include("visitor/Statement_APPEND.hpp")
            #include "visitor/Statement_APPEND.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_APPEND.hpp")
            #include "ebmcodegen/default_visitor/Statement_APPEND.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_RETURN(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::ExpressionRef& value) {
            #if __has_include("visitor/Statement_RETURN.hpp")
            #include "visitor/Statement_RETURN.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_RETURN.hpp")
            #include "ebmcodegen/default_visitor/Statement_RETURN.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_ERROR_RETURN(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::ExpressionRef& value) {
            #if __has_include("visitor/Statement_ERROR_RETURN.hpp")
            #include "visitor/Statement_ERROR_RETURN.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_ERROR_RETURN.hpp")
            #include "ebmcodegen/default_visitor/Statement_ERROR_RETURN.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_ASSERT(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::AssertDesc& assert_desc) {
            #if __has_include("visitor/Statement_ASSERT.hpp")
            #include "visitor/Statement_ASSERT.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_ASSERT.hpp")
            #include "ebmcodegen/default_visitor/Statement_ASSERT.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_READ_DATA(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::IOData& read_data) {
            #if __has_include("visitor/Statement_READ_DATA.hpp")
            #include "visitor/Statement_READ_DATA.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_READ_DATA.hpp")
            #include "ebmcodegen/default_visitor/Statement_READ_DATA.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_WRITE_DATA(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::IOData& write_data) {
            #if __has_include("visitor/Statement_WRITE_DATA.hpp")
            #include "visitor/Statement_WRITE_DATA.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_WRITE_DATA.hpp")
            #include "ebmcodegen/default_visitor/Statement_WRITE_DATA.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_SEEK_STREAM(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::ExpressionRef& offset,const ebm::StreamType& stream_type) {
            #if __has_include("visitor/Statement_SEEK_STREAM.hpp")
            #include "visitor/Statement_SEEK_STREAM.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_SEEK_STREAM.hpp")
            #include "ebmcodegen/default_visitor/Statement_SEEK_STREAM.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_IF_STATEMENT(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::IfStatement& if_statement) {
            #if __has_include("visitor/Statement_IF_STATEMENT.hpp")
            #include "visitor/Statement_IF_STATEMENT.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_IF_STATEMENT.hpp")
            #include "ebmcodegen/default_visitor/Statement_IF_STATEMENT.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_LOOP_STATEMENT(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::LoopStatement& loop) {
            #if __has_include("visitor/Statement_LOOP_STATEMENT.hpp")
            #include "visitor/Statement_LOOP_STATEMENT.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_LOOP_STATEMENT.hpp")
            #include "ebmcodegen/default_visitor/Statement_LOOP_STATEMENT.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_MATCH_STATEMENT(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::MatchStatement& match_statement) {
            #if __has_include("visitor/Statement_MATCH_STATEMENT.hpp")
            #include "visitor/Statement_MATCH_STATEMENT.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_MATCH_STATEMENT.hpp")
            #include "ebmcodegen/default_visitor/Statement_MATCH_STATEMENT.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_MATCH_BRANCH(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::MatchBranch& match_branch) {
            #if __has_include("visitor/Statement_MATCH_BRANCH.hpp")
            #include "visitor/Statement_MATCH_BRANCH.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_MATCH_BRANCH.hpp")
            #include "ebmcodegen/default_visitor/Statement_MATCH_BRANCH.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_BREAK(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::LoopFlowControl& break_) {
            #if __has_include("visitor/Statement_BREAK.hpp")
            #include "visitor/Statement_BREAK.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_BREAK.hpp")
            #include "ebmcodegen/default_visitor/Statement_BREAK.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_CONTINUE(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::LoopFlowControl& continue_) {
            #if __has_include("visitor/Statement_CONTINUE.hpp")
            #include "visitor/Statement_CONTINUE.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_CONTINUE.hpp")
            #include "ebmcodegen/default_visitor/Statement_CONTINUE.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_FUNCTION_DECL(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::FunctionDecl& func_decl) {
            #if __has_include("visitor/Statement_FUNCTION_DECL.hpp")
            #include "visitor/Statement_FUNCTION_DECL.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_FUNCTION_DECL.hpp")
            #include "ebmcodegen/default_visitor/Statement_FUNCTION_DECL.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_VARIABLE_DECL(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::VariableDecl& var_decl) {
            #if __has_include("visitor/Statement_VARIABLE_DECL.hpp")
            #include "visitor/Statement_VARIABLE_DECL.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_VARIABLE_DECL.hpp")
            #include "ebmcodegen/default_visitor/Statement_VARIABLE_DECL.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_FIELD_DECL(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::FieldDecl& field_decl) {
            #if __has_include("visitor/Statement_FIELD_DECL.hpp")
            #include "visitor/Statement_FIELD_DECL.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_FIELD_DECL.hpp")
            #include "ebmcodegen/default_visitor/Statement_FIELD_DECL.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_ENUM_DECL(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::EnumDecl& enum_decl) {
            #if __has_include("visitor/Statement_ENUM_DECL.hpp")
            #include "visitor/Statement_ENUM_DECL.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_ENUM_DECL.hpp")
            #include "ebmcodegen/default_visitor/Statement_ENUM_DECL.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_ENUM_MEMBER_DECL(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::EnumMemberDecl& enum_member_decl) {
            #if __has_include("visitor/Statement_ENUM_MEMBER_DECL.hpp")
            #include "visitor/Statement_ENUM_MEMBER_DECL.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_ENUM_MEMBER_DECL.hpp")
            #include "ebmcodegen/default_visitor/Statement_ENUM_MEMBER_DECL.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_STRUCT_DECL(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::StructDecl& struct_decl) {
            #if __has_include("visitor/Statement_STRUCT_DECL.hpp")
            #include "visitor/Statement_STRUCT_DECL.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_STRUCT_DECL.hpp")
            #include "ebmcodegen/default_visitor/Statement_STRUCT_DECL.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_UNION_DECL(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::UnionDecl& union_decl) {
            #if __has_include("visitor/Statement_UNION_DECL.hpp")
            #include "visitor/Statement_UNION_DECL.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_UNION_DECL.hpp")
            #include "ebmcodegen/default_visitor/Statement_UNION_DECL.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_UNION_MEMBER_DECL(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::UnionMemberDecl& union_member_decl) {
            #if __has_include("visitor/Statement_UNION_MEMBER_DECL.hpp")
            #include "visitor/Statement_UNION_MEMBER_DECL.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_UNION_MEMBER_DECL.hpp")
            #include "ebmcodegen/default_visitor/Statement_UNION_MEMBER_DECL.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_PROGRAM_DECL(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::Block& block) {
            #if __has_include("visitor/Statement_PROGRAM_DECL.hpp")
            #include "visitor/Statement_PROGRAM_DECL.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_PROGRAM_DECL.hpp")
            #include "ebmcodegen/default_visitor/Statement_PROGRAM_DECL.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_STATE_DECL(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::StateDecl& state_decl) {
            #if __has_include("visitor/Statement_STATE_DECL.hpp")
            #include "visitor/Statement_STATE_DECL.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_STATE_DECL.hpp")
            #include "ebmcodegen/default_visitor/Statement_STATE_DECL.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_BIT_FIELD_DECL(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::BitFieldDecl& bit_field_decl) {
            #if __has_include("visitor/Statement_BIT_FIELD_DECL.hpp")
            #include "visitor/Statement_BIT_FIELD_DECL.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_BIT_FIELD_DECL.hpp")
            #include "ebmcodegen/default_visitor/Statement_BIT_FIELD_DECL.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_PROPERTY_DECL(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::PropertyDecl& property_decl) {
            #if __has_include("visitor/Statement_PROPERTY_DECL.hpp")
            #include "visitor/Statement_PROPERTY_DECL.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_PROPERTY_DECL.hpp")
            #include "ebmcodegen/default_visitor/Statement_PROPERTY_DECL.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_METADATA(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::Metadata& metadata) {
            #if __has_include("visitor/Statement_METADATA.hpp")
            #include "visitor/Statement_METADATA.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_METADATA.hpp")
            #include "ebmcodegen/default_visitor/Statement_METADATA.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_IMPORT_MODULE(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::IdentifierRef& alias,const ebm::IdentifierRef& module_name) {
            #if __has_include("visitor/Statement_IMPORT_MODULE.hpp")
            #include "visitor/Statement_IMPORT_MODULE.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_IMPORT_MODULE.hpp")
            #include "ebmcodegen/default_visitor/Statement_IMPORT_MODULE.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_EXPRESSION(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::ExpressionRef& expression) {
            #if __has_include("visitor/Statement_EXPRESSION.hpp")
            #include "visitor/Statement_EXPRESSION.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_EXPRESSION.hpp")
            #include "ebmcodegen/default_visitor/Statement_EXPRESSION.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_PHI_NODE(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const std::vector<ebm::PhiParam>& params,const ebm::Varint& params_len,const ebm::ExpressionRef& target_var) {
            #if __has_include("visitor/Statement_PHI_NODE.hpp")
            #include "visitor/Statement_PHI_NODE.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_PHI_NODE.hpp")
            #include "ebmcodegen/default_visitor/Statement_PHI_NODE.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_ERROR_REPORT(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::ErrorReport& error_report) {
            #if __has_include("visitor/Statement_ERROR_REPORT.hpp")
            #include "visitor/Statement_ERROR_REPORT.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_ERROR_REPORT.hpp")
            #include "ebmcodegen/default_visitor/Statement_ERROR_REPORT.hpp"
            #endif
            return {};
        }
        expected<void> visit_Statement_LOWERED_STATEMENTS(const ebm::StatementRef& item_id,const ebm::StatementOp& kind,const ebm::LoweredStatements& lowered_statements) {
            #if __has_include("visitor/Statement_LOWERED_STATEMENTS.hpp")
            #include "visitor/Statement_LOWERED_STATEMENTS.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Statement_LOWERED_STATEMENTS.hpp")
            #include "ebmcodegen/default_visitor/Statement_LOWERED_STATEMENTS.hpp"
            #endif
            return {};
        }
        expected<void> visit_Expression_LITERAL_INT(const ebm::ExpressionRef& item_id,const ebm::TypeRef& type,const ebm::ExpressionOp& kind,const ebm::Varint& int_value) {
            #if __has_include("visitor/Expression_LITERAL_INT.hpp")
            #include "visitor/Expression_LITERAL_INT.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Expression_LITERAL_INT.hpp")
            #include "ebmcodegen/default_visitor/Expression_LITERAL_INT.hpp"
            #endif
            return {};
        }
        expected<void> visit_Expression_LITERAL_INT64(const ebm::ExpressionRef& item_id,const ebm::TypeRef& type,const ebm::ExpressionOp& kind,const std::uint64_t& int64_value) {
            #if __has_include("visitor/Expression_LITERAL_INT64.hpp")
            #include "visitor/Expression_LITERAL_INT64.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Expression_LITERAL_INT64.hpp")
            #include "ebmcodegen/default_visitor/Expression_LITERAL_INT64.hpp"
            #endif
            return {};
        }
        expected<void> visit_Expression_LITERAL_BOOL(const ebm::ExpressionRef& item_id,const ebm::TypeRef& type,const ebm::ExpressionOp& kind,const std::uint8_t& bool_value) {
            #if __has_include("visitor/Expression_LITERAL_BOOL.hpp")
            #include "visitor/Expression_LITERAL_BOOL.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Expression_LITERAL_BOOL.hpp")
            #include "ebmcodegen/default_visitor/Expression_LITERAL_BOOL.hpp"
            #endif
            return {};
        }
        expected<void> visit_Expression_LITERAL_STRING(const ebm::ExpressionRef& item_id,const ebm::TypeRef& type,const ebm::ExpressionOp& kind,const ebm::StringRef& string_value) {
            #if __has_include("visitor/Expression_LITERAL_STRING.hpp")
            #include "visitor/Expression_LITERAL_STRING.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Expression_LITERAL_STRING.hpp")
            #include "ebmcodegen/default_visitor/Expression_LITERAL_STRING.hpp"
            #endif
            return {};
        }
        expected<void> visit_Expression_LITERAL_TYPE(const ebm::ExpressionRef& item_id,const ebm::TypeRef& type,const ebm::ExpressionOp& kind,const ebm::TypeRef& type_ref) {
            #if __has_include("visitor/Expression_LITERAL_TYPE.hpp")
            #include "visitor/Expression_LITERAL_TYPE.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Expression_LITERAL_TYPE.hpp")
            #include "ebmcodegen/default_visitor/Expression_LITERAL_TYPE.hpp"
            #endif
            return {};
        }
        expected<void> visit_Expression_IDENTIFIER(const ebm::ExpressionRef& item_id,const ebm::TypeRef& type,const ebm::ExpressionOp& kind,const ebm::StatementRef& id) {
            #if __has_include("visitor/Expression_IDENTIFIER.hpp")
            #include "visitor/Expression_IDENTIFIER.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Expression_IDENTIFIER.hpp")
            #include "ebmcodegen/default_visitor/Expression_IDENTIFIER.hpp"
            #endif
            return {};
        }
        expected<void> visit_Expression_BINARY_OP(const ebm::ExpressionRef& item_id,const ebm::TypeRef& type,const ebm::ExpressionOp& kind,const ebm::BinaryOp& bop,const ebm::ExpressionRef& left,const ebm::ExpressionRef& right) {
            #if __has_include("visitor/Expression_BINARY_OP.hpp")
            #include "visitor/Expression_BINARY_OP.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Expression_BINARY_OP.hpp")
            #include "ebmcodegen/default_visitor/Expression_BINARY_OP.hpp"
            #endif
            return {};
        }
        expected<void> visit_Expression_UNARY_OP(const ebm::ExpressionRef& item_id,const ebm::TypeRef& type,const ebm::ExpressionOp& kind,const ebm::ExpressionRef& operand,const ebm::UnaryOp& uop) {
            #if __has_include("visitor/Expression_UNARY_OP.hpp")
            #include "visitor/Expression_UNARY_OP.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Expression_UNARY_OP.hpp")
            #include "ebmcodegen/default_visitor/Expression_UNARY_OP.hpp"
            #endif
            return {};
        }
        expected<void> visit_Expression_CALL(const ebm::ExpressionRef& item_id,const ebm::TypeRef& type,const ebm::ExpressionOp& kind,const ebm::CallDesc& call_desc) {
            #if __has_include("visitor/Expression_CALL.hpp")
            #include "visitor/Expression_CALL.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Expression_CALL.hpp")
            #include "ebmcodegen/default_visitor/Expression_CALL.hpp"
            #endif
            return {};
        }
        expected<void> visit_Expression_INDEX_ACCESS(const ebm::ExpressionRef& item_id,const ebm::TypeRef& type,const ebm::ExpressionOp& kind,const ebm::ExpressionRef& base,const ebm::ExpressionRef& index) {
            #if __has_include("visitor/Expression_INDEX_ACCESS.hpp")
            #include "visitor/Expression_INDEX_ACCESS.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Expression_INDEX_ACCESS.hpp")
            #include "ebmcodegen/default_visitor/Expression_INDEX_ACCESS.hpp"
            #endif
            return {};
        }
        expected<void> visit_Expression_MEMBER_ACCESS(const ebm::ExpressionRef& item_id,const ebm::TypeRef& type,const ebm::ExpressionOp& kind,const ebm::ExpressionRef& base,const ebm::ExpressionRef& member) {
            #if __has_include("visitor/Expression_MEMBER_ACCESS.hpp")
            #include "visitor/Expression_MEMBER_ACCESS.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Expression_MEMBER_ACCESS.hpp")
            #include "ebmcodegen/default_visitor/Expression_MEMBER_ACCESS.hpp"
            #endif
            return {};
        }
        expected<void> visit_Expression_TYPE_CAST(const ebm::ExpressionRef& item_id,const ebm::TypeRef& type,const ebm::ExpressionOp& kind,const ebm::CastType& cast_kind,const ebm::TypeRef& from_type,const ebm::ExpressionRef& source_expr) {
            #if __has_include("visitor/Expression_TYPE_CAST.hpp")
            #include "visitor/Expression_TYPE_CAST.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Expression_TYPE_CAST.hpp")
            #include "ebmcodegen/default_visitor/Expression_TYPE_CAST.hpp"
            #endif
            return {};
        }
        expected<void> visit_Expression_RANGE(const ebm::ExpressionRef& item_id,const ebm::TypeRef& type,const ebm::ExpressionOp& kind,const ebm::ExpressionRef& end,const ebm::ExpressionRef& start) {
            #if __has_include("visitor/Expression_RANGE.hpp")
            #include "visitor/Expression_RANGE.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Expression_RANGE.hpp")
            #include "ebmcodegen/default_visitor/Expression_RANGE.hpp"
            #endif
            return {};
        }
        expected<void> visit_Expression_DEFAULT_VALUE(const ebm::ExpressionRef& item_id,const ebm::TypeRef& type,const ebm::ExpressionOp& kind) {
            #if __has_include("visitor/Expression_DEFAULT_VALUE.hpp")
            #include "visitor/Expression_DEFAULT_VALUE.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Expression_DEFAULT_VALUE.hpp")
            #include "ebmcodegen/default_visitor/Expression_DEFAULT_VALUE.hpp"
            #endif
            return {};
        }
        expected<void> visit_Expression_IS_LITTLE_ENDIAN(const ebm::ExpressionRef& item_id,const ebm::TypeRef& type,const ebm::ExpressionOp& kind,const ebm::StatementRef& endian_expr) {
            #if __has_include("visitor/Expression_IS_LITTLE_ENDIAN.hpp")
            #include "visitor/Expression_IS_LITTLE_ENDIAN.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Expression_IS_LITTLE_ENDIAN.hpp")
            #include "ebmcodegen/default_visitor/Expression_IS_LITTLE_ENDIAN.hpp"
            #endif
            return {};
        }
        expected<void> visit_Expression_GET_STREAM_OFFSET(const ebm::ExpressionRef& item_id,const ebm::TypeRef& type,const ebm::ExpressionOp& kind,const ebm::StreamType& stream_type,const ebm::SizeUnit& unit) {
            #if __has_include("visitor/Expression_GET_STREAM_OFFSET.hpp")
            #include "visitor/Expression_GET_STREAM_OFFSET.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Expression_GET_STREAM_OFFSET.hpp")
            #include "ebmcodegen/default_visitor/Expression_GET_STREAM_OFFSET.hpp"
            #endif
            return {};
        }
        expected<void> visit_Expression_GET_REMAINING_BYTES(const ebm::ExpressionRef& item_id,const ebm::TypeRef& type,const ebm::ExpressionOp& kind,const ebm::StreamType& stream_type) {
            #if __has_include("visitor/Expression_GET_REMAINING_BYTES.hpp")
            #include "visitor/Expression_GET_REMAINING_BYTES.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Expression_GET_REMAINING_BYTES.hpp")
            #include "ebmcodegen/default_visitor/Expression_GET_REMAINING_BYTES.hpp"
            #endif
            return {};
        }
        expected<void> visit_Expression_CAN_READ_STREAM(const ebm::ExpressionRef& item_id,const ebm::TypeRef& type,const ebm::ExpressionOp& kind,const ebm::Size& num_bytes,const ebm::StreamType& stream_type) {
            #if __has_include("visitor/Expression_CAN_READ_STREAM.hpp")
            #include "visitor/Expression_CAN_READ_STREAM.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Expression_CAN_READ_STREAM.hpp")
            #include "ebmcodegen/default_visitor/Expression_CAN_READ_STREAM.hpp"
            #endif
            return {};
        }
        expected<void> visit_Expression_ARRAY_SIZE(const ebm::ExpressionRef& item_id,const ebm::TypeRef& type,const ebm::ExpressionOp& kind,const ebm::ExpressionRef& array_expr) {
            #if __has_include("visitor/Expression_ARRAY_SIZE.hpp")
            #include "visitor/Expression_ARRAY_SIZE.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Expression_ARRAY_SIZE.hpp")
            #include "ebmcodegen/default_visitor/Expression_ARRAY_SIZE.hpp"
            #endif
            return {};
        }
        expected<void> visit_Expression_IS_ERROR(const ebm::ExpressionRef& item_id,const ebm::TypeRef& type,const ebm::ExpressionOp& kind,const ebm::ExpressionRef& target_expr) {
            #if __has_include("visitor/Expression_IS_ERROR.hpp")
            #include "visitor/Expression_IS_ERROR.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Expression_IS_ERROR.hpp")
            #include "ebmcodegen/default_visitor/Expression_IS_ERROR.hpp"
            #endif
            return {};
        }
        expected<void> visit_Expression_MAX_VALUE(const ebm::ExpressionRef& item_id,const ebm::TypeRef& type,const ebm::ExpressionOp& kind,const ebm::ExpressionRef& lowered_expr) {
            #if __has_include("visitor/Expression_MAX_VALUE.hpp")
            #include "visitor/Expression_MAX_VALUE.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Expression_MAX_VALUE.hpp")
            #include "ebmcodegen/default_visitor/Expression_MAX_VALUE.hpp"
            #endif
            return {};
        }
        expected<void> visit_Expression_READ_DATA(const ebm::ExpressionRef& item_id,const ebm::TypeRef& type,const ebm::ExpressionOp& kind,const ebm::StatementRef& io_statement,const ebm::StatementRef& target_stmt) {
            #if __has_include("visitor/Expression_READ_DATA.hpp")
            #include "visitor/Expression_READ_DATA.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Expression_READ_DATA.hpp")
            #include "ebmcodegen/default_visitor/Expression_READ_DATA.hpp"
            #endif
            return {};
        }
        expected<void> visit_Expression_WRITE_DATA(const ebm::ExpressionRef& item_id,const ebm::TypeRef& type,const ebm::ExpressionOp& kind,const ebm::StatementRef& io_statement,const ebm::ExpressionRef& target_expr) {
            #if __has_include("visitor/Expression_WRITE_DATA.hpp")
            #include "visitor/Expression_WRITE_DATA.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Expression_WRITE_DATA.hpp")
            #include "ebmcodegen/default_visitor/Expression_WRITE_DATA.hpp"
            #endif
            return {};
        }
        expected<void> visit_Type_INT(const ebm::TypeRef& item_id,const ebm::TypeKind& kind,const std::uint8_t& size) {
            #if __has_include("visitor/Type_INT.hpp")
            #include "visitor/Type_INT.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Type_INT.hpp")
            #include "ebmcodegen/default_visitor/Type_INT.hpp"
            #endif
            return {};
        }
        expected<void> visit_Type_UINT(const ebm::TypeRef& item_id,const ebm::TypeKind& kind,const std::uint8_t& size) {
            #if __has_include("visitor/Type_UINT.hpp")
            #include "visitor/Type_UINT.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Type_UINT.hpp")
            #include "ebmcodegen/default_visitor/Type_UINT.hpp"
            #endif
            return {};
        }
        expected<void> visit_Type_FLOAT(const ebm::TypeRef& item_id,const ebm::TypeKind& kind,const std::uint8_t& size) {
            #if __has_include("visitor/Type_FLOAT.hpp")
            #include "visitor/Type_FLOAT.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Type_FLOAT.hpp")
            #include "ebmcodegen/default_visitor/Type_FLOAT.hpp"
            #endif
            return {};
        }
        expected<void> visit_Type_STRUCT(const ebm::TypeRef& item_id,const ebm::TypeKind& kind,const ebm::StatementRef& id) {
            #if __has_include("visitor/Type_STRUCT.hpp")
            #include "visitor/Type_STRUCT.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Type_STRUCT.hpp")
            #include "ebmcodegen/default_visitor/Type_STRUCT.hpp"
            #endif
            return {};
        }
        expected<void> visit_Type_RECURSIVE_STRUCT(const ebm::TypeRef& item_id,const ebm::TypeKind& kind,const ebm::StatementRef& id) {
            #if __has_include("visitor/Type_RECURSIVE_STRUCT.hpp")
            #include "visitor/Type_RECURSIVE_STRUCT.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Type_RECURSIVE_STRUCT.hpp")
            #include "ebmcodegen/default_visitor/Type_RECURSIVE_STRUCT.hpp"
            #endif
            return {};
        }
        expected<void> visit_Type_BOOL(const ebm::TypeRef& item_id,const ebm::TypeKind& kind) {
            #if __has_include("visitor/Type_BOOL.hpp")
            #include "visitor/Type_BOOL.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Type_BOOL.hpp")
            #include "ebmcodegen/default_visitor/Type_BOOL.hpp"
            #endif
            return {};
        }
        expected<void> visit_Type_VOID(const ebm::TypeRef& item_id,const ebm::TypeKind& kind) {
            #if __has_include("visitor/Type_VOID.hpp")
            #include "visitor/Type_VOID.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Type_VOID.hpp")
            #include "ebmcodegen/default_visitor/Type_VOID.hpp"
            #endif
            return {};
        }
        expected<void> visit_Type_META(const ebm::TypeRef& item_id,const ebm::TypeKind& kind) {
            #if __has_include("visitor/Type_META.hpp")
            #include "visitor/Type_META.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Type_META.hpp")
            #include "ebmcodegen/default_visitor/Type_META.hpp"
            #endif
            return {};
        }
        expected<void> visit_Type_ENUM(const ebm::TypeRef& item_id,const ebm::TypeKind& kind,const ebm::TypeRef& base_type,const ebm::StatementRef& id) {
            #if __has_include("visitor/Type_ENUM.hpp")
            #include "visitor/Type_ENUM.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Type_ENUM.hpp")
            #include "ebmcodegen/default_visitor/Type_ENUM.hpp"
            #endif
            return {};
        }
        expected<void> visit_Type_ARRAY(const ebm::TypeRef& item_id,const ebm::TypeKind& kind,const ebm::TypeRef& element_type,const ebm::Varint& length) {
            #if __has_include("visitor/Type_ARRAY.hpp")
            #include "visitor/Type_ARRAY.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Type_ARRAY.hpp")
            #include "ebmcodegen/default_visitor/Type_ARRAY.hpp"
            #endif
            return {};
        }
        expected<void> visit_Type_VECTOR(const ebm::TypeRef& item_id,const ebm::TypeKind& kind,const ebm::TypeRef& element_type) {
            #if __has_include("visitor/Type_VECTOR.hpp")
            #include "visitor/Type_VECTOR.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Type_VECTOR.hpp")
            #include "ebmcodegen/default_visitor/Type_VECTOR.hpp"
            #endif
            return {};
        }
        expected<void> visit_Type_VARIANT(const ebm::TypeRef& item_id,const ebm::TypeKind& kind,const ebm::TypeRef& common_type,const ebm::Types& members) {
            #if __has_include("visitor/Type_VARIANT.hpp")
            #include "visitor/Type_VARIANT.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Type_VARIANT.hpp")
            #include "ebmcodegen/default_visitor/Type_VARIANT.hpp"
            #endif
            return {};
        }
        expected<void> visit_Type_RANGE(const ebm::TypeRef& item_id,const ebm::TypeKind& kind,const ebm::TypeRef& base_type) {
            #if __has_include("visitor/Type_RANGE.hpp")
            #include "visitor/Type_RANGE.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Type_RANGE.hpp")
            #include "ebmcodegen/default_visitor/Type_RANGE.hpp"
            #endif
            return {};
        }
        expected<void> visit_Type_ENCODER_RETURN(const ebm::TypeRef& item_id,const ebm::TypeKind& kind) {
            #if __has_include("visitor/Type_ENCODER_RETURN.hpp")
            #include "visitor/Type_ENCODER_RETURN.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Type_ENCODER_RETURN.hpp")
            #include "ebmcodegen/default_visitor/Type_ENCODER_RETURN.hpp"
            #endif
            return {};
        }
        expected<void> visit_Type_DECODER_RETURN(const ebm::TypeRef& item_id,const ebm::TypeKind& kind) {
            #if __has_include("visitor/Type_DECODER_RETURN.hpp")
            #include "visitor/Type_DECODER_RETURN.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Type_DECODER_RETURN.hpp")
            #include "ebmcodegen/default_visitor/Type_DECODER_RETURN.hpp"
            #endif
            return {};
        }
        expected<void> visit_Type_PROPERTY_SETTER_RETURN(const ebm::TypeRef& item_id,const ebm::TypeKind& kind,const ebm::TypeRef& property_type) {
            #if __has_include("visitor/Type_PROPERTY_SETTER_RETURN.hpp")
            #include "visitor/Type_PROPERTY_SETTER_RETURN.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Type_PROPERTY_SETTER_RETURN.hpp")
            #include "ebmcodegen/default_visitor/Type_PROPERTY_SETTER_RETURN.hpp"
            #endif
            return {};
        }
        expected<void> visit_Type_OPTIONAL(const ebm::TypeRef& item_id,const ebm::TypeKind& kind,const ebm::TypeRef& inner_type) {
            #if __has_include("visitor/Type_OPTIONAL.hpp")
            #include "visitor/Type_OPTIONAL.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Type_OPTIONAL.hpp")
            #include "ebmcodegen/default_visitor/Type_OPTIONAL.hpp"
            #endif
            return {};
        }
        expected<void> visit_Type_PTR(const ebm::TypeRef& item_id,const ebm::TypeKind& kind,const ebm::TypeRef& pointee_type) {
            #if __has_include("visitor/Type_PTR.hpp")
            #include "visitor/Type_PTR.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Type_PTR.hpp")
            #include "ebmcodegen/default_visitor/Type_PTR.hpp"
            #endif
            return {};
        }
        expected<void> visit_Type_FUNCTION(const ebm::TypeRef& item_id,const ebm::TypeKind& kind,const ebm::Types& params,const ebm::TypeRef& return_type) {
            #if __has_include("visitor/Type_FUNCTION.hpp")
            #include "visitor/Type_FUNCTION.hpp"
            #elif __has_include("ebmcodegen/default_visitor/Type_FUNCTION.hpp")
            #include "ebmcodegen/default_visitor/Type_FUNCTION.hpp"
            #endif
            return {};
        }
    };
    static_assert(has_visitor_Statement_BLOCK<Visitor>, "Visitor does not implement visit_Statement_BLOCK");
    static_assert(has_visitor_Statement_ASSIGNMENT<Visitor>, "Visitor does not implement visit_Statement_ASSIGNMENT");
    static_assert(has_visitor_Statement_APPEND<Visitor>, "Visitor does not implement visit_Statement_APPEND");
    static_assert(has_visitor_Statement_RETURN<Visitor>, "Visitor does not implement visit_Statement_RETURN");
    static_assert(has_visitor_Statement_ERROR_RETURN<Visitor>, "Visitor does not implement visit_Statement_ERROR_RETURN");
    static_assert(has_visitor_Statement_ASSERT<Visitor>, "Visitor does not implement visit_Statement_ASSERT");
    static_assert(has_visitor_Statement_READ_DATA<Visitor>, "Visitor does not implement visit_Statement_READ_DATA");
    static_assert(has_visitor_Statement_WRITE_DATA<Visitor>, "Visitor does not implement visit_Statement_WRITE_DATA");
    static_assert(has_visitor_Statement_SEEK_STREAM<Visitor>, "Visitor does not implement visit_Statement_SEEK_STREAM");
    static_assert(has_visitor_Statement_IF_STATEMENT<Visitor>, "Visitor does not implement visit_Statement_IF_STATEMENT");
    static_assert(has_visitor_Statement_LOOP_STATEMENT<Visitor>, "Visitor does not implement visit_Statement_LOOP_STATEMENT");
    static_assert(has_visitor_Statement_MATCH_STATEMENT<Visitor>, "Visitor does not implement visit_Statement_MATCH_STATEMENT");
    static_assert(has_visitor_Statement_MATCH_BRANCH<Visitor>, "Visitor does not implement visit_Statement_MATCH_BRANCH");
    static_assert(has_visitor_Statement_BREAK<Visitor>, "Visitor does not implement visit_Statement_BREAK");
    static_assert(has_visitor_Statement_CONTINUE<Visitor>, "Visitor does not implement visit_Statement_CONTINUE");
    static_assert(has_visitor_Statement_FUNCTION_DECL<Visitor>, "Visitor does not implement visit_Statement_FUNCTION_DECL");
    static_assert(has_visitor_Statement_VARIABLE_DECL<Visitor>, "Visitor does not implement visit_Statement_VARIABLE_DECL");
    static_assert(has_visitor_Statement_FIELD_DECL<Visitor>, "Visitor does not implement visit_Statement_FIELD_DECL");
    static_assert(has_visitor_Statement_ENUM_DECL<Visitor>, "Visitor does not implement visit_Statement_ENUM_DECL");
    static_assert(has_visitor_Statement_ENUM_MEMBER_DECL<Visitor>, "Visitor does not implement visit_Statement_ENUM_MEMBER_DECL");
    static_assert(has_visitor_Statement_STRUCT_DECL<Visitor>, "Visitor does not implement visit_Statement_STRUCT_DECL");
    static_assert(has_visitor_Statement_UNION_DECL<Visitor>, "Visitor does not implement visit_Statement_UNION_DECL");
    static_assert(has_visitor_Statement_UNION_MEMBER_DECL<Visitor>, "Visitor does not implement visit_Statement_UNION_MEMBER_DECL");
    static_assert(has_visitor_Statement_PROGRAM_DECL<Visitor>, "Visitor does not implement visit_Statement_PROGRAM_DECL");
    static_assert(has_visitor_Statement_STATE_DECL<Visitor>, "Visitor does not implement visit_Statement_STATE_DECL");
    static_assert(has_visitor_Statement_BIT_FIELD_DECL<Visitor>, "Visitor does not implement visit_Statement_BIT_FIELD_DECL");
    static_assert(has_visitor_Statement_PROPERTY_DECL<Visitor>, "Visitor does not implement visit_Statement_PROPERTY_DECL");
    static_assert(has_visitor_Statement_METADATA<Visitor>, "Visitor does not implement visit_Statement_METADATA");
    static_assert(has_visitor_Statement_IMPORT_MODULE<Visitor>, "Visitor does not implement visit_Statement_IMPORT_MODULE");
    static_assert(has_visitor_Statement_EXPRESSION<Visitor>, "Visitor does not implement visit_Statement_EXPRESSION");
    static_assert(has_visitor_Statement_PHI_NODE<Visitor>, "Visitor does not implement visit_Statement_PHI_NODE");
    static_assert(has_visitor_Statement_ERROR_REPORT<Visitor>, "Visitor does not implement visit_Statement_ERROR_REPORT");
    static_assert(has_visitor_Statement_LOWERED_STATEMENTS<Visitor>, "Visitor does not implement visit_Statement_LOWERED_STATEMENTS");
    static_assert(has_visitor_Expression_LITERAL_INT<Visitor>, "Visitor does not implement visit_Expression_LITERAL_INT");
    static_assert(has_visitor_Expression_LITERAL_INT64<Visitor>, "Visitor does not implement visit_Expression_LITERAL_INT64");
    static_assert(has_visitor_Expression_LITERAL_BOOL<Visitor>, "Visitor does not implement visit_Expression_LITERAL_BOOL");
    static_assert(has_visitor_Expression_LITERAL_STRING<Visitor>, "Visitor does not implement visit_Expression_LITERAL_STRING");
    static_assert(has_visitor_Expression_LITERAL_TYPE<Visitor>, "Visitor does not implement visit_Expression_LITERAL_TYPE");
    static_assert(has_visitor_Expression_IDENTIFIER<Visitor>, "Visitor does not implement visit_Expression_IDENTIFIER");
    static_assert(has_visitor_Expression_BINARY_OP<Visitor>, "Visitor does not implement visit_Expression_BINARY_OP");
    static_assert(has_visitor_Expression_UNARY_OP<Visitor>, "Visitor does not implement visit_Expression_UNARY_OP");
    static_assert(has_visitor_Expression_CALL<Visitor>, "Visitor does not implement visit_Expression_CALL");
    static_assert(has_visitor_Expression_INDEX_ACCESS<Visitor>, "Visitor does not implement visit_Expression_INDEX_ACCESS");
    static_assert(has_visitor_Expression_MEMBER_ACCESS<Visitor>, "Visitor does not implement visit_Expression_MEMBER_ACCESS");
    static_assert(has_visitor_Expression_TYPE_CAST<Visitor>, "Visitor does not implement visit_Expression_TYPE_CAST");
    static_assert(has_visitor_Expression_RANGE<Visitor>, "Visitor does not implement visit_Expression_RANGE");
    static_assert(has_visitor_Expression_DEFAULT_VALUE<Visitor>, "Visitor does not implement visit_Expression_DEFAULT_VALUE");
    static_assert(has_visitor_Expression_IS_LITTLE_ENDIAN<Visitor>, "Visitor does not implement visit_Expression_IS_LITTLE_ENDIAN");
    static_assert(has_visitor_Expression_GET_STREAM_OFFSET<Visitor>, "Visitor does not implement visit_Expression_GET_STREAM_OFFSET");
    static_assert(has_visitor_Expression_GET_REMAINING_BYTES<Visitor>, "Visitor does not implement visit_Expression_GET_REMAINING_BYTES");
    static_assert(has_visitor_Expression_CAN_READ_STREAM<Visitor>, "Visitor does not implement visit_Expression_CAN_READ_STREAM");
    static_assert(has_visitor_Expression_ARRAY_SIZE<Visitor>, "Visitor does not implement visit_Expression_ARRAY_SIZE");
    static_assert(has_visitor_Expression_IS_ERROR<Visitor>, "Visitor does not implement visit_Expression_IS_ERROR");
    static_assert(has_visitor_Expression_MAX_VALUE<Visitor>, "Visitor does not implement visit_Expression_MAX_VALUE");
    static_assert(has_visitor_Expression_READ_DATA<Visitor>, "Visitor does not implement visit_Expression_READ_DATA");
    static_assert(has_visitor_Expression_WRITE_DATA<Visitor>, "Visitor does not implement visit_Expression_WRITE_DATA");
    static_assert(has_visitor_Type_INT<Visitor>, "Visitor does not implement visit_Type_INT");
    static_assert(has_visitor_Type_UINT<Visitor>, "Visitor does not implement visit_Type_UINT");
    static_assert(has_visitor_Type_FLOAT<Visitor>, "Visitor does not implement visit_Type_FLOAT");
    static_assert(has_visitor_Type_STRUCT<Visitor>, "Visitor does not implement visit_Type_STRUCT");
    static_assert(has_visitor_Type_RECURSIVE_STRUCT<Visitor>, "Visitor does not implement visit_Type_RECURSIVE_STRUCT");
    static_assert(has_visitor_Type_BOOL<Visitor>, "Visitor does not implement visit_Type_BOOL");
    static_assert(has_visitor_Type_VOID<Visitor>, "Visitor does not implement visit_Type_VOID");
    static_assert(has_visitor_Type_META<Visitor>, "Visitor does not implement visit_Type_META");
    static_assert(has_visitor_Type_ENUM<Visitor>, "Visitor does not implement visit_Type_ENUM");
    static_assert(has_visitor_Type_ARRAY<Visitor>, "Visitor does not implement visit_Type_ARRAY");
    static_assert(has_visitor_Type_VECTOR<Visitor>, "Visitor does not implement visit_Type_VECTOR");
    static_assert(has_visitor_Type_VARIANT<Visitor>, "Visitor does not implement visit_Type_VARIANT");
    static_assert(has_visitor_Type_RANGE<Visitor>, "Visitor does not implement visit_Type_RANGE");
    static_assert(has_visitor_Type_ENCODER_RETURN<Visitor>, "Visitor does not implement visit_Type_ENCODER_RETURN");
    static_assert(has_visitor_Type_DECODER_RETURN<Visitor>, "Visitor does not implement visit_Type_DECODER_RETURN");
    static_assert(has_visitor_Type_PROPERTY_SETTER_RETURN<Visitor>, "Visitor does not implement visit_Type_PROPERTY_SETTER_RETURN");
    static_assert(has_visitor_Type_OPTIONAL<Visitor>, "Visitor does not implement visit_Type_OPTIONAL");
    static_assert(has_visitor_Type_PTR<Visitor>, "Visitor does not implement visit_Type_PTR");
    static_assert(has_visitor_Type_FUNCTION<Visitor>, "Visitor does not implement visit_Type_FUNCTION");
}  // namespace ebm2python
DEFINE_ENTRY(Flags,Output) {
    ebm2python::Visitor visitor{ebm,w};
    #if __has_include("visitor/pre_entry.hpp")
    #include "visitor/pre_entry.hpp"
    #elif __has_include("ebmcodegen/default_visitor/pre_entry.hpp")
    #include "ebmcodegen/default_visitor/pre_entry.hpp"
    #endif
    auto result = visitor.entry();
    if (!result) {
        futils::wrap::cerr_wrap() << "error: " << result.error();
        return 1;
    }
    #if __has_include("visitor/post_entry.hpp")
    #include "visitor/post_entry.hpp"
    #elif __has_include("ebmcodegen/default_visitor/post_entry.hpp")
    #include "ebmcodegen/default_visitor/post_entry.hpp"
    #endif
    return 0;
}
