/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Expression_CAN_READ_STREAM_class
  Available Variables:
    ctx: Context_Expression_CAN_READ_STREAM
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        module_: ebmgen::MappingTable
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
      item_id: ebm::ExpressionRef
      type: const ebm::TypeRef&
      kind: const ebm::ExpressionKind&
      io_ref: const ebm::StatementRef&
      num_bytes: const ebm::Size&
        unit: SizeUnit
        ref: *ExpressionRef
        size: *Varint
      stream_type: const ebm::StreamType&
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/
#include "../codegen.hpp"

DEFINE_VISITOR(Expression_CAN_READ_STREAM) {
    using namespace CODEGEN_NAMESPACE;
    auto& v = ctx.visitor;
    auto io_val = v.module_.get_associated_identifier(ctx.io_ref);

    MAYBE(size_str, get_size_str(ctx, ctx.num_bytes));

    bool only_one_byte = size_str.to_string() == "1";
    auto tmp_id = std::format("{}", get_id(ctx.item_id));
    auto current_offset = std::format("current_offset_{}", tmp_id);
    auto end_offset = std::format("end_offset_{}", tmp_id);
    auto result = std::format("result_{}", tmp_id);

    auto peek_pattern = CODELINE(result, " = builtins.len(", io_val, ".peek(", size_str, "))");
    auto seek_pattern = CODE(
        current_offset, " = ", io_val, ".tell()", CODELINE(),
        end_offset, " = ", io_val, ".seek(0,2)", CODELINE(),
        io_val, ".seek(", current_offset, ")", CODELINE(),
        result, " = ", end_offset, " - ", current_offset, CODELINE());

    CodeWriter w;
    w.writeln("if isinstance(", io_val, ", io.BytesIO) and ", io_val, ".seekable():");
    {
        auto scope = w.indent_scope();
        w.writeln(seek_pattern);
    }
    w.writeln("elif isinstance(", io_val, ", io.BufferedReader):");
    {
        auto scope = w.indent_scope();
        w.writeln(peek_pattern);
    }
    w.writeln("else:");
    {
        auto scope = w.indent_scope();
        w.writeln("raise ValueError(\"Unsupported stream type for CAN_READ_STREAM\")");
    }
    MAYBE(got_writer, v.wm.get_writer());
    got_writer.write(std::move(w));

    return CODE("bool(", result, " >= ", size_str, ")");
}