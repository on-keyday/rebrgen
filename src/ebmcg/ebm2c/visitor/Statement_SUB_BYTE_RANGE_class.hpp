/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Statement_SUB_BYTE_RANGE_class
  Available Variables:
    ctx: Context_Statement_SUB_BYTE_RANGE
      visitor: MergedVisitor&
        program_name: static constexpr const char*
        module_: ebmgen::MappingTable
        flags: Flags&
        output: Output&
        wm: ebmcodegen::WriterManager<CodeWriter>
      item_id: ebm::StatementRef
      kind: const ebm::StatementKind&
      sub_byte_range: const ebm::SubByteRange&
        stream_type: StreamType
        range_type: SubByteRangeType
        expression: *ExpressionRef
        length: *ExpressionRef
        offset: *ExpressionRef
        io_ref: StatementRef
        parent_io_ref: StatementRef
        io_statement: StatementRef
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/


#include "../codegen.hpp"
DEFINE_VISITOR(Statement_SUB_BYTE_RANGE) {
    using namespace CODEGEN_NAMESPACE;
    auto io_name = ctx.identifier(ctx.sub_byte_range.io_ref);
    auto parent_io_name = ctx.identifier(ctx.sub_byte_range.parent_io_ref);
    std::string type_name = ctx.sub_byte_range.stream_type == ebm::StreamType::OUTPUT ? ctx.config().encoder_input_type : ctx.config().decoder_input_type;
    // remove * from type name if it is pointer type, because we declare variable here
    if (type_name.ends_with("*")) {
        type_name.pop_back();
    }

    CodeWriter w;
    w.write(type_name, " ", io_name, " = *", parent_io_name, ";");
    w.writeln("");
    
    if (ctx.sub_byte_range.range_type == ebm::SubByteRangeType::bytes) {
        MAYBE(len, ctx.visit(*ctx.sub_byte_range.length()));
        w.write(io_name, ".data = ", parent_io_name, "->data + ", parent_io_name, "->offset;");
        w.writeln("");
        w.write(io_name, ".data_end = ", io_name, ".data + ", len.to_writer(), ";");
        w.writeln("");
        w.write(io_name, ".offset = 0;");
        w.writeln("");
        // Advance parent
        w.write(parent_io_name, "->offset += ", len.to_writer(), ";");
        w.writeln("");
    }
    else if (ctx.sub_byte_range.range_type == ebm::SubByteRangeType::seek_bytes) {
        MAYBE(len, ctx.visit(*ctx.sub_byte_range.length()));
        MAYBE(off, ctx.visit(*ctx.sub_byte_range.offset()));
        w.write(io_name, ".data = ", parent_io_name, "->data + ", off.to_writer(), ";");
        w.writeln("");
        w.write(io_name, ".data_end = ", io_name, ".data + ", len.to_writer(), ";");
        w.writeln("");
        w.write(io_name, ".offset = 0;");
        w.writeln("");
    }
    
    return w;
}

