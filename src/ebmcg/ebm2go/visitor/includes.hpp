/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: includes
  Available variables:
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/

/*here to write the hook*/
#include "ebm/extended_binary_module.hpp"
#include <format>
namespace ebm2go {
    const ebm::FieldDecl* get_composite_field(auto&& ctx, auto target) {
        ebmgen::MappingTable& mapping = get_visitor(ctx).module_;
        const ebm::FieldDecl* comp = ebmgen::access_field<"body.id.field_decl">(mapping, target);
        if (!comp) {
            return nullptr;
        }
        auto comp_type = ebmgen::access_field<"composite_field_decl">(mapping, comp->composite_field());
        if (comp_type && (comp_type->kind == ebm::CompositeFieldKind::BULK_PRIMITIVE ||
                          comp_type->kind == ebm::CompositeFieldKind::PREFIXED_UNION_PRIMITIVE)) {
            return comp;
        }
        return nullptr;
    }

    constexpr auto physical_field = "body.id.struct_decl.related_variant.variant_desc.related_field.field_decl";

    struct ArrayLengthInfo {
        const ebm::IOData* write_data = nullptr;
        const ebm::FieldDecl* vector_field = nullptr;
        const ebm::FieldDecl* length_field = nullptr;
        const ebm::Type* vector_type = nullptr;
        const ebm::Type* length_type = nullptr;
    };

    struct IOMode {
        bool slice_io = false;
        bool std_io = false;
        bool bytes_io = false;
    };

    inline std::string offset_var(std::string x) {
        return x + "Offset";
    }
    inline std::string offset_ref(std::string x) {
        return std::format("*{}Offset", x);
    }

    inline std::string byte_io_ref(std::string x) {
        return std::format("{}ByteIO", x);
    }

    inline bool is_single_byte_io(auto&& ctx, const ebm::IOData& io_) {
        auto kind = ctx.get_kind(io_.data_type);
        return ctx.config().has_byte_io &&
               io_.size.unit == ebm::SizeUnit::BYTE_FIXED &&
               io_.size.size()->value() == 1 &&
               (kind == ebm::TypeKind::UINT || kind == ebm::TypeKind::ARRAY);
    }

}  // namespace ebm2go
