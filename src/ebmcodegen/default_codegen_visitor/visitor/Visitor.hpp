/*DO NOT EDIT BELOW SECTION MANUALLY*/
/*license*/
// Template generated by ebmcodegen at https://github.com/on-keyday/rebrgen
/*
  Name: Visitor
  Available variables:
*/
/*DO NOT EDIT ABOVE SECTION MANUALLY*/
bool use_brace_for_condition = true;
bool use_elif = false;
bool auto_output_root = true;
std::string bool_true = "true";
std::string bool_false = "false";
std::string bool_type = "bool";
std::string setter_status_ok = "";
std::string setter_status_failure = "";
std::string struct_keyword = "struct";
std::function<expected<Result>(Context_Statement_STRUCT_DECL& ctx)> struct_definition_start_wrapper;
std::function<expected<Result>(Context_Statement_STRUCT_DECL& ctx, ebm::StatementRef encode)> struct_encode_start_wrapper;
std::function<expected<Result>(Context_Statement_STRUCT_DECL& ctx, ebm::StatementRef decode)> struct_decode_start_wrapper;
std::string variable_initializer = "=";
std::string begin_block = "{";
std::string end_block = "}";
std::string empty_block_marker = "";
std::string default_object_brace = "{}";
std::string default_vector_brace = "[]";
std::string variable_define_keyword = "";
std::string immutable_variable_define_keyword = "";
std::string constant_define_keyword = "";
std::string constant_initializer = "";  // if set, used instead of variable_initializer for CONSTANT decls
bool variable_with_type = true;
bool cast_initial_value_when_no_type = false;  // when variable_with_type is false, wrap initial value with type cast
std::string variable_type_separator = ":";
std::map<ebm::BinaryOp, std::string> alt_binary_op;
std::map<ebm::UnaryOp, std::string> alt_unary_op;
std::string metadata_comment_prefix = "/*";
std::string metadata_comment_suffix = "*/";
std::string self_value = "this";
DefaultValueOption default_value_option;
std::string endof_statement = "";
std::string endof_struct_definition = "";
std::string endof_enum_definition = "";
std::string enum_member_separator = "";
std::string enum_member_accessor = ".";
std::string array_size_get_function = "len";
bool surrounded_array_size = false; /*true: len(x) false: x.len()*/
std::string append_function = "append";
std::function<expected<Result>(Context_Statement_APPEND& ctx)> append_visitor;
std::string infinity_loop_keyword = "";
std::string conditional_loop_keyword = "while";
bool field_name_prior_to_type = false;
bool variable_name_prior_to_type = true;
std::string usize_type_name = "usize";
bool byte_aligned_int = true;
bool byte_aligned_float = true;
bool support_small_size_float = true;
bool support_large_size_float = false;
std::string uint_prefix = "u";
std::string uint_suffix = "";
std::string int_prefix = "i";
std::string int_suffix = "";
std::string float_prefix = "f";
std::string float_suffix = "";
std::string function_define_keyword = "fn";
std::function<expected<Result>(Result return_type, std::string_view name, CodeWriter params, Context_Statement_FUNCTION_DECL& ctx)> function_definition_start_wrapper;
std::string encoder_return_type = "EncoderReturn";
std::string decoder_return_type = "DecoderReturn";
std::string encoder_input_type = "EncoderInput";
std::string decoder_input_type = "DecoderInput";
std::string property_setter_return_type = "bool";
bool forward_type_in_function_decl = false;
std::string function_return_type_separator = "->";
bool use_base_type_of_enum = false;
std::function<expected<Result>(Result elem_type, size_t len, ebm::ArrayAnnotation anot)> array_type_wrapper;
std::function<expected<Result>(Result elem_type)> vector_type_wrapper;
std::function<expected<Result>(Result typ, bool is_state_variable)> param_type_wrapper;
std::function<expected<Result>(Context_Statement_PARAMETER_DECL& ctx, Result typ)> param_visitor;
std::function<expected<Result>(Result elem_type)> pointer_type_wrapper;
std::function<expected<Result>(Result elem_type)> optional_type_wrapper;
std::function<expected<Result>(Result elem_type)> recursive_struct_type_wrapper;
std::function<expected<Result>(Result elem)> make_pointer_wrapper;
std::function<expected<Result>(Result elem)> make_optional_wrapper;
std::function<expected<Result>(Context_Type_VARIANT& ctx)> variant_type_custom;
std::function<expected<Result>(size_t bit_size)> make_int_type;
std::function<expected<Result>(size_t bit_size)> make_uint_type;
std::function<expected<Result>(size_t bit_size)> make_float_type;
std::string variant_prefix = "Variant";
bool func_style_cast = true;

std::vector<CodeWriter> decl_toplevel;
bool on_assign = false;  // useful for expression generation

std::function<expected<Result>(Context_Statement_WRITE_DATA& ctx)> write_data_visitor;
std::function<expected<Result>(Context_Statement_READ_DATA& ctx)> read_data_visitor;
std::function<expected<Result>(Context_Expression_CAN_READ_STREAM& ctx)> can_read_stream_visitor;
std::function<expected<Result>(Context_Statement_RESERVE_DATA& ctx)> reserve_data_visitor;

std::function<expected<Result>(Context_Statement_COMPOSITE_FIELD_DECL& ctx)> composite_field_decl_visitor;

std::function<expected<Result>(Context_Expression_IS_ERROR& ctx)> is_error_visitor;
std::function<expected<Result>(Context_Statement_ERROR_RETURN& ctx)> error_return_visitor;
std::function<expected<Result>(Context_Statement_ERROR_REPORT& ctx)> error_report_visitor;

std::function<expected<Result>(Context_Expression_AS_ARG& ctx)> as_arg_visitor;

std::function<expected<Result>(Context_Statement_ENUM_DECL& ctx)> enum_decl_visitor;
std::function<expected<Result>(Context_Statement_ENUM_MEMBER_DECL& ctx)> enum_member_decl_visitor;
std::function<expected<Result>(Context_Statement_INIT_CHECK& ctx)> init_check_visitor;

// if this returns `pass` using default logic
std::function<expected<Result>(Context_Expression_DEFAULT_VALUE& ctx)> default_value_custom;
std::function<expected<Result>(Context_Expression_CONDITIONAL& ctx)> conditional_visitor;

template <class Kind>
struct MemoizationConfig {
    bool enable = false;
    bool target_kind_as_exclusive = false;
    std::unordered_set<Kind> target_kinds;
    std::unordered_map<std::uint64_t, CodeWriter> memoized_items;

    expected<Result> try_get_memoized(std::uint64_t id) {
        if (!enable) {
            return pass;
        }
        auto found = memoized_items.find(id);
        if (found != memoized_items.end()) {
            auto copy = found->second;
            return copy;
        }
        return pass;
    }

    void try_memoize(std::uint64_t id, Kind kind, const CodeWriter& result) {
        if (!enable) {
            return;
        }
        if (target_kind_as_exclusive) {
            if (target_kinds.find(kind) != target_kinds.end()) {
                return;
            }
        }
        else {
            if (target_kinds.find(kind) == target_kinds.end()) {
                return;
            }
        }
        memoized_items[id] = result;
    }
};

// experimental
MemoizationConfig<ebm::ExpressionKind> expression_memoization_config;
MemoizationConfig<ebm::TypeKind> type_memoization_config;